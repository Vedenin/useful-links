"category"	"name"	"url"	"description"	"star"	"stackOverflow"	"stackOverflowUrl"	"license"	"licenseUrl"	"site"	"userGuide"	"newStars"	"newWatchs"	"newForks"	"pageText"	"newStackOverflow"	"github"	"allText"	"isExist"
"README.md"	""	"https://avatars2.githubusercontent.com/u/12118456?v=3&s=75"	""	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	""	"false"
"Canvas"	"Monet"	"https://github.com/rm-hull/monet"	"– A small ClojureScript library to make it easier to work with canvas and visuals."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"118"	"7"	"20"	"GitHub - rm-hull/monet: A ClojureScript visual library Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 118 Fork 20 rm-hull/monet forked from ibdknox/monet Code Issues 3 Pull requests 0 Pulse Graphs A ClojureScript visual library http://www.destructuring-bind.org/monet/ 76 commits 2 branches 5 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show 0.3.0 0.2.2 0.2.1 0.2.0 0.1.10 Nothing to show New pull request Pull request Compare This branch is 74 commits ahead, 2 commits behind ibdknox:master. Latest commit fa38d5d May 20, 2016 rm-hull Add `lein-codox` plugin Permalink Failed to load latest commit information. doc Move doc into separate file; prep. for codox Apr 20, 2014 src/monet Add rect May 17, 2016 test/monet initial import Feb 4, 2012 .gitignore Move doc into separate file; prep. for codox Apr 20, 2014 .travis.yml Removed jdk6 build directive Sep 6, 2014 CHANGELOG.md Bump minor version: 0.2.2 -> 0.3.0 May 20, 2016 README.md Bump minor version: 0.2.2 -> 0.3.0 May 20, 2016 project.clj Add `lein-codox` plugin May 20, 2016 README.md monet monet is a small ClojureScript library to make it easier (and performant) to work with canvas and visuals. Including in your project There is a version hosted at Clojars. For leiningen include a dependency: [rm-hull/monet ""0.3.0""] For maven-based projects, add the following to your pom.xml: <dependency>   <groupId>rm-hull</groupId>   <artifactId>monet</artifactId>   <version>0.2.2</version> </dependency> Usage (ns game.core   (:require [monet.canvas :as canvas])  (def canvas-dom (.getElementById js/document ""canvas""))  (def monet-canvas (canvas/init canvas-dom ""2d""))  (canvas/add-entity monet-canvas :background                    (canvas/entity {:x 0 :y 0 :w 600 :h 600} ; val                                   nil                       ; update function                                   (fn [ctx val]             ; draw function                                     (-> ctx                                         (canvas/fill-style ""#191d21"")                                         (canvas/fill-rect val))))) Documentation See the API Documentation. For more info on what the functions do look at the camel case versions in JS docs (for example the mozilla developer network). Some futher usage details can be found in doc/GUIDE.md License Copyright (C) 2011-14 Chris Granger, Richard Hull & others. Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/rm-hull/monet"	"– A small ClojureScript library to make it easier to work with canvas and visuals."	"true"
"Client/Server Communication"	"Fetch"	"https://github.com/LightTable/fetch"	"– A ClojureScript library that makes client/server interaction painless."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"187"	"17"	"28"	"GitHub - LightTable/fetch: A ClojureScript library for Client/Server interaction Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 17 Star 187 Fork 28 LightTable/fetch Code Issues 5 Pull requests 1 Pulse Graphs A ClojureScript library for Client/Server interaction 20 commits 1 branch 0 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit 6aa3273 Jul 14, 2015 kenny-evitt Merge pull request #17 from brabadu/master … Remove dependency on goog.net.XhrIo and goog.events Permalink Failed to load latest commit information. src Remove dependency on goog.net.XhrIo and goog.events Jul 12, 2015 test/fetch initial import Feb 4, 2012 .gitignore initial import Feb 4, 2012 CHANGELOG.md CONTRIBUTING.md LICENSE.md Update project.clj and switch to MIT since all LT projects use it Nov 15, 2014 README.md Update project.clj and switch to MIT since all LT projects use it Nov 15, 2014 project.clj Update project.clj and switch to MIT since all LT projects use it Nov 15, 2014 README.md fetch A ClojureScript library that makes client/server interaction painless. Usage Remotes Remotes let you make calls to a noir server without having to think about XHR. On the client-side you simply have code that looks like this: (ns playground.client.test   (:require [fetch.remotes :as remotes])   (:require-macros [fetch.macros :as fm]))  (fm/remote (adder 2 5 6) [result]   (js/alert result))  (fm/remote (get-user 2) [{:keys [username age]}]   (js/alert (str ""Name: "" username "", Age: "" age)))  ;; for a much nicer experience, use letrem (fm/letrem [a (adder 3 4)             b (adder 5 6)]     (js/alert (str ""a: "" a "" b: "" b))) Note that the results we get are real Clojure datastructures and so we use them just as we would in normal Clojure code. No JSON here. The noir side of things is just as simple. All you do is declare a remote using defremote. (use 'noir.fetch.remotes)  (defremote adder [& nums]            (apply + nums))  (defremote get-user [id]            {:username ""Chris""             :age 24})  (server/start 8080) License Copyright (c) 2014 Kodowa, Inc. & Light Table contributors Distributed under the MIT License. See LICENSE.md Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/LightTable/fetch"	"– A ClojureScript library that makes client/server interaction painless."	"true"
"Data Serialization"	"Cljson"	"https://github.com/tailrecursion/cljson"	"– Clojure/ClojureScript library for accelerated browser data deserialization."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"65"	"6"	"3"	"GitHub - tailrecursion/cljson: Clojure/ClojureScript library for accelerated browser data deserialization Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 6 Star 65 Fork 3 tailrecursion/cljson Code Issues 3 Pull requests 0 Pulse Graphs Clojure/ClojureScript library for accelerated browser data deserialization 173 commits 4 branches 4 releases Fetching contributors Clojure 58.1% JavaScript 37.4% Shell 2.3% HTML 1.6% Makefile 0.6% Clojure JavaScript Shell HTML Makefile Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags deep-collection master stack stack2 Nothing to show 1.0.7 1.0.6 1.0.5 1.0.4 Nothing to show New pull request Latest commit 180c0c3 Oct 20, 2015 alandipert Update README.md Permalink Failed to load latest commit information. doc initial commit Jun 10, 2013 script bugfix makefile Oct 18, 2013 src 1.0.7 -- remove reference to goog.date.DateTime Aug 27, 2014 test simplify ff building Oct 18, 2013 .gitignore 1.0.3 Oct 18, 2013 .travis.yml 1.0.3 buildfix Oct 18, 2013 Makefile fix issues with makefile Oct 18, 2013 README.md Update README.md Oct 20, 2015 project.clj 1.0.7 -- remove reference to goog.date.DateTime Aug 27, 2014 README.md DEPRECATED As of 10/20/2015, this library is in maintenance mode. We will continue to review pull requests for bug fixes, but for new projects, consider using transit-cljs instead. While built on the same idea of using JSON as the transport format, it is probably more efficient and supports interchange between a multitude of platforms beyond Clojure and ClojureScript. We have been using Transit for the past few months ourselves in Hoplon and it has been a good experience so far. cljson Use cljson to send data between Clojure and ClojureScript applications using JSON as the data transfer format. The cljson library has implementations for Clojure and ClojureScript and supports all the data types that ClojureScript supports, including tagged literals and metadata. Install Artifacts are published on Clojars. Usage There are two functions exported by this library: clj->cljson and cljson->clj. They convert Clojure data to and from JSON strings. user=> (require '[tailrecursion.cljson :refer [clj->cljson cljson->clj]]) nil  user=> (clj->cljson [1 2 3]) ""[\""v\"",1,2,3]""  user=> (cljson->clj ""[\""v\"",1,2,3]"") [1 2 3]  user=> (clj->cljson '(1 2 3)) ""[\""l\"",1,2,3]""  user=> (cljson->clj ""[\""l\"",1,2,3]"") (1 2 3)  user=> (clj->cljson [(java.util.Date.) {[1 2 3] :foo 'bar #{""bar""}}]) ""[\""v\"",[\""inst\"",\""2013-06-24T17:34:04.183-00:00\""],[\""m\"",[\""v\"",1,2,3],[\""k\"",\""foo\""],[\""y\"",\""bar\""],[\""s\"",\""bar\""]]]""  user=> (cljson->clj ""[\""v\"",[\""inst\"",\""2013-06-24T17:34:04.183-00:00\""],[\""m\"",[\""v\"",1,2,3],[\""k\"",\""foo\""],[\""y\"",\""bar\""],[\""s\"",\""bar\""]]]"") [#inst ""2013-06-24T17:34:04.183-00:00"" {[1 2 3] :foo, bar #{""bar""}}]  user> (defrecord Person [name]) user.Person user> (clj->cljson (Person. ""Bob"")) ""[\""user.Person\"",[\""m\"",[\""k\"",\""name\""],\""Bob\""]]"" user> (binding [*data-readers* {'user.Person map->Person}] (cljson->clj ""[\""user.Person\"",[\""m\"",[\""k\"",\""name\""],\""Bob\""]]"")) #user.Person{:name ""Bob""} Tagged Literals Cljson provides the EncodeTagged protocol which can be extended to user types and records. This protocol is used to transform a Clojure/ClojureScript thing into JSON-ready data. If a type does not satisfy this protocol then cljson will use the core printer to obtain a printed representation of the thing. If the printed representation is a tagged literal then the data part is reread and converted to JSON-ready data. Reading of tagged literals is done via the normal tagged literal mechanisms built into Clojure and ClojureScript. Have a look at cljson.clj and cljson.cljs to see examples of this. Metadata Bind *print-meta* to true to have metadata included in the JSON output. ClojureScript and Records Unlike clojure.core, ClojureScript lacks a *data-readers* dynamic var. Instead, use cljs.reader's register-tag-parser! function to declare constructors for records and types: (ns example   (:require [tailrecursion.cljson :refer [clj->cljson cljson->clj]]             [cljs.reader          :refer [register-tag-parser!]]))  (defrecord Person [name]) (register-tag-parser! ""example.Person"" map->Person) (print (cljson->clj (clj->cljson (Person. ""Bob"")))) ;=> #example.Person{:name Bob} License Copyright © 2013 Alan Dipert and Micha Niskin Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/tailrecursion/cljson"	"– Clojure/ClojureScript library for accelerated browser data deserialization."	"true"
"Data Serialization"	"Transit"	"https://github.com/cognitect/transit-cljs"	"– A data interchange format and set of libraries for conveying values between applications written in different programming languages."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"180"	"45"	"8"	"GitHub - cognitect/transit-cljs: Transit for ClojureScript Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 45 Star 180 Fork 8 cognitect/transit-cljs Code Issues 5 Pull requests 0 Wiki Pulse Graphs Transit for ClojureScript http://transit-format.org 242 commits 2 branches 32 releases 4 contributors Clojure 87.4% Shell 9.6% HTML 2.4% JavaScript 0.6% Clojure Shell HTML JavaScript Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show v0.8.239 v0.8.237 v0.8.232 v0.8.225 v0.8.220 v0.8.219 v0.8.218 v0.8.215 v0.8.207 v0.8.205 v0.8.202 v0.8.199 v0.8.194 v0.8.192 v0.8.188 v0.8.186 v0.8.184 v0.8.182 v0.8.178 v0.8.176 v0.8.174 v0.8.172 v0.8.170 v0.8.168 v0.8.166 v0.8.165 v0.0 0.8.161 0.8.160 0.8.158 0.8.152 0.8.137 Nothing to show New pull request Latest commit 46a8f5f Jun 20, 2016 swannodette cleanup pom and deps Permalink Failed to load latest commit information. bench/transit update benchmark to load the files from the right location Jul 18, 2014 bin cleanup namespace, now aligns nicely with transit-clj Jul 14, 2014 build update to latest codox for api docs Oct 20, 2015 resources Clojure 1.6.0 and ClojureScript 0.0-2261 dep. Better settings for dev Jul 1, 2014 script set REPL :verbose true Dec 15, 2015 src/cognitect TCLJS-26: exclude uuid? Jun 20, 2016 test/transit cleanup pom and deps Jun 20, 2016 .gitignore add Node REPL script, ignore .cljs_node_repl May 10, 2015 LICENSE add license Jul 3, 2014 README.md Update README.md with 0.8.239 Jun 20, 2016 VERSION_PREFIX version needs to match spec version Jul 16, 2014 pom.xml cleanup pom and deps Jun 20, 2016 project.clj TCLJS-22: bump transit dependency, add test Dec 21, 2015 README.md transit-cljs Transit is a data format and a set of libraries for conveying values between applications written in different languages. This library provides support for marshalling Transit data to/from ClojureScript. Unlike the Java and Clojure implementations it relies on the non-streaming JSON parsing mechanism of the host JavaScript environment. Rationale API docs Specification Getting Started This implementation's major.minor version number corresponds to the version of the Transit specification it supports. NOTE: Transit is a work in progress and may evolve based on feedback. As a result, while Transit is a great option for transferring data between applications, it should not yet be used for storing data durably over time. This recommendation will change when the specification is complete. Releases and Dependency Information Latest release: 0.8.239 All Released Versions Leiningen Add the following to your project.clj :dependencies: [com.cognitect/transit-cljs ""0.8.239""]  Maven Maven dependency information: <dependency>   <groupId>com.cognitect</groupId>   <artifactId>transit-cljs</artifactId>   <version>0.8.239</version> </dependency> Usage (ns example   (:require [cognitect.transit :as t]))  (defn roundtrip [x]   (let [w (t/writer :json)         r (t/reader :json)]     (t/read r (t/write w x))))  (defn test-roundtrip []   (let [list1 [:red :green :blue]         list2 [:apple :pear :grape]         data  {(t/integer 1) list1                (t/integer 2) list2}         data' (roundtrip data)]     (assert (= data data')))) Default Type Mapping Abbreviations: cc = cljs.core gm = goog.math cct = com.cognitect.transit Transit type Write accepts Read returns null null null string String String boolean Boolean Boolean integer Number, gm.Long Number, gm.Long decimal Number Number keyword cc.Keyword cc.Keyword symbol cc.Symbol cc.Symbol big integer cct.BigInteger cct.BigInteger big decimal cct.BigDecimal cct.BigDecimal time Date Date uri cct.URI cct.URI uuid cct.UUID cct.UUID char String String array cc.IVector cc.IVector list cc.IList cc.IList set cc.ISet cc.ISet map cc.IMap cc.IMap link cct.Link cct.Link cmap cct.IMap cct.IMap Contributing This library is open source, developed internally by Cognitect. We welcome discussions of potential problems and enhancement suggestions on the transit-format mailing list. Issues can be filed using GitHub issues for this project. Because transit is incorporated into products and client projects, we prefer to do development internally and are not accepting pull requests or patches. Development Dependencies Install dependencies with lein deps  Running the tests & benchmarks Running the tests: lein cljsbuild once test  In order to run the transit-format bin/verify you must first clone transit-format into the same parent directory as your transit-cljs checkout and build the roundtrip file: lein cljsbuild once roundtrip  To run the benchmarks you must first clone transit-format into the same parent directory as your transit-cljs checkout. Running the benchmarks: lein cljsbuild once bench node target/transit.bench.js  Build Build JAR for ClojureScript Assuming you have a JDK and Maven installed, the following will install a JAR suitable for use from ClojureScript into your local Maven repository. build/package_local  Copyright and License Copyright © 2014 Cognitect Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/cognitect/transit-cljs"	"– A data interchange format and set of libraries for conveying values between applications written in different programming languages."	"true"
"Data Visualition"	"C2"	"https://keminglabs.com/c2"	"– It lets you declaratively create HTML and SVG markup based on data."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"626"	"45"	"50"	"GitHub - lynaghk/c2: Declarative data visualization in Clojure(Script). Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 45 Star 626 Fork 50 lynaghk/c2 Code Issues 8 Pull requests 1 Pulse Graphs Declarative data visualization in Clojure(Script). http://keminglabs.com/c2/ 317 commits 3 branches 11 releases Fetching contributors JavaScript 57.5% Clojure 42.3% Other 0.2% JavaScript Clojure Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master no-match undom Nothing to show v0.2.2 v0.2.0 v0.1.2 v0.1.1 v0.1.0 v0.1.0-beta1 v0.1.0-RC4 v0.1.0-RC3 v0.1.0-RC2 v0.1.0-RC1 v0.0.1 Nothing to show New pull request Latest commit c6b51e4 Mar 2, 2016 lynaghk Add deprecation notice. Permalink Failed to load latest commit information. resources/closure-js/externs Move externs to path that'll get picked up automatically by cljsbuild… May 29, 2012 src Merge pull request #29 from jblomo/svg-line Apr 23, 2014 test Merge pull request #29 from jblomo/svg-line Apr 23, 2014 vrepl Actually use color scale in SVG output Dec 30, 2013 .gitignore Ignore cljsbuild's output in target/, update cljsbuild config to use … Feb 2, 2013 .gitmodules Remove Pinot & ClojureScript submodules; use CLJS compiler from offic… Feb 23, 2012 CHANGES.markdown Release 0.2.3. May 31, 2013 LICENSE Remove ColorBrewer license info, since those schemes are now in Vomni… Mar 17, 2012 README.markdown Add deprecation notice. Mar 2, 2016 TODO.markdown Release v0.2.2 Feb 2, 2013 project.clj Use latest SNAPSHOT versions of singult and reflex. Oct 13, 2013 README.markdown   _____   ___    / ____| |__ \  | |         ) | | |        / /  | |____   / /_   \_____| |____|  Declarative visualization in Clojure(Script)  C2 is a D3-inspired data visualization library for Clojure and ClojureScript. As with D3, the core idea is to build declarative mappings from your data to HTML or SVG markup. This lets you leverage CSS and the existing web ecosystem to construct bespoke data visualizations. C2 encourages a ""data-driven"" approach to application design. Compose pure functions to map your data to native Clojure vectors and maps that represent the DOM, and then let the library handle rendering into actual elements (on the clientside) or a string of markup (on the serverside). In a browser, C2 handles DOM updates as well, so it will add/remove nodes and set attributes/styles when your data changes so you don't have to deal with the incidental state and complexity of low-level, imperative manipulation. To see what this ""data-driven"" approach looks like in a simple application, see this C2-powered todo list. See also: Google group Example visualizations Annotated source Deprecated C2 was first released in Jan 2012 and in May 2012 its DOM-manipulation engine was factored into a separate library, Singult. Singult's core idea, providing an data-oriented abstraction for DOM-manipulation, has since been adopted by many other projects---most notably React.js (released May 2013). These libraries provide a superset of C2/Singult's capabilities: Everything you can make in C2/Singult you can also make using React.js. React.js is likely faster (using ""virtual DOM diffs"" rather than direct DOM walking) and provides API hooks into low-level details via lifecycle methods. So, rather than use C2 I suggest you look into: React.js: Similar ideas as C2, but supported by Facebook and the trendy JavaScript masses. Rum: ClojureScript bindings to React.js. This is what I use now instead of C2. Elm: A compile-to-JS language that includes a virtual DOM system, typed pattern matching, and the most humane compiler messages I've ever seen. In terms of data visualization specifically, I suggest: Show me the numbers: A great coverage of the fundamentals (hint: use a lot of bar and line charts). Drawing points, rectangles, and lines using SVG or HTML flexbox. Sticking to simple animations using CSS transitions or (even better) come up with a design that doesn't rely on animation/interaction. Play around See vrepl/README.markdown for instructions on using the built-in examples+interactive-development server (Clojure-only). For a full ClojureScript application example, check out the C2-powered todo list. There's also a two minute screencast, and a longer overview/tutorial video on the library. To use from Clojure/ClojureScript add this to your project.clj: [com.keminglabs/c2 ""0.2.3""]  Leiningen 2.0.0 is required. For ClojureScript development, check out lein-cljsbuild. Differences from D3 Language D3 is written in JavaScript and C2 is written in Clojure. Clojure is a richer language than JavaScript, with features like destructuring, lazy evaluation, namespaces, and macros, which JavaScript does not provide. Since Clojure runs on the Java Virtual Machine, it's possible to work with much larger data sets than JavaScript can handle, directly access datastores, and perform advanced computations (in parallel). C2 also leverages ClojureScript, a Clojure-to-JavaScript compiler, so you can take advantage of the expressiveness of Clojure while maintaining the reach of JavaScript. The ClojureScript compiler is built on Google's Closure compiler, and in many cases your visualizations may compile to JavaScript with a smaller file size than the D3.js library itself! (If you want a ClojureScript library that actually leverages D3, take a look at the awesomely polyfilled Strokes library.) View is data Rather than think of DOM nodes as foreign objects to be manipulated with methods like addChild or setClass, in C2 you build the DOM you want using standard Clojure data structures like vectors and maps. That is, you just specify what you want on the DOM by composing pure functions. Since all you're doing is data transformation, you don't actually need a DOM; that means you can test your code without a browser render all of your visualizations on the server and send down pure markup render visualizations with computationally-heavy mappings (e.g., detailed map projections or Hilbert curves) on background web workers With standard data structures, you're also not limited (as in D3) to mapping each datum to a single DOM node. For instance, you could build a bar chart's title, bars, and their labels all at the same time: (bind! ""#barchart""        [:div#barchart         [:h2 ""Rad barchart!""]         [:div.bars          (unify {""A"" 1, ""B"" 2, ""C"" 4, ""D"" 3}                 (fn [[label val]]                   [:div.bar                    [:div.bar-fill {:style {:width (x-scale val)}}]                    [:span.label label]]))]]) whereas in D3 (because of the chained syntax) you'd have to build the bars and labels in separate passes (or manually, using each). Sensible state All of Clojure's data structures are immutable; if you want to model mutable state, explicit semantics are required. Both Clojure and ClojureScript have the atom reference type, which just ""points"" to an immutable value. If you want to ""change"" an atom, you point it to another immutable value. To get at the value, you have to explicitly dereference it using the @ syntax (e.g., @a ;;=> ""stuff pointed at by a"") C2 takes advantage of this to automatically setup bindings. In the previous example, if the bar chart's data were dereferenced from an atom rather than being inlined ({""A"" 1, ""B"" 2, ""C"" 4, ""D"" 3}), then the bind! macro would automatically watch that atom and re-render the view when the atom pointed to a new value. (Watchers are added to every atom that is dereferenced within bind!.) No animation Unlike D3, C2 does not have an animation system, although you can use CSS transitions to perform animations. Development The C2 library itself is a grab bag of data visualization helpers (scales, map projections, &c.) and some wrappers around the Google Closure library's DOM-manipulation and event handling facilities. The core DOM-manipulation and binding functionality is provided by two other libraries: Singult renders hiccup vectors into DOM-elements and merges into existing DOM trees. Singult is written in CoffeeScript (for speed) and does not depend on ClojureScript at all, so you can use it from plain JavaScript if you like. Reflex provides a macro that ""captures"" dereferenced atoms, which is what powers C2's bind! macro. Reflex also provides some macros to help coordinate (e.g., automatically add/remove watchers on multiple atoms). Most of C2 is written in platform-agnostic Clojure using cljx, a Clojure/ClojureScript code generator. If you edit a .cljx file, run lein cljx  to regenerate the corresponding .clj and .cljs files. Unit tests are written in Midje; run with: lein midje  For ClojureScript-specific integration testing, you can run the highly advanced, PhantomJS-powered ""list-of-assertions"" testing framework: lein cljsbuild test  or, if you're too cool to go headless: lein cljsbuild once  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/lynaghk/c2"	"– It lets you declaratively create HTML and SVG markup based on data."	"true"
"Database"	"Datascript"	"https://github.com/tonsky/datascript"	"– An immutable in-memory database and Datalog query engine in ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"2150"	"138"	"136"	"GitHub - tonsky/datascript: Immutable database and Datalog query engine for Clojure, ClojureScript and JS Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 138 Star 2,150 Fork 136 tonsky/datascript Code Issues 17 Pull requests 3 Wiki Pulse Graphs Immutable database and Datalog query engine for Clojure, ClojureScript and JS 335 commits 1 branch 41 releases 22 contributors Clojure 94.4% JavaScript 5.0% Other 0.6% Clojure JavaScript Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show 0.15.2 0.15.1 0.15.0 0.14.0 0.13.3 0.13.2 0.13.1 0.13.0 0.12.2 0.12.1 0.12.0 0.11.6 0.11.5 0.11.4 0.11.3 0.11.2 0.11.1 0.11.0 0.10.0 0.9.0 0.8.1 0.8.0 0.7.2 0.7.1 0.7.0 0.6.0 0.5.2 0.5.1 0.5.0 0.4.2 0.4.1 0.4.0 0.3.1 0.3.0 0.2.1 0.2.0 0.1.6 0.1.5 0.1.4 0.1.3 0.1.2 Nothing to show New pull request Latest commit 7e77545 Jul 13, 2016 tonsky Version 0.15.2 Permalink Failed to load latest commit information. bench Renamed datascript.core → datascript.db, datascript → datascript.core Sep 20, 2015 dev Renamed datascript.core → datascript.db, datascript → datascript.core Sep 19, 2015 release-js Version 0.15.2 Jul 13, 2016 src large long entity ids were breaking `init-db` (closes #165) Jul 13, 2016 test Version 0.15.1 Jul 6, 2016 .gitignore Node.js and Browser repls for dev profile (closes #93) Jul 20, 2015 .travis.yml Added new built-ins Jan 10, 2016 CHANGELOG.md Version 0.15.2 Jul 13, 2016 LICENSE ns renamed Apr 24, 2014 README.md Version 0.15.2 Jul 13, 2016 circle.yml Added new built-ins Jan 10, 2016 dev.html Node.js and Browser repls for dev profile (closes #93) Jul 19, 2015 project.clj Version 0.15.2 Jul 13, 2016 test_node.js Renamed datascript.core → datascript.db, datascript → datascript.core Sep 19, 2015 README.md What if creating a database would be as cheap as creating a Hashmap? An immutable in-memory database and Datalog query engine in Clojure and ClojureScript. DataScript is meant to run inside the browser. It is cheap to create, quick to query and ephemeral. You create a database on page load, put some data in it, track changes, do queries and forget about it when the user closes the page. DataScript databases are immutable and based on persistent data structures. In fact, they’re more like data structures than databases (think Hashmap). Unlike querying a real SQL DB, when you query DataScript, it all comes down to a Hashmap lookup. Or series of lookups. Or array iteration. There’s no particular overhead to it. You put a little data in it, it’s fast. You put in a lot of data, well, at least it has indexes. That should do better than you filtering an array by hand anyway. The thing is really lightweight. The intention with DataScript is to be a basic building block in client-side applications that needs to track a lot of state during their lifetime. There’s a lot of benefits: Central, uniform approach to manage all application state. Clients working with state become decoupled and independent: rendering, server sync, undo/redo do not interfere with each other. Immutability simplifies things even in a single-threaded browser environment. Keep track of app state evolution, rewind to any point in time, always render consistent state, sync in background without locking anybody. Datalog query engine to answer non-trivial questions about current app state. Structured format to track data coming in and out of DB. Datalog queries can be run against it too. Resources Books: Learning ClojureScript has a chapter on DataScript Docs: Getting started Tutorials DataScript 101 Tips & tricks Posts: How DataScript fits into the current webdev ecosystem DataScript internals explained Sketch of client/server reactive architecture Talks: “Frontend with Joy” talk (FPConf, August 2015): video in Russian “Programming Web UI with Database in a Browser” talk (PolyConf, July 2015): slides, video “DataScript for Web Development” talk (Clojure eXchange, Dec 2014): slides, video “Building ToDo list with DataScript” webinar (ClojureScript NYC, Dec 2014): video, app DataScript hangout (May 2014, in Russian): video Projects using DataScript: Precursor, collaborative prototyping tool LightMesh, datacenter management Cognician, coaching platform bitfountain, iOS courses PartsBox, electronic parts management I am Fy, accessories e-shop Acha-acha, github achievements (sources, code walkthrough) Radiant, datalog sketchpad (sources) Showkr, flickr gallery viewer (sources) Zetawar, turn-based tactical strategy game Related projects: DataScript-Transit, transit serialization for database and datoms Posh, lib that lets you use a single DataScript db to store Reagent app state DataScript-mori, DataScript & Mori wrapper for use from JS DatSync, Datomic ↔︎ DataScript syncing/replication utilities Intension, lib to convert associative structures to in-memory databases for querying them Demo applications: Localisation Demo with Om Next ToDo, task manager demo app (persistence via localStorage and transit, filtering, undo/redo): sources, live CatChat, chat demo app: sources, code walkthrough, live clj-crud, demo CRUD app: sources, blog post OmNext TodoMVC Usage examples For more examples, see our acceptance test suite. :dependencies [   [org.clojure/clojure ""1.7.0""]   [org.clojure/clojurescript ""1.7.228""]   [datascript ""0.15.2""] ] Note: Since DataScript 0.13 main namespace to include is datascript.core, not datascript. This was done because usage of top-level namespaces is discouraged and even generates a warning in CLJS. Old datascript.core, if you were using it, was renamed to datascript.db WARN: ClojureScript versions 1.7.48, 1.7.58 and 1.7.107 break DataScript. Use either 1.7.28, 1.7.122 or newer Note: DataScript 0.11.3 and later requires CLJS 0.0-3291 or later Note: DataScript 0.11.2 and later requires Clojure 1.7.0-beta2 or later Note: DataScript 0.11.0 and later will only work with CLJS 0.0-3196 and later (require '[datascript.core :as d])  ;; Implicit join, multi-valued attribute  (let [schema {:aka {:db/cardinality :db.cardinality/many}}       conn   (d/create-conn schema)]   (d/transact! conn [ { :db/id -1                         :name  ""Maksim""                         :age   45                         :aka   [""Maks Otto von Stirlitz"", ""Jack Ryan""] } ])   (d/q '[ :find  ?n ?a           :where [?e :aka ""Maks Otto von Stirlitz""]                  [?e :name ?n]                  [?e :age  ?a] ]        @conn))  ;; => #{ [""Maksim"" 45] }   ;; Destructuring, function call, predicate call, query over collection  (d/q '[ :find  ?k ?x         :in    [[?k [?min ?max]] ...] ?range         :where [(?range ?min ?max) [?x ...]]                [(even? ?x)] ]       { :a [1 7], :b [2 4] }       range)  ;; => #{ [:a 2] [:a 4] [:a 6] [:b 2] }   ;; Recursive rule  (d/q '[ :find  ?u1 ?u2         :in    $ %         :where (follows ?u1 ?u2) ]       [ [1 :follows 2]         [2 :follows 3]         [3 :follows 4] ]      '[ [(follows ?e1 ?e2)          [?e1 :follows ?e2]]         [(follows ?e1 ?e2)          [?e1 :follows ?t]          (follows ?t ?e2)] ])  ;; => #{ [1 2] [1 3] [1 4] ;;       [2 3] [2 4] ;;       [3 4] }   ;; Aggregates  (d/q '[ :find ?color (max ?amount ?x) (min ?amount ?x)         :in   [[?color ?x]] ?amount ]      [[:red 10]  [:red 20] [:red 30] [:red 40] [:red 50]       [:blue 7] [:blue 8]]      3)  ;; => [[:red  [30 40 50] [10 20 30]] ;;     [:blue [7 8] [7 8]]] Using from vanilla JS DataScript can be used from any JS engine without additional dependencies: <script src=""https://github.com/tonsky/datascript/releases/download/0.15.2/datascript-0.15.2.min.js""></script> or as a CommonJS module (npm page): npm install datascript  var ds = require('datascript'); or as a RequireJS module: require(['datascript'], function(ds) { ... }); Queries: Query and rules should be EDN passed as strings Results of q are returned as regular JS arrays Entities: Entities returned by entity call are lazy as in Clojure Use e.get(""prop""), e.get("":db/id""), e.db to access entity properties Entities implement ECMAScript 6 Map interface (has/get/keys/...) Transactions: Use strings such as "":db/id"", "":db/add"", etc. instead of db-namespaced keywords Use regular JS arrays and objects to pass data to transact and db_with Transaction reports: report.tempids has string keys (""-1"" for entity tempid -1), use resolve_tempid to set up a correspondence Check out test/js/tests.js for usage examples. Project status Beta quality. Most of the features done, expecting some API polishing (breaking) and performance optimizations. No docs at the moment, use examples & Datomic documentation. The following features are supported: Database as a value: each DB is an immutable value. New DBs are created on top of old ones, but old ones stay perfectly valid too Triple store model EAVT, AEVT and AVET indexes Multi-valued attributes via :db/cardinality :db.cardinality/many Lazy entities and :db/valueType :db.type/ref auto-expansion Database “mutations” via transact! Callback-based analogue to txReportQueue via listen! Direct index lookup and iteration via datoms and seek-datoms Filtered databases via filter Lookup refs Unique constraints, upsert Pull API (thx David Thomas Hume) Query engine features: Implicit joins Query over DB or regular collections Parameterized queries via :in clause Tuple, collection, relation binding forms in :in clause Query over multiple DB/collections Predicates and user functions in query Rules, recursive rules Aggregates Find specifications Interface differences: Conn is just an atom storing last DB value, use @conn instead of (d/db conn) Instead of #db/id[:db.part/user -100] just use -100 in place of :db/id or entity id Transactor functions can be called as [:db.fn/call f args] where f is a function reference and will take db as first argument (thx @thegeez) Custom query functions and aggregates should be passed as source instead of being referenced by symbol (due to lack of resolve in CLJS) Custom aggregate functions are called via aggregate keyword: :find (aggregate ?myfn ?e) :in $ ?myfn Additional :db.fn/retractAttribute shortcut Transactions are not annotated by default with :db/txInstant Expected soon: Better error reporting Proper documentation not, not-join, or and or-join datalog clauses Differences from Datomic DataScript is built totally from scratch and is not related by any means to the popular Clojure database Datomic Runs in a browser and/or in a JVM Simplified schema, not queryable Attributes do not have to be declared in advance. Put them to schema only when you need special behaviour from them Any type can be used for values No :db/ident attributes, keywords are literally attribute values, no integer id behind them No schema migrations No cache segments management, no laziness. Entire DB must reside in memory No facilities to persist, transfer over the wire or sync DB with the server No pluggable storage options, no full-text search, no partitions No external dependencies Free Aimed at interactive, long-living browser applications, DataScript DBs operate in constant space. If you do not add new entities, just update existing ones, or clean up database from time to time, memory consumption will be limited. This is unlike Datomic which keeps history of all changes, thus grows monotonically. DataScript does not track history by default, but you can do it via your own code if needed. Some of the features are omitted intentionally. Different apps have different needs in storing/transfering/keeping track of DB state. DataScript is a foundation to build exactly the right storage solution for your needs without selling too much “vision”. License Copyright © 2014–2015 Nikita Prokopov Licensed under Eclipse Public License (see LICENSE). Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/tonsky/datascript"	"– An immutable in-memory database and Datalog query engine in ClojureScript."	"true"
"Database"	"Jaki"	"https://github.com/pandeiro/jaki"	"– A simple ClojureScript CouchDB client."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"11"	"1"	"4"	"GitHub - pandeiro/jaki: A simple ClojureScript CouchDB client Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 1 Star 11 Fork 4 pandeiro/jaki Code Issues 0 Pull requests 0 Pulse Graphs A simple ClojureScript CouchDB client 40 commits 1 branch 0 releases Fetching contributors Clojure 83.8% Shell 15.8% JavaScript 0.4% Clojure Shell JavaScript Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. couchapp-template script src/jaki .gitignore README.md project.clj README.md Jaki 0.1.0 Browser-based CouchDB applications with ClojureScript Jaki's principal components are src/jaki/req.cljs: a request client that automatically converts Clojure and JavaScript datatypes src/jaki/couch.cljs: a basic library covering most of the CouchDB API using Clojure idioms couchapp-template & script/jaki: a template and script for generating new projects (to be used with the couchapp upload tool). Usage With leiningen: [jaki ""0.1.0""] ...or just copy the src/jaki directory to your ClojureScript project. Use or require the library's namespace: (ns myapp.core   (:require [jaki.couch :as couch]))  (couch/all-dbs (fn [dbs] (js/alert (apply str (interpose "", "" dbs))))) Setup Jaki will automatically try to use the URL path to determine the current database, although you can always specify the database in each request as well. You also have the option of setting a default database to use: (couch/set-default-db ""jazz"") (couch/get-docs (fn [resp] (js/alert (str (count (:rows resp)) "" docs found in 'jazz' database"")))) If you are able to do cross-domain XHR requests, as with browser extensions, you can set the host like so: (couch/set-host! ""http://username.iriscouch.com"") If your endpoint is not at the root of the URL path, you can set a prefix like so: (couch/set-url-prefix ""myapp"") Couch CRUD Jaki abstracts CRUD operations to three main functions: get-docs, post-docs, and delete-docs. get-docs At its simplest, Jaki guesses the current database (or taps a default database if set), and requests all documents (with include_docs=true): (get-docs (fn [resp] (js/alert (str (-> resp :rows count) "" documents found!"")))) There's also some sugar for limiting the number of results (also implies include_docs=true): (get-docs 10 (fn [resp]                 (js/alert (apply str (map #(str %2 "". "" (:id %1) ""\n"") (:rows resp) (iterate inc 1)))))) And there's sugar for specifying just the document(s) you want by id, like so (also implies include_docs=true): (get-docs [""_design/app"" ""_design/test""]           (fn [docs] (js/alert (str (count (map #(-> % :views keys) docs)) "" total views found"")))) For more granular control, specify a view-map with a database and/or design document, view, and options (no implict include_docs=true): (get-docs {:db ""articles"" :design ""blog"" :view ""most-recent"" :descending true :include_docs true :limit 10}           (fn [resp] (js/alert (-> resp :rows first :doc :title)))) post-docs You can save a document (map) or vector of documents, with or without a callback, and with or without specifying the database: (post-docs {:_id ""b9725ae4542ce6252937"" :_rev ""3-a2362326892374879692""} (fn [resp] (js/alert ""Updated!"")))  (post-docs ""albums"" [{:title ""St. Louis Blues"" :album ""Sunshine of my Soul"" :recorded -68508000000}                      {:title ""Parisian Thoroughfare"" :album ""The Jaki Byard Experience"" :recorded -40683600000}]) delete-docs Likewise, documents can be deleted in the same way they are posted: (delete-docs {:_id ""b9725ae4542ce6252937"" :_rev ""3-a2362326892374879692""})  (delete-docs ""albums"" [{:_id ""ce672987ad32919732523b6"" :_rev ""2-ab4452cd382236274346""}                        {:_id ""ce672987ad32919732527f9"" :_rev ""1-f32353a25bc544574232""}]              (fn [resp] (js/alert ""Deleted!""))) There's also sugar for when you don't have the rev handy, in which case you can just use the id string, though this has a performance penalty of an extra request behind-the-scenes to retrieve the _rev: (delete-docs [""ce672987ad32919732523b6"" ""ce672987ad32919732527f9""]) App Generator Script To generate an application skeleton, edit jaki/script to use the appropriate template location, make sure it's executable, place the script somewhere in your $PATH, and run it: jaki new myapp  This will create a new subdirectory myapp in the current directory, containing app and src subdirectories. Inside app will be a basic couchapp structure with an index.html that already contains a reference to your app and the entrypoint invocation myapp.start(). From here, simply specify authentication credentials and target database in .couchapprc and compile the src subdirectory and you are ready to push your couchapp. API Todo Listening for _changes Replication Contributing This is my first real attempt at writing a library and using ClojureScript. I am very grateful to anyone who wants to use, test, or contribute to this project. You can get in touch with me here on github or on freenode's #clojure and #couchdb channels. License Copyright (C) 2011 Murphy McMahon Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/pandeiro/jaki"	"– A simple ClojureScript CouchDB client."	"true"
"Database"	"Konserve"	"https://github.com/replikativ/konserve"	"– A clojuresque key-value/document store protocol with core.async."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"14"	"5"	"0"	"GitHub - replikativ/konserve: A clojuresque key-value/document store protocol with core.async. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 14 Fork 0 replikativ/konserve Code Issues 0 Pull requests 0 Pulse Graphs A clojuresque key-value/document store protocol with core.async. 50 commits 1 branch 0 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src/konserve test/konserve .gitignore LICENSE README.md project.clj README.md konserve Simple durability, made easy. A key-value store protocol defined with core.async semantics to allow Clojuresque collection operations on associative key-value stores, both from Clojure and ClojureScript for different backends. Data is generally serialized with edn semantics or, if supported, as native binary blobs and can be accessed similar to clojure.core functions get-in,assoc-in and update-in. update-in especially allows to run functions atomically and returns old and new value. Each operation is run atomically and must be consistent (in fact ACID), but further consistency is not supported (Riak, CouchDB and many scalable solutions don't have transactions over keys for that reason). This is meant to be a building block for more sophisticated storage solutions (Datomic also builds on kv-stores). It is not necessarily fast depending on the usage pattern. The general idea is to write most values once (e.g. in form of index fragments) and only update one place once all data is written, similar to Clojure's persistent datastructures. To store values under non-conflicting keys, have a look at hasch. This was initially implemented as an elementary storage protocol for replikativ. Supported Backends A file-system store in Clojure and IndexedDB for ClojureScript are provided as elementary reference implementations for the two most important platforms. No setup and no additional dependencies are needed. fs-store The file-system store currently uses fressian and is quite efficient. It also allows to access values as a normal file-system file, e.g. to open it with a native database like HDF5 in Java. IndexedDB For IndexedDB there is no internal JSON-representation of the underlying store like transit yet, hence it is fairly slow for edn still. There is a JSON store protocol implemented for IndexedDB in case interoperability with a JavaScript application is wanted. Be careful not to confuse values with edn values, they are stored in separate locations and cannot clash. External Backends The protocol is implemented for CouchDB in a separate project konserve-couch New storage backends, e.g. Riak, MongoDB, Redis, JDBC, WebSQL, Local-Storage are welcome. Serialization formats Different formats for edn serialization like fressian, transit or a simple pr-str version are supported and can be combined with different stores. Stores have reasonable default setting. You can also extend the serialization protocol to other formats if you need it. You also need to provide incognito support for records, if you need them. Tagged Literals You can read and write custom records according to incognito. Usage Add to your leiningen dependencies: For simple purposes a memory store wrapping an Atom is implemented as well: (ns test-db   (:require [konserve.memory :refer [new-mem-store]]             [konserve.core :as k]))  (go (def my-db (<! (new-mem-store)))) ;; or (go (def my-db (<! (new-mem-store (atom {:foo 42}))))) From a Clojure REPL run: (ns test-db     (:require [konserve.filestore :refer [new-fs-store]]               [konserve.core :as k]               [clojure.core.async :as async :refer [<!!]]))  (def store (<!! (new-fs-store ""/tmp/store"")))  (<!! (k/assoc-in store [""foo"" :bar] {:foo ""baz""})) (<!! (k/get-in store [""foo""])) (<!! (k/exists? store ""foo""))  (<!! (k/assoc-in store [:bar] 42)) (<!! (k/update-in store [:bar] inc)) (<!! (k/get-in store [:bar]))  (let [ba (byte-array (* 10 1024 1024) (byte 42))]   (time (<!! (k/bassoc store ""banana"" ba)))) (<!! (k/bget store ""banana"" :input-stream)) In ClojureScript from a browser (you need IndexedDB available in your js env): (ns test-db   (:require [konserve.indexeddb :refer [new-indexeddb-store]])   (:require-macros [cljs.core.async.macros :refer [go go-loop]]))  (go (def my-db (<! (new-indexeddb-store ""konserve""))))  (go (println ""get:"" (<! (k/get-in my-db [""test"" :a]))))  (go (doseq [i (range 10)]        (<! (k/assoc-in my-db [i] i))))  ;; prints 0 to 9 each on a line (go (doseq [i (range 10)]       (println (<! (k/get-in my-db [i])))))  (go (println (<! (k/assoc-in my-db [""test""] {:a 1 :b 4.2}))))  (go (println (<! (k/update-in my-db [""test"" :a] inc)))) ;; => ""test"" contains {:a 2 :b 4.2} An example for ClojureScript with IndexedDB is: (defrecord Test [a])  (go (def my-store (<! (new-indexeddb-store ""konserve"" (atom {'user.Test                                                              map->Test})))))  (go (println (<! (k/assoc-in my-store [""rec-test""] (Test. 5))))) (go (println (<! (k/get-in my-store [""rec-test""])))) For more examples have a look at the comment blocks at the end of the respective namespaces. JavaScript bindings There are experimental javascript bindings in the konserve.js namespace: goog.require(""konserve.js"");  konserve.js.new_mem_store(function(s) { store = s; }); # or konserve.js.new_indexeddb_store(""test_store"", function(s) { store = s; })  konserve.js.exists(store, [""foo""], function(v) { console.log(v); }); konserve.js.assoc_in(store, [""foo""], 42, function(v) {}); konserve.js.get_in(store,                    [""foo""],                    function(v) { console.log(v); }); konserve.js.update_in(store,                       [""foo""],                       function(v) { return v+1; },                       function(res) { console.log(""Result:"", res); }); TODO add transit cljs support (once it is declared stable) implement generic cached store(s) to wrap durable ones depend on hasch and use uuid hash as key/filename for file-store (and others) allow to iterate keys (model a cursor? or just return a snapshot of keys?) move repl examples to tests calculate deltas and store base-value and edn patches, to allow fast small nested updates Changelog 0.3.6 experimental JavaScript bindings 0.3.4 use fixed incognito version 0.3.0 - 0.3.2 fix return value of assoc-in 0.3.0-beta3 Wrap protocols in proper Clojure functions in the core namespace. Implement assoc-in in terms of update-in Introduce serialiasation protocol with the help of incognito and decouple stores 0.3.0-beta1 filestore: disable cache factor out all tagged literal functions to incognito use reader conditionals bump deps 0.2.3 filestore: flush output streams, fsync on fs operations filestore can be considered beta quality couchdb: add -exists? couchdb: move to new project remove logging and return ex-info exceptions in go channel 0.2.2 filestore: locking around java strings is a bad idea, use proper lock objects filestore: do io inside async/thread (like async's pipeline) to not block the async threadpool filestore: implement a naive cache (flushes once > 1000 values) filestore, indexeddb: allow to safely custom deserialize file-inputstream in transaction/lock filestore, indexeddb, memstore: implement -exists? 0.2.1 filestore: fix fressian collection types for clojure, expose read-handlers/write-handlers filestore: fix -update-in behaviour for nested values filestore: fix rollback renaming order 0.2.0 experimental native ACID file-store for Clojure native binary blob support for file-store, IndexedDB and mem-store License Copyright © 2014-2016 Christian Weilbach & Konrad Kühne Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/replikativ/konserve"	"– A clojuresque key-value/document store protocol with core.async."	"true"
"Development"	"Ambly"	"https://github.com/omcljs/ambly"	"— A ClojureScript REPL into iOS JavaScriptCore."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"430"	"29"	"19"	"GitHub - omcljs/ambly: ClojureScript REPL into embedded JavaScriptCore Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 29 Star 430 Fork 19 omcljs/ambly Code Issues 8 Pull requests 0 Wiki Pulse Graphs ClojureScript REPL into embedded JavaScriptCore 302 commits 2 branches 7 releases Fetching contributors Objective-C 50.7% Clojure 47.2% Ruby 1.4% Other 0.7% Objective-C Clojure Ruby Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master tvos Nothing to show 0.7.0 0.6.0 0.5.0 0.4.0 0.3.0 0.2.0 0.1.0 Nothing to show New pull request Latest commit 923e58c Jan 10, 2016 mfikes 0.7.0 release prep Permalink Failed to load latest commit information. Clojure 0.7.0 release prep Jan 10, 2016 ObjectiveC 0.7.0 release prep Jan 10, 2016 .gitignore Ignore .DS_Store May 1, 2015 Ambly.podspec 0.7.0 release prep Jan 10, 2016 LICENSE Revert back to LICENSE file May 23, 2015 README.md 0.7.0 release prep Jan 10, 2016 icon.png Link in an icon Mar 5, 2015 README.md Ambly A ClojureScript REPL into embedded JavaScriptCore on iOS, OS X, and tvOS. Ambly is a REPL designed for use when developing hybrid ClojureScript / native apps. Ambly comprises a ClojureScript REPL implementation, along with Objective-C code interfacing JavaScriptCore. An iOS and tvOS demo app is included, making it easy to give the REPL a spin. pod ""Ambly"", ""~> 0.7.0""  Running Prerequisites You must have Xcode installed as well as support for CocoaPods. You must have Java 7 or later installed along with Leiningen or Boot. Demo App In ambly/ObjectiveC/Ambly Demo run pod install. Open Ambly Demo.xcworkspace in Xcode and run the app in the simulator or on a device. REPL In ambly/Clojure run script/repl to start the REPL if you're using Leiningen. If you're using Boot, run $ boot ambly. Here is a sample REPL startup sequence, illustrating device auto-discovery: $ lein run   [1] Ambly Demo on iPod touch [2] Ambly Demo on iPad [3] Ambly Demo on iPhone Simulator (My-Mac-Pro) [4] Ambly Demo TV on Apple TV  [R] Refresh  Choice: 1  Connecting to Ambly Demo on iPod touch ...  To quit, type: :cljs/quit cljs.user=> (+ 3 4) 7  Note: See Connectivity for details, should any networking difficulty arise. Manual REPL Startup If you would like to manually start the Ambly REPL from a Clojure REPL, issue the following two forms: (require   '[cljs.repl :as repl]   '[ambly.core :as ambly]) (repl/repl (ambly/repl-env)) rlwrap For a better REPL experience (keyboard input editing and history support), you can install rlwrap under OS X with Homebrew: brew install rlwrap  Then script/repl will automatically detect rlwrap and use it. Contributing Please contact David Nolen via email to request an electronic Contributor Agreement. Pull requests will be accepted once your electronic CA has been signed and returned. Copyright and license Copyright © 2015–2016 David Nolen Licensed under the EPL (see the file LICENSE). Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/omcljs/ambly"	"— A ClojureScript REPL into iOS JavaScriptCore."	"true"
"Development"	"cljs-devtools"	"https://github.com/binaryage/cljs-devtools"	"Better presentation of ClojureScript values in Chrome Devtools."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"531"	"22"	"12"	"GitHub - binaryage/cljs-devtools: A collection of Chrome DevTools enhancements for ClojureScript developers Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 22 Star 531 Fork 12 binaryage/cljs-devtools Code Issues 4 Pull requests 0 Wiki Pulse Graphs A collection of Chrome DevTools enhancements for ClojureScript developers 365 commits 1 branch 19 releases 3 contributors Clojure 68.0% JavaScript 30.7% Other 1.3% Clojure JavaScript Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v0.7.2 v0.7.1 v0.7.0 v0.6.1 v0.6.0 v0.5.4 v0.5.3 v0.5.2 v0.5.1 v0.5.0 v0.4.1 v0.4.0 v0.3.0 v0.2.2 v0.2.1 v0.2.0 v0.1.2 v0.1.1 v0.1.0 Nothing to show New pull request Latest commit 868cf1e Jul 6, 2016 darwin test :external-config instead of :tooling-config Permalink Failed to load latest commit information. docs docs: add a note about new :preloads based install Jun 22, 2016 scripts move all sources under src dir Jun 6, 2016 src read configuration from :external-config, deprecate :tooling-config Jul 6, 2016 test make some format tests more DRY Jul 6, 2016 .gitignore reorganize test directory tree (preparation for dead-code-elimination) Mar 25, 2016 .travis.yml Tell Travis to use PhantomJS 2.0 Oct 16, 2015 changelog.md add changelog Mar 26, 2016 license.txt update license Jan 20, 2016 project.clj test :external-config instead of :tooling-config Jul 6, 2016 readme.md update readme Apr 7, 2016 readme.md cljs-devtools A collection of Chrome DevTools enhancements for ClojureScript developers: Better presentation of ClojureScript values in Chrome DevTools More informative exceptions Documentation Installation FAQ An example of formatting various ClojureScript data structures: Scope view / drawer Console (toggle with ESC) An example of a sanity hint: Read more in v0.4.0 release notes. What next? Dirac DevTools Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/binaryage/cljs-devtools"	"Better presentation of ClojureScript values in Chrome Devtools."	"true"
"Development"	"lein-cljsbuild"	"https://github.com/emezeske/lein-cljsbuild"	"— A Leiningen plugin to make ClojureScript development easy."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"846"	"36"	"149"	"GitHub - emezeske/lein-cljsbuild: Leiningen plugin to make ClojureScript development easy. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 36 Star 846 Fork 149 emezeske/lein-cljsbuild Code Issues 29 Pull requests 7 Wiki Pulse Graphs Leiningen plugin to make ClojureScript development easy. 527 commits 3 branches 54 releases 50 contributors Clojure 94.7% JavaScript 2.7% Shell 1.7% HTML 0.9% Clojure JavaScript Shell HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags 2.0.0 develop/1.x master Nothing to show 1.1.3 1.1.2 1.1.1 1.1.1-SNAPSHOT 1.1.0 1.0.6 1.0.5 1.0.4 1.0.3 1.0.2 1.0.1 1.0.0 1.0.0-alpha2 1.0.0-alpha1 0.3.4 0.3.3 0.3.2 0.3.1 0.3.0 0.2.10 0.2.9 0.2.8 0.2.7 0.2.6 0.2.5 0.2.4 0.2.3 0.2.2 0.2.1 0.2.0 0.1.10 0.1.9 0.1.8 0.1.7 0.1.6 0.1.5 0.1.4 0.1.3 0.1.2 0.1.1 0.1.0 0.0.14 0.0.13 0.0.12 0.0.11 0.0.10 0.0.9 0.0.8 0.0.7 0.0.6 0.0.5 0.0.4 0.0.3 0.0.2 Nothing to show New pull request Latest commit 5258763 May 10, 2016 mneise Use full project config to create subproject. Permalink Failed to load latest commit information. bin Remove cljs-compat. Feb 23, 2016 doc 1.1.3 Mar 7, 2016 example-projects 1.1.3 Mar 7, 2016 plugin Use full project config to create subproject. May 10, 2016 support Use full project config to create subproject. May 10, 2016 .gitignore Restore functionality of plugin tests Aug 4, 2015 COPYING Preparing for release. Dec 30, 2011 README.md 1.1.3 Mar 7, 2016 sample.project.clj latest released versions Dec 4, 2015 README.md lein-cljsbuild Latest version: This is a Leiningen plugin that makes it quick and easy to automatically compile your ClojureScript code into Javascript whenever you modify it. It's simple to install and allows you to configure the ClojureScript compiler from within your project.clj file. Beyond basic compiler support, lein-cljsbuild can optionally help with a few other things: Launching REPLs for interactive development Launching ClojureScript tests The latest version of lein-cljsbuild is 1.1.3. See the release notes here. Note that cljsbuild crossovers are deprecated, and will be removed eventually. You should never use them. Please use either reader conditionals (available in Clojure >= 1.7.0-beta2 and ClojureScript >= 0.0-3255), or cljx to target both Clojure and ClojureScript from the same codebase. If you are using ClojureScript >= 1.7.170 you need to use a lein-cljsbuild version >= 1.1.1. Requirements The lein-cljsbuild plugin works with Leiningen version 2.1.2 or higher. Installation You can install the plugin by adding lein-cljsbuild to your project.clj file in the :plugins section: (defproject lein-cljsbuild-example ""1.2.3""   :plugins [[lein-cljsbuild ""1.1.3""]]) In addition, you should add an explicit ClojureScript dependency to your project, like this: :dependencies [[org.clojure/clojurescript ""0.0-XXXX""]] lein-cljsbuild will add a dependency to your project if it doesn't already contain one, but that functionality will not remain for long. The latest version of lein-cljsbuild currently requires a minimum of ClojureScript 0.0-3211. Just Give Me a Damned Example Already! See the example-projects directory for a couple of simple examples of how to use lein-cljsbuild. The simple project shows a dead-simple ""compile only"" configuration, which is a good place to start. The advanced project contains examples of how to use the extended features of the plugin. Also, see the sample.project.clj file for an exhaustive list of all options supported by lein-cljsbuild. Basic Configuration The lein-cljsbuild configuration is specified under the :cljsbuild section of your project.clj file. A simple project might look like this: (defproject lein-cljsbuild-example ""1.2.3""   :plugins [[lein-cljsbuild ""1.1.3""]]   :cljsbuild {     :builds [{         ; The path to the top-level ClojureScript source directory:         :source-paths [""src-cljs""]         ; The standard ClojureScript compiler options:         ; (See the ClojureScript compiler documentation for details.)         :compiler {           :output-to ""war/javascripts/main.js""  ; default: target/cljsbuild-main.js           :optimizations :whitespace           :pretty-print true}}]}) For an exhaustive list of the configuration options supported by lein-cljsbuild, see the sample.project.clj file. Basic Usage Once the plugin is installed, you can build the ClojureScript once: $ lein cljsbuild once  Or you can have lein-cljsbuild watch your source files for changes and automatically rebuild them. This is recommended for development, as it avoids the time-consuming JVM startup for each build: $ lein cljsbuild auto  Assuming you have configured cljsbuild to emit compiler output to one of Leiningen's :clean-targets (which includes ./target by default), running lein clean will delete all of the JavaScript and ClojureScript files that lein-cljsbuild generates during compilation. Color-coded output on Windows Colors are a big deal when reading ClojureScript compiler output, but Windows consoles don't support ANSI color codes. This limitation is commonly corrected by installing ANSICON: Download and unzip ANSICON anywhere. Open a command prompt (Run as administrator). Navigate to the unzipped folder. cd x86 or x64 (depending on whether you have 32-bit or 64-bit machine, respectively) Run ansicon -i to install. Afterwards, you should get colored output from all future console sessions that use ANSI color codes. Hooks Some common lein-cljsbuild tasks can hook into the main Leiningen tasks to enable ClojureScript support in each of them. The following tasks are supported: $ lein compile $ lein test $ lein jar  To enable ClojureScript support for these tasks, add the following entry to your project configuration: :hooks [leiningen.cljsbuild] Note that by default the lein jar task does not package your ClojureScript code in the JAR file. This feature needs to be explicitly enabled by adding the following entry to each of the :builds that you want included in the JAR file. lein uberjar derives its behavior from lein jar and will include the ClojureScript as well if enabled. :jar true Debug Note: There is a known issue (#366) where the lein uberjar task fails to build when using hooks and a cljsbuild configuration within an :uberjar profile. Instead of hooks, you can use :prep-tasks as an alternative: :prep-tasks [""compile"" [""cljsbuild"" ""once""]] Multiple Build Configurations If the :builds sequence contains more than one map lein-cljsbuild will treat each map as a separate ClojureScript compiler configuration, and will build all of them in parallel: (defproject lein-cljsbuild-example ""1.2.3""   :plugins [[lein-cljsbuild ""1.1.3""]]   :cljsbuild {     :builds [       {:source-paths [""src-cljs-main""]        :compiler {:output-to ""main.js""}}       {:source-paths [""src-cljs-other""]        :compiler {:output-to ""other.js""}}]}) This is extremely convenient for doing library development in ClojureScript. This allows cljsbuild to compile in all four optimization levels at once, for easier testing, or to compile a test suite alongside the library code. You can optionally assign an ID to a build configuration and build only that one: (defproject lein-cljsbuild-example ""1.2.3""   :plugins [[lein-cljsbuild ""1.1.3""]]   :cljsbuild {     :builds [       {:source-paths [""src-cljs-main""]        :compiler {:output-to ""main.js""}}       {:id ""other""        :source-paths [""src-cljs-other""]        :compiler {:output-to ""other.js""}}]}) $ lein cljsbuild auto other  If you want IDs for all of your build configurations, you can specify them as a map instead of a vector: (defproject lein-cljsbuild-example ""1.2.3""   :plugins [[lein-cljsbuild ""1.1.3""]]   :cljsbuild {     :builds {       :main       {:source-paths [""src-cljs-main""]        :compiler {:output-to ""main.js""}}       :other       {:source-paths [""src-cljs-other""]        :compiler {:output-to ""other.js""}}}}) You can also build multiple configurations at once: $ lein cljsbuild auto main other  See the example-projects/advanced directory for a working example of a project that uses this feature. REPL Support Lein-cljsbuild has built-in support for launching ClojureScript REPLs in a variety of ways. See the REPL documentation for more details. Testing Support Lein-cljsbuild has built-in support for running external ClojureScript test processes. See the testing documentation for more details. Extended Configuration Custom warning handlers You can place custom warning handlers for the ClojureScript compiler under the :warning-handlers key. The value should be a vector of either 1.) fully-qualified symbols that resolve to your custom handler, or 2.) anonymous functions that will get eval'd at project build-time. (defproject lein-cljsbuild-example ""1.2.3""   :plugins [[lein-cljsbuild ""1.0.4""]]   :cljsbuild {     :builds {:id           ""example""              :compiler     {}              :warning-handlers [my.ns/custom-warning-handler ;; Fully-qualified symbol                                 ;; Custom function (to be evaluated at project build-time)                                 (fn [warning-type env extra]                                   (when-let [s (cljs.analyzer/error-message warning-type extra)]                                     (binding [*out* *err*]                                       (cljs.analyzer/message env s))))]}}) ClojureScript Version After configuring lein-cljsbuild, lein deps will fetch a known-good version of the ClojureScript compiler. You can use a different version of the compiler via a local clone of the ClojureScript git repository. See the wiki for details. License Source Copyright © Evan Mezeske, 2011-2013. Released under the Eclipse Public License - v 1.0. See the file COPYING. Contributors A big thank you to all contributors who help to make this project better. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/emezeske/lein-cljsbuild"	"— A Leiningen plugin to make ClojureScript development easy."	"true"
"Development"	"lein-figwheel"	"https://github.com/bhauman/lein-figwheel"	"– Leiningen plugin that pushes ClojureScript code changes to the client."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"1662"	"57"	"135"	"GitHub - bhauman/lein-figwheel: Figwheel builds your ClojureScript code and hot loads it into the browser as you are coding! Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 57 Star 1,662 Fork 135 bhauman/lein-figwheel Code Issues 45 Pull requests 3 Wiki Pulse Graphs Figwheel builds your ClojureScript code and hot loads it into the browser as you are coding! 1,243 commits 9 branches 25 releases 57 contributors Clojure 98.3% HTML 1.2% Other 0.5% Clojure HTML Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags add-repl heads_up_wip integrate-new-builder lighttable-compat master nutmeg revert-191-feature-multiple-on-jsload-hooks serperate-to-sidecar validate_config Nothing to show v0.5.4 v0.5.4-7 v0.5.4-6 v0.5.4-4 v0.5.4-3 v0.5.1 v0.5.0-5 v0.5.0-4 v0.5.0-3 v0.5.0-2 v0.5.0-1 v0.2.4-snap v0.2.3-snap v0.2.3-client-side-transitive-deps v0.2.2-snap v0.2.1-snap v0.2.0-snap v0.1.7-snap v0.1.6-snap 0.5.0 0.5.0old-SNAPSHOT 0.5.0-SNAPSHOT 0.3.3 0.3.2 0.2.5 Nothing to show New pull request Latest commit 88879aa Jul 12, 2016 bhauman add validate-interactive … fixes #444 Permalink Failed to load latest commit information. example bump to 0.5.5-SNAPSHOT Jul 8, 2016 plugin bump to 0.5.5-SNAPSHOT Jul 8, 2016 scripts bump to 0.5.4-4-SNAPSHOT Jun 15, 2016 sidecar add validate-interactive Jul 12, 2016 support add advice to the figwheel client version miss-match notification Jul 12, 2016 .gitignore ignore _figwheel.edn Jun 13, 2016 CHANGES.md bump to 0.5.4-7 Jul 8, 2016 LICENSE initial commit Apr 17, 2014 README.md bump to 0.5.4-7 Jul 8, 2016 TODO.md clean up TODOs file Jan 23, 2016 README.md lein-figwheel Figwheel builds your ClojureScript code and hot loads it into the browser as you are coding! Get a quick idea of what figwheel does by watching the 6 minute flappy bird demo of figwheel. Learn even more by watching a 45 minute talk on Figwheel given at ClojureWest 2015. Read the introductory blog post. Current version: Features Live code reloading If you write reloadable code, figwheel can facilitate automated live interactive programming. Every time you save your ClojureScript source file, the changes are sent to the browser so that you can see the effects of modifying your code in real time. Supports Node.js You can use figwheel to live code ClojureScript in Node.js! Static file server The inclusion of a static file server allows you to get a decent ClojureScript development environment up and running quickly. For convenience there is a :ring-handler option so you can load a ring handler into the figwheel server. Live CSS reloading Figwheel will reload your CSS live as well. Live JavaScript reloading Figwheel can live reload your JavaScript source files. Heads up display Figwheel has a non-intrusive heads up display that gives you feedback on how well your project is compiling. By writing a shell script you can click on files in the heads up display and they will open in your editor! Built-in ClojureScript REPL When you launch figwheel it not only starts a live building/reloading process but it also optionally launches a CLJS REPL into your running application. This REPL shares compilation information with the figwheel builder, so as you change your code the REPL is also aware of the code changes. The REPL also has some special built-in control functions that allow you to control the auto-building process and execute various build tasks without having to stop and rerun lein-figwheel. Robust connection Figwheel's connection is fairly robust. I have experienced figwheel sessions that have lasted for days through multiple OS sleeps. You can also use figwheel like a REPL if you are OK with using print to output the evaluation results to the browser console. Message broadcast Figwheel broadcasts changes to all connected clients. This means you can see code and CSS changes take place in real time on your phone and in your laptop browser simultaneously. Respects dependencies Figwheel will not load a file that has not been required. It will also respond well to new requirements and dependency tree changes. Calculates minimal reload set Figwheel does its best to only reload what needs to be reloaded. This minimizes the surface area of dynamically reloaded code, which in turn should increase the stability of the client environment. Doesn't load code that is generating warnings If your ClojureScript code is generating compiler warnings Figwheel won't load it. This, again, is very helpful in keeping the client environment stable. This behavior is optional and can be turned off. Testimonials My cofounder, Danny, and I can't imagine working without Figwheel. We have been using it since December to build Precursor, a collaborative drawing tool. It has saved us a ton of time and contributed a lot towards Danny's appreciation of ClojureScript for design. Danny King and Daniel Woelfel My major issue is that Figwheel is too awesome. Julian Leviston Try Figwheel Make sure you have the latest version of leiningen installed. You can try figwheel out quickly with the flappy bird demo: git clone https://github.com/bhauman/flappy-bird-demo.git  then cd into flappy-bird-demo and type lein figwheel  You can now goto localhost:3449/index.html and open up src/flappy_bird_demo/core.cljs with your favorite editor and start coding. Make sure you open your browser's development console so you can get feedback about code reloads. If you would prefer to greenfield a new project you can use the figwheel leiningen template. lein new figwheel hello-world  Or optionally:     lein new figwheel hello-world -- --om       ;; for an om based project     lein new figwheel hello-world -- --reagent  ;; for a reagent based project   Learning ClojureScript If you are brand new to ClojureScript it is highly recommended that you do the ClojureScript Quick Start first. If you skip this you will probably suffer. There is a lot to learn when you are first learning ClojureScript, I recommend that you bite off very small pieces at first. Smaller bites than you would take when learning other languages like JavaScript and Ruby. Please don't invest too much time trying to set up a sweet development environment, there is a diverse set of tools that is constantly in flux and it's very difficult to suss out which ones will actually help you. If you spend a lot of time evaluating all these options it can become very frustrating. If you wait a while, and use simple tools you will have much more fun actually using the language itself. Quick Start If you are new to Figwheel here is a Quick Start tutorial. Working through this Quick Start will probably save you a tremendous amount of time. Usage Make sure you have the latest version of leiningen installed. Then include the following :dependencies in your project.clj file. [org.clojure/clojure ""1.8.0""] [org.clojure/clojurescript ""1.8.51""] Then include lein-figwheel in the :plugins section of your project.clj. [lein-figwheel ""0.5.4-7""] Configure your builds You also need to have your :cljsbuild configuration set up in your project.clj. Here is an example: :cljsbuild {   :builds [ { :id ""example""                :source-paths [""src/""]               :figwheel true               :compiler {  :main ""example.core""                            :asset-path ""js/out""                            :output-to ""resources/public/js/example.js""                            :output-dir ""resources/public/js/out"" } } ] } The important part here is that you have to have at least one build that has :optimizations set to :none or nil. If you leave out the :optimizations key the ClojureScript compiler will default to :none. Setting :figwheel true or :figwheel { :on-jsload ""example.core/reload-hook"" } will automagically insert the figwheel client code into your application. If you supply :on-jsload the name of a function, that function will be called after new code gets reloaded. If you want to serve the HTML file that will host your application from figwheel's built in server, then the output directory has to be in a directory that can be served by the static webserver. The default for the webserver root is ""resources/public"" so your output files need to be in a subdirectory of ""resources/public"" unless you change the webserver root. For now the webserver root has to be in a subdirectory of resources. If you are serving your application HTML from your own server you can configure :output-to and :output-dir as you like. Start the figwheel server. (This will get the first :optimizations :none build) $ lein figwheel  or optionally give the name of the build $ lein figwheel example  This will start a server at http://localhost:3449 with your resources being served via the compojure resources ring handler. So you can load the HTML file that's hosting your ClojureScript app by going to http://localhost:3449/<yourfilename>.html If you are using your own server please load your app from that server. Figwheel server side configuration This is not necessary but you can configure the figwheel system. At the root level of your project.clj you can add the following server side configuration parameters: :figwheel {    :http-server-root ""public"" ;; this will be in resources/    :server-port 5309          ;; default is 3449    :server-ip   ""0.0.0.0""     ;; default is ""localhost""     ;; CSS reloading (optional)    ;; :css-dirs has no default value     ;; if :css-dirs is set figwheel will detect css file changes and    ;; send them to the browser    :css-dirs [""resources/public/css""]     ;; Server Ring Handler (optional)    ;; if you want to embed a ring handler into the figwheel http-kit    ;; server    :ring-handler example.server/handler     ;; Clojure Macro reloading    ;; disable clj file reloading    ; :reload-clj-files false    ;; or specify which suffixes will cause the reloading    ; :reload-clj-files {:clj true :cljc false}     ;; To be able to open files in your editor from the heads up display    ;; you will need to put a script on your path.    ;; that script will have to take a file path, a line number and a column    ;; ie. in  ~/bin/myfile-opener    ;; #! /bin/sh    ;; emacsclient -n +$2:$3 $1     ;;    :open-file-command ""myfile-opener""     ;; if you want to disable the REPL    ;; :repl false     ;; to configure a different figwheel logfile path    ;; :server-logfile ""tmp/logs/figwheel-logfile.log""      ;; Start an nREPL server into the running figwheel process    ;; :nrepl-port 7888     ;; Load CIDER, refactor-nrepl and piggieback middleware    ;;  :nrepl-middleware [""cider.nrepl/cider-middleware""    ;;                     ""refactor-nrepl.middleware/wrap-refactor""    ;;                     ""cemerick.piggieback/wrap-cljs-repl""]     ;; if you need to watch files with polling instead of FS events    ;; :hawk-options {:watcher :polling}         ;; ^ this can be useful in Docker environments     ;; if your project.clj contains conflicting builds,    ;; you can choose to only load the builds specified    ;; on the command line    ;; :load-all-builds false ; default is true } Client side usage Make sure you have setup an html file to host your cljs. For example you can create this resources/public/index.html file: <!DOCTYPE html> <html>   <head>   </head>   <body>     <div id=""main-area"">     </div>     <script src=""js/example.js"" type=""text/javascript""></script>      </body> </html> Client side configuration options Instead of setting :figwheel true in your cljsbuild configuration you can pass a map of options as below: :cljsbuild {   :builds [ { :id ""example""                :source-paths [""src/""]                ;; put client config options in :figwheel               :figwheel { :websocket-host ""localhost""                            :on-jsload ""example.core/fig-reload""}                :compiler {  :main ""example.core""                            :asset-path ""js/out""                            :output-to ""resources/public/js/example.js""                            :output-dir ""resources/public/js/out""                            :optimizations :none } } ] } The following configuration options are available: ;; Configure :websocket-host for the figwheel js client to connect to. ;; (Don't specify the port; figwheel already knows it). ;; Defaults to ""localhost"".  Valid values are: ;;  ;;   <any-string>      Uses that exact string as hostname. ;; ;;   :js-client-host   Uses window.location.hostname from JS.  This is useful when connecting ;;                     from a different device/computer on your LAN, e.g. testing mobile ;;                     safari. ;; ;;   :server-ip        Uses the IP address of the figwheel server.  This is Useful in special ;;                     situations like an iOS (WK)WebView.  Be sure to check your CORS headers. ;; ;;   :server-hostname  Like :server-ip, but uses hostname string rather than IP address. ;;                     (On unix, check that `hostname` outputs the right string in shell). ;; :websocket-host :js-client-host  ;; optional callback :on-jsload ""example.core/fig-reload""  ;; if you want to do REPL based development and not have ;; have compiled files autoloaded into the client env :autoload false  ;; The heads up display is enabled by default to disable it:  :heads-up-display false  ;; when the compiler emits warnings figwheel blocks the loading of files. ;; To disable this behavior: :load-warninged-code true  ;; You can override the websocket url that is used by the figwheel client ;; by specifying a :websocket-url ;; ;; The value of :websocket-url is usually ;; :websocket-url ""ws://localhost:3449/figwheel-ws"" ;; ;; The :websocket-url is normally derived from the :websocket-host option. ;; If you supply a :websocket-url the :websocket-host option will be ignored. ;; ;; The :websocket-url allows you to use tags for common dynamic values. ;; For example in: ;; :websocket-url ""ws://[[client-hostname]]:[[server-port]]/figwheel-ws"" ;; Figwheel will fill in the [[client-hostname]] and [[server-port]] tags ;; ;; Available tags are ;; [[server-hostname]] ;; [[server-ip]] ;; [[server-port]] ;; [[client-hostname]] ;; [[client-port]] To see all the client side config options look here. Preventing and forcing file reloads Figwheel normally reloads any file that has changed. If you want to prevent certain files from being reloaded by figwheel, you can add meta-data to the namespace declaration like so: (ns ^:figwheel-no-load example.core) Figwheel will not load or reload files that haven't been required by your application. If you want to force a file to be loaded when it changes add the follwoing meta-data the namespace declaration of the file: (ns ^:figwheel-load example.core) It can be very helpful to have a file reload every time a file changes in your ClojureScript source tree. This can facilitate reloading your main app and running tests on change. To force a file to reload on every change: (ns ^:figwheel-always example.test-runner) Using the ClojureScript REPL When you run lein figwheel a REPL will be launched into your application. You will need to open your application in a browser in order for the REPL to connect and show its prompt. This REPL is a little different than other REPLs in that it has live compile information from the build process. This effectively means that you will not have to call (require or (load-namespace unless it is a namespace that isn't in your loaded application's required dependencies. In many cases you can just (in-ns 'my.namespace) and everything you need to access will be there already. The REPL doesn't currently have built-in readline support. To have a better experience please install rlwrap. You can do this on OSX using brew: brew install rlwrap. When rlwrap is installed you can now execute lein figwheel as so: $ rlwrap lein figwheel  This will give you a much nicer REPL experience with history and line editing. REPL Figwheel control functions. The Figwheel REPL has the following control functions: Figwheel Controls:  (stop-autobuild)            ;; stops Figwheel autobuilder  (start-autobuild [id ...])  ;; starts autobuilder focused on optional ids  (switch-to-build id ...)    ;; switches autobuilder to different build  (reset-autobuild)           ;; stops, cleans, and starts autobuilder  (build-once [id ...])       ;; builds source one time  (clean-builds [id ..])      ;; deletes compiled cljs target files  (fig-status)                ;; displays current state of system  These functions are special functions that poke through the ClojureScript env into the underlying Clojure process. As such you can't compose them. You can think of these functions having an implicit set of build ids that they operate on. If you call (reset-autobuild) it will stop the figwheel autobuilder, clean the builds, reload the build configuration from your project.clj and then restart the autobuild process. If you call (stop-autobuild) it will stop the figwheel autobuilder. If you call (start-autobuild) it will start the figwheel autobuilder with the current implicit build ids. If you call (start-autobuild example) it will start the figwheel autobuilder on the provided build id example. It will also make [example] the implicit set of build ids. start-autobuild and switch-to-build are the only functions that update the build-id set. clean-builds and build-once both allow you to do one off builds and cleans. They do not alter the implicit build ids. fig-status displays information on the current Figwheel system state, including whether the autobuilder is running, which build ids are in focus, and the number of client connections. Editor REPLs and nREPL You may want a REPL in your editor. This makes it much easier to ship code from your buffer to be evaluated. If you use lein repl or something that invokes it like CIDER, you are using nREPL. A ClojureScript REPL will not just run over an nREPL connection without Piggieback. If you are just starting out I would use the Figwheel console REPL because it's aready set up and ready to go, complexity conquered! If you want to integrate a REPL into your editor, here are my top recommendations: Emacs: use inf-clojure as described on the wiki page alternatively use Cider and nREPL. Using the ClojureScript REPL over an nREPL connection is considered advanced Cursive: use the instructions on the wiki page Vi: use tmux mode to interact with the figwheel REPL, still trying to get a wiki page for this if you can help that would be great If you are going to use nREPL with Figwheel please see: Using Figwheel within NRepl Scripting Figwheel As your development workflow grows in complexity, the declarative approach of lein can be limiting when you want to launch and control different services (ie. SASS compilation). It is really helpful to use Clojure itself to script whatever workflow services you want. Figwheel has a Clojure API that makes it easy to start, stop and control Figwheel from Clojure. In order for the following examples to work, you will need to have [figwheel-sidecar ""0.5.4-7""] in your dependencies. To start Figwheel from a script, you will need to require the figwheel-sidecar.repl-api and provide your build configuration to figwheel-sidecar.repl-api/start-figwheel! like so: (require '[figwheel-sidecar.repl-api :as ra])  ;; this will start figwheel and will start autocompiling the builds specified in `:builds-ids` (ra/start-figwheel!   {:figwheel-options {} ;; <-- figwheel server config goes here     :build-ids [""dev""]   ;; <-- a vector of build ids to start autobuilding    :all-builds          ;; <-- supply your build configs here    [{:id ""dev""      :figwheel true      :source-paths [""src""]      :compiler {:main ""example.core""                 :asset-path ""out""                 :output-to ""resources/public/main.js""                 :output-dir ""resources/public/out""                 :verbose true}}]})  ;; you can also just call (ra/start-figwheel!) ;; and figwheel will do its best to get your config from the ;; project.clj or a figwheel.edn file  ;; start a ClojureScript REPL (ra/cljs-repl) ;; you can optionally supply a build id ;; (ra/cljs-repl ""dev"") Build config notes It's important to remember that figwheel can autobuild and reload multiple builds at the same time. It can also switch between builds and focus on autobuilding one at a time. For this reason you need to supply the initial :build-ids to tell figwheel which builds you want to start building. It's also really helpful to supply your :advanced builds because while you can't autobuild them you can call build-once on them Assuming the above script is in script/figwheel.clj you can invoke it as follows: $ rlwrap lein run -m clojure.main script/figwheel.clj  The above command will start figwheel and it will behave just like running lein figwheel. Please note that the above command is not running the script in the same environment as lein repl or cider-jack-in. Both of these start an nREPL session. I am intentionally not using nREPL in order to remove a lot of complexity from ClojureScript REPL communication. If you are using nREPL, launching the ClojureScript REPL requires that you have Piggieback installed. Please see the section above titled ""Editor REPLs and nREPL"" Let's make a small helper library and then initialize a Clojure REPL with it: (require  '[figwheel-sidecar.repl-api :as ra])  (defn start []   (ra/start-figwheel!     {:figwheel-options {} ;; <-- figwheel server config goes here       :build-ids [""dev""]   ;; <-- a vector of build ids to start autobuilding      :all-builds          ;; <-- supply your build configs here      [{:id ""dev""        :figwheel true        :source-paths [""src""]        :compiler {:main ""example.core""                   :asset-path ""out""                   :output-to ""resources/public/main.js""                   :output-dir ""resources/public/out""                   :verbose true}}]}))  ;; Please note that when you stop the Figwheel Server http-kit throws ;; a java.util.concurrent.RejectedExecutionException, this is expected  (defn stop []   (ra/stop-figwheel!))  (defn repl []   (ra/cljs-repl)) The next line will call clojure.main and initialize it with our script and then continue on to launch a REPL. $ rlwrap lein run -m clojure.main --init script/figwheel.clj  -r  After the Clojure REPL has launched, you will now have the ability to call (start), (repl) and (stop) as you need. You can also call all of the functions in the figwheel-sidecar.repl-api. This is a powerful way to work, as you now have the interactivity and generality of the Clojure programming language available. Need to start a server? Go for it. Need to watch and compile SASS files? No problem. Scripting with Component I highly recommend Stuart Sierra's component library to compose all the services you will need in your development process. Here is an example of creating a Figwheel component and composing it with a Ring server component to serve your application. (require  '[figwheel-sidecar.repl-api :as ra]  '[com.stuartsierra.component :as component]  '[ring.component.jetty :refer [jetty-server]])  (def figwheel-config    {:figwheel-options {} ;; <-- figwheel server config goes here      :build-ids [""dev""]   ;; <-- a vector of build ids to start autobuilding     :all-builds          ;; <-- supply your build configs here     [{:id ""dev""       :figwheel true       :source-paths [""src/main""]       :compiler {:main ""example.core""                  :asset-path ""/out""                  :output-to ""resources/public/main.js""                  :output-dir ""resources/public/out""                  :verbose true}}]})  (defrecord Figwheel []   component/Lifecycle   (start [config]     (ra/start-figwheel! config)     config)   (stop [config]     ;; you may want to restart other components but not Figwheel     ;; consider commenting out this next line if that is the case     (ra/stop-figwheel!)     config))  (defn handler [request]   {:status  200    :headers {""Content-Type"" ""text/plain""}    :body    ""Hello World""})  (def system   (atom    (component/system-map     :app-server (jetty-server {:app {:handler handler}, :port 3000})     :figwheel   (map->Figwheel figwheel-config))))  (defn start []   (swap! system component/start))  (defn stop []   (swap! system component/stop))  (defn reload []   (stop)   (start))  (defn repl []   (ra/cljs-repl)) Again you can run this script as so: $ rlwrap lein run -m clojure.main --init script/figwheel.clj  -r  As you can see with humble beginnings you can build up arbitrary functionality. Please see Daniel Szmulewicz's excellent system which is a set of helpful components If you are using nREPL, launching the ClojureScript REPL requires that you have Piggieback installed. Please see the section above titled ""Editor REPLs and nREPL"" Please note that when you stop the Figwheel server, http-kit throws a java.util.concurrent.RejectedExecutionException, this is expected Read more about the clojure.main command line options Read more about component Tips and Support Figwheel was created out of the pure desire to make programming more fun. While I have been lucky to receive a couple spontaneous donations, it is not currently sponsored in any way. If you like Figwheel and want to support its development: Not Magic, just plain old file reloading This plugin starts a ClojureScript auto builder, opens a websocket and starts static file server. When you save a ClojureScript file, Figwheel will detect that and compile it and other affected files. It will then pass a list of those changed files off to the figwheel server. The figwheel server will in turn push the paths of the relevant compiled javascript files through a websocket so that the browser can reload them. The main motivation for lein-figwheel is to allow for the interactive development of ClojureScript. Figwheel doesn't provide this out of the box, the developer has to take care to make their code reloadable. Writing reloadable code Figwheel relies on having files that can be reloaded. Reloading works beautifully on referentially transparent code and code that only defines behavior without bundling state with the behavior. If you are using React or Om it's not hard to write reloadable code, in fact you might be doing it already. There are several coding patterns to look out for when writing reloadable code. One problematic pattern is top level definitions that have local state. (def state (atom {})) The state definition above is holding an atom that has local state. Every time the file that holds this definition gets reloaded the state definition will be redefined and the state it holds will be reset back to the original state. But with figwheel we are wanting to change our programs while maintaining the state of the running program. The way to fix this is to use defonce (defonce state (atom {})) This will fix most situations where you have code that is relying on a definition that has local state. Keep in mind though that if you change the code that is wrapped in a defonce you won't see the changes, because the identifier won't be redefined. Complicated object networks wired together with callbacks (Backbone, Ember, etc.) are also problematic. Instantiating these object callback networks and then storing them in a global var is yet another version of this problem. Functions that maintain local state like counters and such are also definitions with local state, and as such are problematic. You also need to look out for common setup code that hooks into the browser. Often you will see statements like this at the bottom of a file. (.click ($ ""a.button"") (fn [e] (print ""clicked button""))) Every time this file gets loaded a new listener will get added to all the anchor tags with a ""button"" class. This is obviously not what we want to happen. This code is very problematic and points to the why using the browser APIs directly has always been really difficult. For instance if we make it so that these hooks are only executed once, like so: (defonce setup-stuff    (do       (.click ($ ""a.button"") (fn [e] (print ""clicked button""))))) When you are live editing code, this doesn't work very well. If you alter your HTML template any new ""a.button"" elements aren't going to have the listener bound to them. You can fix this by using an event delegation strategy as so: (defonce setup-stuff    (do       (.on ($ ""div#app"") ""click"" ""a.button"" (fn [e] (print ""clicked button""))))) But even with the above strategy you won't be able to edit any of the code in the setup up block and see your changes take effect. If you are not using React and you want to build things this way and have reloadable code we need to create setup and teardown functions to be invoked on code reload. (defn setup []    (.on ($ ""div#app"") ""click"" ""a.button"" (fn [e] (print ""clicked button""))))  (defn teardown []    (.off ($ ""div#app"") ""click"" ""a.button"")  ;; define a reload hook in the (defn fig-reload-hook []       (teardown)       (setup))  Now you can edit the code in the setup and teardown functions and see the resulting changes in your application. In a way you can think of the previous definitions of setup-stuff as functions that have local state of sorts. They are altering and storing callbacks in the DOM directly and this is why it is so problematic. This is one of the reasons React is so damn brilliant. You never end up storing things directly in the DOM. State is mediated and managed for you. You just describe what should be there and then React takes care of making the appropriate changes. For this reason React is a prime candidate for writing reloadable code. React components already have a lifecycle protocol that embeds setup and teardown in each component and invokes them when neccessary. It is worth repeating that React components don't have local state, it just looks like they do. You have to ask for the local state and React in turn looks this state up in a larger state context and returns it, very similar to a State Monad. Reloadable code is easy to write if we are very conscious and careful about the storage of state, state transitions and side effects. Since a great deal of programming complexity stems from complex interactions (side effecting events) between things that have local state, it is my belief that reloadable code is often simply better code. More React Advocacy If you want to do less thinking and write more reliable front end code you should really be looking at React, Om etc. OK enough. License Copyright © 2014 Bruce Hauman Distributed under the Eclipse Public License either version 1.0 or any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/bhauman/lein-figwheel"	"– Leiningen plugin that pushes ClojureScript code changes to the client."	"true"
"Development"	"Ribol"	"http://docs.caudate.me/ribol/"	"– Conditional restarts for clojure/clojurescript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"ribol ribol conditional restarts for clojure Author: Chris Zheng  (z@caudate.me) Library: v0.3.3 Date: 31 October 2013 Website: http://www.github.com/zcaudate/ribol Generated By: MidjeDoc 1   Overview   1.1   Installation 2   Unlucky Numbers 3   Conditional Restarts   3.1   Raising issues   3.2   Managing issues 4   API Reference   4.1   raise     4.1.1   hash-map     4.1.2   keyword     4.1.3   vector     4.1.4   option/default   4.2   manage/on     4.2.1   checkers     4.2.2   bindings     4.2.3   catch and finally   4.3   special forms     4.3.1   continue     4.3.2   fail     4.3.3   choose     4.3.4   default     4.3.5   escalate   4.4   hooks     4.4.1   raise-on     4.4.2   raise-on-all     4.4.3   anticipate 5   Control Strategies   5.1   Normal     5.1.1   No Raise     5.1.2   Issue Raised   5.2   Catch     5.2.1   First Level Catch     5.2.2   Second Level Catch   5.3   Continue     5.3.1   First Level Continue     5.3.2   Second Level Continue   5.4   Choose     5.4.1   Choose Lower-Level     5.4.2   Choose Upper-Level   5.5   Choose - More Strategies     5.5.1   Overridding An Option     5.5.2   Default Option     5.5.3   Overriding Defaults   5.6   Escalate     5.6.1   Simple Escalation     5.6.2   Escalation with Options   5.7   Fail   5.8   Default     5.8.1   Escalation with Defaults   5.9   Branch Using On 6   Implementation   6.1   The Workplace     6.1.1   The dumb throw     6.1.2   The smart raise     6.1.3   The proactive workplace   6.2   The Issue Management Board     6.2.1   Control Flow as Data     6.2.2   Implementing Catch     6.2.3   Implementing Choose     6.2.4   Implementing the Rest 7   End Notes ribol conditional restarts for clojure Author: Chris Zheng  (z@caudate.me) Library: v0.3.3 Date: 31 October 2013 Website: http://www.github.com/zcaudate/ribol Generated By: MidjeDoc 1    Overview This is quite a comprehensive guide to ribol and how conditional restart libraries may be used. There are currently three other conditional restart libraries for clojure: errorkit was the first and provided the guiding architecture for this library. swell and conditions have been written to work with slingshot.A simple use case looking at the advantage in using restarts over exceptions can be seen in Unlucky Numbers. There is also a Core library API with examples. For those that wish to know more about conditional restarts, a comparison of different strategies that can be implemented is done in Control Strategies. While for those curious about how this jumping around has been achieved, look at Implementation. 1.1    Installation Add to project.clj dependencies (use double quotes):  [im.chit/ribol '0.3.3']  All functionality is found contained in ribol.core (use 'ribol.core)  2    Unlucky Numbers In this demonstration, we look at how code bloat problems using throw/try/catch could be reduced using raise/manage/on. Two functions are defined: check-unlucky which takes a number as input, throwing a RuntimeException when it sees an unlucky number. int-to-str which calls check-unlucky, pretends to do work and outputs a string represention of the number. (defn check-unlucky [n]   (if (#{4 13 14 24 666} n)     (throw (RuntimeException. ""Unlucky Number""))     n))  (defn int-to-str [n]   (do (Thread/sleep 10)  ;; Work out something       (str (check-unlucky n))))  (int-to-str 1) => ""1""  (int-to-str 666) => (throws RuntimeException ""Unlucky Number"")  We can then use int-to-str to run across multiple numbers: (mapv int-to-str (range 4)) => [""0"" ""1"" ""2"" ""3""]  Exceptions mess up the middle Except when we try to use it in with a sequence containing an unlucky number (mapv int-to-str (range 20))  => (throws RuntimeException ""Unlucky Number"")  We can try and recover using try/catch (try   (mapv int-to-str (range 20))   (catch RuntimeException e     ""Unlucky number in the sequence""))  => ""Unlucky number in the sequence""  But we can never get the previous sequence back again because we have blown the stack. The only way to 'fix' this problem is to change int-to-str so that it catches the exception: (defn int-to-str-fix [n]   (try     (if (check-unlucky n)    ;;       (do (Thread/sleep 10)  ;; Work out something           (str n)))     (catch RuntimeException e       ""-"")))  (mapv int-to-str-fix (range 20)) => [""0"" ""1"" ""2"" ""3"" ""-"" ""5"" ""6"" ""7"" ""8"" ""9"" ""10""     ""11"" ""12"" ""-"" ""-"" ""15"" ""16"" ""17"" ""18"" ""19""]  This is seriously unattractive code. We have doubled our line-count to int-to-str without adding too much functionality. For real world scenarios like batch processing a bunch of files, there are more ways that the program can go wrong. The middle code becomes messy very quickly. Raising issues, not throwing exceptions This problem actually has a very elegant solution if we use ribol. Instead of throwing an exception, we can raise an issue in check-unlucky: (defn check-unlucky [n]   (if (#{4 13 14 24 666} n)     (raise [:unlucky-number {:value n}])     n))  int-to-str does not have to change (defn int-to-str [n]   (do (Thread/sleep 10)  ;; Work out something       (str (check-unlucky n))))  We still get the same functionality: (int-to-str 1) => ""1""  (mapv int-to-str (range 4)) => [""0"" ""1"" ""2"" ""3""]  Handling raised issues What happens when we use this with unlucky numbers? Its almost the same... except that instead of raising a RuntimeException, we get a clojure.lang.ExceptionInfo object: (mapv int-to-str (range 20)) => (throws clojure.lang.ExceptionInfo)  We can still use try/catch to recover from the error (try   (mapv int-to-str (range 20))   (catch clojure.lang.ExceptionInfo e     ""Unlucky number in the sequence"")) => ""Unlucky number in the sequence""  We set up the ribol handlers by replacing try with manage and catch with on. This gives the exact same result as before. (manage   (mapv int-to-str (range 20))   (on :unlucky-number []     ""Unlucky number in the sequence"")) => ""Unlucky number in the sequence""  A sleight of code However, the whole point of this example is that we wish to keep the previous results without ever changing int-to-str. We will do this with continue: (manage   (mapv int-to-str (range 20))   (on :unlucky-number []       (continue ""-""))) => [""0"" ""1"" ""2"" ""3"" ""-"" ""5"" ""6"" ""7"" ""8"" ""9"" ""10""     ""11"" ""12"" ""-"" ""-"" ""15"" ""16"" ""17"" ""18"" ""19""]  What just happened? continue is a special form that allows higher level functions to jump back into the place where the exception was called. So once the manage block was notified of the issue raised in check-unlucky, it did not blow away the stack but jumped back to the back at which the issue was raised and continued on with - instead. In this way, the exception handling code instead of being written in int-to-str, can now be written at the level that it is required. Unlucky for whom? The chinese don't like the number 4 and any number with the number 4, but they don't mind 13 and 666. We can write use the on handler to define cases to process: (defn ints-to-strs-chinese [arr]   (manage    (mapv int-to-str arr)    (on {:unlucky-number true         :value #(or (= % 666)                     (= % 13))}        [value]        (continue value))     (on :unlucky-number []        (continue ""-""))))  (ints-to-strs-chinese [11 12 13 14]) => [""11"" ""12"" ""13"" ""-""]  (ints-to-strs-chinese [1 2 666]) => [""1"" ""2"" ""666""]  The christians don't mind the numbers with 4, don't like 13 and really don't like 666. In this example, it can be seen that if 666 is seen, it will jump out and return straight away, but will continue on processing with other numbers. (defn ints-to-strs-christian [arr]   (manage    (mapv int-to-str arr)    (on [:unlucky-number] [value]        (condp = value          13 (continue ""-"")          666 ""ARRRGHHH!""          (continue value)))))  (ints-to-strs-christian [11 12 13 14]) => [""11"" ""12"" ""-"" ""14""]  (ints-to-strs-christian [1 2 666]) => ""ARRRGHHH!""  It can be seen from this example that the int-to-str function can be reused without any changes. this would be extremely difficult to do with just try/catch. For the still sceptical, I'm proposing a challenge: to reimplement ints-to-strs-christian without changing unlucky-numbers or int-to-str using only try and catch. I am scared just thinking about it... 3    Conditional Restarts ribol provides a conditional restart system. It can be thought of as an issue resolution system or try++/catch++. We use the term issues to differentiate them from exceptions. The difference is purely semantic: issues are managed whilst exceptions are caught. They all refer to abnormal program flow. Restart systems are somewhat analogous to a management structure. A low level function will do work until it encounter an abnormal situation. An issue is raised up the chain to higher-level functions. These can manage the situation depending upon the type of issue raised. In the author's experience, there are two forms of exceptions that a programmer will encounter: Programming Mistakes - These are a result of logic and reasoning errors, should not occur in normal operation and should be eliminated as soon as possible. The best strategy for dealing with this is to write unit tests and have functions fail early with a clear message to the programmer what the error is. Null pointers Wrong inputs to functions Exceptions due to Circumstances - These are circumstancial and should be considered part of the normal operation of the program. A database connection going down A file not found User input not valid The common method of try and catch is not really needed when dealing with the Type 1 exceptions and a little too weak when dealing with those of Type 2. The net effect of using only the try/catch paradigm in application code is that in order to mitigate these Type 2 exceptions, there requires a lot of defensive programming. This turns the middle level of the application into spagetti code with program control flow (try/catch) mixed in with program logic. Conditional restarts provide a way for the top-level application to more cleanly deal with Type 2 exceptions. 3.1    Raising issues ribol provide richer semantics for resolution of Type 2 exceptions. Instead of throw, a new form raise is introduced (e.3.1). e.3.1  -  raise syntax (raise {:input-not-string true :input-data 3}     ;; issue payload        (option :use-na [] ""NA"")                   ;; option 1        (option :use-custom [n] n)                 ;; option 2        (default :use-custom ""nil""))               ;; default choice  raise differs to throw in a few ways: issues are of type clojure.lang.ExceptionInfo. the payload is a hash-map. optional: multiple option handlers can be specified. optional: a default choice can be specified. 3.2    Managing issues Instead of the try/catch combination, manage/on is used (e.3.2). e.3.2  -  manage/on syntax (manage (complex-operation)         (on :node-working [node-name]             (choose :wait-for-node))         (on :node-failed [node-name]             (choose :reinit-node))         (on :database-down []             (choose :use-database backup-database))         (on :core-failed []             (terminate-everything)))  Issues are managed through on handlers within a manage block. If any issue is raised with the manage block, it is passed to each handler. There are six ways that a handler can deal with a raised issue: directly (same as try/catch) using continue to keep going with a given value using choose to specify an option using escalate to notify higher level managers using default to allow the issue to resolve itself using fail to throw an exceptionUsing these six different different issue resolution directives, the programmer has the richness of language to craft complex process control flow strategies without mixing logic handling code in the middle tier. Restarts can also create new ways of thinking about the problem beyond the standard throw/catch mechanism and offer more elegant ways to build programs and workflows. 4    API Reference 4.1    raise The keyword raise is used to raise an 'issue'. At the simplest, when there is no manage blocks, raise just throws a clojure.lang.ExceptionInfo object [[{:title ""raise is of type clojure.lang.ExceptionInfo"" :tag ""raise-type""}]] (raise {:error true}) => (throws clojure.lang.ExceptionInfo)  The payload of the issue can be extracted using ex-data (try   (raise {:error true})   (catch clojure.lang.ExceptionInfo e     (ex-data e))) => {:error true}  The payload can be expressed as a hash-map, a keyword or a vector. We define the raises-issue macro to help explore this a little further: (defmacro raises-issue [payload]   `(throws (fn [e#]               ((just ~payload) (ex-data e#)))))  Please note that the raises-issue macro is only working with midje. In order to work outside of midje, we need to define the payload macro: (defmacro payload [& body]     `(try ~@body           (throw (Throwable.))           (catch clojure.lang.ExceptionInfo e#             (ex-data e#))           (catch Throwable t#             (throw (Exception. ""No Issue raised"")))))  Its can be used to detect what type of issue has been raised: (payload (raise :error)) => {:error true}  4.1.1    hash-map Because the issue can be expressed as a hash-map, it is more general than using a class to represent exceptions. (raise {:error true :data ""data""}) => (raises-issue {:error true :data ""data""})  4.1.2    keyword When a keyword is used, it is shorthand for a map with having the specified keyword with value true. (raise :error) => (raises-issue {:error true})  4.1.3    vector Vectors can contain only keywords or both maps and keywords. They are there mainly for syntacic sugar (raise [:lvl-1 :lvl-2 :lvl-3]) => (raises-issue {:lvl-1 true :lvl-2 true :lvl-3 true})   (raise [:lvl-1 {:lvl-2 true :data ""data""}])  => (raises-issue {:lvl-1 true :lvl-2 true :data ""data""})  4.1.4    option/default Strategies for an unmanaged issue can be specified within the raise form: e.4.1 specifies two options and the specifies the default option as :use-nil. e.4.2 sets the default as :use-custom with an argument of 10. e.4.3 shows that if there is no default selection, then an exception will be thrown as per previously seen: e.4.1  -  default :use-nil (raise :error        (option :use-nil [] nil)        (option :use-custom [n] n)        (default :use-nil))  => nil  e.4.2  -  default :use-custom (raise :error        (option :use-nil [] nil)        (option :use-custom [n] n)        (default :use-custom 10))  => 10  e.4.3  -  no default (raise :error        (option :use-nil [] nil)        (option :use-custom [n] n))  => (raises-issue {:error true})  4.2    manage/on Raised issues can be resolved through use of manage blocks set up. The blocks set up execution scope, providing handlers and options to redirect program flow. A manage block looks like this: (manage   ... code that may raise issue ...   (on <chk> <bindings>      ... handler body ...)   (option <label> <bindings>      ... option body ...)   (finally                   ;; only one      ... finally body ...))  We define half-int and its usage: (defn half-int [n]   (if (= 0 (mod n 2))     (quot n 2)     (raise [:odd-number {:value n}])))  (half-int 2) => 1  (half-int 3) => (raises-issue {:odd-number true :value 3})  4.2.1    checkers Within the manage form, issue handlers are specified with on. The form requires a check, which if returns true will be (manage  (mapv half-int [1 2 3 4])  (on :odd-number []      ""odd-number-exception"")) => ""odd-number-exception""  The checker can be a map with the value (manage  (mapv half-int [1 2 3 4])  (on {:odd-number true} []      ""odd-number-exception"")) => ""odd-number-exception""  Or it can be a map with a checking function: (manage  (mapv half-int [1 2 3 4])  (on {:odd-number true?} []      ""odd-number-exception"")) => ""odd-number-exception""  A set will check if any elements are true (manage  (mapv half-int [1 2 3 4])  (on #{:odd-number} []      ""odd-number-exception"")) => ""odd-number-exception""  A vector will check if all elements are true (manage  (mapv half-int [1 2 3 4])  (on [:odd-number] []      ""odd-number-exception"")) => ""odd-number-exception""  An underscore will match anything (manage  (mapv half-int [1 2 3 4])  (on _ []      ""odd-number-exception"")) => ""odd-number-exception""  on-any can also be used instead of on _ (manage  (mapv half-int [1 2 3 4])  (on-any []      ""odd-number-exception"")) => ""odd-number-exception""  4.2.2    bindings Bindings within the on handler allow values in the issue payload to be accessed: (manage  (mapv half-int [1 2 3 4])  (on :odd-number e      (str ""odd-number: "" (:odd-number e) "", value: "" (:value e)))) => ""odd-number: true, value: 1""  Bindings can be a vector (manage  (mapv half-int [1 2 3 4])  (on :odd-number [odd-number value]      (str ""odd-number: "" odd-number "", value: "" value))) => ""odd-number: true, value: 1""  Bindings can also be a hashmap (manage  (mapv half-int [1 2 3 4])  (on :odd-number {odd? :odd-number v :value}      (str ""odd-number: "" odd? "", value: "" v))) => ""odd-number: true, value: 1""  4.2.3    catch and finally The special forms catch and finally are also supported in the manage blocks for exception handling just as they are in try blocks. (manage  (throw (Exception. ""Hello""))  (catch Exception e    ""odd-number-exception"")  (finally    (println ""Hello""))) => ""odd-number-exception"" ;; Also prints ""Hello""  They can be mixed and matched with on forms (manage  (mapv half-int [1 2 3 4])  (on :odd-number []      ""odd-number-exception"")  (finally    (println ""Hello""))) => ""odd-number-exception"" ;; Also prints ""Hello""  4.3    special forms There are five special forms that can be used within the on handler: continue fail choose default escalate 4.3.1    continue The continue special form is used to continue the operation from the point that the issue was raised (e.4.4). It must be pointed out that this is impossible to do using the try/catch paradigm because the all the information from the stack will be lost. The on handler can take keys of the payload of the raised issue as parameters. In e.4.5, a vector containing strings of the odd numbers are formed. Whereas in e.4.6, the on handler puts in fractions instead. e.4.4  -  continue using nan (manage  (mapv half-int [1 2 3 4])  (on :odd-number []      (continue :nan)))  => [:nan 1 :nan 2]  e.4.5  -  continue using str (manage  (mapv half-int [1 2 3 4])  (on :odd-number [value]      (continue (str value))))  => [""1"" 1 ""3"" 2]  e.4.6  -  continue using fractions (manage  (mapv half-int [1 2 3 4])  (on :odd-number [value]      (continue (/ value 2))))  => [1/2 1 3/2 2]  4.3.2    fail The fail special form will forcibly cause an exception to be thrown. It is used when there is no need to advise managers of situation. More data can be added to the failure (e.). e.4.7  -  failure (manage   (mapv half-int [1 2 3 4])   (on :odd-number []     (fail [:unhandled :error])))  => (raises-issue {:value 1 :odd-number true :unhandled true :error true})  4.3.3    choose The choose special form is used to jump to a option. A new function half-int-b (e.) is defined giving options to jump to within the raise form. (defn half-int-b [n]     (if (= 0 (mod n 2))       (quot n 2)       (raise [:odd-number {:value n}]              (option :use-nil [] nil)              (option :use-nan [] :nan)              (option :use-custom [n] n))))  Its usage can be seen in e.4.8 where different paths can be chosen depending upon :value. An option can also be specified in the manage block (e.4.9). Options can also be overridden when specified in higher manage blocks (e.4.10). e.4.8  -  choosing different paths based on value (manage  (mapv half-int-b [1 2 3 4])  (on {:value 1} []      (choose :use-nil))  (on {:value 3} [value]      (choose :use-custom (/ value 2))))  => [nil 1 3/2 2]  e.4.9  -  choosing option within manage form (manage  (mapv half-int-b [1 2 3 4])  (on :odd-number []      (choose :use-empty))  (option :use-empty [] []))  => []  e.4.10  -  overwriting :use-nil within manage form (manage  (mapv half-int-b [1 2 3 4])  (on :odd-number []      (choose :use-nil))  (option :use-nil [] nil))  => nil  4.3.4    default The default special short-circuits the raise process and skips managers further up to use an issue's default option. A function is defined and is usage is shown how the default form behaves. (defn half-int-c [n]   (if (= 0 (mod n 2))     (quot n 2)     (raise [:odd-number {:value n}]            (option :use-nil [] nil)            (option :use-custom [n] n)            (default :use-custom :odd))))  (manage  (mapv half-int-c [1 2 3 4])  (on :odd-number [value] (default))) => [:odd 1 :odd 2]  The default form can even refer to an option that has to be implemented higher up in scope. An additional function is defined: (defn half-int-d [n]   (if (= 0 (mod n 2))     (quot n 2)     (raise [:odd-number {:value n}]            (default :use-empty))))  The usage for half-int-d can be seen in (e.4.11 and e.4.12) to show these particular cases. e.4.11  -  half-int-d alone (half-int-d 3)  => (throws java.lang.Exception ""RAISE_CHOOSE: the label :use-empty has not been implemented"")  e.4.12  -  half-int-d inside manage block (manage  (mapv half-int-d [1 2 3 4])  (option :use-empty [] [])  (on :odd-number []      (default)))  => []  4.3.5    escalate The escalate special form is used to add additional information to the issue and raised to higher managers. In the following example, if a 3 or a 5 is seen, then the flag :three-or-five is added to the issue and the :odd-number flag is set false. (defn half-array-e [arr]   (manage     (mapv half-int-d arr)     (on {:value (fn [v] (#{3 5} v))} [value]         (escalate [:three-or-five {:odd-number false}]))))  (manage   (half-array-e [1 2 3 4 5])   (on :odd-number [value]       (continue (* value 10)))   (on :three-or-five [value]       (continue (* value 100))))   => [10 1 300 2 500]  Program decision points can be changed by higher level managers through escalate (defn half-int-f [n]  (manage    (if (= 0 (mod n 2))      (quot n 2)      (raise [:odd-number {:value n}]        (option :use-nil [] nil)        (option :use-custom [n] n)        (default :use-nil)))      (on :odd-number []       (escalate :odd-number         (option :use-zero [] 0)         (default :use-custom :nan)))))  (half-int-f 3) => :nan  ;; (instead of nil) (mapv half-int-f [1 2 3 4])  => [:nan 1 :nan 2] ;; notice that the default is overridden  (manage   (mapv half-int-f [1 2 3 4])   (on :odd-number []     (choose :use-zero)))  => [0 1 0 2]   ;; using an escalated option  Options specified higher up are favored: (manage   (mapv half-int-f [1 2 3 4])   (on :odd-number []     (choose :use-nil)))    => [nil 1 nil 2]    (manage    (mapv half-int-f [1 2 3 4])    (on :odd-number []      (choose :use-nil))    (option :use-nil [] nil))    => nil  ;; notice that the :use-nil is overridden  4.4    hooks When working with jvm libraries, there will always be exceptions. ribol provides macros to hook into thrown exceptions. Because all of the three methods are macros involving try, they all support the finally clause. 4.4.1    raise-on raise-on hooks ribol into the java exception system. Once an exception is thrown, it can be turned into an issue: (raise-on [ArithmeticException :divide-by-zero]           (/ 4 2)) => 2  (raise-on [ArithmeticException :divide-by-zero]           (/ 1 0)) => (raises-issue {:divide-by-zero true                    :origin #(instance? ArithmeticException %)})  (manage  (raise-on [ArithmeticException :divide-by-zero]            (/ 1 0))  (on :divide-by-zero []      (continue :infinity))) => :infinity  Any thrown clojure.lang.ExceptionInfo objects will be raised as issues. (raise-on []           (throw (ex-info """" {:a 1 :b 2}))) => (raises-issue {:a 1 :b 2                   :origin #(= (ex-data %) {:a 1 :b 2})})  Multiple exceptions are supported, as well as the finally clause. (raise-on [[NumberFormatException ArithmeticException] :divide-by-zero            Throwable :throwing]           (throw (Throwable. ""oeuoeu""))           (finally (println 1))) => (raises-issue {:throwing true                   :origin #(instance? Throwable %)}) ;; prints 1  4.4.2    raise-on-all raise-on-all will raise an issue on any Throwable (manage  (raise-on-all :error (/ 4 2))  (on :error []      (continue :none))) => 2  (manage  (raise-on-all :error (/ nil nil))  (on :error []      (continue :none))) => :none  4.4.3    anticipate anticipate is another way to perform try and catch. Instead catching exceptions at the bottom of the block, it is possible to anticipate what exceptions will occur and deal with them directly. Anticipate also supports the finally clause (anticipate [ArithmeticException :infinity]             (/ 1 0)) => :infinity  (anticipate [ArithmeticException :infinity              NullPointerException :null]             (/ nil nil)) => :null  5    Control Strategies This is a comprehensive (though non-exhaustive) list of program control strategies that can be used with ribol. It can be noted that the try/catch paradigm can implement sections 5.1 and 5.2. Other clojure restart libraries such as errorkit, swell and conditions additionally implement sections 5.3, 5.4 and 5.5. ribol supports novel (and more natural) program control mechanics through the escalate (5.6), fail (5.7) and default (5.8) special forms as well as branching support in the on special form (5.9). 5.1    Normal 5.1.1    No Raise The most straightforward code is one where no issues raised: e.5.1  -  No Issues (manage                          ;; L2   [1 2 (manage 3)])              ;; L1 and L0  => [1 2 3]  fig.1  -  No Issues Flow 5.1.2    Issue Raised If there is an issue raised with no handler, it will throw an exception. e.5.2  -  Unmanaged Issue (manage                          ;; L2  [1 2 (manage                    ;; L1        (raise {:A true}))])      ;; L0  => (raises-issue {:A true})  fig.2  -  Unmanaged Issue Flow 5.2    Catch Once an issue has been raised, it can be handled within a managed scope through the use of 'on'. 'manage/on' is the equivalent to 'try/catch' in the following two cases: 5.2.1    First Level Catch e.5.3  -  Catch on :A (manage                          ;; L2  [1 2 (manage                    ;; L1        (raise :A)                ;; L0        (on :A [] :A))]           ;; H1A  (on :B [] :B))                  ;; H2B  => [1 2 :A]  fig.3  -  Catch on :A Flow 5.2.2    Second Level Catch e.5.4  -  Catch on :B (manage                          ;; L2  [1 2 (manage                    ;; L1        (raise :B)                ;; L0        (on :A [] :A))]           ;; H1A  (on :B [] :B))                  ;; H2B  => :B  fig.4  -  Catch on :B Flow 5.3    Continue The 'continue' form signals that the program should resume at the point that the issue was raised. 5.3.1    First Level Continue In the first case, this gives the same result as try/catch. e.5.5  -  Continue on :A (manage                          ;; L2  [1 2 (manage                    ;; L1        (raise :A)                ;; L0        (on :A []                 ;; H1A            (continue :3A)))]  (on :B []                       ;; H2B      (continue :3B)))  => [1 2 :3A]  fig.5  -  Continue on :A Flow 5.3.2    Second Level Continue However, it can be seen that when 'continue' is used on the outer manage blocks, it provides the 'manage/on' a way for top tier forms to affect the bottom tier forms without manipulating logic in the middle tier e.5.6  -  Continue on :B (manage                          ;; L2  [1 2 (manage                    ;; L1        (raise :B)                ;; L0        (on :A []                 ;; H1A            (continue :3A)))]  (on :B []                       ;; H2B      (continue :3B)))  => [1 2 :3B]  fig.6  -  Continue on :B Flow 5.4    Choose choose and option work together within manage scopes. A raised issue can have options attached to it, just a worker might give their manager certain options to choose from when an unexpected issue arises. Options can be chosen that lie anywhere within the manage blocks. 5.4.1    Choose Lower-Level e.5.7  -  Choose :X (manage                           ;; L2  [1 2 (manage                     ;; L1         (raise :A                  ;; L0                (option :X [] :3X)) ;; X         (on :A []                  ;; H1A             (choose :X))         (option :Y [] :3Y))]       ;; Y    (option :Z [] :3Z))              ;; Z  => [1 2 :3X]  fig.7  -  Choose :X Flow However in some cases, upper level options can be accessed as in this case. This can be used to set global strategies to deal with very issues that have serious consequences if it was to go ahead. An example maybe a mine worker who finds a gas-leak. Because of previously conveyed instructions, he doesn't need to inform his manager and shuts down the plant immediately. 5.4.2    Choose Upper-Level e.5.8  -  Choose :Z (manage                           ;; L2  [1 2 (manage                     ;; L1        (raise :A                  ;; L0               (option :X [] :3X)) ;; X        (on :A []                  ;; H1A            (choose :Z))        (option :Y [] :3Y))]       ;; Y  (option :Z [] :3Z))              ;; Z  => :3Z  fig.8  -  Choose :Z Flow 5.5    Choose - More Strategies 5.5.1    Overridding An Option If there are two options with the same label, choose will take the option specified at the highest management level. This means that managers at higher levels can over-ride lower level strategies. e.5.9  -  Choose :X1 (manage                            ;; L2  [1 2 (manage                      ;; L1        (raise :A                   ;; L0               (option :X [] :3X0)) ;; X0 - This is ignored        (on :A []                   ;; H1A          (choose :X))        (option :X [] :3X1))]       ;; X1 - This is chosen  (option :Z [] :3Z))               ;; Z  => [1 2 :3X1]  fig.9  -  Choose :X1 Flow 5.5.2    Default Option Specifying a 'default' option allows the raiser to have autonomous control of the situation if the issue remains unhandled. e.5.10  -  Choose Default (manage                            ;; L2  [1 2 (manage                      ;; L1        (raise :A                   ;; L0               (default :X)         ;; D               (option :X [] :3X))  ;; X        (option :Y [] :3Y))]        ;; Y  (option :Z [] :3Z))               ;; Z  => [1 2 :3X]  fig.10  -  Choose Default Flow 5.5.3    Overriding Defaults This is an example of higher-tier managers overriding options e.5.11  -  Choose Default :X2 (manage                            ;; L2  [1 2 (manage                      ;; L1        (raise :A                   ;; L0               (default :X)         ;; D               (option :X [] :3X0)) ;; X0        (option :X [] :3X1))]       ;; X1   (option :X [] :3X2))             ;; X2  => :3X2  fig.11  -  Choose Default :X2 Flow 5.6    Escalate 5.6.1    Simple Escalation When issues are escalated, more information can be added and this then is passed on to higher-tier managers e.5.12  -  Escalate :B (manage                            ;; L2  [1 2 (manage                      ;; L1        (raise :A)                  ;; L0        (on :A []                   ;; H1A           (escalate :B)))]  (on :B []                         ;; H2B      (continue :3B)))  => [1 2 :3B]  fig.12  -  Escalate :B Flow 5.6.2    Escalation with Options More options can be added to escalate. When these options are chosen, it will continue at the point in which the issue was raised. e.5.13  -  Escalate :B, Choose :X (manage                            ;; L2  [1 2 (manage                      ;; L1        (raise :A)                  ;; L0        (on :A []                   ;; H1A            (escalate             :B             (option :X [] :3X))))] ;; X   (on :B []                        ;; H2B       (choose :X)))  => [1 2 :3X]  fig.13  -  Escalate :B, Choose :X Flow 5.7    Fail Fail forces a failure. It is used where there is already a default option and the manager really needs it to fail. e.5.14  -  Force Failure (manage                          ;; L2  [1 2 (manage                    ;; L1        (raise :A                 ;; L0               (option :X [] :X)               (default :X))        (on :A []                 ;; H1A            (fail :B)))])  => (raises-issue {:A true :B true})  fig.14  -  Force Fail Flow 5.8    Default Default short-circuits higher managers so that the issue is resolved internally. e.5.15  -  Force Default (manage                          ;; L2  [1 2 (manage                    ;; L1        (raise :A                 ;; L0               (option :X [] :X)               (default :X))        (on :A []                  ;; H1A            (default)))]  (on :A [] (continue 3)))  => [1 2 :X]  5.8.1    Escalation with Defaults This is default in combination with escalate to do some very complex jumping around. e.5.16  -  Escalate :B, Choose Default (manage                            ;; L2  [1 2 (manage                      ;; L1        (raise :A                   ;; L0          (option :X [] :X))        ;; X        (on :A []                   ;; H1A            (escalate             :B             (default :X))))]       ;; D1   (on :B []                        ;; H2B       (default)))  => [1 2 :X]  fig.15  -  Escalate :B, Choose Default Flow 5.9    Branch Using On Ribol strategies can also be combined within the on handler. In the following example, it can be seen that the on :error handler supports both escalate and continue strategies. e.5.17  -  Input Dependent Branching (manage (manage          (mapv (fn [n]                  (raise [:error {:data n}]))                [1 2 3 4 5 6 7 8])          (on :error [data]              (if (> data 5)                (escalate :too-big)                (continue data))))         (on :too-big [data]             (continue (- data))))  => [1 2 3 4 5 -6 -7 -8]  Using branching strategies with on much more complex interactions can be constructed beyond the scope of this document. 6    Implementation 6.1    The Workplace Two macros - raise and manage work together in creating the illusion of allowing code to seemingly jump around between higher and lower level functions. This in reality is not the case at all. We revisit the analogy of the worker who comes across something in their everyday routine that they cannot process. 6.1.1    The dumb throw When (throw .....) is invoked, the worker basically says: 'Dude, I quit! You deal with it' and lets higher up managers deal with the consequences. fig.16  -  Lazy Worker 6.1.2    The smart raise When (raise ....) is used, the worker will attempt to notify their manager and ask for instructions. Only when there are no instructions forthcoming will they quit: e.6.1  -  Continue Example (defn dislike-odd [n]   (if (odd? n) (raise :error) n))  (manage  (mapv dislike-odd (range 10))  (on :error [] (continue :odd))) => [0 :odd 2 :odd 4 :odd 6 :odd 8 :odd]  Purely from looking at the example code, it reads: perform mapv of dislike-odd over the range of 0 to 10 if :error is raised by dislike-odd, tell dislike-odd to proceed at the point that the error was raised, using the value :odd instead. fig.17  -  Smart Worker Anytime there is an odd input to dislike-odd, the code seemingly jumps out to the context of the manager and having handled the issue, the code then seemingly jumps back into the function again. Note the words seemingly. This is how we as programmers should be thinking about the problem as we write code to handle these type of issues. We are tricked for our own good because it makes us able to better reason about our programs without having to deal with the implementation details. However, we are naturally suspicious of this from a performance point of view. If we don't know the mechanism, we ask ourselves... won`t all this jumping around make our code slower? 6.1.3    The proactive workplace In reality, the program never left the place where raise was called. There was no saving of the stack or anything fancy. The raise/continue combination was an illusion of a jump. There was no jump. Calling raise/continue is most likely computationally cheaper than try/catch. Going back to the workplace analogy, another way to manage exceptional circumstances is to have a prearranged noticeboard of what to do when things go wrong. Managers can write/override different ways to handle an issue on this board proactively. The worker, when encountering an issue, would go look at the board first to decide upon the best course of action to take. Only when there are no matching solutions to the issue will they solve it themselves or give up and quit. In this way, managers will not have to be called everytime something came up. This is the same mechanism of control that ribol uses. fig.18  -  Proactive Management 6.2    The Issue Management Board We look at what happens when there is such an Issue Management Board put in place. raise is called. The worker will look at the board, starting with lowest level manager and proceeding up the management chain to see what strategies has to be been put into place. In the case of e.6.1, there would have been a handler already registered on the board to deal with the :error. The worker will pass any arguments of the issue to the handler function and then return with the result. fig.19 The management does not even need to know that an exception has occured because they have been proactive. 6.2.1    Control Flow as Data Whilst the raise/continue mechanism was decribed in brief, a bit more explanation is required to understand how different forms of jumps occur. Ribol implements the 5 special forms as data-structures:   (defmacro continue [& body]     `{::type :continue ::value (do ~@body)})    (defmacro default [& args]     `{::type :default ::args (list ~@args)})    (defmacro choose [label & args]     `{::type :choose ::label ~label ::args (list ~@args)})    (defmacro fail     ([] {::type :fail})     ([contents]        `{::type :fail ::contents ~contents}))  escalate is not shown because it a bit more complex as options and defaults can. Essentially, it is still just a data structure. The raise macro calls raise-loop which looks at the ::type signature of the result returned by the on handler.   (defn raise-loop [issue managers optmap]     (... code ...          (condp = (::type res)            :continue (::value res)            :choose (raise-choose issue (::label res) (::args res) optmap)            :default (raise-unhandled issue optmap)            :fail (raise-fail issue (::contents res))            :escalate (raise-escalate issue res managers optmap)            (raise-catch mgr res)))      ... code ...)  In the case of :continue, it can be seen that the function just returns (::value res). The function in which raise was called proceeds without ever jumping anywhere. In the case of other forms, there are different handlers to handle each case. If the on handler returns a non-special form value, it will call raise-catch. So it is possible to mess with the internals of ribol by creating a datastructure of the same format of the special forms. However, please do it for shits and giggles only as I'm not sure what it would do to your program. 6.2.2    Implementing Catch To understand how catch is implemented, we have to look at the manage macro: (defmacro manage   ... code ...    `(binding [*managers* (cons ~manager *managers*)              *optmap* (merge ~optmap *optmap*)]      (try        ~@body-forms        (catch clojure.lang.ExceptionInfo ~'ex          (manage-signal ~manager ~'ex))        ~@finally-forms)))  So essentially, it is a try/catch block wrapped in an binding form. When raise-loop gets a non-special form value back from a function handler in the manager it will call raise-catch, which will create a catch signal and actually throw it. The signal is just a clojure.lang.ExceptionInfo. The signal has a ::target, which is the :id of the manager. It also has ::value, which is the original result from on.   (defn- raise-catch [manager value]     (throw (create-catch-signal (:id manager) value)))    (defn- create-catch-signal     [target value]     (ex-info ""catch"" {::signal :catch ::target target ::value value}))  Going back to the manage block, it can be seen that manage will catch any clojure.lang.ExceptionInfo objects thrown. When a signal is thrown from lower functions, it will be caught and manage-signal is then called. If the target does not match the :id, then the exception is rethrown. If the exception has ::signal of :catch then the manager will return (::value data). (defn manage-signal [manager ex]     (let [data (ex-data ex)]       (cond (not= (:id manager) (::target data))             (throw ex)              ... choose code ....              (= :catch (::signal data))             (::value data)              :else (throw ex))))  6.2.3    Implementing Choose Choose works with options. It can be seen that apart from the *managers* structure, there is also an *optmap*. The optmap holds as the key/value pairs the labels of what options are registered and the id of the manager that provided the option. Choose also requires that a signal be sent, but the target will now be a lookup on the optmap given an option label. The signal is very similar to the catch signal. (defn- create-choose-signal     [target label args]      (ex-info ""choose"" {::signal :choose ::target target ::label label ::args args}))  The part that processes :choose is shown in manage-signal:  (defn manage-signal   ...        (= :choose (::signal data))        (let [label (::label data)              f (get (:options manager) label)              args (::args data)]          (manage-apply f args label))   ...)  6.2.4    Implementing the Rest fail, default, escalate all use similar data as control-flow mechanisms to allow control to be directed to the correct part of the program. It is through this mechanism that branching in the on handlers can be achieved. 7    End Notes For any feedback, requests and comments, please feel free to lodge an issue on github or contact me directly. Chris."	"null"	"null"	"– Conditional restarts for clojure/clojurescript."	"true"
"Development"	"shadow-build"	"https://github.com/thheller/shadow-build"	"– A ClojureScript build library capable of compiling multiple output files."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"92"	"8"	"13"	"GitHub - thheller/shadow-build: ClojureScript compile&build library Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 8 Star 92 Fork 13 thheller/shadow-build Code Issues 1 Pull requests 0 Wiki Pulse Graphs ClojureScript compile&build library 213 commits 1 branch 0 releases 2 contributors Clojure 75.4% JavaScript 21.8% Java 2.5% HTML 0.3% Clojure JavaScript Java HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit 57a3fa9 Jul 10, 2016 thheller temporary work arround for :node-global-prefix … usually you'd create just one file via (umd/flush) which skips outputting seperate files  but as seen in proton you sometimes want to combine this with a REPL and the REPL must be able to load seperate files later, it should use the same global object the single file did. Permalink Failed to load latest commit information. cljs-data fix ns :use Dec 7, 2015 doc first public release Dec 14, 2013 src temporary work arround for :node-global-prefix Jul 10, 2016 test/shadow temporary work arround for :node-global-prefix Jul 10, 2016 .gitignore remove iml Nov 5, 2015 LICENSE first public release Dec 14, 2013 README.md bump Jun 28, 2016 project.clj temporary work arround for :node-global-prefix Jul 10, 2016 README.md shadow-build A ClojureScript build library capable of compiling multiple output files. It is basically a rewrite of cljs.closure since it assumes to only ever produce one output file. Its a lot more flexible than cljs.closure which also means its a little more complex to use. Example Project can be found at: http://github.com/thheller/shadow-build-example Usage Right now this really only is a library and not a tool like lein-cljsbuild. But Leiningen provides enough hooks to make integration easy, assuming you are using Leiningen of course. Include the necessary options in your project.clj :profiles {:dev {:source-paths [""dev""]                  :dependencies [[org.clojure/clojurescript ""1.9.93""]                                 [thheller/shadow-build ""1.0.209""]]}} I recommend putting it into the :dev profile since you usually don't need it in production. You'll also need to provide ClojureScript itself. For a basic usage example see: http://github.com/thheller/shadow-build-example License Copyright © 2015 Thomas Heller Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/thheller/shadow-build"	"– A ClojureScript build library capable of compiling multiple output files."	"true"
"Document Object Model"	"cljs-binding"	"https://github.com/fluentsoftware/cljs-binding"	"– It binds html elements to ClojureScript functions."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"55"	"2"	"5"	"GitHub - fluentsoftware/cljs-binding: A ClojureScript binding library Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 55 Fork 5 fluentsoftware/cljs-binding Code Issues 2 Pull requests 1 Pulse Graphs A ClojureScript binding library 53 commits 2 branches 0 releases Fetching contributors JavaScript 97.9% Clojure 2.0% Racket 0.1% JavaScript Clojure Racket Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. examples src-cljs src/cljsbinding .gitignore README.md project.clj README.md cljs-binding A ClojureScript binding library cljs-binding makes it easy to bind html elements to ClojureScript functions. Examples Simple binding In your view, add an element [:p {:bind ""text: sample.content""}], or if you are coding straight html, then <p bind=""text: sample.content""></p> The paragraphs text will be set to the return value of the sample.content javascript/ClojureScript function. Any jQuery method can be used as the key in the binding. If the ClojureScript sample.content function dereferences any atoms, then when the values of any of those atoms change, the text of the paragraph will be automatically updated. Multiple bindings can be specified e.g. <p bind=""text: sample.content; css: sample.contentcss""></p> Binding keys In addition to supporting jQuery methods as keys, as shown above with text, css, there are also some additional functions that make life easier: visible - Controls the visibility of the element using jQuery show and hide internally class - Removes all classes from the element, and sets the classes to whatever classes the function returns (as a space separated string) checked - For checkbox elements, allows you to control whether a checkbox is checked from a function returning a boolean. Binding atoms to inputs As well as binding UI elements to functions that are dependent on atoms, atoms can also be bound to the value (or more specifically .val()) of an input [:input {:bindatom ""sample.MyAtom"" :type ""text""}], or <input bindatom=""sample.MyAtom"" type=""text"">. This is a two way binding, so not only will the input's value be updated whenever the atom changes, whenever the input fires the change event, the atom will be reset to the new value of the input. For checkbox inputs, special handling is applied, so that you can bind an atom with a boolean value in exactly the same way. If the atom is a map, then multiple input elements can be bound to the atom. In this case, the id of the input element is used as the key to lookup the particular item in the map e.g. <input bindatom=""sample.myatom"" type=""text"" id=""mykey""> will bind the input to the item in the map with key :mykey. Again, this will be a two way binding, so whenever the input fires the change event, the atom will be updated with a new map. Sequences and loops In addition to binding form input elements to atoms, you can also bind regions of html to an atom that is a sequence. This will clone the region of html for each item in the sequence. The region of html can also contain bindings. In this case, the binding functions will be called with a single parameter, which is the item from the sequence. This is best demonstrated with an example: <ul>     <li bindseq=""sample.sequenceAtom"">         <i bind=""text: sample.itemtext""></i>     </li> </ul>  In this example there will be a list item for every item in the sequence contained in the sample.sequenceAtom atom. The html will be automatically updated whenever the sequenceAtom is modified. The sample.itemtext function will be called with each item in the sequence. Binding dynamically cljs-binding provides a few functions that make it easy to dynamically create elements with bindings applied. apply-binding The apply-binding function can be used to apply a binding to an element. apply-binding takes an element and the binding you wish to apply. The binding can be an atom e.g. (def name (atom ""matthew""))  (apply-binding ($ ""#myinput"") name)   In this case the atom will be bound to the input element as described above in Binding atoms to inputs. The binding can also be a map where the keys specify the binding key, and the values are the functions to be applied e.g. (defn status-text [] (str ""System status: "" @status)) (defn background-color [] (... some calculation for color ...))  (apply-binding ($ ""#myelem"") {:text status-text :background background-color})  Crate cljs-binding provides some helper functions and macros that make it easier to dynamically bind elements using the crate library (a ClojureScript hiccup implementation) The function cljsbinding.create/add-binding can be used to dynamically add a binding. It works much in the same way as apply-binding does as described above, but instead of taking an jQuery element as it's first parameter, it takes the hiccup element. In order for this to be correctly applied when the html is generated, a macro cljsbinding.crate-macros/bound-html is provided, which wraps a call to crate.core/html and in addition applies the registered bindings. Another helper macro cljsbinding.crate-macros/insert-content takes an id and hiccup elements, and appends those elements with bindings applied to the element with the given id. The example below illustrates how crate can be used to dynmically generate a form for all entries in a map: (ns sample   (:use-macros [crate.def-macros :only [defpartial]]                [cljsbinding.crate-macros :only [insert-content]] )   (:require [cljsbinding :as binding]             [cljsbinding.crate :as bind-crate]             [crate.core :as crate]             )   (:use [jayq.core :only [$ attr val change show hide append remove]]) )  (def testatom (atom {:name ""mr t"" :phone ""123456""}))  (defn gen-form-input [atm k]    [:div      [:label (name k)]     (bind-crate/add-binding [:input {:id (name k)}] atm)]   )  (defn gen-form [atm]   (map (partial gen-form-input atm) (keys @atm)))  (defn phone-number [] (str ""Tel: "" (:phone @testatom)))  (defn gen-content []   (insert-content ""placeholder""      [:div        (gen-form testatom)       [:div ""You can reach ""          (bind-crate/add-binding [:span {:id :name}] testatom)          "" on ""          (bind-crate/add-binding [:span] {:text phone-number})]     ]))  Example projects For a more complete example, checkout the todo example project under examples. This is a completely client side example, so no web server, or hiccup, and demonstrates how you can use cljs-binding to create a todo application. This is based on the TodoMVC template. Click here to see the todo example running live There are other examples which provide examples of binding to maps, and dynamic bindings. Usage Update your project.clj to have a dependency on fluentsoftware/cljs-binding ""1.0.1"". The clojure function cljsbinding.core/bind will generate the appropriate javascript to initialise the cljs-binding client code if you are using hiccup to generate your html. If not, then simply call the cljsbinding.boot javascript function on page load. In your ClojureScript code, simply :require [cljsbinding :as binding] to ensure that cljsbinding client code is compiled in. Optimization If you are setting the ClojureScript optimization level to advanced, then there a couple of things to be aware of You need to make sure the cljsbuild settings has externs for jquery e.g. :cljsbuild {     :builds [{:source-path ""src-cljs""               :jar true               :compiler {:output-to ""todo.js""                          :optimizations :advanced                          :externs [""externs/jquery.js""]                          :pretty-print true}}]}    Any atoms that you want to bind to need to have export set in the same way any functions you want to export to javascript e.g. (def ^:export todos (atom []))  (defn ^:export todocount []    (count @todos) )         License Copyright © 2012 Fluent Software Solutions Ltd Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fluentsoftware/cljs-binding"	"– It binds html elements to ClojureScript functions."	"true"
"Document Object Model"	"Crate"	"https://github.com/ibdknox/crate"	"– A ClojureScript implementation of Hiccup."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"202"	"16"	"24"	"GitHub - ibdknox/crate: A ClojureScript implementation of Hiccup Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 16 Star 202 Fork 24 ibdknox/crate Code Issues 6 Pull requests 2 Pulse Graphs A ClojureScript implementation of Hiccup 42 commits 1 branch 0 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit ac992fa Dec 16, 2013 ibdknox bulleting and use of Element protocol … Signed-off-by: Chris Granger <ibdknox@gmail.com> Permalink Failed to load latest commit information. src/crate bulleting and use of Element protocol Dec 16, 2013 test/crate initial import Feb 4, 2012 .gitignore initial import Feb 4, 2012 README.md Update README.md Jan 16, 2013 project.clj README.md crate Crate is a ClojureScript implementation of the awesome Hiccup html templating library. Usage (ns myapp  (:use-macros [crate.def-macros :only [defpartial]])  (:require [crate.core :as crate]))  (crate/html [:p.woot {:id ""blah""} ""Hey!""]) => <p class=""woot"" id=""blah"">Hey!</p>  (defpartial header []  [:header    [:h1 ""My app!""]])  (header) => <header><h1>My app!</h1></header>  Differences from Hiccup The crate.core/html returns dom nodes instead of strings of html You can use dom nodes in element bodies like this: (crate/html [:div (crate/raw ""<span>foo</span><strong>bar</strong>"")]) => <div><span>foo</span><strong>bar</strong></div> License Copyright (C) 2011 Chris Granger Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/ibdknox/crate"	"– A ClojureScript implementation of Hiccup."	"true"
"Document Object Model"	"Dominator"	"https://github.com/dubiousdavid/dominator"	"– Virtual-Dom in ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"69"	"9"	"4"	"GitHub - dubiousdavid/dominator: Virtual-Dom in ClojureScript Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 9 Star 69 Fork 4 dubiousdavid/dominator Code Issues 2 Pull requests 0 Pulse Graphs Virtual-Dom in ClojureScript 52 commits 3 branches 3 releases 1 contributor JavaScript 98.6% Clojure 1.3% Other 0.1% JavaScript Clojure Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags animation-experiment gh-pages master Nothing to show v0.4.0 v0.3.0 v0.1.0 Nothing to show New pull request Latest commit 428468a Jun 8, 2015 dubiousdavid Be even lazier when it comes to patching. Permalink Failed to load latest commit information. examples Be even lazier when it comes to patching. Jun 8, 2015 externs Moved externs file. May 8, 2015 scripts Refactoring. Apr 1, 2015 src/dominator Be even lazier when it comes to patching. Jun 9, 2015 .gitignore Add examples. Jun 2, 2015 README.md Be even lazier when it comes to patching. Jun 9, 2015 build-vdom Refactoring. Apr 1, 2015 package.json Refactoring. Apr 1, 2015 project.clj Be even lazier when it comes to patching. Jun 9, 2015 vdom-main.js Refactoring. Apr 1, 2015 vdom.js Refactoring. Apr 1, 2015 README.md Dominator ClojureScript + Zelkova + Virtual Dom + ""The Elm Pattern"" = Sane Javascript! Uses stch-html for representing HTML in ClojureScript. Features Single flow of events. Use core.async. Use pure functions for updating state and rendering. Minimal learning curve (i.e., easier than Om). Installation [com.2tothe8th/dominator ""0.4.0""] Note: You will need to download the compiled vdom.js file to your project directory and reference it in your HTML file. wget https://raw.githubusercontent.com/dubiousdavid/dominator/master/vdom.js You will also need to add :externs [""dominator.js""] to the compiler options map if using advanced compilation. Sample programs Counter (source) Wikipedia (source) Mario (source) API Documentation http://dubiousdavid.github.io/dominator/doc/ Example Usage Overview In the example below there is a single signal actions that all events are put onto. The sig/reductions function acts like an unending reduce over the actions signal. reductions takes a pure function, an initial value, and a signal, and produces a signal. update-model takes the existing model, the ""action"" (value from the signal), and returns a new model. The view function is mapped over each value from the model signal. This function returns a representation of the markup. Finally the markup signal and root element are passed to render, which patches the DOM with each value from the signal (uses requestAnimationFrame under the hood). (ns dominator.counter   (:require [dominator.core :refer [render]]             [stch.html :refer [div table tr td input]]             [cljs.core.async :as async :refer [<!]]             [dominator.async :as as :refer-macros [forever]]             [dominator.test.util :as util]             [jamesmacaulay.zelkova.signal :as sig]             [cljs.core.match])   (:require-macros [cljs.core.match.macros :refer [match]]))  (enable-console-print!)  (def people [""Billy"" ""Bobby"" ""Joey""]) (def actions (sig/write-port :no-op))  (defn view [model]   (div     (table       (tr         (for [person people]           (td             (input :type ""button"" :value person                    :onclick (as/send actions [:clicked person])))))       (tr         (for [person people]           (td             (input :type ""text"" :readonly true :value (get model person))))))     (div :id ""button-row""       (input :type ""button"" :value ""Reset""              :onclick (as/send actions :reset)))))  (def empty-model   {""Billy"" 0    ""Bobby"" 0    ""Joey"" 0})  (def initial-model   (or (util/get-storage ""clicks"") empty-model))  (defn update-model [model action]   (match action     :no-op model     :reset empty-model     [:clicked n] (update-in model [n] inc)))  (def model (sig/reductions update-model initial-model actions)) (def modelc (sig/to-chan model))  (render (sig/map view model) js/document.body)  (forever   (let [m (<! modelc)]     (util/set-storage ""clicks"" m))) Wikipedia search example Below is a slightly more complicated example where we have two signals, one for actions and one for queries. (ns dominator.wiki   (:require [dominator.core :refer [render]]             [stch.html :refer [div input ul li]]             [cljs.core.async :as async :refer [<! >!]]             [dominator.async :as as :refer-macros [forever]]             [dominator.test.util :as util]             [clojure.string :as string]             [cljs.core.match]             [jamesmacaulay.zelkova.signal :as sig]             [jamesmacaulay.zelkova.time :as time])   (:require-macros [cljs.core.match.macros :refer [match]]))  (enable-console-print!)  (def wikipedia-endpoint   ""http://en.wikipedia.org/w/api.php?action=opensearch&format=json&search="")  (defn wikipedia [search]   (str wikipedia-endpoint search))  (def query (sig/write-port """")) (def actions (sig/write-port :no-op))  (defn view [results]   (div     (input :placeholder ""Search Wikipedia!""            :oninput #(async/put! query (-> % util/target-value string/trim)))     (ul       (for [result results]         (li result)))))  (def empty-model [])  (defn update-model [model action]   (match action     :no-op model     [:results results] results))  (def queries   (->> query        sig/drop-repeats        (time/debounce 150)        (sig/drop-if string/blank?)        (sig/map wikipedia)        sig/to-chan))  (forever   (let [q (<! queries)]     (let [result (<! (util/jsonp q))]       (>! actions [:results (second result)]))))  (def model (sig/reductions update-model empty-model actions))  (render (sig/map view model) js/document.body) Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/dubiousdavid/dominator"	"– Virtual-Dom in ClojureScript."	"true"
"Document Object Model"	"Dommy"	"https://github.com/plumatic/dommy"	"– A no-nonsense ClojureScript templating and DOM manipulation library."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"708"	"68"	"74"	"GitHub - plumatic/dommy: A tiny ClojureScript DOM manipulation and event library Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 68 Star 708 Fork 74 plumatic/dommy Code Issues 9 Pull requests 7 Pulse Graphs A tiny ClojureScript DOM manipulation and event library 337 commits 4 branches 0 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags as-str create-element-attrs desmatic master Nothing to show Nothing to show New pull request Latest commit ba5a6f3 Jan 13, 2016 w01fe Update for org name change Permalink Failed to load latest commit information. resources update readme/project and remove old test runner Jan 16, 2014 src/dommy Fix default value for boolean attributes in set-attr! Apr 23, 2015 test/dommy Fix default value for boolean attributes in set-attr! Apr 23, 2015 .gitignore Update .gitignore Aug 5, 2014 CHANGELOG.md Update CHANGELOG from #98 Apr 28, 2015 README.md Update for org name change Jan 13, 2016 project.clj Update for org name change Jan 13, 2016 README.md A ClojureScript DOM manipulation and event library. Usage Add the following dependency to your project.clj: [prismatic/dommy ""1.1.0""] Upgrading to 1.0.0+ from 0.X.Y Version ""1.0.0"" includes breaking API changes. Here's a quick overview of what's changed: dommy.template namespace and all related templating features (node, deftemplate, etc) have been removed from the library. Simplified namespace structure. Everything in dommy.macros and dommy.attrs has been moved into dommy.core See CHANGELOG.md or https://github.com/plumatic/dommy/pull/85 for more details. If you are looking for hiccup-style templating features, check out https://github.com/jeluard/hipo/ Selection DOM nodes are selected using macros, which expand to the correct native dom calls. Because selectors don't wrap returned nodes, there is a distinction between single and multiple selections. A selector can be a keyword, string or vector. (ns foo.bar   (:require      [dommy.core :refer-macros [sel sel1]]))  (sel1 :body) ; => document.body (sel1 :#header) ; => document.getElementById(""header"") (sel1 "".todo"") ; => document.getElementsByClassName(""todo"")[0]  (sel [:#todos :li]) ; => document.querySelectorAll(""#todos li"") Sometimes its useful to specify the base node from which the selection takes place. (sel1 todos-element :.todo) DOM Manipulation Inspired by jQuery, but adapted to be functional in order to better fit with ClojureScript core. (dommy/append! (sel1 :#todos) todo-element)  (doseq [todo (sel :.todo)]   (dommy/add-class! todo :complete))  (map dommy/text (sel :.todo)) Functions that modify take the target node as their first argument, and return the same modified node, allowing the use of threading macros to accomplish jQuery-like chaining. (-> (sel1 :#my-button)     (dommy/remove-attr! :disabled)     (dommy/add-class! :active)     (dommy/set-text! ""Click me!""))  (->> (sel :.image)      (filter #(> (dommy/px % :width) 500))      (map #(dommy/add-class! % :big-image))) Events Dommy's event API closely resembles the native JavaScript API. (ns foo.bar   (:require     [dommy.core :as dommy :refer-macros [sel1]]))  (defn click-handler [e]     (.log js/console ""You clicked my button! Congratulations""))  (dommy/listen! (sel1 :#my-button) :click click-handler)  (dommy/unlisten! (sel1 :#my-button) :click click-handler) If the first argument to listen! is a sequence, the handler will delegate events to the selected element defined by the sequence. A special property selectedTarget added to the event specifies the element selected. (defn todo-click-handler [e]   (.log js/console ""The clicked todo is"" (.-selectedTarget e)))  (dommy/listen! [todos-element :.todo] :click todo-click-handler)) Testing For all pull requests, please ensure your tests pass (or add test cases) before submitting. $ lein cljsbuild test  License Copyright (C) 2014 Prismatic Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/plumatic/dommy"	"– A no-nonsense ClojureScript templating and DOM manipulation library."	"true"
"Document Object Model"	"Enfocus"	"http://ckirkendall.github.io/enfocus-site/"	"– A DOM manipulation and templating library for ClojureScript inspired by Enlive."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Enfocus2 Documentation [:enfocus2] About Quick Start Transforms Event Handling Animations Templates/Snippets Extractors View Bindings Enfocus2 A platform for building rich UIs in ClojureScript. Quick Start Version 2.1.0 What's New! From optimizations and new features to improved semantics, there were significant changes in Enfocus from 1.x to 2.x releases. To see a complete list of what Enfocus2 brings to the table, click below. View details » Finding Help Enfocus has online forum where users can post questions, share informtion and and find general help. This is also where the status of features and current development is discussed. View details » Enfocus Charts We are currently working on an another project that is in the early phases. It is a charting library written entirely in ClojureScript. It integrates with both enfocus and domina. It is very early but if you would like to take a peek. View details » Designed by @crkirkendall. Code licensed under Eclipse Public License v1.0 Issues"	"null"	"null"	"– A DOM manipulation and templating library for ClojureScript inspired by Enlive."	"true"
"Document Object Model"	"Freactive"	"https://github.com/aaronc/freactive"	"– A high-performance, pure Clojurescript, declarative DOM library inspired by reagent, om, reflex and hiccup."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"365"	"25"	"25"	"GitHub - aaronc/freactive: High-performance, pure Clojurescript, declarative DOM library Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 25 Star 365 Fork 25 aaronc/freactive Code Issues 16 Pull requests 1 Wiki Pulse Graphs High-performance, pure Clojurescript, declarative DOM library http://documentup.com/aaronc/freactive 401 commits 4 branches 1 release Fetching contributors Clojure 98.5% HTML 1.5% Clojure HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: develop Switch branches/tags Branches Tags develop experimental-diffing gh-pages master Nothing to show v0.1.0 Nothing to show New pull request Latest commit b8d8c1d Nov 11, 2015 aaronc Setting freactive-state on root nodes so that they can be unmounted p… … …roperly. WIP on more generic as-velem to support scoped plugins. Permalink Failed to load latest commit information. example/freactive Replaced existing dom impl with new dom impl and documented public API. Jun 3, 2015 resources/public Replaced existing dom impl with new dom impl and documented public API. Jun 3, 2015 src/freactive Setting freactive-state on root nodes so that they can be unmounted p… Nov 11, 2015 .gitignore WIP on new DOM impl. Jun 2, 2015 LICENSE First commit. Jul 10, 2014 README.md Update README.md Jun 10, 2015 project.clj Fixed bug in DOM. Sep 24, 2015 README.md freactive pronounced ""f-reactive"" for functional reactive - name subject to change. This library should be considered experimental - it has not been widely tested. FYI: this documentation is now significantly out-dated and will hopefully get updated soon freactive is a high-performance, pure Clojurescript, declarative DOM library. It uses hiccup-style syntax and Clojure's built-in deref and atom patterns. It is inspired by reagent, om and reflex (as well as my experience with desktop GUI frameworks such as QML, JavaFX and WPF). See it in action! Goals: Provide a simple, intuitive API that should be almost obvious to those familiar with Clojure (inspiration from reagent) Allow for high-performance rendering good enough for animated graphics based on a purely declarative syntax Allow for reactive binding of any attribute, style property or child node Allow for coordinated management of state via cursors (inspiration from om) Provide deeply-integrated animation support Allow for cursors based on paths as well as lenses Provide a generic items view component for efficient viewing of large data sets Minimize unnecessary triggering of update events Allow for binding of any DOM tag including Polymer elements Coordinate all updates via requestAnimationFrame wherever possible Use generic algorithms wherever possible for pluggable extension points including custom polyfills, event delegation, etc. Be easy to debug Be written in pure Clojurescript Provide support for older browsers via polyfills (not yet implemented) Two-minute tutorial Leiningen dependency info: Hello World example: To try this quickly, you can install the austin repl plugin, run austin-exec, open a browser with the URL provided by austin and execute the code below. This code is also compatible with lein-figwheel - this is possibly the best approach for live Clojurescript development available now. (ns example1   (:refer-clojure :exclude [atom])   (:require [freactive.core :refer [atom cursor]]             [freactive.dom :as dom])   (:require-macros [freactive.macros :refer [rx]]))  (defonce mouse-pos (atom nil))  (defn view []   [:div     {:width ""100%"" :height ""100%"" :style {:border ""1px solid black""}      :on-mousemove (fn [e] (reset! mouse-pos [(.-clientX e) (.-clientY e)]))}     [:h1 ""Hello World!""]     [:p ""Your mouse is at: "" (rx (str @mouse-pos))]])  (defonce root (dom/append-child! (.-body js/document) [:div#root]))  (dom/mount! root (view)) Explanation: If you already understand hiccup syntax and Clojure's atom, you're 90% of the way to understanding freactive. freactive's syntax is very similar to that of reagent with a few small differences. Reactive atoms: In freactive, instead of Clojure's atom, you use freactive's reactive atom which allows deref's to be captured by an enclosing reactive expression - an rx in this case. (This is exactly the same idea as in reagent and I believe it originally came from reflex). The rx macro: The rx macro returns an IDeref instance (can be deref'ed with @) whose value is the body of the expression. This value gets updated when (and only when) one of the dependencies captured in its body (reactive atoms, other rx's and also things like cursor's) gets ""invalidated"". (Pains were taken to make this invalidation process as efficient and configurable as possible.) Binding to attributes, style properties and node positions: Passing an rx or reactive atom (or any IDeref instance) as an attribute, style property or child of a DOM element represented via a hiccup vector binds it to that site. freactive makes sure that any updates to rx's or atom's are propogated directly to that DOM site only as often as necessary (coordinated with requestAnimationFrame). Mounting components: Components are mounted by passing a target node and hiccup vector to the mount! function (this will replace the last child of the target node with the mounted node!). Events: All attributes prefixed with :on- will treated as event handlers and take a Clojurescript function as an argument. Helper functions: A few additional helper functions such as - append-child!, remove!, and listen! - are included, but it is encouraged to use them sparingly and prefer the declarative hiccup syntax wherever possible. Note: atom and rx are also available for Java Clojure and can be used with JavaFX via fx-clj using a similar API. Originally this library was conceived as just a clj/cljs atom and rx library. After working with it in fx-clj, I wanted to do the same thing for the DOM and voila. Eventually a ""core"" library containing just the reactive data types will be split off. The Java version of core.clj is slightly out of sync with core.cljs. There is also an out-of-date ClojureCLR version. Performance freactive should be able to handle fairly high performance graphics. Rather than saying how fast freactive does X compared to framework Y (which isn't always productive), I created an example that would really tax its ability to render. This is to give me (as well as potential library users) an idea of what it can and can't handle on different platforms. This example tries to animate points on the screen (SVG circle nodes) relative to the current mouse position. It has a complexity factor, n, which can be controlled by the + and - buttons. The number of points is (2n + 1)2. When you're observing the example, you can view the calculated FPS rate as well as the estimated number of DOM attributes updated per second. I recommend trying different values of n in different browsers (even try your phone!). Notice at which number of points the animation is and isn't smooth. Please report any issues you find here so we can make it better!: https://github.com/aaronc/freactive/issues. Here is the example: http://aaronc.github.io/freactive/dom-perf All of this is done declaratively with only the syntax described above, easers and transitions. Here is the source for the example: https://github.com/aaronc/freactive/blob/master/test/freactive/dom_perf.cljs This example benchmarks performance of reactive atom, rx and easer updates, freactive's rendering loop and applying those updates to DOM attributes and style properties. It also tests freactive's ability to clean up after itself and create new DOM elements. In the pause between transitions (usually not perceptable for small n values), freactive is cleaning up old elements (with attached rx's that need to be deactivated) and creating new DOM elements. If the average frame rate for a given n doesn't drop after many transitions, it means that freactive is doing a good job of cleaning up after itself. If you notice a significant drop, please report it! You should be able to see fairly smooth animations with thousands of points (n >= 16) on most modern computers even though the frame rate will start drop significantly. The ""number of attrs updated"" calculation is only valid when either the mouse is moving or a transition is happening. (Okay... you may be wondering if I did a Reagent comparsion because the code is so similar. Here it is. Reagent and React are quite fast! but freactive does seem to scale better for higher values of n. freactive also provides built-in animations.) Transitions Transition callbacks can be added to any DOM element using the with-transitions function. (with-transitions   [:h1 ""Hello World!""]   {:on-show (fn [node callback]               ;; do something               (when callback (callback)))}) The framework understands the :on-show and :on-hide transitions. These transitions will be applied upon changes at binding sites - i.e. at the site of an rx or an initial mount!. (A mechanism for triggering transitions based on changes to data-state is also planned.) Animations Easers An API that wraps easer functionality in a convenient animate! function that takes style and attribute properties is planned. easer's are the basis of freactive animations. An easer is a specialized type of deref value that is updated at every animation frame based on an easing function and target and duration parameters. Essentially it provides ""tween"" values. Easers are defined with the easer function which takes an initial value. They can be transitioned to another value using the start-easing! function which takes the following parameters: from (optional), to, duration, easing-fn and a on-complete callback. An easer is designed to be used as a dependency in a reactive computation, like this: (def ease-factor (animation/easer 0.0)) (defn my-view []   (dom/with-transitions     [:h1 {:style           {:font-size (rx (str (* 16 @ease-factor) ""px""))}} ""Hello World!""]     {:on-show (fn [node callback]                 (animation/start-easing! ease-factor 0 1.0 1000                                          (ease :quad-in-out) callback))})) By creating an easing-chain, we can do some more complex things: (def ease1 (animation/easer 0.0)) (def ease2 (animation/easer 1.0)) (def complex-transition   (animation/easing-chain     [[ease1 0.0 1.0 1000 (ease :quad-in-out)]      [ease2 1.0 0.0 500 (ease :quad-out)]      [ease2 0.0 1.0 150 (ease :quint-in)]])) (defn my-view []   (dom/with-transitions     [:h1 {:style           {:font-size (rx (str (* 16 @ease1) ""px""))            :opacity (rx (str @ease2))}}      ""Hello World!""]     {:on-show      (fn [node callback] (complex-transition callback))})) Easing functions: an easing function, f, is a function that is designed to take an input t parameter that ranges from 0.0 to 1.0 that has the property (= (f 0) 0) and (= (f 1) 1). Basically the easing function is supposed to smoothly transition from 0 to 1. The easer itself takes care of properly scaling the values based on duration and from and to values. The easing functions shown above use bardo's ease function from bardo.ease. Any third-party easing library such as bardo can be used for easing functions. (freactive only provides the most basic quad-in and quad-out easing functions built-in.) Optional from parameter: the optional from parameter to start-easing! has a special behavior - if the current value of the easer is different from from, the duration of easing will be adjusted (linearly for now) based on the difference bettween from and the current value. This is to keep the speed of easing somewhat consistent. If you don't want this behavior and always want the same duration regardless of the current value of the easer, don't specify a from value. Interupting in progress easings: if start-easing! is called on an easer that is already in an easing transition that hasn't completed, it is equivalent to cancelling the current easing and sending the easer in a different direction starting from the current value. If there was on on-complete callback to the easing that was in progress it won't be called and is effectively ""cancelled"". (This behavior can be observed in the performance example if you click + or - while a transition is happening.) Cursors cursor's in freactive behave and look exactly like atom's. You can use Clojurescript's built-in swap! and reset! functions on them and state will be propogated back to their parents. By default, change notifications from the parent propagate to the cursor when and only when they affect the state of the cursor. Fundamentally, cursors are based on lenses. That means that you can pass any arbitrary getter (of the form (fn [parent-state])) and setter (of the form (fn [parent-state cursor-state])) and the cursor will handle it. (def my-atom (atom 0)) (defn print-number [my-atom-state]   ;; print the number with some formmating ) (defn parse-number [my-atom-state new-cursor-state]   ;; parse new-cursor-state into a number and return it   ;; if parsing fails you can just return my-atom-state   ;; to cancel the update or throw a validation   ;; exception ) (def a-str (cursor my-atom print-number parse-number)) ;; @a-str -> ""0"" (reset! a-str ""1.2"") (println @my-atom) ;; 1.2 cursors can also be created by passing in a keyword or a key sequence that would be passed to get-in or assoc-in to the cursor function: (def my-atom (atom {:a {:b [{:x 0}]}})) (def ab0 (cursor my-atom [:a :b 0])) ;; @ab0 -> {:x 0} (def a (cursor my-atom :a) ;; a keyword can be used as well This is somewhat similar (but not exactly) to cursors in om - which was the inspiration for cursors in freactive. It should be noted that in freactive, cursors were designed to work with lenses first and then with key or key sequences (korks) for convenience. A cursor doesn't know anything about the structure of data it references (i.e. the associative path from parent to child). Items View An experimental items-view has been created, but is still a work in progress... This documentation describes the concept in a very general way. The idea of the items-view is to provide a generic container for large collections of objects that send notifications about exactly which items changed so that diffing is not neeeded. An analogue to this in the desktop UI world is the WPF ItemsControl which is a base class for ListView's and TreeView's. Basically it allows to framework to observe a collection and add or remove nodes rendering them based on a data template. In freactive, the items-view will take a container parameter (hiccup virtual node), a template-fn which will receive a single argument representing a cursor to a single item in the collection and should return a hiccup virtual node (can be reactive), and a collection parameter representing the underlying collection that is being rendered. The collection should be satisfy the IObservableCollection protocol which is still being fleshed out. A basic implementation of IObservableCollection will be provided which wraps an atom containing a Clojure map or vector and provides specific methods for adding/updating/removing individual items so that notifications can be done on an item-specific basis with no need for diffing. This type of idiom will allow for quite large collections. IObservableCollection could eventually be extended to support a database-backed collection and then we have something like Meteor in Clojurescript..! The items-view should provide built-in support for applying and removing sorts in a stable way, for adding and removing filters and for limiting the displayed elements to a specific range (to support paging and infinite scrolling). It should be agnostic to the underlying IObservableCollection as well as the container and template-fn and do things as generically as possible. It should be noted that the items-view will be orthogonal to the other functionality in freactive - freactive ""core"" will just attempt to provide idioms which would support an items-view and a good out of the box implementation. In reality, items-view could be a separate library and alternate implementations could co-exist. Debugging Reactive Expressions Reactive expressions can be hard to debug - sometimes we notice that something should be getting invalidated that isn't or it seems like something is getting updated too often. The debug-rx macro can be placed around the initialization of any rx:  (debug-rx (rx (str @n))) and you should seeing verbose debug statements corresponding to: start of dependency capture each dependency capture each invalidation event with a print out of watch keys (note: not all watches aware of this rx may be registered - part of freactive's optimizations are smart attaching and removing of watches based on dirty flags) Reactive Change Notifications In-depth Differences between regular atoms and reactive atoms In addition to their ability to register themselves as a dependency to an rx, reactive atom's have one additional difference from regular atoms. Reactive atoms do an equality check (using =) before completing a change and notifying watches. i.e: they will only report a change when the value actually has changed. Eagerness and Laziness A lazy dependency invalidates a parent rx whenever it gets invalidated (but it doesn't check to see if its value has really changed). An eager dependency checks to see if it really has changed before notifying its parent. By default, rx's are lazy and cursor's are eager. This is because an rx is something whose value almost always changes whenever a dependency changes and a cursor is usually something that will only change when its portion of a larger state changes (i.e. the path [:a :b] in {:a {:b 1} c: {:d 2}}). There is also an eager-rx and a lazy-cursor if you want to invert this default behavior. Details: You probably shouldn't need to understand this to develop most apps, but it may be useful to those trying to maximize performance in complex situations. Laziness relates to the IInvalidates protocol which freactive introduces. Basically IInvalidates defines three protocol methods: -add-invalidation-watch, -remove-invalidation-watch and -notify-invalidations-watches. These take the same parameters as the corresponding -add-watch, -remove-watch, etc. methods from IWatchable. The only difference is that the callback function should take 2 args (instead of 4): key and ref. When something is invalidated, we are communicating that it's state will probably change, but that we don't know what the new state is yet! So, if we register an invalidation-watch against an rx, it will perform lazily - i.e. it will only compute its new state when we deref it. If we register a watch against it, it will perform eagerly and it will only notify about state changes (to both watches and invalidation watches) if the value has actually change! So, how do we make an rx or cursor lazy or eager? Well, it may seem counter-intuitive, but reactives in freactive actually register their own dependencies. Instead of ""registering"" with the parent, they look for a *invalidate-rx* function to be bound in the current context and they they register it either as a watch or invalidation watch. *invalidate-rx* actually should be a fn with 0, 2 and 4 arity overloads. The 0 arity-overload allows the dependency to take entire control over the invalidation process and the 2 and 4 arities correspond to invalidation watches and watches respectively. Whenever *invalidate-rx* is called, it immediately removes the watch on whatever dependency called it (it will be added the next time the rx is derefed if it is still in the rx scope.) After some benchmarking, this method seemed to be the most efficient general method. Anyway, because dependencies register themselves, they can decide whether to register themselves lazily or eagerly. It should be noted that a dependency is eager whenever anything registers a watch (as opposed to an invalidation-watch) against it. We can override a dependency's choice of eagerness or laziness by derefing them within an eagerly or lazily macro - if you ever should need that: (eagerly @a). Propogation of changes to the DOM: Attribute and node change listeners always try to register an invalidation-watch first and when not available (for atoms for instance) a watch. Whenenver they receive a change notification, they remove the watch, queue an update to the render queue, and add the watch again right before the update is applied (when deref is called). Deciding not to register a reactive dependency Sometimes you want to reference a reactive atom or rx from within an rx without registering it as a dependency! Or maybe you want to make sure that in library code, no surrounding rx is calling your function. The non-reactively macro (in freactive.macros) will take care of this:  ;; a is registered as a dependency, but b isn't! (rx (+ @a (non-reactively @b))) Contributions Contributions (including pull requests) are welcome! TODO list If you would like to contribute, here is a list of things that would help get this library to a mature state. The list is organized by category and relative priority. Each item has a link to an issue which you can comment on, assign to yourself possibly, etc. Core functionality: Good polyfills for things like requestAnimationFrame, addEventListener, etc. to support older browsers where feasible Benchmarking of event handlers - do we need to do something like React's synthentic events? Items view: Efficient algorithms for applying stable (possible in place) sorting to the items-view Animations: A stable (possibly 3rd party) easings library. I incorporated some easings from ominate - it has some open bug reports - maybe those can be fixed and the easings part can be forked so that it's shared. There's also tween-clj. More examples and testing on different platforms is always welcome. Comments, suggestions and questions can be posted here: https://github.com/aaronc/freactive/issues License Distributed under the Eclipse Public License, either version 1.0 or (at your option) any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/aaronc/freactive"	"– A high-performance, pure Clojurescript, declarative DOM library inspired by reagent, om, reflex and hiccup."	"true"
"Document Object Model"	"Hiccups"	"https://github.com/teropa/hiccups"	"– A ClojureScript port of the Hiccup."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"130"	"12"	"14"	"GitHub - teropa/hiccups: A ClojureScript port of Hiccup - a fast library for rendering HTML in ClojureScript Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 12 Star 130 Fork 14 teropa/hiccups Code Issues 1 Pull requests 1 Pulse Graphs A ClojureScript port of Hiccup - a fast library for rendering HTML in ClojureScript 34 commits 1 branch 1 release Fetching contributors Clojure 98.7% HTML 1.3% Clojure HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v0.3.0 Nothing to show New pull request Latest commit feabd15 Sep 15, 2015 teropa Merge pull request #11 from whamtet/master … added new features from hiccup Permalink Failed to load latest commit information. dev-resources update from cljs-start lein-template Nov 24, 2013 src added new features from hiccup Sep 15, 2015 test/cljs/hiccups update from cljs-start lein-template Nov 24, 2013 .gitignore update from cljs-start lein-template Nov 24, 2013 LICENSE.html readme and license Aug 7, 2011 README.md Unobscure 'html' form in README.md Jul 30, 2015 profiles.clj update from cljs-start lein-template Nov 24, 2013 project.clj Reflect 0.3.0 in README and move project.clj to the next snapshot Dec 21, 2013 README.md Hiccups Hiccups is a ClojureScript port of the Hiccup HTML generation library. It uses vectors to represent tags, and maps to represent a tag's attributes. The goal is to provide similar performance to Closure Templates with a much more Clojure friendly syntax. Differences from Hiccup In ClojureScript, macros need to be defined in separate Clojure namespaces. Because of this, core functionality is split into two files: core.clj contains the macros and compile-time only functions, and runtime.cljs contains functions that are also available at runtime. The contents of runtime.cljs are also used at compile-time, so the goal is to keep it portable between ClojureScript and Clojure. Unit tests are run in a PhantomJS browser using lein-cljsbuild and Closure's testing libs. Not everything has been ported yet. See ToDo. Alternatives Crate is an alternative Hiccup style library for ClojureScript. The main difference between Crate and Hiccups is that Crate generates DOM nodes and Hiccups generates strings. There are a few reasons why you might consider Hiccups over Crate (YMMV, of course): As with the original Hiccup, Hiccups tries to do as much as possible at compile time, with macro expansion. Working with strings can be much more performant than working with DOM nodes, especially with large amounts of markup, and especially with older browsers. Easier to use in headless environments like Node.js Closure Templates is Google's Closure templating library. Install Add the following dependency to your project.clj file: [hiccups ""0.3.0""] Usage Require both the core macros and the runtime functions in your namespace declaration: (ns myns   (:require-macros [hiccups.core :as hiccups :refer [html]])   (:require [hiccups.runtime :as hiccupsrt]))  (hiccups/defhtml my-template []   [:div     [:a {:href ""https://github.com/weavejester/hiccup""}       ""Hiccup""]]) Syntax Here is a basic example of Hiccups syntax: (html [:span {:class ""foo""} ""bar""]) ""<span class=\""foo\"">bar</span>"" The first element of the vector is used as the tag name. The second attribute can optionally be a map, in which case it is used to supply the tag's attributes. Every other element is considered part of the tag's body. Hiccups is intelligent enough to render different HTML tags in different ways, in order to accommodate browser quirks: (html [:script]) ""<script></script>"" (html [:p]) ""<p />"" And provides a CSS-like shortcut for denoting id and class attributes: (html [:div#foo.bar.baz ""bang""]) ""<div id=\""foo\"" class=\""bar baz\"">bang</div>"" If the body of the tag is a seq, its contents will be expanded out into the tag body. This makes working with forms like map and for more convenient: (html [:ul         (for [x (range 1 4)]           [:li x])]) ""<ul><li>1</li><li>2</li><li>3</li></ul>"" See the Hiccup wiki for more information. ToDo Catch up with recent changes in Hiccup. Form helpers Page helpers Figure out if the runtime can be pulled in without an explicit require by the user Explore potential performance improvements using Google's StringBuffer et al. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/teropa/hiccups"	"– A ClojureScript port of the Hiccup."	"true"
"Document Object Model"	"Hickory"	"https://github.com/davidsantiago/hickory"	"– It parses HTML into Clojure data structures, so you can analyze, transform, and output back to HTML."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"225"	"10"	"14"	"GitHub - davidsantiago/hickory: HTML as data Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 10 Star 225 Fork 14 davidsantiago/hickory Code Issues 9 Pull requests 5 Pulse Graphs HTML as data 166 commits 3 branches 16 releases 3 contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags develop gh-pages master Nothing to show ie9docfix dsl-expermient 0.6.0 0.5.4 0.5.3 0.5.2 0.5.1 0.5.0 0.4.1 0.4.0 0.3.0 0.2.3 0.2.2 0.2.1 0.2.0 0.1.0 Nothing to show New pull request Latest commit 0c0dc1e Jan 4, 2016 davidsantiago Merge branch 'release/0.6.0' Permalink Failed to load latest commit information. src/hickory Do not define invalid typehints for ClojureScript as they are now rec… Jan 27, 2014 test/hickory/test Update jsoup to version 1.8.3 and udpate tests to match Jan 4, 2016 .gitignore Add codox support for doc generation. May 21, 2013 LICENSE Add EPL license in LICENSE file. Jul 30, 2013 README.md Updated README for 0.6.0 Jan 4, 2016 project.clj Merge branch 'release/0.6.0' Jan 4, 2016 README.md Hickory Hickory parses HTML into Clojure data structures, so you can analyze, transform, and output back to HTML. HTML can be parsed into hiccup vectors, or into a map-based DOM-like format very similar to that used by clojure.xml. It can be used from both Clojure and Clojurescript. There is API documentation available. Usage Parsing To start, you will want to process your HTML into a parsed representation. Once the HTML is in this form, it can be converted to either Hiccup or Hickory format for further processing. There are two parsing functions, parse and parse-fragment. Both take a string containing HTML and return the parser objects representing the document. (It happens that these parser objects are Jsoup Documents and Nodes, but I do not consider this to be an aspect worth preserving if a change in parser should become necessary). The first function, parse expects an entire HTML document, and parses it using an HTML5 parser (Jsoup on Clojure and the browser's DOM parser in Clojurescript), which will fix up the HTML as much as it can into a well-formed document. The second function, parse-fragment, expects some smaller fragment of HTML that does not make up a full document, and thus returns a list of parsed fragments, each of which must be processed individually into Hiccup or Hickory format. For example, if parse-fragment is given ""<p><br>"" as input, it has no common parent for them, so it must simply give you the list of nodes that it parsed. These parsed objects can be turned into either Hiccup vector trees or Hickory DOM maps using the functions as-hiccup or as-hickory. Here's a usage example. user=> (use 'hickory.core) nil user=> (def parsed-doc (parse ""<a href=\""foo\"">foo</a>"")) #'user/parsed-doc user=> (as-hiccup parsed-doc) ([:html {} [:head {}] [:body {} [:a {:href ""foo""} ""foo""]]]) user=> (as-hickory parsed-doc) {:type :document, :content [{:type :element, :attrs nil, :tag :html, :content [{:type :element, :attrs nil, :tag :head, :content nil} {:type :element, :attrs nil, :tag :body, :content [{:type :element, :attrs {:href ""foo""}, :tag :a, :content [""foo""]}]}]}]} user=> (def parsed-frag (parse-fragment ""<a href=\""foo\"">foo</a> <a href=\""bar\"">bar</a>"")) #'user/parsed-frag user=> (as-hiccup parsed-frag) IllegalArgumentException No implementation of method: :as-hiccup of protocol: #'hickory.core/HiccupRepresentable found for class: clojure.lang.PersistentVector  clojure.core/-cache-protocol-fn (core_deftype.clj:495)  user=> (map as-hiccup parsed-frag) ([:a {:href ""foo""} ""foo""] "" "" [:a {:href ""bar""} ""bar""]) user=> (map as-hickory parsed-frag) ({:type :element, :attrs {:href ""foo""}, :tag :a, :content [""foo""]} "" "" {:type :element, :attrs {:href ""bar""}, :tag :a, :content [""bar""]}) In the example above, you can see an HTML document that is parsed once and then converted to both Hiccup and Hickory formats. Similarly, a fragment is parsed, but it cannot be directly used with as-hiccup (or as-hickory), it must have those functions called on each element in the list instead. The namespace hickory.zip provides zippers for both Hiccup and Hickory formatted data, with the functions hiccup-zip and hickory-zip. Using zippers, you can easily traverse the trees in any order you desire, make edits, and get the resulting tree back. Here is an example of that. user=> (use 'hickory.zip) nil user=> (require '[clojure.zip :as zip]) nil user=> (-> (hiccup-zip (as-hiccup (parse ""<a href=foo>bar<br></a>""))) zip/node) ([:html {} [:head {}] [:body {} [:a {:href ""foo""} ""bar"" [:br {}]]]]) user=> (-> (hiccup-zip (as-hiccup (parse ""<a href=foo>bar<br></a>""))) zip/next zip/node) [:html {} [:head {}] [:body {} [:a {:href ""foo""} ""bar"" [:br {}]]]] user=> (-> (hiccup-zip (as-hiccup (parse ""<a href=foo>bar<br></a>""))) zip/next zip/next zip/node) [:head {}] user=> (-> (hiccup-zip (as-hiccup (parse ""<a href=foo>bar<br></a>"")))            zip/next zip/next            (zip/replace [:head {:id ""a""}])            zip/node) [:head {:id ""a""}] user=> (-> (hiccup-zip (as-hiccup (parse ""<a href=foo>bar<br></a>"")))            zip/next zip/next            (zip/replace [:head {:id ""a""}])            zip/root) ([:html {} [:head {:id ""a""}] [:body {} [:a {:href ""foo""} ""bar"" [:br {}]]]]) user=> (-> (hickory-zip (as-hickory (parse ""<a href=foo>bar<br></a>"")))            zip/next zip/next            (zip/replace {:type :element :tag :head :attrs {:id ""a""} :content nil})            zip/root) {:type :document, :content [{:type :element, :attrs nil, :tag :html, :content [{:content nil, :type :element, :attrs {:id ""a""}, :tag :head} {:type :element, :attrs nil, :tag :body, :content [{:type :element, :attrs {:href ""foo""}, :tag :a, :content [""bar"" {:type :element, :attrs nil, :tag :br, :content nil}]}]}]}]} user=> (hickory-to-html *1) ""<html><head id=\""a\""></head><body><a href=\""foo\"">bar<br></a></body></html>"" In this example, we can see a basic document being parsed into Hiccup form. Then, using zippers, the HEAD element is navigated to, and then replaced with one that has an id of ""a"". The final tree, including the modification, is also shown using zip/root. Then the same modification is made using Hickory forms and zippers. Finally, the modified Hickory version is printed back to HTML using the hickory-to-html function. Selectors Hickory also comes with a set of CSS-style selectors that operate on hickory-format data in the hickory.select namespace. These selectors do not exactly mirror the selectors in CSS, and are often more powerful. There is no version of these selectors for hiccup-format data, at this point. A selector is simply a function that takes a zipper loc from a hickory html tree data structure as its only argument. The selector will return its argument if the selector applies to it, and nil otherwise. Writing useful selectors can often be involved, so most of the hickory.select package is actually made up of selector combinators; functions that return useful selector functions by specializing them to the data given as arguments, or by combining together multiple selectors. For example, if we wanted to figure out the dates of the next Formula 1 race weekend, we could do something like this: user=> (use 'hickory.core) nil user=> (require '[hickory.select :as s]) nil user=> (require '[clj-http.client :as client]) nil user=> (require '[clojure.string :as string]) nil user=> (def site-htree (-> (client/get ""http://formula1.com/default.html"") :body parse as-hickory)) #'user/site-htree user=> (-> (s/select (s/child (s/class ""subCalender"") ; sic                               (s/tag :div)                               (s/id :raceDates)                               s/first-child                               (s/tag :b))                      site-htree)            first :content first string/trim) ""10, 11, 12 May 2013"" In this example, we get the contents of the homepage and use select to give us any nodes that satisfy the criteria laid out by the selectors. The selector in this example is overly precise in order to illustrate more selectors than we need; we could have gotten by just selecting the contents of the P and then B tags inside the element with id ""raceDates"". Using the selectors allows you to search large HTML documents for nodes of interest with a relatively small amount of code. There are many selectors available in the hickory.select namespace, including: node-type: Give this function a keyword or string that names the contents of the :type field in a hickory node, and it gives you a selector that will select nodes of that type. Example: (node-type :comment) tag: Give this function a keyword or string that names the contents of the :tag field in a hickory node, and it gives you a selector that will select nodes with that tag. Example: (tag :div) attr: Give this function a keyword or string that names an attribute in the :attrs map of a hickory node, and it gives you a selector that will select nodes whose :attrs map contains that key. Give a single-argument function as an additional argument, and the resulting selector function will additionally require the value of that key to be such that the function given as the last argument returns true. Example: (attr :id #(.startsWith % ""foo"")) id: Give this function a keyword or string that names the :id attribute in the :attrs map and it will return a selector function that selects nodes that have that id (this comparison is case-insensitive). Example: (id :raceDates) class: Give this function a keyword or string that names a class that the node should have in the :class attribute in the :attrs map, and it will return a function that selects nodes that have the given class somewhere in their class string. Example: (class :foo) any: This selector takes no arguments, do not invoke it; returns any node that is an element, similarly to CSS's '*' selector. element: This selector is equivalent to the any selector; this alternate name can make it clearer when the intention is to exclude non-element nodes from consideration. root: This selector takes no arguments and should not be invoked; simply returns the root node (the HTML element). n-moves-until: This selector returns a selector function that selects its argument if that argument is some distance from a boundary. The first two arguments, n and c define the counting: it only selects nodes whose distance can be written in the form nk+c for some natural number k. The distance and boundary are defined by the number of times the zipper-movement function in the third argument is applied before the boundary function in the last argument is true. See doc string for details. nth-of-type: This selector returns a selector function that selects its argument if that argument is the (nk+c)'th child of the given tag type of some parent node for some natural k. Optionally, instead of the n and c arguments, the keywords :odd and :even can be given. nth-last-of-type: Just like nth-of-type but counts backwards from the last sibling. nth-child: This selector returns a selector function that selects its argument if that argument is the (nk+c)'th child of its parent node for some natural k. Instead of the n and c arguments, the keywords :odd and :even can be given. nth-last-child: Just like nth-last-child but counts backwards from the last sibling. first-child: Takes no arguments, do not invoke it; equivalent to (nth-child 1). last-child: Takes no arguments, do not invoke it; equivalent to (nth-last-child 1). There are also selector combinators, which take as argument some number of other selectors, and return a new selector that combines them into one larger selector. An example of this is the child selector in the example above. Here's a list of some selector combinators in the package (see the API Documentation for the full list): and: Takes any number of selectors, and returns a selector that only selects nodes for which all of the argument selectors are true. or: Takes any number of selectors, and retrurns a selector that only selects nodes for which at least one of the argument selectors are true. not: Takes a single selector as argument and returns a selector that only selects nodes that its argument selector does not. el-not: Takes a single selector as argument and returns a selector that only selects element nodes that its argument selector does not. child: Takes any number of selectors as arguments and returns a selector that returns true when the zipper location given as the argument is at the end of a chain of direct child relationships specified by the selectors given as arguments. descendant: Takes any number of selectors as arguments and returns a selector that returns true when the zipper location given as the argument is at the end of a chain of descendant relationships specified by the selectors given as arguments. We can illustrate the selector combinators by continuing the Formula 1 example above. We suspect, to our dismay, that Sebastian Vettel is leading the championship for the fourth year in a row. user=> (-> (s/select (s/descendant (s/class ""subModule"")                                    (s/class ""standings"")                                    (s/and (s/tag :tr)                                           s/first-child)                                    (s/and (s/tag :td)                                           (s/nth-child 2))                                    (s/tag :a))                      site-htree)            first :content first string/trim) ""Sebastian Vettel""           Our fears are confirmed, Sebastian Vettel is well on his way to a fourth consecutive championship. If you were to inspect the page by hand (as of around May 2013, at least), you would see that unlike the child selector we used in the example above, the descendant selector allows the argument selectors to skip stages in the tree; we've left out some elements in this descendant relationship. The first table row in the driver standings table is selected with the and, tag and first-child selectors, and then the second td element is chosen, which is the element that has the driver's name (the first table element has the driver's standing) inside an A element. All of this is dependent on the exact layout of the HTML in the site we are examining, of course, but it should give an idea of how you can combine selectors to reach into a specific node of an HTML document very easily. Finally, it's worth noting that the select function itself returns the hickory zipper nodes it finds. This is most useful for analyzing the contents of nodes. However, sometimes you may wish to examine the area around a node once you've found it. For this, you can use the select-locs function, which returns a sequence of hickory zipper locs, instead of the nodes themselves. This will allow you to navigate around the document tree using the zipper functions in clojure.zip. If you wish to go further and actually modify the document tree using zipper functions, you should not use select-locs. The problem is that it returns a bunch of zipper locs, but once you modify one, the others are out of date and do not see the changes (just as with any other persistent data structure in Clojure). Thus, their presence was useless and possibly confusing. Instead, you should use the select-next-loc function to walk through the document tree manually, moving through the locs that satisfy the selector function one by one, which will allow you to make modifications as you go. As with modifying any data structure as you traverse it, you must still be careful that your code does not add the thing it is selecting for, or it could get caught in an infinite loop. Finally, for more specialized selection needs, it should be possible to write custom selection functions that use the selectors and zipper functions without too much work. The functions discussed in this paragraph are very short and simple, you can use them as a guide. The doc strings for the functions in the hickory.select namespace provide more details on most of these functions. For more details, see the API Documentation. Hickory format Why two formats? It's very easy to see in the example above, Hiccup is very convenient to use for writing HTML. It has a compact syntax, with CSS-like shortcuts for specifying classes and ids. It also allows parts of the vector to be skipped if they are not important. It's a little bit harder to process data in Hiccup format. First of all, each form has to be checked for the presence of the attribute map, and the traversal adjusted accordingly. Raw Hiccup vectors might also have information about class and id in one of two different places. Finally, not every piece of an HTML document can be expressed in Hiccup without resorting to writing HTML in strings. For example, if you want to put a doctype or comment on your document, it has to be done as a string in your Hiccup form containing ""<!DOCTYPE html>"" or ""<!--stuff-->"". The Hickory format is another data format intended to allow a roundtrip from HTML as text, into a data structure that is easy to process and modify, and back into equivalent (but not identical, in general) HTML. Because it can express all parts of an HTML document in a parsed form, it is easier to search and modify the structure of the document. A Hickory node is either a map or a string. If it is a map, it will have some subset of the following four keys, depending on the :type: :type - This will be one of :comment, :document, :document-type, :element :tag - A node's tag (for example, :img). This will only be present for nodes of type :element. :attrs - A node's attributes, as a map of keywords to values (for example, {:href ""/a""}). This will only be present for nodes of type :element. :content - A node's child nodes, in a vector. Only :comment, :document, and :element nodes have children. Text and CDATA nodes are represented as strings. This is almost the exact same structure used by clojure.xml, the only difference being the addition of the :type field. Having this field allows us to process nodes that clojure.xml leaves out of the parsed data, like doctype and comments. Obtaining To get hickory, add [hickory ""0.6.0""] to your project.clj, or an equivalent entry for your Maven-compatible build tool. ClojureScript support Hickory expects a DOM implementation and thus won't work out of the box on node. On browsers it works for IE9+ (you can find a workaround for IE9 here). Changes Released version 0.6.0. Updated JSoup to version 1.8.3. This version of JSoup contains bug fixes, but slightly changes the way it handles HTML: some parses and output might have different case than before. HTML is still case-insensitive, of course, but Hickory minor version has been increased just in case. API and semantics are otherwise unchanged. Released version 0.5.4. Fixed project dependencies so ClojureScript is moved to a dev-dependency. Released version 0.5.3. Minor bug fix to accommodate ClojureScript's new type hinting support. Released version 0.5.2. Updates the Clojurescript version to use the latest version of Clojurescript (0.0-1934). Released version 0.5.1. Added has-child and has-descendant selectors. Be careful with has-descendant, as it must do a full subtree search on each node, which is not fast. Released version 0.5.0. Now works in Clojurescript as well, huge thanks to Julien Eluard for doing the heavy lifting on this. Reorganized parts of the API into more granular namespaces for better organization. Added functions to convert between Hiccup and Hickory format; note that this conversion is not always exact or roundtripable, and can cause a full HTML reparse. Added new selector, element-child, which selects element nodes that are the child of another element node. Numerous bug fixes and improvements. Released version 0.4.1, which adds a number of new selectors and selector combinators, including find-in-text, precede-adjacent, follow-adjacent, precede and follow. Released version 0.4.0. Adds the hickory.select namespace with many helpful functions for searching through hickory-format HTML documents for specific nodes. Released version 0.3.0. Provides a more helpful error message when hickory-to-html has an error. Now requires Clojure 1.4. Released version 0.2.3. Fixes a bug where hickory-to-html was not html-escaping the values of tag attributes. Released version 0.2.2. Fixes a bug where hickory-to-html was improperly html-escaping the contents of script/style tags. Released version 0.2.1. This version fixes bugs: hickory-to-html now properly escapes text nodes text nodes will now preserve whitespace correctly Released version 0.2.0. This version adds a second parsed data format, explained above. To support this, the API for parse and parse-fragment has been changed to allow their return values to be passed to functions as-hiccup or as-hickory to determine the final format. Also added are zippers for both Hiccup and Hickory formats. License Copyright © 2012 David Santiago Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/davidsantiago/hickory"	"– It parses HTML into Clojure data structures, so you can analyze, transform, and output back to HTML."	"true"
"Document Object Model"	"json-html"	"https://github.com/yogthos/json-html"	"– Provide JSON and get a DOM node with a human representation of that JSON."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"69"	"4"	"12"	"GitHub - yogthos/json-html: Provide JSON and get a DOM node with a human representation of that JSON. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 4 Star 69 Fork 12 yogthos/json-html Code Issues 2 Pull requests 0 Pulse Graphs Provide JSON and get a DOM node with a human representation of that JSON. 72 commits 1 branch 0 releases 5 contributors Clojure 90.8% CSS 9.2% Clojure CSS Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit c031315 May 22, 2016 yogthos bumped up lein-cljsbuild Permalink Failed to load latest commit information. resources improved rendering for empty collections Mar 24, 2014 src-cljs/json_html added rendering for symbols Mar 17, 2016 src/json_html added rendering for symbols Mar 17, 2016 test/json_html fixed tests Jul 20, 2015 .gitignore Initial commit Mar 19, 2014 LICENSE Initial commit Mar 20, 2014 README.md Update README.md Apr 4, 2015 project.clj bumped up lein-cljsbuild May 22, 2016 README.md json-html Generates a DOM node with a human representation of the JSON/EDN encoded data. Based on the json.human.js library. Installation The library provides support for Clojure/Script. Leiningen Usage (use 'json-html.core)  (edn->html {:foo [1 2 3] :bar ""baz""}) bar baz foo 0 1 1 2 2 3 (json->html ""{\""foo\"": [1, 2, 3], \""bar\"": \""baz\""}"") bar baz foo 0 1 1 2 2 3 The ClojureScript version has additional functions called edn->hiccup and json->hiccup, these can be used to generate Hiccup forms for use with other libraries such as Reagent. A default CSS is provided in resources/json.human.css and can be included as follows: (ns foo   (:use json-html.core hiccup.page))  (spit ""formatted.html""      (html5       [:head [:style (-> ""json.human.css"" clojure.java.io/resource slurp)]]       (edn->html [:foo ""bar"" :baz [1 2 3]]))) Example: Input JSON: {   ""name"": ""json.human"",   ""description"": ""Convert\n JSON to human readable\r HTML"",   ""author"": ""Mariano Guerra <mariano@marianoguerra.org>"",   ""tags"": [""DOM"", ""HTML"", ""JSON"", ""Pretty Print""],   ""version"": ""0.1.0"",   ""main"": ""json.human.js"",   ""license"" : ""MIT"",   ""dependencies"": {       ""crel"": ""1.0.0""   },   ""repository"": {     ""type"": ""git"",     ""url"": ""git://github.com/marianoguerra/json.human.js.git""   },   ""bugs"": {     ""url"": ""https://github.com/yogthos/json-html/issues""   },   ""contributors"": [],   ""config"": {     ""what?"": ""this object is just to show some extra stuff"",     ""how?"": [""add json.human.js"", ""add json.human.css"", ""???"", ""profit!""],     ""customization?"": [""customize the css prefix"", ""change the css file""],     ""integer"": 42,     ""float"": 12.3,     ""bool"": true,     ""emptyString"": """",     ""emptyArray"": [],     ""emptyObject"": {},     ""htmlEntities"": ""   <- trailing <em>   & </em> and some html   ""   } } Output HTML author Mariano Guerra <mariano@marianoguerra.org> bugs url http://github.com/marianoguerra/json.human.js/issues config bool true customization? 0 customize the css prefix 1 change the css file emptyArray emptyObject emptyString float 12.3 how? 0 add json.human.js 1 add json.human.css 2 ??? 3 profit! htmlEntities <- trailing <em> & </em> and some html integer 42 what? this object is just to show some extra stuff contributors dependencies crel 1.0.0 description Convert JSON to human readable HTML license MIT main json.human.js name json.human repository type git url git://github.com/marianoguerra/json.human.js.git tags 0 DOM 1 HTML 2 JSON 3 Pretty Print version 0.1.0 License MIT Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/yogthos/json-html"	"– Provide JSON and get a DOM node with a human representation of that JSON."	"true"
"Document Object Model"	"Kioo"	"https://github.com/ckirkendall/kioo"	"DOM manipulation and templating library for Facebook's React and Om in ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"359"	"24"	"37"	"GitHub - ckirkendall/kioo: Enlive/Enfocus  style templating for Facebook's React and Om in ClojureScript. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 24 Star 359 Fork 37 ckirkendall/kioo Code Issues 9 Pull requests 1 Pulse Graphs Enlive/Enfocus style templating for Facebook's React and Om in ClojureScript. 187 commits 1 branch 3 releases Fetching contributors Clojure 97.8% HTML 2.2% Clojure HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v0.4.2 v0.4.1 Version-0.1.0 Nothing to show New pull request Latest commit e903828 Jul 3, 2016 ckirkendall hyphenated style attributes are now handled correctly Permalink Failed to load latest commit information. doc initial commit - still very experimental Jan 12, 2014 example #58 - fixed issue with lifecycle not handling shouldupdate correctly Aug 29, 2015 src/kioo hyphenated style attributes are now handled correctly Jul 3, 2016 test-resources hyphenated style attributes are now handled correctly Jul 3, 2016 test/kioo hyphenated style attributes are now handled correctly Jul 3, 2016 .gitignore fixing server side tests Feb 28, 2016 LICENSE initial commit - still very experimental Jan 12, 2014 README.md updated readme Feb 28, 2016 project.clj hyphenated style attributes are now handled correctly Jul 3, 2016 README.md kioo Kioo brings Enlive/Enfocus style templates to React. This allows for much better separation between the view and logic layers of the application. This project is very early on in development and the API is expected to change as development progresses. What does kioo mean? Kioo is Swahili for mirror. Facebook's React library is built around the idea that the view is a reflection of your application state. Artifact All artifacts are published to clojars. Latest stable version is 0.4.0: [kioo ""0.4.2""] ;stable  [kioo ""0.5.0-SNAPSHOT""] ;risky clojure 1.7.0 required  Concepts component is a unit of your page such as header, footer, page element. A kioo component is logically the same as a Facebook's React.js component. What makes kioo components different from React's is they take raw html from the class path and compile it into React.js nodes. This allows you to define the structure of your page as standard html. React.js provides something similar with JSX but it still mixes the content and the logic. Kioo takes a different aproach by allowing you to bring in static content and transform it with selectors in a manner similar to Enlive/Enfocus templates. The biggest difference you will see between Enlive and Kioo is that Kioo only supports unordered transforms. This means that you pass a map of transforms to the component and you can not guarantee what order they will be processed in. This is due to, selection being done at compile time and transforms being done at runtime. Selections cannot take the structure of the content at runtime into consideration. Templates and Snippets A snippet is a function that returns a kioo component, it can be used as a building block for more complex templates, snippets and components. You define a snippet by providing a remote resource, a selector and series of transformations. The snippet definition below selects a table body from the remote resource templates/template1.html and grabs the first row. It then fills the content of the row. (defsnippet snippet2 ""templates/template1.html"" [:tbody :> first-child]   [fruit quantity]   {[:tr :> first-child] (content fruit)    [:tr :> last-child] (content (str quantity))}) A template is very similar to a snippet except it does not require a selector to grap a sub section, instead the entire remote resource is used as the dom. If the remote resource is a full html document only what is inside the body tag is brought into the template. (deftemplate template2 ""/templates/template1.html""    [fruit-data]   {[:#heading1] (content ""fruit"")    [:thead :tr :> last-child] (content ""quantity"")    [:tbody] (content               (map #(snippit2 % (fruit-data %)) (keys fruit-data)))}) Troubleshooting The best way to troubleshoot the processing of Kioo templates and snippets and the matching of selectors is to use Clojure's macroexpand-1 together with clojure.tools.trace/trace-ns applied to 'kioo.core to see the resulting ClojureScript and log of what happened during the processing. You can also call manually the resulting JavaScript function <your ns>.<snippet/template name> and examine the React component it produces. Read more and additional tips in the post Kioo: How to Troubleshoot Template Processing by Jakub Holy. Quickstart tutorial Working With Om Let's take a look at and example. Here we work with David Nolen's om. <!DOCTYPE html> <html lang=""en"">   <body>     <header>       <h1>Header placeholder</h1>       <ul id=""navigation"">         <li class=""nav-item""><a href=""#"">Placeholder</a></li>       </ul>     </header>     <div class=""content"">place holder</div>   </body> </html> (ns kioo-example.core   (:require [kioo.om :refer [content set-attr do-> substitute listen]]             [kioo.core :refer [handle-wrapper]]             [om.core :as om :include-macros true]             [om.dom :as dom :include-macros true])   (:require-macros [kioo.om :refer [defsnippet deftemplate]]))   (defsnippet my-nav-item ""main.html"" [:.nav-item]   [[caption func]]   {[:a] (do-> (content caption)               (listen :onClick #(func caption)))})  (defsnippet my-header ""main.html"" [:header]   [{:keys [heading navigation]}]   {[:h1] (content heading)    [:ul] (content (map my-nav-item navigation))})   (deftemplate my-page ""main.html""   [data]   {[:header] (substitute (my-header data))    [:.content] (content (:content data))})  (defn init [data] (om/component (my-page data)))  (def app-state (atom {:heading ""main""                       :content    ""Hello World""                       :navigation [[""home"" #(js/alert %)]                                    [""next"" #(js/alert %)]]}))  (om/root init app-state {:target  (.-body js/document)}) To view the example: $ git clone https://github.com/ckirkendall/kioo.git $ cd kioo/example/om $ lein cljsbuild once Once the javascript compiles you can open index.html in a browser. For a more fleshed-out example, please see the Kioo implementation of TodoMVC exists here. Working With Reagent Here we work with Dan Holmsand's Reagent. <!DOCTYPE html> <html lang=""en"">   <body>     <header>       <h1>Header placeholder</h1>       <ul id=""navigation"">         <li class=""nav-item""><a href=""#"">Placeholder</a></li>       </ul>     </header>     <div class=""content"">place holder</div>   </body> </html> (ns kioo-example.core   (:require [kioo.reagent :refer [content set-attr do-> substitute listen]]             [reagent.core :as reagent :refer [atom]])   (:require-macros [kioo.reagent :refer [defsnippet deftemplate]]))  (declare data nav)   (defsnippet my-nav-item ""main.html"" [:.nav-item]   [[caption func]]   {[:a] (do-> (content caption)               (listen :on-click func))})   (defsnippet my-header ""main.html"" [:header] []   {[:h1] (content (:header @data))    [:ul] (content (map my-nav-item (:navigation @nav)))})   (deftemplate my-page ""main.html"" []   {[:header] (substitute [my-header])       [:.content] (content (:content @data))})   (def data (atom {:header ""main""                  :content ""Hello World""}))  (def nav (atom {:navigation [[""home"" #(swap! data                                              assoc :content ""home"")]                              [""next"" #(swap! data                                              assoc :content ""next"")]]}))  (reagent/render-component [my-page] (.-body js/document))  To view the example: $ git clone https://github.com/ckirkendall/kioo.git $ cd kioo/example/reagent $ lein cljsbuild once Once the javascript compiles you can open index.html in a browser. Selector Syntax Kioo uses enlive based selectors. See syntax.html Some examples: Enlive                                       CSS ======================================================= [:div]                                       div [:body :script]                              body script #{[:ul.outline :> :li] [:ol.outline :> li]}  ul.outline > li, ol.outline > li [#{:ul.outline :ol.outline} :> :li]          ul.outline > li, ol.outline > li [[#{:ul :ol} :.outline] :> :li]              ul.outline > li, ol.outline > li [:div :> :*]                                 div > * [:div :> text-node]                          (text children of a div) [:div :> any-node]                           (all children (including text nodes and comments) of a div) {[:dt] [:dl]}                                (fragments starting by DT and ending at the *next* DD)  Notice that some of the predefined selector steps are used as naked symbols, i.e. you can just use them (no require :refer etc.). Example: (defsnippet shop-html ""templates/shops.html"" [[:.shop first-of-type]]   [_] ;;                                                 ^- a naked symbol   {[:.content] (content ""Kioo is mighty!"")}) Transformations A transformation is a function that returns either a react node or collection of react nodes. Kioo transforms mirror most of the base enlive transformations: New Transforms ;; attached event listeners to the component (listen :on-click (fn [...] ...))  ;;supported react events :on-mount :on-render :on-update  ;;all standard dom events are supported  Enlive Based Transforms ;; Replaces the content of the element. Values can be nodes or collection of nodes. (content ""xyz"" a-node ""abc"")   ;; Replaces the content of the element with the html provided. (html-content ""<h1>this is html text</h1>"")  ;; Wraps selected node into the given tag (wrap :div) ;; or (wrap :div {:class ""foo""})  ;; Opposite to wrap, returns the content of the selected node unwrap  ;; Sets given key value pairs as attributes for selected node (set-attr :attr1 ""val1"" :attr2 ""val2"")  ;; Removes attribute(s) from selected node (remove-attr :attr1 :attr2)  ;; Sets class attr of the selected node (set-class ""foo bar"")  ;; Adds class(es) on the selected node (add-class ""foo"" ""bar"")  ;; Removes class(es) from the selected node (remove-class ""foo"" ""bar"")  ;; Set styles on to the selected node (set-style :display ""none"" :backgroud-color ""#cfcfcf"")  ;; Removes styles from the selected node (remove-style :display :background-color)  ;; Chains (composes) several transformations. Applies functions from left to right. (do-> transformation1 transformation2)  ;; Appends the values to the content of the selected element. (append ""xyz"" a-node ""abc"")  ;; Prepends the values to the content of the selected element. (prepend ""xyz"" a-node ""abc"")  ;; Inserts the values after the current selection (node or fragment). (after ""xyz"" a-node ""abc"")  ;; Inserts the values before the current selection (node or fragment). (before ""xyz"" a-node ""abc"")  ;; Replaces the current selection (node or fragment). (substitute ""xyz"" a-node ""abc"")   Not supported yet ;; Clones the selected node, applying transformations to it. (clone-for [item items] transformation) (;; or (clone-for [item items]   selector1 transformation1   selector2 transformation2)  ;;;; Takes all nodes (under the current element) matched by src-selector, removes ;; them and combines them with the elements matched by dest-selector. (move) Thanks This library is based on Christophe Grand's enlive library. License Copyright © 2014 Creighton Kirkendall Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/ckirkendall/kioo"	"DOM manipulation and templating library for Facebook's React and Om in ClojureScript."	"true"
"Document Object Model"	"Sablono"	"https://github.com/r0man/sablono"	"– Lisp/Hiccup style templating for Facebook's React in ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"482"	"28"	"39"	"GitHub - r0man/sablono: Lisp/Hiccup style templating for Facebook's React in ClojureScript. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 28 Star 482 Fork 39 r0man/sablono Code Issues 6 Pull requests 2 Wiki Pulse Graphs Lisp/Hiccup style templating for Facebook's React in ClojureScript. 445 commits 7 branches 25 releases 15 contributors Clojure 99.6% Other 0.4% Clojure Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags compile-attributes master mock-console-error parser react-0.13 switch-travis-infrastructure travis-container Nothing to show 0.7.2 0.7.1 0.7.0 0.6.3 0.6.2 0.6.1 0.6.0 0.5.4 0.5.3 0.5.2 0.5.1 0.5.0 0.4.0 0.3.6 0.3.5 0.3.4 0.3.3 0.3.2 0.3.1 0.3.0 0.2.22 0.2.21 0.2.20 0.2.19 0.2.18 Nothing to show New pull request Latest commit 565c62c Jul 15, 2016 r0man committed on GitHub Update dependencies (#126) Permalink Failed to load latest commit information. dev Add devcards Dec 17, 2015 src/sablono Fix wrapped elements, type is string, not a keyword (#124) Jul 8, 2016 test-resources Merge pull request #87 from r0man/hickory-externs Dec 17, 2015 test/sablono Fix wrapped elements, type is string, not a keyword (#124) Jul 8, 2016 .dir-locals.el Add .dir-locals.el Mar 23, 2016 .gitignore Ignore .cljs_node_repl Mar 23, 2016 .travis.yml Add normalize-element benchmark Dec 11, 2015 CHANGELOG.org Update changelog for 0.7.2 May 31, 2016 LICENSE Initial import. Dec 21, 2013 README.org Update dependencies (#126) Jul 15, 2016 project.clj Update dependencies (#126) Jul 15, 2016 README.org ŜABLONO Lisp/Hiccup style templating for Facebook’s React in ClojureScript. Dependencies Ŝablono doesn’t declare a dependency on React anymore. Use the React dependencies from one of the ClojureScript wrappers or provide the dependencies yourself like this: [cljsjs/react ""15.2.1-0""] [cljsjs/react-dom ""15.2.1-0""] If you want to do server rendering and use the render or render-static functions from the sablono.server namespace you need to add the following dependency as well: [cljsjs/react-dom-server ""15.2.1-0""] Usage Most functions from Hiccup are provided in the sablono.core namespace. The library can be used with Om like this: (ns example   (:require [om.core :as om :include-macros true]             [sablono.core :as html :refer-macros [html]]))  (defn widget [data]   (om/component    (html [:div ""Hello world!""           [:ul (for [n (range 1 10)]                  [:li {:key n} n])]           (html/submit-button ""React!"")])))  (om/root widget {} {:target (. js/document (getElementById ""my-app""))}) HTML Tags Ŝablono only supports tags and attributes that can be handled by React. This means you can’t have your own custom tags and attributes at the moment. For more details take a look at the Tags and Attributes section in the React documentation. HTML Attributes HTML attributes in React are camel-cased and the class and for attributes are treated special. Ŝablono renames attributes with dashes in their name to the camel-cased version and handles the class and for special case. This is more consistent with Hiccup and naming conventions used in Clojure. An input element with event listeners attached to it would look like this in Ŝablono: (html [:input        {:auto-complete ""off""         :class ""autocomplete""         :on-change #(on-change %1)         :on-key-down #(on-key-down %1)         :type ""text""}]) Setting innerHTML of a DOM node It is not recommended to directly set the innerHTML of DOM nodes, but in some cases it is necessary. i.e. injecting a HTML string that was generated from Markdown. (html [:div {:dangerouslySetInnerHTML {:__html ""<div>hello world</div>"" }}]) You can read more at React’s special attributes. Thanks This library is based on James Reeves excellent Hiccup library. License Copyright © 2013-2016 r0man Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/r0man/sablono"	"– Lisp/Hiccup style templating for Facebook's React in ClojureScript."	"true"
"Graphics"	"geom"	"https://github.com/thi-ng/geom"	"– A 2D/3D geometry toolkit for Clojure/Clojurescript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"338"	"40"	"24"	"GitHub - thi-ng/geom: 2D/3D geometry toolkit for Clojure/Clojurescript Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 40 Star 338 Fork 24 thi-ng/geom Code Issues 15 Pull requests 2 Pulse Graphs 2D/3D geometry toolkit for Clojure/Clojurescript 922 commits 3 branches 18 releases 6 contributors Shell 74.2% Emacs Lisp 25.8% Shell Emacs Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags develop feature/gl-refactor master Nothing to show v0.0 r1173 r1062 r1046 r908 r881 r859 r856 r815 r803 r783 r770 r743 r737 r725 r715 r709 0.2.0 Nothing to show New pull request Latest commit 05d8136 Feb 21, 2016 postspectacular Merge pull request #33 from reitzensteinm/master … Resolve compilation variable vs fn call error on Windows Permalink Failed to load latest commit information. assets update project overview diagram Dec 4, 2015 dev project restructure: move all .org files into /src (existing ones in … Mar 6, 2014 geom-core [core] fix vec2.reflect Nov 21, 2015 geom-meshops [mesh] refactor write-obj to use protocols for mesh elements Nov 5, 2015 geom-physics [physics] minor update particle ctor Nov 5, 2015 geom-svg [svg] add example links to readmes Nov 9, 2015 geom-types [types] update PTF luxor example (color handling) Oct 11, 2015 geom-viz Fix a small typo. Nov 17, 2015 geom-voxel [voxel] fix ns names in titles Dec 4, 2015 geom-webgl Resolve compilation variable vs fn call error on Windows Feb 18, 2016 src Merge branch 'develop' Dec 26, 2015 .gitignore Add important repository information to readme, add devart link to us… Nov 10, 2014 CHANGELOG.org [meta] update changelog & version info Nov 8, 2015 LICENSE Initial commit Feb 19, 2014 README.md add project overview diagram Dec 4, 2015 deploy-all.sh [viz] add visualization module & initial implementations of SVG scatter Jun 6, 2015 install-all.sh [meta] add viz module to install-all.sh Jun 14, 2015 install-module.sh [meta] remove cljx step from install scripts May 25, 2015 setagenda.el [all] add setagenda.el for global task list Mar 16, 2015 tangle-all.sh [viz] add visualization module & initial implementations of SVG scatter Jun 6, 2015 tangle-module.sh [meta] update tangle-module & tangle-all to clear babel/src & babel/t… May 25, 2015 tangle.sh refactor index.org files for sub-modules, add config.org, add as LOB … May 7, 2014 test-all.sh [viz] add visualization module & initial implementations of SVG scatter Jun 6, 2015 update-changelog.sh [meta] update changelog & script (add dates) Mar 23, 2015 README.md thi.ng/geom Comprehensive and modular geometry toolkit for Clojure/ClojureScript developed in a literate programming style. Currently BETA quality, largely stable, but pre-release software. The libraries have been used in production for several projects, but further breaking API changes are still forthcoming... Note: This library relies on the new conditional reader syntax of recent Clojure & Clojurescript versions and therefore is not compatible with Clojure versions < 1.7.0... Description & usage See index.org for details. Also please note, the dev branch is (as one might expect) often quite a bit ahead of master and I'm aiming to push at least weekly snapshots of all modules to clojars.org... Current Leiningen coordinates [thi.ng/geom ""0.0.908""] Project overview License Copyright © 2013-2015 Karsten Schmidt Distributed under the Apache Software License 2.0. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/thi-ng/geom"	"– A 2D/3D geometry toolkit for Clojure/Clojurescript."	"true"
"HTTP Handler"	"Castra"	"https://github.com/hoplon/castra"	"– An HTTP remote procedure call handler for Clojure."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"82"	"11"	"16"	"GitHub - hoplon/castra: HTTP remote procedure call handler for Clojure. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 11 Star 82 Fork 16 hoplon/castra Code Issues 6 Pull requests 0 Pulse Graphs HTTP remote procedure call handler for Clojure. 178 commits 3 branches 16 releases 9 contributors Clojure 98.2% Shell 1.8% Clojure Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master micha-docs micha-readme Nothing to show 3.0.0-alpha4 3.0.0-alpha3 3.0.0-alpha2 3.0.0-alpha1 2.2.2 2.2.1 2.2.0 2.1.1 2.1.0 2.0.0 1.3.0 1.2.0 1.0.1 1.0.0 0.1.1 0.1.0 Nothing to show New pull request Latest commit dccbc85 May 24, 2016 micha 3.0.0-alpha4 (actual) Permalink Failed to load latest commit information. img basic docs in the readme Dec 22, 2015 script add push script Oct 30, 2013 src/castra Merge branch 'master' into state-fn May 24, 2016 test/castra tailrecursion/ to hoplon/ migration Aug 30, 2015 .gitignore We can generate project.clj locally Dec 21, 2015 README.md 3.0.0-alpha4 (actual) May 24, 2016 build.boot 3.0.0-alpha4 May 24, 2016 README.md Castra Web application RPC library for Clojure/Script and Ring. [hoplon/castra ""3.0.0-alpha4""] ;; latest release The Big Picture The purpose of Castra is to make async server calls feel like expression evaluation, providing a more cohesive programming experience across the front end and back end of your system. Instead of thinking ""I'm going to send this data bag in a POST to the /xyz endpoint,"" supports you in thinking thoughts like ""I'm going to evaluate the expression (update-record 123 {:x 1 :y 2}) on the server."" Castra's front-end and back-end libraries implement this RPC pattern. RPC does come with baggage, though. Implementing an RPC framework that provides a seamless and transparent remote execution model is a very difficult distributed systems problem. Castra does not attempt this. Instead, Castra's RPC model embraces the asynchronous nature of client server communication. Applicable buzzwords, if you're not into the whole brevity thing, are unidirectional dataflow and the CQRS pattern. Overview Castra spans the gap between server and client. This makes documentation a bit more difficult. This section will jump back and forth between client and server code — it should be understood that the server code is Clojure and client is ClojureScript. Server Most of the magic happens in Castra's castra.middleware/wrap-castra ring middleware. This middleware looks for an expression under the :body key of the ring request map. It looks for a request that looks something like: {:request-method :post  :body ""(my.app/update-record 123 {:x 1 :y 2})""} The Castra middleware deserializes the body to obtain Clojure forms. It then dispatches the expression (my.app/update-record 123 {:x 1 :y 2}) by resolving and attempting to call the function my.app/update-record. (This function should be created with castra.core/defrpc, explained below.) The Castra middleware then returns a ring response map with the serialized result in the :body and a 200 status. You can think of the response as if it were this: {:status 200  :body (pr-str (my.app/update-record 123 {:x 1 :y 2}))} Obviously, we don't want the client to be able to evaluate arbitrary expressions on the server (we already have nREPL for that). We want to be able to mark certain functions as part of our application's RPC interface. This is accomplished with castra.core/defrpc: (ns my.app   (:require     [castra.core :as c]     [some.database :as db]))  (c/defrpc get-record   [id]   (first (db/query ""SELECT * FROM record WHERE id = ?"" id)))  (c/defrpc update-record   [id {:keys [x y]}]   (db/execute ""UPDATE IN record SET x = ?, y = ? WHERE id = ?"" x y id)   (get-record id)) Client Castra provides a ClojureScript library for creating the RPC stub functions the client will call. These are constructed by the castra.core/mkremote function. (ns my.app.client   (:require     [castra.core :as c]     [javelin.core :as j :include-macros true]))  (j/defc record  nil) (j/defc error   nil) (j/defc loading nil)  (def get-record    (c/mkremote 'my.app/get-record    record error loading)) (def update-record (c/mkremote 'my.app/update-record record error loading)) The mkremote function takes four arguments, three of which are Javelin cells: The fully qualified symbol associated with the defrpc on the server. The state cell, where the result will go if the operation succeeded. The error cell, where the exception will go if the operation failed. The loading cell, which will contain a vector of all in-flight RPC requests. This defines the get-record and update-record functions in the client, which can be called like any other ClojureScript function. Hoplon Example: Using the server and client code above, we can make a little webapp that shows us the contents of a record. The user interface will display the current record at the top of the page. The user may enter an id into a text input to view a different record. The interface displays an indication when remote operations are in progress. The interface displays error messages when remote operations fail. Here is a simple Hoplon page that satisfies these requirements: (page ""index.html""   (:require     [my.app.client :as c]))  (defc= loading?      (some-> c/loading seq count))      ; contains count of in-flight commands (defc= error-message (some-> c/error .-message))        ; contains the last command's error message  (c/get-record 1)                                        ; get record 1 when page first loads  (html   (head)   (body     (p :toggle loading?                                 ; show when things are being processed       (text ""Processing ~{loading?} requests...""))      (p :toggle error-message                            ; show when an operation fails       (text ""Error: ~{error-message}""))      (p (text ""Record: ~{c/record}""))                    ; display the current record      (let [id (cell nil)]       (form :submit #(c/get-record @id)                 ; edit and submit form to load record         (p (label ""Record ID: "")             (input :value id :keyup #(reset! id @%)))         (p (button :type ""submit"" ""submit"")))))) There are a few things to notice about this application: Commands to change state do not return a value — the value is updated in a Javelin cell asynchronously when the command completes successfully. Dataflow is unidirectional (i.e. getting and changing state are via separate constructs) — getting via formula cells, and setting via RPC functions. The place that commands the change (eg. the form above) does not need to know or care which places will respond to the change (eg. the p displaying the current record), and vice versa. Dataflow The diagram to the right illustrates the flow of data through the application. There are actually two dataflow loops in the program: A local loop for editing the record id form value, and a remote loop which sends commands to the server. Local Loop The user types in the input element. The keyup DOM event fires, triggering a state transition (callback). The callback calls reset! on the id cell, updating its value. The value property of the input element is bound to the id cell, so it is automatically updated when id changes. The user sees the new value in the input element. Remote Loop The user submits the form. The submit DOM event fires, triggering the callback. The callback performs an RPC command, get-record. When the RPC command completes the c/record cell is automatically updated with the new current record. The textContent property of the text node displaying the current record is bound to a formula cell that updates when c/record changes. The user sees the new record's value in the page. Notice how similar the two cases are. The main difference is at step 3. In the local loop the callback directly updates the id cell with the synchronously with reset!. In the remote loop the c/record cell is updated asynchronously with Castra. Examples The Hoplon Demos repo contains demo apps using Castra. TODO explain defrpc and endpoints. explain validation License Copyright © 2013 FIXME Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/hoplon/castra"	"– An HTTP remote procedure call handler for Clojure."	"true"
"Internationalization"	"Tower"	"https://github.com/ptaoussanis/tower"	"– A Clojure(Script) i18n & L10n library."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"234"	"15"	"18"	"GitHub - ptaoussanis/tower: i18n & L10n library for Clojure/Script Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 15 Star 234 Fork 18 ptaoussanis/tower Code Issues 9 Pull requests 0 Pulse Graphs i18n & L10n library for Clojure/Script https://www.taoensso.com 362 commits 2 branches 60 releases 9 contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show v3.1.0-beta4 v3.1.0-beta3 v3.1.0-beta2 v3.1.0-beta1 v3.1.0-alpha3 v3.1.0-alpha2 v3.1.0-alpha1 v3.0.2 v3.0.1 v3.0.0 v2.1.0-RC2 v2.1.0-RC1 v2.0.2 v2.0.1 v2.0.0 v2.0.0-beta5 v2.0.0-beta4 v2.0.0-beta3 v2.0.0-beta2 v2.0.0-beta1 v2.0.0-alpha17 v2.0.0-alpha16 v2.0.0-alpha15 v2.0.0-alpha14 v2.0.0-alpha13 v2.0.0-alpha12 v2.0.0-alpha11 v2.0.0-alpha10 v2.0.0-alpha9 v2.0.0-alpha8 v2.0.0-alpha1 v2.0.0-RC4 v2.0.0-RC3 v2.0.0-RC2 v2.0.0-RC1 v1.7.1 v1.7.0 v1.6.0 v1.5.1 v1.5.0 v1.4.0 v1.3.0 v1.2.0 v1.1.0 v1.0.0 v0.12.3 v0.12.2 v0.12.1 v0.12.0 v0.11.0 v0.10.0 v0.9.1 v0.9.0 v0.8.2 v0.8.1 v0.8.0 v0.7.0 v0.6.0 v0.5.1 v0.5.0 Nothing to show New pull request Latest commit fcaed8a Jun 26, 2016 ptaoussanis Update README Permalink Failed to load latest commit information. resources [#60] Fix faulty unnested external translation dict resource loading … Mar 3, 2015 src/taoensso Some i18n todos for Temple Jul 13, 2015 test/taoensso/tower/tests [#60] Fix faulty unnested external translation dict resource loading … Mar 3, 2015 .gitignore Update .gitignore Mar 17, 2014 .travis.yml Clean up testing config. Jul 28, 2012 CHANGELOG.md Update README template, update lib status Jan 27, 2016 LICENSE Update README Mar 17, 2014 README.md Update README Jun 26, 2016 project.clj v3.1.0-beta4 Jul 13, 2015 README.md CHANGELOG | API | current Break Version: [com.taoensso/tower ""3.0.2""]       ; Deprecated [com.taoensso/tower ""3.1.0-beta4""] ; EOL but stable Please consider helping to support my continued open-source Clojure/Script work? Even small contributions can add up + make a big difference to help sustain my time writing, maintaining, and supporting Tower and other Clojure/Script libraries. Thank you! - Peter Taoussanis Tower Clojure/Script i18n & L10n library The Java platform provides some very capable tools for writing internationalized applications. Unfortunately, they can be... cumbersome. We can do much better in Clojure. Tower's an attempt to present a simple, idiomatic internationalization and localization story for Clojure. It wraps standard Java functionality where possible - with warm, fuzzy, functional love. Library status: EOL but stable Last updated: Jan 2016 Tower's latest beta (3.1.0-beta4) is stable and quite useable in production, but is likely the last major release for the library (modulo unexpected bug fixes). Future development work is going to be focused on: Tempura - Clojure/Script translations API To be determined - Clojure/Script localization API Why the EOL? Tower's quite useable as it is but was initially designed before things like Reactjs (indeed ClojureScript) were available. The API does the job, but it's not what I'd write if I wrote it from scratch today w/o the historical baggage. Rather than try to shoehorn a significant set of potentially-breaking changes into Tower (pressuring stable users to migrate), it seemed logical to instead focus future work on alternative lib/s that could be optionally migrated to in stages. As I find time to publish these libs, I'll make a best effort to also document the procedure necessary for migrating from Tower for those users that want to do that. I apologise for the stress/trouble that this might cause, but hope that the present solution will turn out to be relatively painless in most cases. Long term, I think that the benefits will be worth it. - Peter Taoussanis Features Small all-Clojure library Simple wrappers for standard Java localization features Simple, map-based translation dictionary format. No XML or resource files! Rails-like, pure-Clojure translation function with ClojureScript support Automatic dev-mode dictionary reloading for rapid REPL development Seamless markdown support for translators Ring middleware TODO: export/import to allow use with industry-standard tools for translators Getting started Add the necessary dependency to your project: [com.taoensso/tower ""3.0.2""] And setup your namespace imports: (ns my-clj-ns ; Clojure namespace   (:require [taoensso.tower :as tower :refer (with-tscope)]))  ;; Requires v3.1+ (ns my-cljs-ns ; ClojureScript namespace   (:require [taoensso.tower :as tower :refer-macros (with-tscope)])) Translation The make-t fn handles translations. You give it a config map which includes your dictionary, and get back a (fn [locale-or-locales k-or-ks & fmt-args]): (def my-tconfig   {:dictionary ; Map or named resource containing map    {:en   {:example {:foo         "":en :example/foo text""                      :foo_comment ""Hello translator, please do x""                      :bar {:baz "":en :example.bar/baz text""}                      :greeting ""Hello %s, how are you?""                      :inline-markdown ""<tag>**strong**</tag>""                      :block-markdown* ""<tag>**strong**</tag>""                      :with-exclaim!   ""<tag>**strong**</tag>""                      :with-arguments  ""Num %d = %s""                      :greeting-alias :example/greeting                      :baz-alias      :example.bar/baz}            :missing  ""|Missing translation: [%1$s %2$s %3$s]|""}     :en-US {:example {:foo "":en-US :example/foo text""}}     :de    {:example {:foo "":de :example/foo text""}}     :ja ""test_ja.clj"" ; Import locale's map from external resource     }    :dev-mode? true ; Set to true for auto dictionary reloading    :fallback-locale :de})  (def t (tower/make-t my-tconfig)) ; Create translation fn  (t :en-US :example/foo) => "":en-US :example/foo text"" (t :en    :example/foo) => "":en :example/foo text"" (t :en    :example/greeting ""Steve"") => ""Hello Steve, how are you?""  ;;; Translation strings are escaped and parsed as inline or block Markdown: (t :en :example/inline-markdown) => ""&lt;tag&gt;<strong>strong</strong>&lt;/tag&gt;"" (t :en :example/block-markdown)  => ""<p>&lt;tag&gt;<strong>strong</strong>&lt;/tag&gt;</p>"" ; Notice no ""*"" suffix here, only in dictionary map (t :en :example/with-exclaim)    => ""<tag>**strong**</tag>"" ; Notice no ""!"" suffix here, only in dictionary map (t :en :example/with-arguments 42 ""forty two"") =>   ""Num 42 = forty two"" It's simple to get started, but there's a number of advanced features for if/when you need them: Loading dictionaries from disk/resources Just use a string for the :dictionary and/or any locale value(s) in your config map. Be sure to check that the appropriate files are available on your classpath or one of Leiningen's resource paths (e.g. resources/). Reloading dictionaries on modification** Enable the :dev-mode? option and you're good to go! Scoping translations** Use with-tscope if you're calling t repeatedly within a specific translation-namespace context: (with-tscope :example   [(t :en :foo)    (t :en :bar/baz)]) => ["":en :example/foo text"" "":en :example.bar/baz text""] Missing translations** These are handled gracefully. (t :en-US :example/foo) will search for a translation as follows: :example/foo in the :en-US locale. :example/foo in the :en locale. :example/foo in the dictionary's fallback locale. :missing in any of the above locales. You can also specify fallback keys that'll be tried before other locales. (t :en-US [:example/foo :example/bar])) searches: :example/foo in the :en-US locale. :example/bar in the :en-US locale. :example/foo in the :en locale. :example/bar in the :en locale. :example/foo in the fallback locale. :example/bar in the fallback locale. :missing in any of the above locales. And even fallback locales. (t [:fr-FR :en-US] :example/foo) searches: :example/foo in the :fr-FR locale. :example/foo in the :fr locale. :example/foo in the :en-US locale. :example/foo in the :en locale. :example/foo in the fallback locale. :missing in any of the above locales. In all cases, translation requests are logged upon fallback to fallback locale or :missing key. ClojureScript translations (early support, v3.1+) (def ^:private tconfig   {:fallback-locale :en    ;; Inlined (macro) dict => this ns needs rebuild for dict changes to reflect.    ;; (dictionary .clj file can be placed in project's `/resources` dir):    :compiled-dictionary (tower-macros/dict-compile* ""my-dict.clj"")})  (def t (tower/make-t tconfig)) ; Create translation fn  (t :en-US :example/foo) => "":en-US :example/foo text"" There's two notable differences from JVM translations: The dictionary is provided in a pre-compiled form so that it can be inlined directly into your Cljs. Since we lack a locale-aware Cljs format fn, your translations cannot use JVM locale formatting patterns. The API is otherwise exactly the same, including support for all decorators. Use with React (Reagent/Om/etc.) React presents a bit of a challenge to translations since it automatically escapes all text content as a security measure. This has two important implications for use with Tower's translations: Content intended to allow translator-controlled inline styles needs to provided to React with the dangerouslySetInnerHTML property. All other content should get a :<key>!-style translation to prevent double escaping (Tower already escapes translations not marked with an exlamation point). Localization Check out fmt, parse, lsort, fmt-str, fmt-msg: (tower/fmt   :en-ZA 200       :currency) => ""R 200.00"" (tower/fmt   :en-US 200       :currency) => ""$200.00"" (tower/parse :en-US ""$200.00"" :currency) => 200  (tower/fmt :de-DE 2000.1 :number)               => ""2.000,1"" (tower/fmt :de-DE (java.util.Date.))            => ""12.06.2012"" (tower/fmt :de-DE (java.util.Date.) :date-long) => ""12. Juni 2012"" (tower/fmt :de-DE (java.util.Date.) :dt-long)   => ""12 giugno 2012 16.48.01 ICT""  (tower/lsort :pl [""Warsaw"" ""Kraków"" ""Łódź"" ""Wrocław"" ""Poznań""]) => (""Kraków"" ""Łódź"" ""Poznań"" ""Warsaw"" ""Wrocław"")  (mapv #(tower/fmt-msg :de ""{0,choice,0#no cats|1#one cat|1<{0,number} cats}"" %)         (range 5)) => [""no cats"" ""one cat"" ""2 cats"" ""3 cats"" ""4 cats""] It's that simple. See the API docs for details. Country and languages names, timezones, etc. Check out countries, languages, and timezones. Ring middleware Quickly internationalize your Ring web apps by adding taoensso.tower.ring/wrap-tower to your middleware stack. See the API docs for details. This project supports the goals ClojureWerkz is a growing collection of open-source, batteries-included Clojure libraries that emphasise modern targets, great documentation, and thorough testing. Contacting me / contributions Please use the project's GitHub issues page for all questions, ideas, etc. Pull requests welcome. See the project's GitHub contributors page for a list of contributors. Otherwise, you can reach me at Taoensso.com. Happy hacking! - Peter Taoussanis License Distributed under the EPL v1.0 (same as Clojure). Copyright © 2012-2016 Peter Taoussanis. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/ptaoussanis/tower"	"– A Clojure(Script) i18n & L10n library."	"true"
"JavaScript Interoperability"	"CLJSJS"	"http://cljsjs.github.io/"	"– An easy way for Clojurescript developers to depend on Javascript libraries."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Javascript Libraries packaged for ClojureScript CLJSJS provides an easy way for ClojureScript developers to depend on Javascript libraries. Why Since ClojureScript 0.0-2727 the :foreign-libs option provides an excellent way to integrate Javascript into ClojureScript applications. CLJSJS provides Javascript libraries and their appropriate extern files packaged up with deps.cljs. CLJSJS aims to concentrate packaging efforts to make everyone’s life a little easier. Documentation CLJSJS packages are gathered on Github in cljsjs/packages. There you can also find usage instructions, request new libraries to be packaged or contribute yourself. We use Boot to make packaging quick and easy but it is not required to make use of CLJSJS packaged Jars. Packages airbrake Airbrake JavaScript Notifier https://airbrake.io amplitude Javascript SDK for Amplitude ansiparse Parse ANSI color codes async Higher-order functions and common patterns for asynchronous code auth0 Auth0 JS Lib auth0-lock Auth0 Lock autobahnjs AutobahnJS - A JavaScript library for WAMP ("" The Web Application Messaging Protocol ""). http://autobahn.ws aws-sdk-js AWS Browser SDK babylon Microsoft's Babylon.js 3d game engine bankersbox Javascript API for a redis-like API wrapper for data storage in javascript, using localStorage as a default. bcrypt Optimized bcrypt in JavaScript with zero dependencies benchmark A benchmarking library. As used on jsPerf.com. bignumber A JavaScript library for arbitrary-precision decimal and non-decimal arithmetic. bitauth Authenticate with web services utilizing the same strategy as Bitcoin blockapps Interface to the Ethereum blockchain providing contract creation and transactions, state inspection, and dApp registration and management boot-cljsjs Tooling to package and deploy Javascript libraries for Clojurescript projects bootstrap Javascript for Bootstap bootstrap-slider JavaScript Library for slider input fields bootstrap-toggle Bootstrap Toggle is a highly flexible Bootstrap plugin that converts checkboxes into toggles bytebuffer A fast and complete ByteBuffer implementation using either ArrayBuffers in the browser or Buffers under node.js. c3 A D3-based reusable chart library chance Chance is a minimalist generator of random strings, numbers, etc chartist Chartist.js - Simple responsive charts chartjs Chart.js - Simple yet flexible JavaScript charting for designers & developers chemdoodle A JavaScript Chemostry Visualization Library chosen jQuery plugin that makes long, unwieldly select boxes much more user-friendly. chroma A lightweight but powerful library for dealing with colors classnames A simple javascript utility for conditionally joining classNames together clipboard Modern copy to clipboard. No Flash. Just 2kb clusterize Clusterize.js - Tiny vanilla JS plugin to display large data sets easily codemirror CodeMirror is a versatile text editor implemented in JavaScript for the browser colorbrewer A set of colors based on Cynthia Brewer's Colorbrewer commonmark CommonMark is a rationalized version of Markdown syntax. It provides a library with functions for parsing CommonMark documents to an abstract syntax tree (AST), manipulating the AST, and rendering the document to HTML or to an XML representation of the AST. cortical-io Interface for Cortical-io natural language processing cropper JavaScript image cropper css-layout Reimplementation of CSS layout using pure JavaScript csv A Comma-Separated Values parser for JavaScript. Standards-based, stand alone, and no regular expressions. d3 A JavaScript visualization library for HTML and SVG d3-cloud nil d3geo Extended Projections for D3.js d3kit Read and write OpenType fonts using JavaScript. device Device.js makes it easy to write conditional CSS _and/or_ JavaScript based on device operating system (iOS, Android, Blackberry, Windows, Firefox OS, MeeGo, AppleTV, etc), orientation (Portrait vs. Landscape), and type (Tablet vs. Mobile). dexie A Minimalistic Wrapper for IndexedDB dialog-polyfill Polyfill for the dialog element dimple A JavaScript charting library based on d3 document-register-element A stand-alone working lightweight version of the W3C Custom Elements specification dom-delegator Decorate elements with delegated events dom4 A DOM4 polyfill for parentNodes/childNodes entries dragula Drag and drop so simple it hurts dropbox Javascript client for Dropbox dygraph Dygraph Charting Library eccjs Simple wrapper around SJCL's ECC Implementation echarts A declarative JavaScript chart library built on HTML Canvas emojione EmojiOne™ is the open emoji standard. enquire enquire.js is a lightweight, pure JavaScript library for responding to CSS media queries. esprima ECMAScript parsing infrastructure for multipurpose analysis exif A JavaScript library for reading EXIF meta data from JPEG image files. fabric Fabric.js is a powerful and simple Javascript HTML5 canvas library facebook Facebook Javascript API fastclick Polyfill to remove click delays on browsers with touch UIs field-kit FieldKit lets you take control of your text fields. filesaverjs An HTML5 saveAs() FileSaver implementation filestack Filestack is a client side file upload API & CDN firebase Javascript client for Firebase.com firebase-node Nodejs client for Firebase.com fixed-data-table A React table component designed to allow presenting thousands of rows of data. flot flot packaged up with Google Closure externs forge A native implementation of TLS in Javascript and tools to write crypto-based and network-heavy webapps. gl-matrix Javascript Matrix and Vector library for High Performance WebGL apps google-analytics Google Universal Analytics (analytics.js) google-diff-match-patch Diff, Match and Patch Library google-maps Google Maps ext lib google-platformjs-extern Authenticate with Google API hammer A javascript library for multi-touch gestures hashids A small JavaScript class to generate YouTube-like hashids from one or many numbers. This is a client-side version of Node.js version. heap Heap js ext lib highcharts Create interactive charts easily for your web projects. highlight Javascript syntax highlighter https://highlightjs.org/ highstock Highstock lets you create stock or general timeline charts in pure JavaScript. husl Human-friendly HSL ical Javascript parser for ics (rfc5545) and vcard (rfc6350) data incremental-dom Dom-building library from google jqconsole A jQuery terminal plugin written in CoffeeScript jqgrid jqGrid plugin for jQuery jquery The Write Less, Do More, JavaScript Library. jquery-daterange-picker A jQuery plugin that allows user to select a date range. jquery-timepicker A Javascript timepicker plugin for jQuery inspired by Google Calendar jquery-ui jQuery UI is a curated set of user interface interactions, effects, widgets, and themes js-beautify Beautifier for javascript js-yaml JavaScript YAML parser and dumper. Very fast. jsdiff A javascript text differencing implementation jszip Create, read and edit .zip files juration Human friendly time duration parsing. kemia A chemical structure library klayjs A layer-based layout algorithm, particularly suited for node-link diagrams with an inherent direction and ports. labella Read and write OpenType fonts using JavaScript. ladda Buttons with built-in loading indicators. lamejs Fast MP3 encoder written in JavaScript leaflet JavaScript Library for Mobile-Friendly Interactive Maps leaflet-draw Adds support for drawing and editing vectors and markers on Leaflet maps leaflet-locatecontrol A useful control to geolocate the user with many options llexus-form A dynamic form component for React using a specification format based on JSON-Schema. llexus-validate A simple validator for a subset of JSON-Schema. localforage localForage is a fast and simple storage library for JavaScript. localForage improves the offline experience of your web app by using asynchronous storage (IndexedDB or WebSQL) with a simple, localStorage-like API. lodash A JavaScript utility library delivering consistency, modularity, performance, & extras. long A Long class for representing a 64 bit two's-complement integer value. lunrjs Lunr.js is a small, full-text search library for use in the browser. It indexes JSON documents and provides a simple search interface for retrieving documents that best match text queries. markdown A Markdown parser for javascript marked A markdown parser and compiler. Built for speed. material Material Design Lite is a lightweight HTML, CSS and JS framework for sites that follow Google's Material Design guidelines. material-ui A Set of React Components that Implement Google's Material Design mathbox MathBox 1: Three-dimensional, animated mathematical visualization matter Matter.js is a JavaScript 2D rigid body physics engine for the web media-stream-recorder Record from your webcam to a File (Blob) in Chrome and Firefox. medium-editor Medium.com WYSIWYG editor clone mithril A Javascript Framework for Building Brilliant Applications moment A javascript date library for parsing, validating, manipulating, and formatting dates. moment-range A javascript date library for parsing, validating, manipulating, and formatting dates. morphdom Fast and lightweight DOM diffing/patching (without the virtual part) mousetrap Simple library for handling keyboard shortcuts in Javascript msgpack-lite Fast pure JavaScript MessagePack encoder and decoder mui MUI is a lightweight HTML, CSS and JS framework for sites that follow Google's Material Design guidelines. mustache Mustache.js packaged up with Google Closure externs nodejs-externs Node.js Google Closure Compiler Externs nprogress Slim progress bars for Ajax'y applications. Inspired by Google, YouTube, and Medium. nvd3 A reusable chart library for d3.js oauthio This is the JavaScript SDK for OAuth.io object-assign-shim ES6 Object.assign method polyfill. oboe A streaming approach to JSON. Oboe.js speeds up web applications by providing parsed objects before the response completes. ocean ThreeJS Ocean (water material) openlayers A high-performance, feature-packed library for all your mapping needs opentype Read and write OpenType fonts using JavaScript. paho A JavaScript MQTT client pako zlib port to javascript, very fast! papaparse Fast and powerful CSV (delimited text) parser that gracefully handles large files and malformed input paperjs The Swiss Army Knife of Vector Graphics Scripting parinfer Simpler Lisp Editing parse Parse JavaScript SDK pdfjs PDF Reader in JavaScript peg PEG.js: Parser generator for JavaScript phaser Phaser is a fast, free, and fun open source framework for Canvas and WebGL powered browser games. phoenix Phoenix Elixir Framework client photoswipe JavaScript image gallery for mobile and desktop, modular, framework independent pikaday A refreshing JavaScript Datepicker - lightweight, no dependencies, modular CSS pinterest Pinterest Javascript API pixi 2D webGL renderer with canvas fallback platform A platform detection library plotly The open source javascript graphing library that powers plotly plottable Flexible, interactive charts for the web. pouchdb PouchDB is an open-source JavaScript database inspired by Apache CouchDB that is designed to run well within the browser pubnub Interface for pubnub realtime messaging services pusher Pusher quill Quill is a free, open source WYSIWYG editor built for the modern web. radium A toolchain for React component styling. rangy-core A cross-browser JavaScript range and selection library rangy-textrange A cross-browser JavaScript range and selection library raven raven-js: JavaScript client for Sentry https://getsentry.com react A Javascript library for building user interfaces react-autosuggest WAI-ARIA compliant React autosuggest component react-bootstrap The most popular front-end framework, rebuilt for React. react-bootstrap-datetimepicker Datetime input widget for react-bootstrap react-burger-menu An off-canvas sidebar component with a collection of effects and styles using CSS transitions and SVG path animations react-datepicker A simple and reusable datepicker component for React react-day-picker A Select control built with and for React JS react-dom A Javascript library for building user interfaces react-dom-server A Javascript library for building user interfaces react-drag Up to date fork of react-draggable react-grid-layout A draggable and resizable grid layout with responsive breakpoints, for React. react-infinite A browser-ready efficient scrolling container based on UITableView. react-input-autosize Auto-resizing input field for React react-input-mask Yet another react component for input masking react-leaflet JavaScript Library for Mobile-Friendly Interactive Maps react-mdl React Components wrapper for Material Design Lite UI http://tleunen.github.io/react-mdl/ react-motion A spring that solves your animation problems. react-pixi Create/control a Pixi.js canvas using React react-quill A Quill component for React. react-relay Relay is a JavaScript framework for building data-driven React applications. react-reorderable Simple react sortable component (for more advanced cases use react-dnd). react-router A complete routing solution for React.js react-sanfona Accessible react accordion component react-select A flexible and beautiful Select Input control for ReactJS with multiselect, autocomplete and ajax support. react-selectable A component for react that allows mouse selection of child items react-slider Slider component for React react-timer-mixin TimerMixin provides timer functions for executing code in the future that are safely cleaned up when the component unmounts react-virtualized React components for efficiently rendering large lists and tabular data. react-with-addons A Javascript library for building user interfaces reactable Fast, flexible, and simple data tables in React. reactabular A React tabular component. responsive-nav Responsive navigation plugin without library dependencies and with fast touch screen support. rrule JavaScript library for working with recurrence rules for calendar dates rx Reactive Extensions for JavaScript (RxJS), a set of libraries for composing asynchronous and event-based programs using observable sequences and fluent query operators. scrollex Nifty scroll events for jQuery. scrollify A jQuery plugin that assists scrolling and smoothly snaps to sections. Fully configurable and optimised for touch. selectize Selectize is the hybrid of a textbox and <select> box. semantic-ui Semantic UI jquery behaviors. showdown A Markdown to HTML converter written in Javascript sinon Standalone test spies, stubs and mocks for JavaScript sizzle A pure-JavaScript CSS selector engine designed to be easily dropped in to a host library. skel A lightweight responsive framework for the www smooth-scroll A simple vanilla JS script to animate scrolling to anchor links snapsvg The JavaScript SVG library for the modern web soundjs A Javascript library for working with Audio. spin A spinning activity indicator stripe Stripe js ext lib svgjs A lightweight library for manipulating and animating SVG syn Standalone Synthetic Event Library tabletop Tabletop.js takes a Google Spreadsheet and makes it easily accessible through JavaScript. tether A positioning engine to make overlays, tooltips and dropdowns better #hubspot-open-source textures A JavaScript library for adding svg patterns to d3 visualizations three JavaScript 3D library tinycolor Fast Color Parsing and Manipulation. to-markdown An HTML to Markdown converter written in JavaScript. toastr A Javascript library for Gnome / Growl type non-blocking notifications. topojson An extension to GeoJSON that encodes topology tv4 Tiny Validator for v4 JSON Schema tween JavaScript Tweening library typeahead-bundle A flexible JavaScript library that provides a strong foundation for building robust typeaheads. typedjs jQuery plugin that types. vega Vega is a declarative format for creating, saving, and sharing visualization designs vega-lite A high-level grammar for visual analysis, built on top of Vega. victory victory.js collection of composable React components for building interactive data visualizations virtual-dom A JavaScript DOM model supporting element creation, diff computation and patch operations for efficient re-rendering vis Dynamic, browser-based visualization library wad Web Audio DAW. Use the HTML5 Web Audio API for dynamic sound synthesis. waypoints Waypoints is a library that makes it easy to execute a function whenever you scroll to an element. web-animations A polyfill for Web Animations web3 Ethereum JavaScript API webcomponents jQuery plugin that types. webcomponents-lite jQuery plugin that types."	"null"	"null"	"– An easy way for Clojurescript developers to depend on Javascript libraries."	"true"
"JavaScript Interoperability"	"Jayq"	"https://github.com/ibdknox/jayq"	"– A ClojureScript wrapper for jQuery."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"389"	"22"	"59"	"GitHub - ibdknox/jayq: A ClojureScript wrapper for jQuery Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 22 Star 389 Fork 59 ibdknox/jayq Code Issues 0 Pull requests 0 Wiki Pulse Graphs A ClojureScript wrapper for jQuery 158 commits 1 branch 18 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show 2.5.4 2.5.3 2.5.2 2.5.1 2.3.0 2.1.0 1.0.0 0.3.2 0.3.1 0.3.0 0.2.3 0.2.2 0.2.1 0.2.0 0.1.0-alpha4 0.1.0-alpha3 0.1.0-alpha2 0.1.0-alpha1 Nothing to show New pull request Latest commit 9cf2479 Jun 16, 2015 frankhale Merge pull request #58 from iamjarvo/clojar-version-badge … Add clojar version badge Permalink Failed to load latest commit information. src/jayq Add jquery? predicate May 12, 2015 .gitignore Bump to version 2.5.1 May 11, 2014 CHANGELOG.md Release 2.5.4 Feb 9, 2015 LICENSE Add EPL LICENSE May 11, 2014 README.md Add clojar version badge Jun 15, 2015 project.clj Release 2.5.4 Feb 9, 2015 README.md jayq A jQuery wrapper for ClojureScript. Wait a second.. I thought we weren't supposed to use jQuery? When ClojureScript first came out, the prevailing wisdom was that since jQuery wasn't compatible with the Google Closure Compiler, we shouldn't be using it. So I set off to work on Pinot, a library that wrapped the goog.* APIs. The journey was painful and frustrating, and before long I realized I was essentially rewriting parts of jQuery for no gain. Instead of doing that, I figured my time would be better spent building on top of the most battle hardened JS library out there. Before I started down this path though, I wanted to make sure that I had answers to all the arguments against using it. They were as follows: It can't be compiled by the Closure compiler and means we can't use Advanced compilation. It will add another thing for you to download and increase the size of the cljs code, because the symbols won't be munged by the Closure compiler. It won't lend itself to Clojure idioms. I'll tackle each of these in order. In terms of it not being able to be compiled, we shouldn't be packaging jquery with our apps anyways. Virtually the entire web is built on $ and that means nearly every computer connected to the internet already has a google CDN'd version of jquery on their machine. That means there's no extra weight and no reason to compile it. This also addresses the first part of the second one - there's nothing more to download. While it's true that if we used jQuery directly, all method calls would be left alone and could not be replaced with a minified name. With a wrapper, however, that happens exactly once per method and all occurences of the wrapper will be munged. This means that at most we're talking about a difference on the magnitude of bytes. If you need to optimize for size at that level, you shouldn't be using CLJS anyways. Lastly, there's the argument that it won't lead to idiomatic usage. That's likely true if we use jQuery directly, but I'm not sure I really believe that's a valid argument. The same goes for Clojure if we use Java libraries directly all over the place. Wrappers, however, allow us to utilize all the functionality provided by these libraries, but still create Clojure idioms over top of them. There's no reason to ignore the most solid base out there, when we can just build greater abstractions on top of it. Do I think jQuery is the pinnacle of the client side web? Not at all, but I do believe it provides a great foundation for us to build exactly that. Installation Add the following to your project.clj [jayq ""2.5.4""] Note: If you are upgrading to a major version be sure to check the changelog for breaking changes. Usage jayq.core Source Most of the API in jayq.core maps 1:1 with jQuery functions. (ns myapp   (:use [jayq.core :only [$ css html]]))  (def $interface ($ :#interface))  (-> $interface   (css {:background ""blue""})   (html ""Loading!""))  jayq.core/ajax clojure & edn mime types support Requests with :contentType option matching text/clojure text/edn application/clojure application/edn (as string or keyword) will have the :data turned into its string representation (via pr-str) Responses with text/clojure text/edn application/clojure application/edn mime types are read as clojure data before being passed to callbacks. The same applies if the dataType option is set to :edn or :clojure. jayq.util Source jayq.util/log [value & text] : console.log wrapper jayq.util/wait [ms f] : setTimeout wrapper jayq.macros Source jayq.macros/queue [elem & body] : a wrapper of jayq.core/queue that includes the lambda with a scoped this symbol jayq.macros/ready [& body] : a wrapper of jayq.core/document-ready jayq.macros/let-ajax [steps & body]: let like form allowing chaining of ajax calls and binding return values to locals for use once all the calls are complete (or in a :let intermediary step). The step value expected is a valid jq.core/ajax request map. You can supply :let/:when steps (like in for/doseq) between ""regular"" steps. (let-ajax [a {:url ""http://localhost:8000/1.json""               :dataType :json}            b  {:dataType :json :url ""http://localhost:8000/2.json""}]        (merge a b)) jayq.macros/let-deferred [steps & body]: let like form allowing chaining of deferreds and binding return values to locals for use once all the deferreds are realized (or in a :let/:when intermediary step). The step value expected is anything that returns a deferred instance. You can supply :let/:when steps (like in for/doseq) between ""regular"" steps. (let-deferred     [a (jq/ajax ""http://localhost:8000/1.json"")      :let [foo ""bar""]      :when (= (concat a foo) ""foobar"")      b (jq/ajax ""http://localhost:8000/2.json"")] (merge a b foo)) jayq.macros/do-> [m-specs steps & body]: let-* macros are built from it. m-specs is a map of :bind and :return functions that dictate the workflow (see: jayq.core/deferred-m and jayq.core/ajax-m). Error handling in let-ajax and let-deferred forms should be done using jq.core/fail or the :error key on the request map. Changelog See CHANGELOG.md Compiling If you're using advanced Clojurescript compilation you'll need to reference a jQuery externs file. You can find externs files from the closure-compiler repository for a specific jQuery version. Add this to your compilation options (assuming that your put the externs file in ./externs/):   {     :optimizations :advanced     :externs [""externs/jquery.js""]     ...   } Without this, you will see errors like Object ... has no method XX. See http://lukevanderhart.com/2011/09/30/using-javascript-and-clojurescript.html for more on externs. License Copyright (C) 2011 Chris Granger Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/ibdknox/jayq"	"– A ClojureScript wrapper for jQuery."	"true"
"JavaScript Interoperability"	"Purnam"	"http://purnam.github.io/purnam/"	"– A ClojureScript library designed to provide better clojurescript/javascript interop, testing and documentation tools."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"purnam purnam Language extensions for clojurescript Author: Chris Zheng  (z@caudate.me) Library: v0.5.1 Date: 09 October 2014 Website: http://www.github.com/purnam/purnam Generated By: MidjeDoc 1   Installation 2   Motivation 3   Quickstart   3.1   Native Datastructures   3.2   Native Functions   3.3   Native Protocols   3.4   DSL for Testing 4   purnam.native.functions   4.1   init   4.2   js-lookup   4.3   js-equals   4.4   js-assoc   4.5   js-dissoc   4.6   js-empty   4.7   js-merge   4.8   js-merge-nil   4.9   js-copy   4.10   js-deep-copy   4.11   js-replace   4.12   js-map   4.13   js-concat   4.14   js-mapcat   4.15   js-arities 5   purnam.native   5.1   init   5.2   seq protocol   5.3   transient protocol   5.4   collection protocol 6   purnam.core   6.1   init   6.2   obj   6.3   arr   6.4   getter - ?   6.5   setter - !   6.6   call - ?>   6.7   call on - !>   6.8   this   6.9   self   6.10   def.n   6.11   f.n   6.12   do.n   6.13   raw forms 7   purnam.test   7.1   init   7.2   describe   7.3   async   7.4   fact   7.5   facts 8   Running Tests 9   Generating Documentation 10   End Notes purnam Language extensions for clojurescript Author: Chris Zheng  (z@caudate.me) Library: v0.5.1 Date: 09 October 2014 Website: http://www.github.com/purnam/purnam Generated By: MidjeDoc 1    Installation Add to project.clj dependencies: [im.chit/purnam ""0.5.1""] Looking for documentation for purnam.angular? The library has been renamed and moved to a new home at http://purnam.github.io/gyr 2    Motivation purnam is a clojurescript library designed to provide better clojurescript/javascript interop, testing and documentation tools to the programmer. Current projects requiring interface with external javascript libraries will greatly benefit from purnam language extensions. 'Pure' clojure/clojurescript libraries will also benefit with its unit-testing and documentation workflows. The library was written to solve a number of pain points that are experienced in clojurescript development: Better JS Interop The first pain point was having to deal with the clojurish (.dot syntax) for javascript interop as well as a lack of functionality when working with native js objects. This made it especially hard for working with any external js library. purnam offers: purnam.native.functions - functions for native objects and arrays purnam.native - clojure protocols for native objects and arrays purnam.core - a set of macros allowing javascript-like syntax for better interop In-Browser Testing purnam.test was written to allow clojurescript tests to work with the karma test runner. There are various advantages to using the karma test runner over existing clojurescript solutions: Supports a variety of browsers including Chrome, Firefox, Safari, Phantomjs and Node Webkit Uses nodejs and so has a very quick startup time It is supported by Google and the Angularjs team Very active community with lots of users and development activityFurthermore, the javascript dot.notational.style to be used for better native integration. Since version 0.4, there is much better support for error reporting and the library can now be used on its own, outside of all other purnam libraries. Currently two flavors are supported describing clojurescript tests: Jasmine style - describe, it and is. It gives a more fully featured interface and has async support (runs, waits-for) Midje style - fact and =>. It can be combined with MidjeDoc to generate documentation from unit tests (the current article being an auto-generated document using this technique). Integrated Documentation The third pain point was the lack of documentation tools for clojurescript as well as clojure. purnam is compatible with midje-doc so that the integrated testing and documentation workflow can be also used in clojurescript. 3    Quickstart The quickest way to start is to look at some sample projects: Crafty.js Example uses purnam.core Karma Testing Example uses purnam.test and purnam.test.sweet 3.1    Native Datastructures obj, arr and def* in the purnam.core namespace allow nested objects and arrays to be constructed. The examples below show equivalent objects in javascript and clojurescript e.3.1  -  js object var user = {ids: [1, 2, 3], account: {username: 'user', password: 'pass'}}  e.3.2  -  cljs object - obj (def user (obj :ids [1 2 3] :account {:username ""user"" :password ""pass""}))  e.3.3  -  cljs object - def* (def* user {:ids [1 2 3] :account {:username ""user"" :password ""pass""}})  Arrays are constructed using arr. The two examples below show equivalent arrays in javascript and clojurescript: e.3.4  -  js array var kids = [{name: 'Sam' age: 3}, {name: 'Bob' age: 10}]  e.3.5  -  cljs array - arr (def kids (arr {:name ""Sam"" :age 3} {:name ""Bob"" :age 10}))  e.3.6  -  cljs array - def* (def* kids [{:name ""Sam"" :age 3} {:name ""Bob"" :age 10}])  3.2    Native Functions def.n and f.n allow functions to be defined using the javascript dot-notation syntax. The following are examples of the square function defined in javascript and clojurescript. e.3.7  -  js function square = function(x) {return x.value * x.value}  e.3.8  -  cljs function - def.n (def.n square [x]   (obj :value (* x.value x.value)))  e.3.9  -  cljs function - f.n (def square    (f.n [x]     (obj :value (* x.value x.value))))  As a comparison, here is the same function in clojurescript without the macro helpers. e.3.10  -  cljs function - defn (defn square [x]   (let [o (js-obj)         v (aget x ""value"")]     (aset o ""value"" (* v v))     o))  3.3    Native Protocols The purnam.native namespace provide for idiomatic clojure syntax to be used: e.3.11  -  Idiomatic Clojure Protocols (count (obj :a 1 :b 2 :c 3)) => 3  (get (obj :a 1 :b 2 :c 3) ""a"") => 1  (nth (arr :0 :1 :2 :3 :4) 3) => :3  The purnam.native.functions namespace also provide additional manipulation functions like js-merge, js-merge-nil and js-deep-copy. More examples can be seen in the api). 3.4    DSL for Testing Choose between two styles of sytax for testing clojurescript code - jasmine style or midje style (in the purnam.test namespace). Or you can mix and match both of them together. e.3.12  -  testing - jasmine style (describe ""Addition""   (it ""should add things""     (is (+ 1 1) 2)     (is (+ 1 2) 3)     (is (+ 1 3) 4)     (is-not (+ 1 4) 0)))  e.3.13  -  testing - midje style (fact [[{:doc ""Addition should add things""}]]   (+ 1 1) => 2   (+ 1 2) => 3   (+ 1 3) => 4   (+ 1 4) => #(not= 0 %))  Although there are currently more features available when using the jasmine style syntax, using midje style syntax also allow compilation of your test files into beautiful documentation using midje-doc. The current document has been generated in this way. 4    purnam.native.functions Clojure protocols for javascript native objects and arrays. 4.1    init To use this package, require purnam.native.functions in your namespace (:require [purnam.native.functions :refer [js-lookup js-equals ....]])  Utility functions for javascript native objects and arrays. 4.2    js-lookup js-lookup is like get for native javascript. It works with keywords and strings (js-lookup (js* ""{a:1, b:2}"") ""a"")  => 1  (js-lookup (js* ""{a:1, b:2}"") :b)  => 2  4.3    js-equals js-equals checks for equality on native objects. The clojurescript equality = does not check for equality on native objects (= (js* ""{a:1}"") (js* ""{a:1}""))  => false?  js-equals fills this gap: (js-equals (js* ""{a:1}"") (js* ""{a:1}""))  => true  js-equals will also check equality for nested native objects and arrays (js-equals (js* ""{a:[{b: [{c: 1}]}]}"")            (js* ""{a:[{b: [{c: 1}]}]}""))  => true  4.4    js-assoc js-assoc is the native mutable version of assoc, it works with both keyword and string keys (def o (js* ""{a:1}""))  (js-assoc o ""b"" 2)  ;; string  => (js* ""{a:1,b:2}"")  (js-assoc o :c 3 ""d"" 4)  ;; keyword and string   => (js* ""{a:1,b:2,c:3,d:4}"")  js-assoc also works with native arrays and allows number keys (def o (array 0))  (js-assoc o ""1"" 1)   ;; string  => (array 0 1)  (js-assoc o 2 2)     ;; number  => (array 0 1 2)  4.5    js-dissoc js-dissoc is the native mutable version of dissoc, it works with both keyword and string keys (def o (js* ""{a:1,b:2,c:3,d:4}""))  (js-dissoc o ""a"" :b :c)  => (js* ""{d:4}"")  4.6    js-empty js-empty is the native mutable version of empty (def o (js* ""{a:1,b:2,c:3,d:4}""))  (js-empty o)  => (js-obj)  4.7    js-merge js-merge is the native mutable version of merge. It will only mutate the first object argument. (def o1 (js* ""{a:1}""))  (def o2 (js* ""{b:2}""))  (js-merge o1 o2)  => (js* ""{a:1,b:2}"")  If the keys are the same, it will overwrite (def o3 (js* ""{b:3}""))  (js-merge o1 o3)  => (js* ""{a:1,b:3}"")  4.8    js-merge-nil js-merge-nil is like js-merge but it will only merge the keys that are not defined (def o1 (js* ""{a:1}""))  (def o2 (js* ""{a:2,b:2}""))  (js-merge-nil o1 o2)  => (js* ""{a:1,b:2}"")  4.9    js-copy js-copy creates another object with the same key/values (def o1 (js* ""{a:1,b:2}""))  (def o2 (js-copy o1))  (js-equals o1 o2)  => true  (= o1 o2)  => false  4.10    js-deep-copy js-deep-copy copys everything about an object, including circular references (def o1 (js* ""function(){var a = {val:1}; a.ref = a; return a;}()""))  (def o2 (js-deep-copy o1))  Notice that we can walk o2. (aget o2 ""ref"" ""ref"" ""val"")  => 1  But o1 and o2 are not equal (= o1 o2)  => false?  And neither are the references (= (aget o1 ""ref"") (aget o2 ""ref""))  => false?  4.11    js-replace js-replace is like js-copy, but it uses keeps the pointer to the first object argument (def o1 (js* ""{a:1}""))  (js-replace o1 (js* ""{b:2}""))  o1  => (js* ""{b:2}"")  4.12    js-map A multi argument version of map, like clojure's map but returns a native arrays (js-map + (js* ""[1,2,3,4]"")            (js* ""[5,6,7,8]"")            [9 10 11 12])  => (js* ""[15,18,21,24]"")  4.13    js-concat Concats multiple arrays into a single native arrays (js-concat (js* ""[1,2,3,4]"")           (js* ""[5,6,7,8]"")           [9 10 11 12])  => (js* ""[1,2,3,4,5,6,7,8,9,10,11,12]"")  4.14    js-mapcat Like clojure's mapcat but returns a native arrays (js-mapcat list (js* ""[1,2,3,4]"")                  (js* ""[5,6,7,8]"")                  [9 10 11 12])  => (js* ""[1,5,9,2,6,10,3,7,11,4,8,12]"")  4.15    js-arities Returns all arities of a function. Works with f.n and def.n (js-arities (fn [x] x))  => [1]  5    purnam.native Clojure protocols for javascript native objects and arrays. 5.1    init To use this package, require purnam.native in your namespace (:require [purnam.native])  5.2    seq protocol The seq can now be used on native js arrays and objects. (seq (js* ""[1, 2, 3, 4]""))  => '(1 2 3 4)  (seq (js* ""{a:1, b:2}""))  => '([""a"" 1] [""b"" 2])  As well as all the built-in functionality that come with it. Although the datastructure then becomes a clojurescript lazyseq. (map #(* 2 %) (js* ""[1, 2, 3, 4]""))  => '(2 4 6 8)  (take 2 (js* ""[1, 2, 3, 4]""))  => '(1 2)  (count (js* ""[1, 2, 3, 4]""))  => 4  (get (js* ""[1, 2, 3, 4]"") ""1"")  => 2  (get-in (js* ""{a:{b:{c:1}}}"") (js* ""['a', 'b', 'c']""))  => 1  5.3    transient protocol Transient protocol allow native js objects arrays to be manipulated using assoc!, dissoc! and persistent! (let [o (js-obj)]   (assoc! o :a 1)   o)  => (js* ""{a:1}"")  (let [o (js* ""{a:1}"")]   (dissoc! o :a)   o)  => (js-obj)  (persistent! (js* ""{a:1}""))  => {:a 1}  5.4    collection protocol Extension of clojure collection protocols allow native js objects arrays to use conj, assoc and dissoc methods. (def o (js-obj))   (def o1 (conj o [:a 1]))   o => (js-obj)   o1 => (js* ""{a:1}"")     It works with both arrays and objects (conj (js* ""[1]"") 2 3)  => (js* ""[1,2,3]"")  (conj (js* ""{a:1}"") [:b 2] [:c 3])  => (js* ""{a:1,b:2,c:3}"")  (assoc (js* ""{a:1}"") :b 2 :c 3)  => (js* ""{a:1,b:2,c:3}"")  (dissoc (js* ""{a:1}"") :a)  => (js-obj)  6    purnam.core (set-safe-aget true)  6.1    init purnam.core extensions are packaged as macros. They are accessible via :use-macro declaration. (:use-macros [purnam.core :only [? ?> ! !> f.n def.n do.n                                 obj arr def* do*n def*n f*n]])  6.2    obj Raw js objects are constructed in clojurescript with obj: (obj ""key1"" ""val1"" ""key2"" ""val2"")  => (js* ""{key1: 'val1', key2: 'val2'}"")  Keywords can be used instead of strings for improved legibility. The previous example can also be written as: (obj :key1 ""val1"" :key2 ""val2"")  => (js* ""{key1: 'val1', key2: 'val2'}"")  Symbol are evalutated. This will produce an equivalent object to the previous examples: (let [s1 ""key1""       s2 ""key2""]   (obj s1 ""val1"" s2 ""val2""))  => (js* ""{key1: 'val1', key2: 'val2'}"")  Note that the symbols have to represent strings to get the same output as previous. The following WILL NOT construct the equivalent object as before: (let [s1 :key1       s2 :key2]   (obj s1 ""val1"" s2 ""val2""))  => #(not (= % (js* ""{key1: 'val1', key2: 'val2'}"")))  The obj form can be used to set up nested js objects and arrays primitives. Using [] with the form will create a new js array, {} will create a new js object. (obj :data [{:id 1 :name ""one""}             {:id 2 :name ""two""}])  => (js* ""{data: [{id:1,name:'one'},                  {id:2,name:'two'}]}"")  The nesting notation alleviates the use of the clj->js transform for constructing large javascipt variables. In this way, deeply nested javascript object structures can be created in clojurescript in the same way clojure maps and arrays are created. (obj :name ""l1"" :data [1 2 3]      :next {:name ""l2"" :data [4 5 6]             :next {:name ""l3"" :data [7 8 9]}})  => (js* ""{name: 'l1',           data: [1,2,3],           next: {name: 'l2',                  data: [4,5,6],                  next: {name: 'l3',                         data: [7,8,9]}}}"")  6.3    arr arr constructs a javascript array primitive, the same way as array (arr 1 2 3 4 5)  => (js* ""[1,2,3,4,5]"")  arr supports nesting of native objects and arrays much like obj (arr {:data [1 2 3 4 5]}      {:data [6 7 8 9 10]})  => (js* ""[{data: [1,2,3,4,5]},             {data: [6,7,8,9,10]}]"")  6.4    getter - ? ? provides javascript-like dot notation access for objects (let [o (obj :a 1 :b 2 :c 3)]   (+ (? o.a) (? o.b) (? o.c)))  => 6  Pipe notation object.|key| provides symbol lookup (let [o (obj :a 1 :b 2 :c 3)       k ""a""]   (- (? o.b) (? o.|k|)))  => 1  ? also works on javascript arrays (let [o (arr [1 2 3] [4 5 6] [7 8 9])]    (- (? o.2.2) (? o.0.0)))  => 8  If any of the keys are missing, ? will not throw an object undefined exception but will return nil. (let [o (obj)]   (? o.any.nested.syntax))  => nil?  6.5    setter - ! The ! form provides setting using dot notation: (let [o (obj)]   (! o.a 6)     (? o.a))  => 6  Pipe notation object.|key| also works (let [o (obj)       k ""a""]   (! o.|k| 6)   (? o.a))  => 6  If there is no value or the value is nil, ! will delete the key from the object: (let [o (obj :a 1)]   (! o.a)   o)  => (obj)  If the hierachy of nested objects does not exist, ! will create it (let [o (obj)]   (! o.a.b.c 10)   (? o.a.b.c))  => 10  If one of the keys in the object accessor is not an object, ! WILL NOT create nested structures (let [o (obj :a 1)]   (! o.a.b.c 10)   [(? o.a.b.c) (? o.a)])  => [nil 1]  6.6    call - ?> ?> allows function calls with dot-notation syntax. (let [o1 (obj :a 1)       o2 (obj :a 3)]   (?> + o1.a o2.a))  => 4  Inner forms within ?> are automatically interpreted using dot-notation. There is no need to write ?. (?> .map (arr {:a 1} {:a 2} {:a 3})          (fn [x] (inc x.a))) ;; no need to write (inc (? x.a))  => (arr 2 3 4)  6.7    call on - !> The !> form allows for writing dot-notation function calls. (let [a (arr)]   (!> a.push 1)   (!> a.push 2)   a)  => (arr 1 2)  We can also use pipe notation to dynamically invoke our function. (let [a (arr)       k ""push""]   (!> a.|k| 1)   (!> a.|k| 2)   a)  => (arr 1 2)  6.8    this The rational for adding this back into our language is that when a piece of a program really needs to work with existing javascript libraries (and it usually does), then clojurescript should give allow the flexibility to do that without adding additional noise to the code. Use with care! (let [o1 (obj :a 10                :func (fn [] this.a))       o2 (obj :a 20               :func o1.func)]   [(!> o1.func) (!> o2.func)])  => [10 20]  When this is nested, it works within the scope of the nested object (let [o (obj :a 10              :func (fn [] this.a)              :b {:a 20                  :func (fn [] this.a)})]   [(!> o.func) (!> o.b.func)])  => [10 20]  6.9    self A new existential construct has been added, it be use only within the obj form. It is used to refer to the object itself and does not change contexts the way this does. It provides a somewhat safer self reference which does not change when the context is changed. self is similar to this. Note that the two keywords both refer to the object itself. (let [o (obj :a 1              :thisfn (fn [] this.a)              :selffn (fn [] self.a))]     [(!> o.thisfn) (!> o.selffn)])  => [1 1]  We can quickly see the difference by creating another object. o1 has been initiated with functions defined o. If we invoke the o1 functions, it can be seen that the context for o.thisfn has changed and so it returns o1.a (2). While o1.selffn returns the value o.a (1) (let [o (obj :a 1              :thisfn (fn [] this.a)              :selffn (fn [] self.a))       o1 (obj :a 2              :thisfn o.thisfn              :selffn o.selffn)]   [(!> o1.thisfn) (!> o1.selffn)])  => [2 1]  A useful property of obj and self can be seen in the next example. Even though both have the same structure, self in a1 refers to a1 whereas self in a2 refers to a2.b. This was due to the fact that in a1, a hashmap was used to construct :b as opposed to the obj form in a2. (let [a1 (obj :a 1               :b {:a 2         ;; Note {} is used                   :func (fn [] self.a)})       a2 (obj :a 1               :b (obj :a 2   ;; Note obj is used                       :func (fn [] self.a)))]     [(!> a1.b.func) (!> a2.b.func)])  => [1 2]  6.10    def.n def.n allow construction of functions with the javascript dot-notation. Within the forms, there is no need to add ?, ?> and !> forms: ? getters are automatic (? a.b) => a.b  ?> call syntax is automatically applied (?> + a.b c.d) => (+ a.b c.d)  !> syntax is also automatically applied: (!> a.b c.d) => (a.b c.d)  The defn function: (defn dostuff0 [a b c]   (!> b.func 10 10)   (?> + a.val b.val)   (inc (? c.val)))  Can be written more succinctly using def.n: (def.n dostuff1 [a b c]   (b.func 10 10)   (+ a.val b.val)   (inc c.val))  6.11    f.n f.n is the equivalent dot-notation counterpart for fn (def dostuff2    (f.n [a b c]     (b.func 10 10)     (+ a.val b.val)     (inc c.val)))  6.12    do.n The do.n block is like do but allows dot-notation syntax: (do.n   (let [o (obj)]     (! o.val.a 1)     (! o.val.b 2)     (+ o.val.a o.val.b)))  => 3  6.13    raw forms For those that want to write clojurescript with {} interpreted as js objects and [] interpreted as arrays, then the raw js forms are very handy. def*, def*n, f*n and do*n allow this. The same function raw-fn can be defined the following four ways: (def raw-fn (f*n [o] (! o.val [1 2 3 4 5])))  (def* raw-fn (fn [o] (! o.val [1 2 3 4 5])))  (def*n raw-fn [o] (! o.val [1 2 3 4 5]))  (do*n (def raw-fn (fn [o] (! o.val [1 2 3 4 5]) o)))  where (raw-fn (obj))  => (obj :val [1 2 3 4 5])  Within the raw js form, self refers to the top level object. (def* o (obj :a 10              :b {:a 20                  :func (fn [] self.a)}))  (!> o.b.func)  => 10  The raw js forms will only recognise the cljs.core vector binding constructs: let, loop, for, doseq, if-let and when-let. Any custom macros within a raw form will run into problems. (set-safe-aget false)  7    purnam.test 7.1    init All tests require the following within the namespace declaration. (:require [purnam.test]) (:use-macros [purnam.test :only [describe it is is-not]])  PLEASE NOTE: (:require [purnam.test]) must be placed inside your namespace. This configures jasmine with the correct checker so that tests can be run. There will be random errors outputted without it when karma is run. 7.2    describe describe is the top-level form for testing. Its usage is in combination with the setup clause it and the checkers is and is-not. :globals sets up bindings for variables that can be manipulated but cannot be rebounded. :vars are allowed to be rebounded. e.7.1  -  describe purnam example (describe    {:doc ""an example test description""     :globals [ka ""a""               kb ""b""]     :vars [o (js* ""{a:1,b:2,c:3}"")            y (js* ""[[1, 2, 3],                     [4, 5, 6],                     [7, 8, 9]]"")]}     (it ""dot notation for native objects""        (is 1 o.a)        (is 6 (+ o.a o.b o.c)))     (it ""support for both native and cljs comparisons""        (is [1 2 3 4] [1 2 3 4]))     (it ""support for function comparison""        (is 2 even?)        (is-not 2 odd?)        (is 3 (comp not even?)))     (it ""globals""        (is o.|ka| 1)        (is 3 (+ o.|ka| o.|kb|))))  7.3    async An example of testing async functionality can be seen e.7.2  -  async macros (describe {:doc  ""Testing Async macros""            :vars [flag (atom false)                    value (atom 0)]}   (it ""Should support async execution of test preparation and exepectations""     (runs (js/setTimeout (fn [] (reset! flag true)) 500))     (waits-for ""Flag should be true"" 750 (swap! value inc) @flag)     (runs (is @flag true)           (is (> @value 0) true))))  7.4    fact fact is the default form for testing. It can currently only use the => checker and is a much lighter version of midje. However, it is enough for all but the most common cases. The describe example is rewritten below: e.7.3  -  fact form example (fact [[{:doc ""an example test description""          :globals [ka ""a""                    kb ""b""]          :vars [o (js* ""{a:1,b:2,c:3}"")                 y (js* ""[[1, 2, 3],                          [4, 5, 6],                          [7, 8, 9]]"")]}]]   ""dot notation for native objects""  o.a => 1  (+ o.a o.b o.c) => 6   ""support for both native and cljs comparisons""  o => (js* ""{a:1,b:2,c:3}"")  [1 2 3 4] => [1 2 3 4]    ""support for function comparison""   2 => even?   3 => (comp not even?)     ""globals""   o.|ka| => 1   (+ o.|ka| o.|kb|) => 3      ""vars are allowed to be rebound""                 (- y.2.2 y.0.0) => 8   )  7.5    facts facts and fact are interchangeable. The difference is how they are rendered in a document. See lein-midje-doc for more details. e.7.4  -  facts form example (facts [[{:doc ""Basic Hashmaps""           :globals [o {:a 1 :b 2 :c 3}]}]]   (o :a)       => 1    (o :a)       => #(not= 0 %)   (get o :b)   => 2   (:c o)       => 3   (select-keys o [:a :b]) => {:a 1 :b 2})  8    Running Tests To run tests, the karma test library is required. It can be installed using npm. There are two files that needs to be updated: /project.clj /karma.conf.jsIn project.clj, add your clojurescript builds. Usually the test code is built to a seperate file than the application code. In the following case, the tests are compiled to target/example-test.js. e.8.1  -  project.clj - cljsbuild :cljsbuild {:builds [{:source-paths [""src""]                       :compiler {:output-to ""target/example.js""                                  :optimizations :whitespace                                  :pretty-print true}}                      {:source-paths [""src"", ""test/cljs""]                       :compiler {:output-to ""target/example-test.js""                                  :optimizations :whitespace                                  :pretty-print true}}]}  A karma.conf.js file is required at the root level of your project. It is created by running karma init in the root project directory and following a bunch of instructions: Make sure that autoWatch is set to true and that the the compiled output from cljsbuild is included as one of the files. e.8.2  -  karma.conf.js ....      files: [     'target/example-test.js'   ],      autoWatch: true,      ....  Run in one window: lein cljsbuild auto. Run in another window: karma start. Note that you will have to restart karma if the *.js file was not found before the test runner starts. The following video shows the entire process in detail: 9    Generating Documentation If the midje flavor testing is used, MidjeDoc can be used to auto generate documentation from test cases. The following should be added to project.clj: e.9.1  -  project.clj - documentation :profiles {:dev {:plugins [...                            [lein-midje-doc ""0.0.18""]                            ... ]}}                             :documentation {:files {""index""                         {:input ""test/cljs/midje_doc/example_guide.cljs""                          :title ""example""                          :sub-title ""this is an example""                          :author ""Your Name""                          :email  ""example@email.com""                          :tracking ""UA-31320512-2""}}}  Running in a third window: lein midje-doc will watch files for changes and generate a pretty viewable output to index.html on any change. A demonstration of how this works can be seen here: 10    End Notes For any feedback, requests and comments, please feel free to lodge an issue on github or contact me directly. Chris."	"null"	"null"	"– A ClojureScript library designed to provide better clojurescript/javascript interop, testing and documentation tools."	"true"
"JavaScript Interoperability"	"Pylon"	"https://github.com/bodil/pylon"	"– A Javascript class system in 100% Clojurescript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"33"	"4"	"1"	"GitHub - bodil/pylon: A Javascript class system in 100% Clojurescript Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 4 Star 33 Fork 1 bodil/pylon Code Issues 0 Pull requests 0 Pulse Graphs A Javascript class system in 100% Clojurescript 22 commits 1 branch 2 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show 0.3.0 0.2.0 Nothing to show New pull request Latest commit a08a100 Jan 27, 2013 bodil Check that a deref conversion's second element is in fact a symbol be… … …fore operating on it as such. Permalink Failed to load latest commit information. src/pylon Check that a deref conversion's second element is in fact a symbol be… Jan 27, 2013 .gitignore Initial commit. Dec 31, 2012 README.md Bump docs. Jan 27, 2013 project.clj Bump for 0.3.0 release. Jan 27, 2013 pylon.gif Docs. Dec 31, 2012 README.md Pylon A Javascript class system in 100% Clojurescript. Rationale Class based OO is not cool. In fact, it's quite the opposite of the kind of code you should be writing as a Clojurescript developer. However, you sometimes find yourself having to deal with Javascript's ecosystem—certain of its more popular libraries in particular—out of necessity. Clojurescript's core interop facilities are fine for dealing with dumb JS objects, but when you have to get into more advanced OO—creating classes and subclasses—the primitives are no longer adequate. Pylon is intended as an interop facility. It is most emphatically not intended as a tool for turning Clojurescript into an OO language. Don't build your applications on it; be smart and use functional programming instead. Pylon is only for when you really need to deal with legacy Javascript code. Installation To use Pylon in your project, put the following in the :dependencies vector of your project.clj file: [org.bodil/pylon ""0.3.0""] Defining Classes Use the defclass macro to build Javascript style classes using Pylon. (ns pylon.test   (:require [pylon.classes])   (:use-macros [pylon.macros :only [defclass]]))  (defclass Hello   (defn constructor [name]     (set! @.name name))   (defn hello []     (console/log (str ""Hello "" @.name ""!""))))  (.hello (Hello. ""Kitty"")) ;; => ""Hello Kitty!"" Note that all methods have a this symbol available to them, just like in Javascript. Unlike in Javascript, it will always be bound to the actual object instance, even when passing an instance method as a callback. Notice the shorthand for referencing object properties: @.name anywhere inside a defclass is synonymous to (.-name this). Thus, to read a property foo on the current object, simply use @.foo, and to set the property, use (set! @.foo value). If foo is a method, you can invoke it directly using (@.foo), or with arguments, (@.foo ""bar"" ""gazonk""). (Note that this only works reliably on Pylon methods, as Clojurescript will clobber this when a function is called in this way.) Inheritance Pylon allows you to define inheritance using the :extends keyword, and call superclass methods using the super macro. (ns pylon.test   (:require [pylon.classes])   (:use-macros [pylon.macros :only [defclass super]]))  (defclass Hello   (defn constructor [name]     (set! @.name name))   (defn hello []     (console/log (str ""Hello "" @.name ""!""))))  (.hello (Hello. ""everypony"")) ;; => ""Hello everypony!""  (defclass HelloSailor :extends Hello   (defn constructor []     (super ""sailor"")))  (.hello (HelloSailor.)) ;; => ""Hello sailor!"" Mixins If you need multiple inheritance, you can use the :mixin keyword to extend your prototype further. Note that we've left the world of prototypal inheritance behind when we do this: properties are copied from the mixin objects into your object prototype; it does not actually add more parent prototypes, which would be impossible. License Copyright 2012 Bodil Stokke Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0. Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/bodil/pylon"	"– A Javascript class system in 100% Clojurescript."	"true"
"Miscellaneous"	"Automat"	"https://github.com/ztellman/automat"	"– A Clojure(Script) library for defining and using finite-state automata, inspired by Ragel."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"365"	"15"	"24"	"GitHub - ztellman/automat: better automata through combinators Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 15 Star 365 Fork 24 ztellman/automat Code Issues 13 Pull requests 1 Pulse Graphs better automata through combinators 107 commits 3 branches 3 releases Fetching contributors Clojure 95.9% Java 4.1% Clojure Java Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags doc-changes gh-pages master Nothing to show 0.1.3 0.1.2 0.1.0 Nothing to show New pull request Latest commit d1dc473 Jul 2, 2016 ztellman whoops, wrong reader syntax Permalink Failed to load latest commit information. docs fix image name Jun 7, 2014 src/automat whoops, wrong reader syntax Jul 2, 2016 test/automat Ported to cljc Feb 8, 2016 .gitignore Clojure 1.7 works Feb 8, 2016 .travis.yml remove Java 6 (ClojureScript does not support it) and add Java 8 to .… Feb 16, 2015 README.md update link to full documentation Jan 13, 2016 project.clj whoops, wrong reader syntax Jul 3, 2016 README.md Automat is a Clojure and ClojureScript library for defining and using finite-state automata, inspired by Ragel. However, instead of defining a DSL, it allows them to be built using simple composition of functions. These automata, once compiled, are quite fast. An array with 100 million elements can be processed in 500ms, giving a mean transition time of 5ns. However, Automat isn't just for high throughput use cases; it's meant to be useful wherever an FSM is necessary. [automat ""0.1.3""] Full documentation can be found here. defining an FSM A finite-state machine or finite-state automaton is defined as a series of states and transitions between these states, driven by a sequence of inputs. The automaton begins at a start state, and proceeds through the transitions until it reaches an accept state. If given an input that isn't a valid transition, the automaton may either reject the input sequence or reset to the beginning, depending on the use case. In Automat, the simplest automaton is simply a vector representing a chain of valid inputs. > (require '[automat.viz :refer (view)]) nil > (require '[automat.core :as a]) nil > (view [1 2 3]) The circle on the left is the start state, and the circle on the right with the double-lined border is the accept state. Note that the transitions don't have to be numbers: > (view [:foo ""bar"" 'baz]) Each argument to fsm can either be an input or another automaton. > (view [1 [2 [3]]]) Note that this is identical to the first automaton. If you want to consume inputs which are vectors without them being flattened, they can be represented as lists: > (view [1 '(2 (3))]) We can also combine existing automatons using the operators in automat.core: > (view (a/or [1 2 3] [1 3])) This represents the union of the two automata, and returns an automaton which will either accept 1, 2, 3 or 1, 3. If we want to accept a range of inputs, we can use ..: > (view [1 (a/.. 2 10) 11]) This will accept 1, 2, 11, 1, 3, 11, and so on. If we subsequently want to narrow this, we can use and: > (view     (a/and       [1 (a/.. 2 7) 11]       [1 (a/.. 6 12) 11])) This represents the intersection of two automata, in this case giving us an automaton that either accepts 1, 6, 11 or 1, 7, 11. Note that if the intersection is empty, this will give us an automaton that cannot accept anything. > (view (a/difference (a/.. 1 10) 2 (a/... 5 6))) This represents the difference between the automata, in this case an automata that accepts [1,10], less the inputs 2, 5, 6. The operators *, +, and ? behave as they do in regular expressions: > (view [(a/? 1) (a/* 2) (a/+ 3)]) This gives us an automaton that accepts zero or one 1 inputs, zero or more 2 inputs, and one or more 3 inputs. The not operator is equivalent to the regex ^ flag for negating character classes: > (view [1 (a/not 2) 3]) In this diagram, DEF represents the default transition (in this case, anything but 2), and REJ represents a rejection state. The DEF transition will consume the input, but the transition to the REJ state will not. using an FSM Once we've defined an FSM, we can compile it: (a/compile [1 2 3]) This will optimize the FSM, emit code that processes it, and call eval on it. The resulting compiled FSM can be interacted with via advance, find, greedy-find. These operations are pure, and can be safely called on multiple threads. Notice that when we visualize a compiled FSM, the states themselves are now labeled: > (view (a/compile [4 5 6])) The simplest way to interact with a compiled FSM is (advance fsm state input). It takes a state, which will be discussed later, and a single input. > (def f (a/compile [1 2 3])) #'f > (a/advance f nil 1) {:accepted? false  :checkpoint nil  :state-index 1  :start-index 0  :stream-index 1  :value nil} This returns a map representing the FSM state produced by the input. field description accepted? whether the FSM is at an accept state state-index the numeric identifier for the current FSM state, as shown by view start-index the stream index where the FSM last (re)started stream-index the current stream index checkpoint the previous match, only non-nil when used with greedy-find value the current reduce value, explained below This map can be passed back into advance as the state parameter: > (def adv (partial a/advance f)) #'adv > (-> nil (adv 1) (adv 2) (adv 3)) {:accepted? true  :checkpoint nil  :state-index 3  :start-index 0  :stream-index 3  :value nil} Notice that advance either accepts the map descriptor returned by a previous call to advance, or an arbitrary value, representing an initial value at the beginning of the FSM. The reasons for this are shown below. If we pass an input into advance that isn't accepted by the FSM, it will throw an exception. Alternately, we can pass an additional field into advance specifying what it should return if the input is rejected: > (a/advance f nil 42) IllegalArgumentException > (a/advance f nil 42 :error) :error Normal finite-state automata are represented only by the state-index. The additional fields give us some additional capabilities; of special interest is the value field, which allows us to treat the FSM as a pattern-matching reduction over a stream of values. We can define reduction operations within our FSM using the $ function: > (def f (a/compile            [1 2 3 (a/$ :complete)]            {:reducers {:complete (fn [state input] :completed)}}))) #'f > (view f) As shown here, the :complete action is something that's associated with the previous input, in this case 3. Then, when calling compile, we associate a reduce function with that action, which takes the current reduce :value and the latest input. In this case, it simply returns :completed when it gets the sequence [1 2 3]. > (def adv (partial a/advance f)) #'adv > (-> :incomplete (adv 1) (adv 2) :value) :incomplete > (-> :incomplete (adv 1) (adv 2) (adv 3) :value) :completed While this is a fairly trivial application, there are a wide variety of ways this can be used. For instance, this means that unlike a normal automaton, we can tell whether a list of parentheses are balanced, by tracking the number of un-closed parens in our :value. a short example For a more real-world use case, consider tracking browsing behavior on an online store. We want to see when the customer visits the cart, begins to checkout, but then returns back to the cart without having completed the checkout. Seeing this indecisive behavior, we can make a special offer. This means that we want to track this pattern: [:cart :checkout :cart] However, the user may wander around a bit, so we want to allow for arbitrary pages in between: > (def pages [:cart :checkout :cart]) #'pages > (def page-pattern     (vec       (interpose (a/* a/any) pages))) #'page-pattern > (view page-pattern) Here we've interposed (a/* a/any) between each transition, which will happily accept zero or more pages that don't match the expected pattern. However, the data that represents our pages is likely more complicated than just a keyword. Likely it will be a map describing the URL, the page contents, and so on. In this case, we want to define the :signal when compiling the FSM, which is a function that takes the raw input, and returns the signal that will actually be matched on. In this case, let's assume that each pageview is represented by a map with a :page-type field that will contain :cart, :checkout, and others. Let's also assume that we want to keep track of the full data for the cart and checkout pages. This is all fairly straightforward: > (def page-pattern     (->> [:cart :checkout :cart]          (map #(vector [% (a/$ :save)]))          (interpose (a/* a/any))          vec)) #'page-pattern  > (def f     (a/compile        [(a/$ :init)        page-pattern        (a/$ :offer)]        {:signal :page-type        :reducers {:init (fn [m _] (assoc m :offer-pages []))                   :save (fn [m page] (update-in m [:offer-pages] conj page))                   :offer (fn [m _] (assoc m :offer? true))}})) #'f > (view f) First, we take each of the notable pages and add a :save action to them. Then we interpose the wildcard matcher to each. Then we define reducer functions that saves the full page data under :offer-pages, and sets :offer? to true if we continue through the whole process. Notice that the first action doesn't have an associated input, it simply happens upon entering the FSM. Notice too that the final input has two associated actions. This is perfectly safe, but the order in which the actions occur is not well-defined, so they should always be indepenent of each other. If the same action is defined twice on a given transition, it will only be performed once. This is a fairly verbose way to define simple behavior, but it's worth noting that almost everything except for the [:cart :checkout :cart] sequence can be abstracted away. With the proper domain-specific scaffolding, this can be a powerful declarative mechanism. It's also easy to extend. Let's say that we want to save any :product pages the user visits, to better inform our offer. This is a fairly small modification: > (view     (->> [:cart :checkout :cart]          (map #(vector [% (a/$ :save)]))          (interpose            (a/*              (a/or                [:product (a/$ :save)]                a/any)))          vec)) As our desired behavior gets more complicated, they can still be defined as small, composable pieces of behavior. searching over streams find works similarly to regex matching. It takes the stream of inputs, which can be a byte-array, java.nio.Buffer, java.io.InputStream, java.io.Reader, or a normal Clojure sequence. The inputs in the FSM correspond to elements from these streams, which will be consumed until an accept state is reached, or the end of the stream is reached. In either case, find will return a new state. If a match is found, accepted? will be true, start-index will be the point within the stream where the match begins, and stream-index will be the point where the match ends. > (a/find f nil [1 2 3]) {:accepted? true, :checkpoint nil, :state-index 3, :start-index 0, :stream-index 3, :value nil} If accepted? is false, the start-index will describe where the FSM last restarted. This state can be passed into find with a new stream of inputs. > (a/find f nil [1 2 1 2]) {:accepted? false, :checkpoint nil, :state-index 2, :start-index 2, :stream-index 4, :value nil)} In either case, state-index will describe where we are in the actual compiled automaton. This can be correlated by calling automat.viz/view on a compiled FSM. When defining patterns that are subsets of each other, such as (or [1 2] [1 2 3]), find will always return upon matching the shortest of the two. If we want to match on the longest, we can use greedy-find instead. Note that greedy-find will always consume at least one more input than it needs for the match, which means that reduce actions used with it must not have side effects. When using $ for accumulation tasks with find or greedy-find, it can be tedious to place an accumulation reduce function in between every transition. In these cases, we can simply use interpose-$: > (def f     (a/compile       [($:clear) (a/interpose-$ :conj (range 5))]       {:clear (constantly [])        :conj conj})) #'f > (a/find f (a/start f nil) (range 5)) {:accepted? true, :checkpoint nil, :state-index 5, :start-index 0, :stream-index 5, :value [0 1 2 3 4]} Using $ can be a powerful tool, but it will have a performance impact - for high throughput use cases prefer using the :start-index and :stream-index values to pull out the input data in bulk. using in ClojureScript Automat in ClojureScript works just as it does in Clojure except that there is no ClojureScript version of automat.viz. Compiling FSMs can be slow if they have many states. While rarely a concern for JVM applications, quick startup time is often crucial for client-side JavaScript applications. If you find that compiling your ClojureScript FSMs is too slow, consider defining and precompiling them in Clojure: (ns clj.namespace   (:require    [automat.core :as a]))  (defmacro get-fsm []   (->> [:foo :bar :baz]        (a/interpose-$ :conj)        a/precompile)) (ns cljs.namespace   (:require    [automat.core :as a])   (:require-macros    [clj.namespace :refer [get-fsm]]))  (def fsm   (a/compile (get-fsm) {:reducers {:conj conj}}))  (defn fsm-find [input]   (a/find fsm nil input))  (fsm-find [:foo :bar :baz]) ;=> {:accepted? true, :checkpoint nil, :state-index 3, :start-index 0, :stream-index 3, :value (:baz :bar :foo)} license Copyright © 2014 Zachary Tellman Distributed under the MIT License Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/ztellman/automat"	"– A Clojure(Script) library for defining and using finite-state automata, inspired by Ragel."	"true"
"Miscellaneous"	"Bardo"	"https://github.com/pleasetrythisathome/bardo"	"– A Clojure(Script) library for functional interpolation and transitions."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"80"	"7"	"3"	"GitHub - pleasetrythisathome/bardo: A clojure(script) library to assist with transitions between dimensions Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 80 Fork 3 pleasetrythisathome/bardo Code Issues 0 Pull requests 0 Pulse Graphs A clojure(script) library to assist with transitions between dimensions 78 commits 1 branch 0 releases Fetching contributors Clojure 98.3% HTML 1.7% Clojure HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. dev examples resources src/bardo test/bardo .gitignore LICENSE README.md boot.properties build.boot README.md bardo A clojure(script) library to assist with transitions between dimensions. Bardo defines semantics for represting interpolators between data and provides a suite of tools for manipulating them. More eastern themed names! Really? But I have a good reason for this one, I promise! From wikipedia, The Tibetan word bardo (བར་དོ་ Wylie: bar do) means literally ""intermediate state"" —also translated as ""transitional state"" or ""in-between state"" or ""liminal state"".  Generally, the term ""bardo"" represents the inbetween state between life and death, during which one's consciousness is not connected to the outside world. Installation Bardo is available in clojars. Add this to your :dependencies vector. [bardo ""0.1.2-SNAPSHOT""] ;; import vars used in feature examples below. available in both clojure and clojurescript (ns bardo.features   (require [bardo.ease :refer [wrap ease shift clamp]]            [bardo.interpolate :refer [interpolate into-lazy-seq mix blend chain pipeline]]            [bardo.transition :refer [transition]] What is an interpolator? Bardo defines an interpolator as a higher order function that returns a single-arity function (fn [t]) where t is a float (<= 0 t 1) that produces a corresponding intermediate value. an interpolator between two numbers a and b can be defined as (defn intrpl-nums [a b]   (fn [t]     (+ a (* t (- b a)))))  (def zero->ten (intrpl-nums 0 10)) (zero->ten 0.5) ;; => 5.0 interpolators can be used to produce a sequence of values, or to produce an intermediate value at a point in time. We can produce sequences of values from an interpolator using normal clojure functions. (mapv zero->ten [0 0.5 1]) ;; => [0 5.0 10] You can produce lazy sequences using bardo.interpolate/into-lazy-seq (take 100 (interpolate/into-lazy-seq zero->ten (iterate #(/ % 2) 1))) ;; only 100 are computed Features Bardo provides features for automatic and extensible interpolation between values of a variety of types. (def times [0 0.5 1])  ;; primatives (map (interpolate 0 10) times) ;; => (0 5.0 10)  ;; sequences (map (interpolate [0 1] [5 9]) times) ;; => ([0 1] [2.5 5.0] [5 9])  (map (interpolate {:a 0 :b 1} {:a 5 :b 0}) times) ;; => ({:a 0, :b 1} {:b 0.5, :a 2.5} {:a 5, :b 0})  ;; different dimensions (map (interpolate [0] [5 9]) times) ;; => ([0] [2.5 4.5] [5 9]) (map (interpolate [0 nil] [5 9]) times) ;; => ([0 0] [2.5 4.5] [5 9])  (map (interpolate {:b 1} {:a 5}) times) ;; => ({:b 1} {:b 0.5, :a 2.5} {:a 5})  ;; coerce sequence types (map (interpolate [1 2] (repeat 5)) times) ;; => ([1 2] [3.0 3.5] [5 5])  (map (interpolate (repeat 5) (repeat 5)) times) ;; => java.lang.Exception: Cannot interpolate between two uncounted sequences  ;; throw errors if you can't interpolate (map (interpolate [1 2] {:a 5 :b 0}) times) ;; => java.lang.Exception: Cannot interpolate between a seq and something else  ;; make lazy sequences if you want them (take 10 (into-lazy-seq (interpolate 0 10) (range 0 1 (/ 1 10000))))  Compose interpolators (def times [0 0.25 0.5 0.75 1])  ;; interpolate between outputs (-> (interpolate 0 5)     (mix (interpolate 0 10))     (map times)) ;; => (0 1.5625 3.75 6.5625 10)  ;; blend to new target (-> (interpolate 0 5)     (blend 10)     (map times)) ;; => (0 3.4375 6.25 8.4375 10)  ;; chaining (-> (interpolate 0 5)     (chain 20)     (map times)) ;; => (0.0 2.5 5.0 12.5 20.0)  ;; set midpoint (-> (interpolate 0 5)     (chain 20 0.8)     (map times)) ;; => (0.0 1.5625 3.125 4.6875 20.0)  ;; pipeline (-> (pipeline [0 10 50 3000])     (map times)) ;; => (0.0 7.5 30.0 787.4999999999993 3000.0)  ;; set input steps (-> (pipeline [0 10 50 3000] [0 0.1 0.9 1])     (map times)) ;; => (0.0 17.5 30.0 42.5 3000.0)  Combine with easing functions (def times (concat (range 0 1 (/ 1 20)) [1])) (defn sig [n]   (fn [x]     (-> x         (* (Math/pow 10 n))         Math/round         (/ (Math/pow 10 n)))))  (-> (interpolate 0 5)     (wrap (ease :cubic-in-out))     (map times)     (->> (map (sig 2)))) ;; => (0.0 0.0 0.02 0.07 0.16 0.31 0.54 0.86 1.28 1.82 2.5 3.18 3.72 4.14 4.46 4.69 4.84 4.93 4.98 5.0 5.0)  (-> (interpolate 0 5)     (clamp)     (shift 0.5 1)     (map times)     (->> (map (sig 2)))) ;; => (0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0)  Output values over time (transition 0 5 {:duration 1000 :easing :cubic-in-out}) ;; => channel onto which values are placed that closes 1000ms later. ;; resolution is 60 values/second by default Easing Bardo defines an easing function as a single-arity function (fn [t] (f t)) where f produces a new value t. Easing functions are most commonly used to provide different curves to time values, but can be used to produce a varity of effects. (defn faster [t]   (+ 0.1 t)) (faster 0) ;; => 0.1  ;; we can also write this as a higher order function (defn easer [f]   (fn [t]     (f t))) (def faster (easer (partial + 0.1))) (faster 0) ;; => 0.1  Easing functions can also be used to define or change input boundaries. clamp and shift can be found in bardo.ease (defn clamp   [f]   (fn [t]     (f (cond         (< t 0) 0         (> t 1) 1         :else t))))  (def not-too-fast (easer (clamp #(/ % 2)))) (not-too-fast 1) ;; => 1/2 (not-too-fast 1.5) ;; => 1/2  (defn shift   ""shifts the domain of input from [cmin cmax] to [nmin nmax]""   ([f cmin cmax] (shift f cmin cmax 0 1))   ([f cmin cmax nmin nmax]      (fn [t]        (f (-> t               (- cmin)               (/ (- cmax cmin))               (* (- nmax nmin))               (+ nmin))))))  (def percent (shift slower 0 100)) (percent 50) ;; => 1/4 Bardo provides a higher level api for creating functions for common easing curves in bardo.ease/ease. All of the standard easing functions are provided in skewer case (ie. clj ""cubicInOut"" -> :cubic-in-out) (def cubic (ease/ease :cubic-in-out)) (mapv cubic (range 0 1 (/ 1 10))) ;; => [0.0 0.004 0.032 0.108 0.256 0.5 0.744 0.892 0.968 0.996] Interpolation Protocol Extension Bardo can automatically create interpolation functions from data. Bardo supports sequences, hashmaps, and numbers out of the box, but can be extended to support any clojure value. Interpolateable types satisfy: ;; perform interpolation (defprotocol IInterpolate   (-interpolate [start end]))  ;; return ""fresh"" value in case of nil or nonexistent (defprotocol IFresh   (fresh [x])) bardo.interpolate/interpolate provides an entry point that wraps nil values, checks for type compatibility, and wraps differently shaped data. interpolate should be used instead of -interpolate unless you want to bypass these wrapping mechanisms. Here's an example of extending bardo to interpolate between garden colors. (ns garden   (:require [bardo.interpolate :refer [IFresh IInterpolate -interpolate interpolate]]             [garden.color :as color]))  (extend-protocol IFresh   garden.color.CSSColor   (fresh [s]     (color/rgb 255 255 255)))  (extend-protocol IInterpolate   garden.color.CSSColor   (-interpolate [start end]     (let [[start end] (map color/as-rgb [start end])]       (fn [t]         (color/color+ start (color/color* t (color/color- end start)))))))  (-> (interpolate (color/hsl 10 50 50) (color/rgb 0 255 0))     (map [0 0.25 0.5 0.75 1])     clojure.pprint/pprint) ;; => ;; ({:alpha nil, ;;   :lightness nil, ;;   :saturation nil, ;;   :hue nil, ;;   :blue 64, ;;   :green 85, ;;   :red 191} ;;  {:red 191.0, ;;   :green 127.5, ;;   :blue 64.0, ;;   :hue nil, ;;   :saturation nil, ;;   :lightness nil, ;;   :alpha nil} ;;  {:red 191.0, ;;   :green 170.0, ;;   :blue 64.0, ;;   :hue nil, ;;   :saturation nil, ;;   :lightness nil, ;;   :alpha nil} ;;  {:red 191.0, ;;   :green 212.5, ;;   :blue 64.0, ;;   :hue nil, ;;   :saturation nil, ;;   :lightness nil, ;;   :alpha nil} ;;  {:alpha nil, ;;   :lightness nil, ;;   :saturation nil, ;;   :hue nil, ;;   :blue 64, ;;   :green 255, ;;   :red 191}) Examples and Development I've been using the boot build tool, it's great. To build bardo from source, install boot, and run boot development to get a full development setup complete with file server, cljx, cljs-repl, and js reloading. Graphics Integration Bardo is well suited for integration into graphical context like Om (or Reagent, Quil, libGDX, etc. etc.). A simple Om example using the transition helper. (defn mover   [{:keys [x y]} owner]   (reify     om/IInitState     (init-state [_]       {:x x        :y y})     om/IWillReceiveProps     (will-receive-props [_ {:keys [x y]}]       (let [[px py] ((juxt :x :y) (om/get-props owner))             intrpl-ch (transition {:x px :y py} {:x x :y y} {:duration 1000})]         (go-loop []           (when-let [{:keys [x y]} (<! intrpl-ch)]             (om/set-state! owner :x x)             (om/set-state! owner :y y)             (recur)))))     om/IRenderState     (render-state [_ {:keys [x y]}]       (html        [:div         {:style {:position ""fixed""                  :top y                  :left x}}         [:div          ""Location""]         [:div          (str ""x: "" (int x))]         [:div          (str ""y: "" (int y))]])))) Mixes between interpolators that represent overlapping time domains can be mixed by shifting the domains of the interpolators. (def a 0) (def b 10) (def intrpl (interpolate a b)) (map intrpl [0 0.5 1]) ;; => (0 5.0 10) ;; => (fn [t]) : t [0 -> 1] : a -> b  ;; interrupt at dt and interpolate to c (def dt 0.6) (def c 50) (def dintrpl (interpolate (intrpl dt) c)) (map dintrpl [0 0.5 1]) ;; => (6.0 28.0 50.0) ;; (fn [t]) : t [0 -> 1] : (intrpl dt) -> c  ;; to mix, we need to shift the domain of the input to intrpl (def sintrpl (ease/shift intrpl 0 (- 1 dt) dt 1)) (map sintrpl [0 (- 1 dt) 1]) ;; => (6.0 10.0 16.0) ;; we get a higher output at 1 because we've extended the domain ;; (fn [t]) ; t [0 -> (- 1 dt)] : (intrpl dt) -> b (-> identity     (ease/shift 0 (- 1 dt) dt 1)     (map [0 (- 1 dt) 1])) ;; => (0.6 1.0 1.6)  (def mixed (mix sintrpl dintrpl)) (map mixed [0 0.25 0.5 0.75 1]) ;; => (6.0 10.625 19.5 32.625 50.0) A full om example is here. More examples coming soon... Disclaimer Bardo is very much alpha software. It's been used in production in some form, but is still under active development. The API is subject to change. Thoughts, comments, feature, and pull requests welcome. License Copyright © 2014 Dylan Butman Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/pleasetrythisathome/bardo"	"– A Clojure(Script) library for functional interpolation and transitions."	"true"
"Miscellaneous"	"core.async"	"https://github.com/clojure/core.async/"	"– A Clojure(Script) library designed to provide facilities for async programming and communication."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"1189"	"152"	"132"	"GitHub - clojure/core.async: Facilities for async programming and communication in Clojure Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 152 Star 1,189 Fork 132 clojure/core.async Code Pull requests 1 Wiki Pulse Graphs Facilities for async programming and communication in Clojure 389 commits 14 branches 20 releases 13 contributors Clojure 93.6% HTML 4.5% Other 1.9% Clojure HTML Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags analyzer-rewrite analyzer cljs-message-channel forkjoin gh-pages ioc-work master meta-fixes net-channels optimize-cljs-timers optimize putret try-catch-bugs xfn-fixes Nothing to show v0.2.385 v0.2.382 v0.2.374 v0.2.371 v0.1.346.0 v0.1.338.0 v0.1.319.0 v0.1.303.0 v0.1.301.0 v0.1.298.0 v0.1.295.0 v0.1.278.0 v0.1.267.0 v0.1.262.0 v0.1.256.0 v0.1.242.0 v0.1.222.0 v0.1.221.0 v0.1.215.5 v0.0 Nothing to show New pull request Latest commit 43139e4 Jul 5, 2016 puredanger ASYNC-171 exclude bounded-count which was added in Clojure 1.9 Permalink Failed to load latest commit information. doc initial commit May 15, 2013 examples typo in walkthrough Jan 25, 2016 script use clojure 1.6.0 during release build Oct 19, 2015 src ASYNC-171 exclude bounded-count which was added in Clojure 1.9 Jul 5, 2016 .gitignore update cljsbuild, update builds, clean targets & ignores Feb 10, 2015 CONTRIBUTING.md Add github CONTRIBUTING file Dec 10, 2013 README.md Mark important Jun 22, 2016 VERSION_TEMPLATE change core.async release version template Oct 19, 2015 epl.html initial commit May 15, 2013 pom.template.xml bump tools.analyzer.jvm dep Jun 17, 2016 project.clj bump tools.analyzer.jvm dep Jun 17, 2016 README.md core.async A Clojure library designed to provide facilities for async programming and communication. Releases and Dependency Information Latest release: 0.2.385 All Released Versions Leiningen dependency information:  [org.clojure/clojure ""1.6.0""]  [org.clojure/core.async ""0.2.385""] Maven dependency information: <dependency>   <groupId>org.clojure</groupId>   <artifactId>core.async</artifactId>   <version>0.2.385</version> </dependency> Documentation Rationale API docs Code walkthrough Presentations Rich Hickey on core.async Tim Baldridge on core.async from Clojure/conj 2013 (code). Tim Baldridge on go macro internals - part 1 part 2 David Nolen core.async webinar Contributing Contributing to Clojure projects requires a signed Contributor Agreement. Pull requests and GitHub issues are not accepted; please use the core.async JIRA project to report problems or enhancements. License Copyright © 2013 Rich Hickey and contributors Distributed under the Eclipse Public License, the same as Clojure. Changelog Release 0.2.385 on 2016.06.17 Updated tools.analyzer.jvm version Release 0.2.382 on 2016.06.13 Important: Change default dispatch thread pool size to 8. Add Java system property clojure.core.async.pool-size to set the dispatch thread pool size ASYNC-152 - disable t.a.jvm's warn-on-reflection pass Release 0.2.374 on 2015.11.11 ASYNC-149 - fix error compiling recur inside case in a go block Updated tools.analyzer.jvm version (and other upstream deps) Updated to latest clojurescript and cljsbuild versions Release 0.2.371 on 2015.10.28 ASYNC-124 - dispatch multiple pending takers from expanding transducer ASYNC-103 - NEW promise-chan ASYNC-104 - NEW non-blocking offer!, poll! ASYNC-101 - async/reduce now respects reduced ASYNC-112 - replace ""transformer"" with ""transducer"" in deprecation messages ASYNC-6 - alts! docs updated to explicitly state ports is a vector Support (try (catch :default)) in CLJS exception handling Use cljs.test Updated tools.analyzer.jvm version (and other upstream deps) Release 0.1.346.0-17112a-alpha on 2014.09.22 cljs nextTick relies on goog.async.nextTick Updated docstring for put! re result on closed channel Release 0.1.338.0-5c5012-alpha on 2014.08.19 Add cljs transducers support Release 0.1.319.0-6b1aca-alpha on 2014.08.06 Add transducers support NEW pipeline Release 0.1.303.0-886421-alpha on 2014.05.08 Release 0.1.301.0-deb34a-alpha on 2014.04.29 Release 0.1.298.0-2a82a1-alpha on 2014.04.25 Release 0.1.278.0-76b25b-alpha on 2014.02.07 Release 0.1.267.0-0d7780-alpha on 2013.12.11 Release 0.1.262.0-151b23-alpha on 2013.12.10 Release 0.1.256.0-1bf8cf-alpha on 2013.11.07 Release 0.1.242.0-44b1e3-alpha on 2013.09.27 Release 0.1.222.0-83d0c2-alpha on 2013.09.12 Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/clojure/core.async/"	"– A Clojure(Script) library designed to provide facilities for async programming and communication."	"true"
"Miscellaneous"	"Entanglement"	"https://github.com/Frozenlock/entanglement"	"– It creates atoms from other atoms and links the data together."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"25"	"3"	"0"	"GitHub - Frozenlock/entanglement: ""Spooky action at a distance"" (between atoms) Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 25 Fork 0 Frozenlock/entanglement Code Issues 0 Pull requests 0 Pulse Graphs ""Spooky action at a distance"" (between atoms) 5 commits 1 branch 0 releases 1 contributor Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit ca07342 Feb 1, 2015 Frozenlock rationale Permalink Failed to load latest commit information. src/entanglement rationale Feb 1, 2015 test initial commit Jan 30, 2015 .gitignore initial commit Jan 31, 2015 LICENSE initial commit Jan 31, 2015 README.md rationale Feb 1, 2015 project.clj add optional 'derefer' Jan 31, 2015 quantum-entanglement1.png initial commit Jan 31, 2015 README.md Entanglement ""Spooky action at a distance"" -Einstein What if an atom could take its values from another atom? Same data, different representation.  ;; Those two atoms **SHARE THE SAME DATA**  atom-a  #<Atom: {:first-name Mike, :last-name Moran, :age 22, :sex M}>   atom-b  #<Atom: [Mike 22]>   ;; Being the same data, you can reset one...   (reset! atom-b [""Bob"" 35])  [""Bob"" 35]   ;; and the other will reflect this change!   atom-a  #<Atom: {:first-name ""Bob"", :last-name ""Moran"", :age 35, :sex ""M""}> You can now have an abstaction layer between your state (atom) and your program. Usage Add this to your project dependencies: In your namespace declaration: (:require [entanglement.core :refer [entangle]]). To re-create atom-a and atom-b from the example above: ;; Let's create the reference atom (def atom-a (atom {:first-name ""Mike"" :last-name ""Moran"" :age 22 :sex ""M""}))  ;; And now we make an atom taking values from the first atom: (def atom-b (entangle atom-a                       ;; getter function                       (fn [s-a]                         [(:first-name s-a) (:age s-a)])                       ;; setter function                       (fn [s-a new-value]                         (assoc s-a                           :first-name (first new-value)                           :age (last new-value)))                       ;;optional validator                       :validator                       (fn [new-value]                         (assert (-> new-value first string?) ""First value should be a string"")                         (assert (-> new-value last number?) ""Second value should be a number"")))) Rationale An atom is a nice state abstraction. You have this 'thing' that holds data and with which you must thread carefully. It has a limited set of functions to play with it (deref,reset!, swap!, add-watch/remove-watch). Simple, yet functional. The problem is that the atom does not necessarily match the simplest code architecture. If you build your code to reflect how the data is stored in the atom, you are adding complexity. The more detached the atom structure is from the code logic, the more you have to juggle the data around. It also means that your code becomes intertwined with this particular atom. Before you know it, your entire code base is dependant on one or more atoms having a particular structure. So long for reusable functions. Entanglement proproses to create atoms from other atoms and linking the data together. It lets you build an 'interface' that presents the data like you want it. Build your code in the simplest way possible, assuming the atom will match what you want. ;; what was... (swap! my-atom update-in [:some :path :that :might :be :quite :deep] my-fn)  ;; ...can now become  (swap! my-atom my-fn) ""Wait, this looks a lot like cursors?"" Right, because it is! In fact, cursors are a subset of entangled atoms. Here is an implement of cursors with entanglement: (defn cursor   ""Create a cursor. Behaves like a normal atom for the value at the   specified path.""   [a path]     (if-not (seq path) ;; if the path is emtpy, just return the atom...     a     (entangle a               #(get-in % path)               #(assoc-in %1 path %2)))) (Cursors are such a common case that we already provide the cursor function in entanglement.core.) Cursors, lenses, wraps... they are all symptomatic of the need to detach atom data structure from the code. Every atom made with entanglement is 100% opaque. From the functions point of view, it's just like any other atom. License Copyright (c) 2015 Frozenlock Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Frozenlock/entanglement"	"– It creates atoms from other atoms and links the data together."	"true"
"Miscellaneous"	"Garden"	"https://github.com/noprompt/garden"	"– A library for rendering CSS in Clojure and ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"678"	"32"	"41"	"GitHub - noprompt/garden: Generate CSS with Clojure Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 32 Star 678 Fork 41 noprompt/garden Code Issues 18 Pull requests 1 Wiki Pulse Graphs Generate CSS with Clojure 461 commits 1 branch 14 releases 11 contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v1.3.2 v1.3.1 v1.3.0 v1.1.7 v1.1.6 v1.1.5 v1.1.4 v1.1.3 v1.1.2 v1.1.1 v1.1.0 v1.0.2 v1.0.1 v1.0.0 Nothing to show New pull request Latest commit 98647de May 19, 2016 noprompt Call for help in the README Permalink Failed to load latest commit information. dev fix node repl script Feb 1, 2016 ideas Add experimental color namespace Nov 12, 2014 src/garden Housekeeping in garden.units namespace Feb 27, 2016 test/garden added weighted-mix helper Feb 3, 2016 .gitignore add manual build, npm source maps, and clj test Aug 6, 2015 ChangeLog.md up change history Aug 31, 2015 README.md Call for help in the README May 19, 2016 project.clj Set development version Feb 27, 2016 README.md Garden Garden is a library for rendering CSS in Clojure and ClojureScript. Conceptually similar to Hiccup, it uses vectors to represent rules and maps to represent declarations. It is designed for stylesheet authors who are interested in what's possible when you trade a preprocessor for a programming language. Table of Contents Getting Started Syntax Development Community Help! Getting Started Add the following dependency to your project.clj file: Garden 1.2.5 and below requires Clojure 1.6.0 and is known to work with ClojureScript 0.0-2342. However, starting with Garden 1.3.0 Garden requires Clojure 1.7 and ClojureScript 1.7.x to leverage a unified syntax with reader conditionals, and other major changes in the compiler and repl in Clojurescript. Syntax Garden syntax is very similar to Hiccup. If you're familiar with Hiccup you should feel right at home. If not, don't sweat it! Garden's syntax is simple. From your project's root directory start up a new REPL and try the following: user=> (require '[garden.core :refer [css]]) nil user=> (css [:body {:font-size ""16px""}]) ""body{font-size:16px}"" First you'll notice the use of the css function. This function takes an optional map of compiler flags, any number of rules, and returns a string of compiled CSS. Vectors represent rules in CSS. The first n non-collection elements of a vector depict the rule's selector where n > 0. When n = 0 the rule is not rendered. To produce a rule which selects the <h1> and <h2> HTML elements for example, we simply begin a vector with [:h1 :h2]: user=> (css [:h1 :h2 {:font-weight ""none""}]) ""h1,h2{font-weight:none}"" To target child selectors nested vectors may be employed: user=> (css [:h1 [:a {:text-decoration ""none""}]]) ""h1 a{text-decoration:none}"" user=> (css [:h1 :h2 [:a {:text-decoration ""none""}]]) ""h1 a, h2 a{text-decoration:none}"" As in Less/Sass, Garden also supports selectors prefixed with the & character allowing you to reference a parent selector: user=> (css [:a              {:font-weight 'normal               :text-decoration 'none}              [:&:hover               {:font-weight 'bold                :text-decoration 'underline}]]) ""a{text-decoration:none;font-weight:normal}a:hover{text-decoration:underline;font-weight:bold}"" A slightly more complex example demonstrating nested vectors with multiple selectors: user=> (css [:h1 :h2 {:font-weight ""normal""}              [:strong :b {:font-weight ""bold""}]]) ""h1,h2{font-weight:normal}h1 strong,h1 b,h2 strong,h2 b{font-weight:bold}"" garden.selectors namespace defines a CSSSelector record. It doubles as both a function and a literal (when passed to the css-selector). When the function is called it will return a new instance that possesses the same properties. All arguments to the function must satisfy ICSSSelector. garden.selectors namespace also defines these macros that create a selector record: defselector, defclass, defid, defpseudoclass and defpseudoelement. garden.selectors namespace also defines many CSSSelector instances such as: Type selectors a, abbr, address and more Pseudo-classes active, checked, disabled and more Language and negation pseudo-classes lang and not Structural pseudo-classes nth-child, nth-last-child, nth-of-type and nth-last-of-type Pseudo-elements after, before, first-letter and first-line Attribute selectors attr=, attr-contains, attr-starts-with, attr-starts-with*, attr-ends-with and attr-matches Combinators descendant, +, - and > Special selector & and allows to compose complex selectors such as this: (defselector *) (defpseudoclass host [x] x) (defpseudoelement content) (> (host (attr :flipped)) content (* last-child)) ;; => :host([flipped]) > ::content > *:last-child garden.selectors namespace also defines a CSS3 selectors's specificity function: (specificity ""#s12:not(FOO)"") ;; => 101 (specificity (a hover)) ;; => 10 Clojure maps represent CSS declarations where map keys and values represent CSS properties and values respectively. Garden's declaration syntax is a bit more involved than rules and understanding it is important to make the most of the library. Declaration map keys should either be a string, keyword, or symbol: user=> (css [:h1 {""font-weight"" ""normal""}]) ""h1{font-weight:normal}"" user=> (css [:h1 {:font-weight ""normal""}]) ""h1{font-weight:normal}"" user=> (css [:h1 {'font-weight ""normal""}]) ""h1{font-weight:normal}"" Be aware, Garden makes no attempt to validate your declarations and will not raise an error if other key types are used. user=> (css [:h1 {30000 ""nom-nom""}]) ""h1{30000:nom-nom}"" We've already seen strings used as declaration map values, but Garden also supports keywords, symbols, numbers, maps, vectors, and lists in addition. Strings, keywords, symbols, and numbers Strings, keywords, symbols, and numbers are rendered as literal CSS values: user=> (css [:body {:font ""16px sans-serif""}]) ""body{font:16px sans-serif}"" Be warned, you must escape literal string values yourself: user=> (css [:pre {:font-family ""\""Liberation Mono\"", Consolas, monospace""}]) ""pre{font-family:\""Liberation Mono\"", Consolas, monospace}"" Development Leiningen commands Building ClojureScript lein build-cljs  Starting a Node REPL lein node-repl  Run Clojure tests, along with a test runner lein test-clj  Run ClojureScript tests (on Node) lein test-cljs  Run both Clojure and ClojureScript tests lein test-cljc  Further Reading & Wiki Detailed documentation and a developer guide for Syntax, Rules, Declarations, and Plugins is under the community-contributed wiki. Please contribute! Contributors Listed by first commit: noprompt malcolmsparks jeluard ToBeReplaced migroh priyatam Help! This project is looking for team members who can help this project succeed! If you are interested in becoming a team member please open an issue. Community Mailing List Google Groups Slack #clojurescript or #css channel on Clojurians License Copyright © 2013-2016 Joel Holdbrooks. Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/noprompt/garden"	"– A library for rendering CSS in Clojure and ClojureScript."	"true"
"Miscellaneous"	"inflections-clj"	"https://github.com/r0man/inflections-clj"	"– Rails-like inflection library for Clojure and ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"125"	"5"	"13"	"GitHub - r0man/inflections-clj: Rails-like inflection library for Clojure and ClojureScript Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 125 Fork 13 r0man/inflections-clj Code Issues 1 Pull requests 0 Pulse Graphs Rails-like inflection library for Clojure and ClojureScript 388 commits 3 branches 27 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags cljx gh-pages master Nothing to show inflections-0.9.7 inflections-0.9.6 inflections-0.9.5 inflections-0.9.4 inflections-0.9.3 inflections-0.9.2 inflections-0.9.1 inflections-0.9.0 0.12.2 0.12.1 0.12.0 0.11.1 0.11.0 0.10.0 0.9.14 0.9.13 0.9.12 0.9.11 0.9.10 0.7.3 0.6.3 0.5.2 0.5.0 0.4 0.3 0.2 0.1 Nothing to show New pull request Latest commit 8402add May 13, 2016 r0man Version 0.12.3-SNAPSHOT Permalink Failed to load latest commit information. src/inflections Coerce back to keyword, string or symbol Feb 17, 2016 test/inflections Coerce back to keyword, string or symbol Feb 17, 2016 .gitignore ot camelize an capitalize working. Sep 17, 2013 .travis.yml Add eastwood Nov 23, 2014 COPYING Added COPYING. Feb 10, 2010 README.org Remove installation section Mar 16, 2016 project.clj Version 0.12.3-SNAPSHOT May 13, 2016 README.org Inflections Rails-like inflection library for Clojure and ClojureScript. Usage (use 'inflections.core)  (plural ""word"") ;=> ""words""  (plural ""virus"") ;=> ""viri""  (pluralize 12 ""virus"") ;=> ""12 viri""  (singular ""apples"") ;=> ""apple""  (singular ""octopi"") ;=> ""octopus""  (underscore ""puni-puni"") ;=> ""puni_puni""  (ordinalize ""52"") ;=> ""52nd""  (capitalize ""clojure"") ;=> ""Clojure""  License Copyright (C) 2013-2016 r0man Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/r0man/inflections-clj"	"– Rails-like inflection library for Clojure and ClojureScript."	"true"
"Miscellaneous"	"Instaparse"	"https://github.com/lbradstreet/instaparse-cljs"	"– It aims to be the simplest way to build parsers in ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"77"	"7"	"85"	"GitHub - lbradstreet/instaparse-cljs: Port of Instaparse to Clojurescript Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 77 Fork 85 lbradstreet/instaparse-cljs forked from Engelberg/instaparse Code Issues 1 Pull requests 0 Pulse Graphs Port of Instaparse to Clojurescript 645 commits 18 branches 25 releases 17 contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags 1.6 abnf cljc cljs-1.4.1 ebnf-combinator efficient-flatten errors index-meta-annotations master nullable-plus repeat-partial-alt-strategy repeat-partial segment stack transform v1.1 v1.2 whitespace Nothing to show v1.4.1.0 v1.3.3 v1.3.1 v1.3.0 v1.2.16 v1.2.15 v1.2.14 v1.2.13 v1.2.12 v1.2.11 v1.2.10 v1.2.9 v1.2.8 v1.2.7 v1.2.6 v1.2.5 v1.2.4 v1.2.3 v1.2.2 v1.2.1 v1.2.0 v1.1.0 v1.0.1 v1.0.0 v0.9 Nothing to show New pull request Pull request Compare This branch is 126 commits ahead, 11 commits behind Engelberg:master. Latest commit 73f3f90 Apr 25, 2016 lbradstreet Bump for snapshot Permalink Failed to load latest commit information. docs Add (as used in ABNF) for consistency Jun 22, 2015 images Redid image in 63dpi Jun 5, 2013 runner/cljs/runner Rework cljs test runner to exit with nonzero code upon failure Jun 17, 2015 src Add print-methods and toString to AutoFlattenSeq and FlattenOnDemandV… Apr 21, 2016 test Add test case to test printing behavior Apr 21, 2016 .gitattributes Retrying image Jun 5, 2013 .gitignore Updated ignore file Mar 31, 2014 CHANGES.md Updated changelog Jun 22, 2015 README.md Release 1.4.1.2 Apr 25, 2016 circle.yml Make cleantest only test cljs Jan 23, 2015 project.clj Bump for snapshot Apr 25, 2016 README.md Instaparse-cljs 1.4.1.2 What if context-free grammars were as easy to use as regular expressions? Clojurescript Port This is a an alpha quality Clojurescript port of Mark Engelberg's fantastic Instaparse library (https://github.com/Engelberg/instaparse). The Clojure code is still retained in this project, so it is still Clojure compatible. Once battle tested, the aim is to merge this upstream. Version numbers will track upstream, with the 4th versioning identifier signaling the port version. A few points of difference between the Clojure and Clojurescript versions of this library: Visualisation is not supported as it depends on Rhizome on the JVM. Slurping grammars is not supported, as slurp cannot be used from clojurescript. Tracing (introduced in Instaparse 1.4.0) is not supported. The Clojurescript version is slower by approximately a magnitude (tested with V8, :advanced compile). Performance with optimizations :none will be slower by around another factor of 3. Please let me know if you are using a grammar that performs especially badly in the Clojurescript version compared to the Clojure version. Any help with optimizations here would be appreciated. Note that some grammars will have a large upfront initial parsing cost that could be prohibitive for some client side use cases. Note that you can serialize the parsed grammars and load them client side, avoiding this cost. Features Instaparse aims to be the simplest way to build parsers in Clojure. Turns standard EBNF or ABNF notation for context-free grammars into an executable parser that takes a string as an input and produces a parse tree for that string. No Grammar Left Behind: Works for any context-free grammar, including left-recursive, right-recursive, and ambiguous grammars. Extends the power of context-free grammars with PEG-like syntax for lookahead and negative lookahead. Supports both of Clojure's most popular tree formats (hiccup and enlive) as output targets. Detailed reporting of parse errors. Optionally produces lazy sequence of all parses (especially useful for diagnosing and debugging ambiguous grammars). ""Total parsing"" mode where leftover string is embedded in the parse tree. Optional combinator library for building grammars programmatically. Performant. Quickstart Instaparse requires Clojure v1.5.1 or later. (It may work with earlier versions, but its speed relies extensively on features new to 1.5.) A Clojurescript port is also available. Add the following line to your leiningen dependencies: [com.lucasbradstreet/instaparse-cljs ""1.4.1.2""]  Require instaparse in your namespace header: (ns example.core   (:require [instaparse.core :as insta]))  Creating your first parser Here's a typical example of a context-free grammar one might see in a textbook on automata and/or parsing. It is a common convention in many textbooks to use the capital letter S to indicate the starting rule, so for this example, we'll follow that convention: S = AB* AB = A B A = 'a'+ B = 'b'+  This looks for alternating runs of 'a' followed by runs of 'b'. So for example ""aaaaabbaaabbb"" satisfies this grammar. On the other hand, ""aaabbbbaa"" does not (because the grammar specifies that each run of 'a' must be followed by a run of 'b'). With instaparse, turning this grammar into an executable parser is as simple as typing the grammar in: (def as-and-bs   (insta/parser     ""S = AB*      AB = A B      A = 'a'+      B = 'b'+""))  => (as-and-bs ""aaaaabbbaaaabb"") [:S  [:AB [:A ""a"" ""a"" ""a"" ""a"" ""a""] [:B ""b"" ""b"" ""b""]]  [:AB [:A ""a"" ""a"" ""a"" ""a""] [:B ""b"" ""b""]]]  At this point, if you know EBNF notation for context-free grammars, you probably know enough to dive in and start playing around. However, instaparse is rich with features, so if you want to know the full scope of what it can do, read on... Tutorial Notation Instaparse supports most of the common notations for context-free grammars. For example, a popular alternative to * is to surround the term with curly braces {}, and a popular alternative to ? is to surround the term with square brackets []. Rules can be specified with =, :, :=, or ::=. Rules can optionally end with ;. Instaparse is very flexible in terms of how you use whitespace (as in Clojure, , is treated as whitespace) and you can liberally use parentheses for grouping. Terminal strings can be enclosed in either single quotes or double quotes (however, since you are writing the grammar specification inside of a Clojure double-quoted string, any use of double-quotes would have to be escaped, therefore single-quotes are easier to read). Newlines are optional; you can put the entire grammar on one line if you desire. In fact, all these notations can be mixed up in the same specification if you want. So here is an equally valid (but messier) way to write out the exact same grammar, just to illustrate the flexibility that you have: (def as-and-bs-alternative   (insta/parser     ""S:={AB}  ;      AB ::= (A, B)      A : \""a\"" + ;      B ='b' + ;""))  Note that regardless of the notation you use in your specification, when you evaluate the parser at the REPL, the rules will be pretty-printed: => as-and-bs-alternative S = AB* AB = A B A = ""a""+ B = ""b""+  Here's a quick guide to the syntax for defining context-free grammars: Category Notations Example Rule : := ::= = S = A End of rule ; . (optional) S = A; Alternation | A | B Concatenation whitespace or , A B Grouping () (A | B) C Optional ? [] A? [A] One or more + A+ Zero or more * {} A* {A} String terminal """" '' 'a' ""a"" Regex terminal #"""" #'' #'a' #""a"" Epsilon Epsilon epsilon EPSILON eps ε """" '' S = 'a' S | Epsilon Comment (* *) (* This is a comment *) As is the norm in EBNF notation, concatenation has a higher precedence than alternation, so in the absence of parentheses, something like A B | C D means (A B) | (C D). Input from resource file Parsers can also be built from a specification contained in a file, either locally or on the web. For example, I stored on github a file with a simple grammar to parse text containing a single 'a' surrounded optionally by whitespace. The specification in the file looks like this: S = #""\s*"" ""a"" #""\s*""  Building the parser from the URI is easy: (insta/parser ""https://gist.github.com/Engelberg/5283346/raw/77e0b1d0cd7388a7ddf43e307804861f49082eb6/SingleA"")  This provides a convenienent way to share parser specifications over the Internet. You can also use a specification contained in a local resource in your classpath: (insta/parser (clojure.java.io/resource ""myparser.bnf""))  Escape characters Putting your grammar in a separate resource file has an additional advantage -- it provides a very straightforward ""what you see is what you get"" view of the grammar. The only escape characters needed are the ordinary escape characters for strings and regular expressions (additionally, instaparse also supports \' inside single-quoted strings). When you specify a grammar directly in your Clojure code as a double-quoted string, extra escape characters may be needed in the strings and regexes of your grammar: All "" string and regex delimiters must be turned into \"" or replaced with a single-quote '. All backslash characters in your strings and regexes \ should be escaped and turned into \\. (In some cases you can get away with not escaping the backslash, but it is best practice to be consistent and always do it.) For example, the above grammar could be written in Clojure as: (insta/parser ""S = #'\\s*' 'a' #'\\s*'"")  It is unfortunate that this extra level of escaping is necessary. Many programming languages provide some sort of facility for creating ""raw strings"" which are taken verbatim (e.g., Python's triple-quoted strings). I don't understand why Clojure does not support raw strings, but it doesn't. Fortunately, for many grammars this is a non-issue, and if the escaping does get bad enough to affect readability, there is always the option of storing the grammar in a separate file. Output format When building parsers, you can specify an output format of either :hiccup or :enlive. :hiccup is the default, but here is an example of the above parser with :enlive set as the output format: (def as-and-bs-enlive   (insta/parser     ""S = AB*      AB = A B      A = 'a'+      B = 'b'+""     :output-format :enlive))  => (as-and-bs-enlive ""aaaaabbbaaaabb"") {:tag :S,  :content  ({:tag :AB,    :content    ({:tag :A, :content (""a"" ""a"" ""a"" ""a"" ""a"")}     {:tag :B, :content (""b"" ""b"" ""b"")})}   {:tag :AB,    :content    ({:tag :A, :content (""a"" ""a"" ""a"" ""a"")}     {:tag :B, :content (""b"" ""b"")})})}  I find the hiccup format to be pleasant and compact, especially when working with the parsed output in the REPL. The main advantage of the enlive format is that it allows you to use the very powerful enlive library to select and transform nodes in your tree. If you want to alter instaparse's default output format: (insta/set-default-output-format! :enlive)  Controlling the tree structure The principles of instaparse's output trees: Every rule equals one level of nesting in the tree. Each level is automatically tagged with the name of the rule. To better understand this, take a look at these two variations of the same parser we've been discussing: (def as-and-bs-variation1   (insta/parser     ""S = AB*      AB = 'a'+ 'b'+""))  => (as-and-bs-variation1 ""aaaaabbbaaaabb"") [:S  [:AB ""a"" ""a"" ""a"" ""a"" ""a"" ""b"" ""b"" ""b""]  [:AB ""a"" ""a"" ""a"" ""a"" ""b"" ""b""]]  (def as-and-bs-variation2   (insta/parser     ""S = ('a'+ 'b'+)*""))  => (as-and-bs-variation2 ""aaaaabbbaaaabb"") [:S ""a"" ""a"" ""a"" ""a"" ""a"" ""b"" ""b"" ""b"" ""a"" ""a"" ""a"" ""a"" ""b"" ""b""]  Hiding content For this next example, let's consider a parser that looks for a sequence of a's or b's surrounded by parens. (def paren-ab   (insta/parser     ""paren-wrapped = '(' seq-of-A-or-B ')'      seq-of-A-or-B = ('a' | 'b')*""))  => (paren-ab ""(aba)"") [:paren-wrapped ""("" [:seq-of-A-or-B ""a"" ""b"" ""a""] "")""]  It's very common in parsers to have elements that need to be present in the input and parsed, but we'd rather not have them appear in the output. In the above example, the parens are essential to the grammar yet the tree would be much easier to read and manipulate if we could hide those parens; once the string has been parsed, the parens themselves carry no additional semantic value. In instaparse, you can use angle brackets <> to hide parsed elements, suppressing them from the tree output. (def paren-ab-hide-parens   (insta/parser     ""paren-wrapped = <'('> seq-of-A-or-B <')'>      seq-of-A-or-B = ('a' | 'b')*""))  => (paren-ab-hide-parens ""(aba)"") [:paren-wrapped [:seq-of-A-or-B ""a"" ""b"" ""a""]]  Voila! The parens ""("" and "")"" tokens have been hidden. Angle brackets are a powerful tool for hiding whitespace and other delimiters from the output. Hiding tags Continuing with the same example parser, let's say we decide that the :seq-of-A-or-B tag is also superfluous -- we'd rather not have that extra nesting level appear in the output tree. We've already seen that one option is to simply lift the right-hand side of the seq-of-A-or-B rule into the paren-wrapped rule, as follows: (def paren-ab-manually-flattened   (insta/parser     ""paren-wrapped = <'('> ('a'|'b')* <')'>""))  => (paren-ab-manually-flattened ""(aba)"") [:paren-wrapped ""a"" ""b"" ""a""]  But sometimes, it is ugly or impractical to do this. It would be nice to have a way to express the concept of ""repeated sequence of a's and b's"" as a separate rule, without necessarily introducing an additional level of nesting. Again, the angle brackets come to the rescue. We simply use the angle brackets to hide the name of the rule. Since each name corresponds to a level of nesting, hiding the name means the parsed contents of that rule will appear in the output tree without the tag and its associated new level of nesting. (def paren-ab-hide-tag   (insta/parser     ""paren-wrapped = <'('> seq-of-A-or-B <')'>      <seq-of-A-or-B> = ('a' | 'b')*""))  => (paren-ab-hide-tag ""(aba)"") [:paren-wrapped ""a"" ""b"" ""a""]  You might wonder what would happen if we hid the root tag as well. Let's take a look: (def paren-ab-hide-both-tags   (insta/parser     ""<paren-wrapped> = <'('> seq-of-A-or-B <')'>      <seq-of-A-or-B> = ('a' | 'b')*""))  => (paren-ab-hide-both-tags ""(aba)"") (""a"" ""b"" ""a"")  With no root tag, the parser just returns a sequence of children. So in the above example where all the tags are hidden, you just get a sequence of parsed elements. Sometimes that's what you want, but in general, I recommend that you don't hide the root tag, ensuring the output is a well-formed tree. Revealing hidden information Sometimes, after setting up the parser to hide content and tags, you temporarily want to reveal the hidden information, perhaps for debugging purposes. The optional keyword argument :unhide :content reveals the hidden content in the tree output. => (paren-ab-hide-both-tags ""(aba)"" :unhide :content) (""("" ""a"" ""b"" ""a"" "")"")  The optional keyword argument :unhide :tags reveals the hidden tags in the tree output. => (paren-ab-hide-both-tags ""(aba)"" :unhide :tags) [:paren-wrapped [:seq-of-A-or-B ""a"" ""b"" ""a""]]  The optional keyword argument :unhide :all reveals all hidden information. => (paren-ab-hide-both-tags ""(aba)"" :unhide :all) [:paren-wrapped ""("" [:seq-of-A-or-B ""a"" ""b"" ""a""] "")""]  No Grammar Left Behind One of the things that really sets instaparse apart from other Clojure parser generators is that it can handle any context-free grammar. For example, some parsers only accept LL(1) grammars, others accept LALR grammars. Many of the libraries use a recursive-descent strategy that fails for left-recursive grammars. If you are willing to learn the esoteric restrictions posed by the library, it is usually possible to rework your grammar to fit that mold. But instaparse lets you write your grammar in whatever way is most natural. Right recursion No problem: => ((insta/parser ""S = 'a' S | Epsilon"") ""aaaa"") [:S ""a"" [:S ""a"" [:S ""a"" [:S ""a"" [:S]]]]]  Note the use of Epsilon, a common name for the ""empty"" parser that always succeeds without consuming any characters. You can also just use an empty string if you prefer. Left recursion No problem: => ((insta/parser ""S = S 'a' | Epsilon"") ""aaaa"") [:S [:S [:S [:S [:S] ""a""] ""a""] ""a""] ""a""]  As you can see, either of these recursive parsers will generate a parse tree that is deeply nested. Unfortunately, Clojure does not handle deeply-nested data structures very well. If you were to run the above parser on, say, a string of 20,000 a's, instaparse will happily try to generate the corresponding parse tree but then Clojure will stack overflow when it tries to hash the tree. So, as is often advisable in Clojure, use recursion judiciously in a way that will keep your trees a manageable depth. For the above parser, it is almost certainly better to just do: => ((insta/parser ""S = 'a'*"") ""aaaa"") [:S ""a"" ""a"" ""a"" ""a""]  Infinite loops If you specify an unterminated recursive grammar, instaparse will handle that gracefully as well and terminate with an error, rather than getting caught in an infinite loop: => ((insta/parser ""S = S"") ""a"") Parse error at line 1, column 1: a ^  Ambiguous grammars (def ambiguous   (insta/parser     ""S = A A      A = 'a'*""))  This grammar is interesting because even though it specifies a repeated run of a's, there are many possible ways the grammar can chop it up. Our parser will faithfully return one of the possible parses: => (ambiguous ""aaaaaa"") [:S [:A ""a""] [:A ""a"" ""a"" ""a"" ""a"" ""a""]]  However, we can do better. First, I should point out that (ambiguous ""aaaaaa"") is really just shorthand for (insta/parse ambiguous ""aaaaaa""). Parsers are not actually functions, but are records that implement the function interface as a shorthand for calling the insta/parse function. insta/parse is the way you ask a parser to produce a single parse tree. But there is another library function insta/parses that asks the parser to produce a lazy sequence of all parse trees. Compare: => (insta/parse ambiguous ""aaaaaa"") [:S [:A ""a""] [:A ""a"" ""a"" ""a"" ""a"" ""a""]]  => (insta/parses ambiguous ""aaaaaa"") ([:S [:A ""a""] [:A ""a"" ""a"" ""a"" ""a"" ""a""]]  [:S [:A ""a"" ""a"" ""a"" ""a"" ""a"" ""a""] [:A]]  [:S [:A ""a"" ""a""] [:A ""a"" ""a"" ""a"" ""a""]]  [:S [:A ""a"" ""a"" ""a""] [:A ""a"" ""a"" ""a""]]  [:S [:A ""a"" ""a"" ""a"" ""a""] [:A ""a"" ""a""]]  [:S [:A ""a"" ""a"" ""a"" ""a"" ""a""] [:A ""a""]]  [:S [:A] [:A ""a"" ""a"" ""a"" ""a"" ""a"" ""a""]])  You may wonder, why is this useful? Two reasons: Sometimes it is difficult to remove ambiguity from a grammar, but the ambiguity doesn't really matter -- any parse tree will do. In these situations, instaparse's ability to work with ambiguous grammars can be quite handy. Instaparse's ability to generate a sequence of all parses provides a powerful tool for debugging and thus removing ambiguity from an unintentionally ambiguous grammar. It turns out that when designing a context-free grammar, it's all too easy to accidentally introduce some unintentional ambiguity. Other parser tools often report ambiguities as cryptic ""shift-reduce"" messages, if at all. It's rather empowering to see the precise parse that instaparse finds when multiple parses are possible. I generally test my parsers using the insta/parses function so I can immediately spot any ambiguities I've inadvertently introduced. When I'm confident the parser is not ambiguous, I switch to insta/parse or, equivalently, just call the parser as if it were a function. Regular expressions: A word of warning As you can see from the above example, instaparse flexibly interprets * and +, trying all possible numbers of repetitions in order to create a parse tree. It is easy to become spoiled by this, and then forget that regular expressions have different semantics. Instaparse's regular expressions are just Clojure/Java regular expressions, which behave in a greedy manner. To better understand this point, contrast the above parser with this one: (def not-ambiguous   (insta/parser     ""S = A A      A = #'a*'""))  => (insta/parses not-ambiguous ""aaaaaa"") ([:S [:A ""aaaaaa""] [:A """"]])  In this parser, the * is inside the regular expression, which means that it follows greedy regular expression semantics. Therefore, the first A eats all the a's it can, leaving no a's for the second A. For this reason, it is wise to use regular expressions judiciously, mainly to express the patterns of your tokens, and leave the overall task of parsing to instaparse. Regular expressions can often be tortured and abused into serving as a crude parser, but don't do it! There's no need; with instaparse, you now have an equally convenient but more expressive tool to bring to bear on parsing problems. Here is an example that I think is a tasteful use of regular expressions to split a sentence on whitespaces, categorizing the tokens as words or numbers: (def words-and-numbers   (insta/parser     ""sentence = token (<whitespace> token)*      <token> = word | number      whitespace = #'\\s+'      word = #'[a-zA-Z]+'      number = #'[0-9]+'""))  => (words-and-numbers ""abc 123 def"") [:sentence [:word ""abc""] [:number ""123""] [:word ""def""]]  Partial parses By default, instaparse assumes you are looking for a parse tree that covers the entire input string. However, sometimes it may be useful to look at all the partial parses that satisfy the grammar while consuming some initial portion of the input string. For this purpose, both insta/parse and insta/parses take a keyword argument, :partial that you simply set to true. (def repeated-a   (insta/parser     ""S = 'a'+""))  => (insta/parses repeated-a ""aaaaaa"") ([:S ""a"" ""a"" ""a"" ""a"" ""a"" ""a""]) => (insta/parses repeated-a ""aaaaaa"" :partial true) ([:S ""a""]  [:S ""a"" ""a""]  [:S ""a"" ""a"" ""a""]  [:S ""a"" ""a"" ""a"" ""a""]  [:S ""a"" ""a"" ""a"" ""a"" ""a""]  [:S ""a"" ""a"" ""a"" ""a"" ""a"" ""a""])  Of course, using :partial true with insta/parse means that you'll only get the first parse result found.  => (insta/parse repeated-a ""aaaaaa"" :partial true) [:S ""a""]  PEG extensions PEGs are a popular alternative to context-free grammars. On the surface, PEGs look very similar to CFGs, but the various choice operators are meant to be interpreted in a strictly greedy, ordered way that removes any ambiguity from the grammar. Some view this lack of ambiguity as an advantage, but it does limit the expressiveness of PEGs relative to context-free grammars. Furthermore, PEGs are usually tightly coupled to a specific parsing strategy that forbids left-recursion, further limiting their utility. To combat that lost expressiveness, PEGs adopted a few operators that actually allow PEGs to do some things that CFGs cannot express. Even though the underlying paradigm is different, I've swiped these juicy bits from PEGs and included them in instaparse, giving instaparse more expressive power than either traditional PEGs or traditional CFGs. Here is a table of the PEG operators that have been adapted for use in instaparse; I'll explain them in more detail shortly. Category Notations Example Lookahead & &A Negative lookahead ! !A Ordered Choice / A / B Lookahead The symbol for lookahead is &, and is generally used as part of a chain of concatenated parsers. Lookahead tests whether there are some number of characters that lie ahead in the text stream that satisfy the parser. It performs this test without actually ""consuming"" characters. Only if that lookahead test succeeds do the remaining parsers in the chain execute. That's a mouthful, and hard to understand in the abstract, so let's look at a concrete example: (def lookahead-example   (insta/parser     ""S = &'ab' ('a' | 'b')+""))  The ('a' | 'b')+ part should be familiar at this point, and you hopefully recognize this as a parser that ensures the text is a string entirely of a's and b's. The other part, &'ab' is the lookahead. Notice how the & precedes the expression it is operating on. Before processing the ('a' | 'b')+, it looks ahead to verify that the 'ab' parser could hypothetically be satisfied by the upcoming characters. In other words, it will only accept strings that start off with the characters ab. => (lookahead-example ""abaaaab"") [:S ""a"" ""b"" ""a"" ""a"" ""a"" ""a"" ""b""] => (lookahead-example ""bbaaaab"") Parse error at line 1, column 1: bbaaaab ^ Expected: ""ab""  If you write something like &'a'+ with no parens, this will be interpreted as &('a'+). Here is my favorite example of lookahead, a parser that only succeeds on strings with a run of a's followed by a run of b's followed by a run of c's, where each of those runs must be the same length. If you've ever taken an automata course, you may remember that there is a very elegant proof that it is impossible to express this set of constraints with a pure context-free grammar. Well, with lookahead, it is possible: (def abc   (insta/parser     ""S = &(A 'c') 'a'+ B      A = 'a' A? 'b'      <B> = 'b' B? 'c'""))  => (abc ""aaabbbccc"") [:S ""a"" ""a"" ""a"" ""b"" ""b"" ""b"" ""c"" ""c"" ""c""]  This example succeeds because there are three a's followed by three b's followed by three c's. Verifying that this parser fails for unequal runs and other mixes of letters is left as an exercise for the reader. Negative lookahead Negative lookahead uses the symbol !, and like &, it precedes the expression. It does exactly what you'd expect -- it performs a lookahead and confirms that the parser is not satisfied by the upcoming characters in the screen. (def negative-lookahead-example   (insta/parser     ""S = !'ab' ('a' | 'b')+""))  So this parser turns around the meaning of the previous example, accepting all strings of a's and b's that don't start off with ab. => (negative-lookahead-example ""abaaaab"") Parse error at line 1, column 1: abaaaab ^ Expected: NOT ""ab"" => (negative-lookahead-example ""bbaaaab"") [:S ""b"" ""b"" ""a"" ""a"" ""a"" ""a"" ""b""]  One issue with negative lookahead is that it introduces the possibility of paradoxes. Consider: S = !S 'a'  How should this parser behave on an input of ""a""? If S succeeds, it should fail, and if it fails it should succeed. PEGs simply don't allow this sort of grammar, but the whole spirit of instaparse is to flexibly allow recursive grammars, so I needed to find some way to handle it. Basically, I've taken steps to make sure that a paradoxical grammar won't cause instaparse to go into an infinite loop. It will terminate, but I make no promises about what the results will be. If you specify a paradoxical grammar, it's a garbage-in-garbage-out kind of situation (although to be clear, instaparse won't return complete garbage; it will make some sort of reasonable judgment about how to interpret it). If you're curious about how instaparse behaves with the above paradoxical example, here it is: => ((insta/parser ""S = !S 'a'"") ""a"") [:S ""a""]  Negative lookahead, when used properly, is an extremely powerful tool for removing ambiguity from your parser. To illustrate this, let's take a look at a very common parsing task, which involves tokenizing a string of characters into a combination of identifiers and reserved keywords. Our first attempt at this ends up ambiguous: (def ambiguous-tokenizer   (insta/parser     ""sentence = token (<whitespace> token)*      <token> = keyword | identifier      whitespace = #'\\s+'      identifier = #'[a-zA-Z]+'      keyword = 'cond' | 'defn'""))  => (insta/parses ambiguous-tokenizer ""defn my cond"") ([:sentence [:identifier ""defn""] [:identifier ""my""] [:identifier ""cond""]]  [:sentence [:keyword ""defn""] [:identifier ""my""] [:identifier ""cond""]]  [:sentence [:identifier ""defn""] [:identifier ""my""] [:keyword ""cond""]]  [:sentence [:keyword ""defn""] [:identifier ""my""] [:keyword ""cond""]])  Each of our keywords not only fits the description of keyword, but also of identifier, so our parser doesn't know which way to parse those words. Instaparse makes no guarantee about what order it processes alternatives, and in this situation, we see that in fact, the combination we wanted was listed last among the possible parses. Negative lookahead provides an easy way to remove this ambiguity: (def unambiguous-tokenizer   (insta/parser     ""sentence = token (<whitespace> token)*      <token> = keyword | !keyword identifier      whitespace = #'\\s+'      identifier = #'[a-zA-Z]+'      keyword = 'cond' | 'defn'""))  => (insta/parses unambiguous-tokenizer ""defn my cond"") ([:sentence [:keyword ""defn""] [:identifier ""my""] [:keyword ""cond""]])  Ordered choice As I mentioned earlier, a PEG's interpretation of +, *, and | are subtly different from the way those symbols are interpreted in CFGs. + and * are interpreted greedily, just as they are in regular expressions. | proceeds in a rather strict order, trying the first alternative first, and only proceeding if that one fails. To remind users that these multiple choices are strictly ordered, PEGs commonly use the forward slash / rather than |. Although the PEG paradigm of forced order is antithetical to instaparse's flexible parsing strategy, I decided to co-opt the / notation to express a preference of one alternative over another. With that in mind, let's look back at the ambiguous-tokenizer example from the previous section. In that example, we found that our desired parse, in which the keywords were classified, ended up at the bottom of the heap: => (insta/parses ambiguous-tokenizer ""defn my cond"") ([:sentence [:identifier ""defn""] [:identifier ""my""] [:identifier ""cond""]]  [:sentence [:keyword ""defn""] [:identifier ""my""] [:identifier ""cond""]]  [:sentence [:identifier ""defn""] [:identifier ""my""] [:keyword ""cond""]]  [:sentence [:keyword ""defn""] [:identifier ""my""] [:keyword ""cond""]])  We've already seen one way to remove the ambiguity by using negative lookahead. But now we have another tool in our toolbox, /, which will allow the ambiguity to remain, while bringing the desired parse result to the top of the list. (def preferential-tokenizer   (insta/parser     ""sentence = token (<whitespace> token)*      <token> = keyword / identifier      whitespace = #'\\s+'      identifier = #'[a-zA-Z]+'      keyword = 'cond' | 'defn'""))  => (insta/parses preferential-tokenizer ""defn my cond"") ([:sentence [:keyword ""defn""] [:identifier ""my""] [:keyword ""cond""]]  [:sentence [:identifier ""defn""] [:identifier ""my""] [:keyword ""cond""]]  [:sentence [:keyword ""defn""] [:identifier ""my""] [:identifier ""cond""]]  [:sentence [:identifier ""defn""] [:identifier ""my""] [:identifier ""cond""]])  The ordered choice operator has its uses, but don't go overboard. There are two main reasons why it is generally better to use the regular unordered alternation operator. When ordered choice interacts with a complex mix of recursion, other ordered choice operators, and indeterminate operators like + and *, it can quickly become difficult to reason about how the parsing will actually play out. The next version of instaparse will support multithreading. In that version, every use of | will be an opportunity to exploit parallelism. On the contrary, uses of / will create a bottleneck where options have to be pursued in a specific order. Parse errors (insta/parse my-parser ""parse this text"") will either return a parse tree or a failure object. The failure object will pretty-print at the REPL, showing you the furthest point it reached while parsing your text, and listing all the possible tokens that would have allowed it to proceed. (insta/parses my-parser ""parse this text"") will return a sequence of all the parse trees, so in the event that no parse can be found, it will simply return an empty list. However, the failure object is still there, attached to the empty list as metadata. (insta/failure? result) will detect both these scenarios and return true if the result is either a failure object, or an empty list with a failure object attached as metdata. (insta/get-failure result) provides a unified way to extract the failure object in both these cases. If the result is a failure object, then it is directly returned, and if the result is an empty list with the failure attached as metadata, then the failure object is retrieved from the metadata. Total parse mode Sometimes knowing the point of failure is not enough and you need to know the entire context of the parse tree when it failed. To help with these sorts of situations, instaparse offers a ""total parse"" mode inspired by Christophe Grand's parsley parser. This total parse mode guarantees to parse the entire string; if the parser fails, it completes the parse anyway, embedding the failure point as a node in the parse tree. To demonstrate, let's revisit the ultra-simple repeated-a parser. => repeated-a S = ""a""+ => (repeated-a ""aaaaaaaa"") [:S ""a"" ""a"" ""a"" ""a"" ""a"" ""a"" ""a"" ""a""]  On a string with a valid parse, the total parse mode performs identically: => (repeated-a ""aaaaaaaa"" :total true) [:S ""a"" ""a"" ""a"" ""a"" ""a"" ""a"" ""a"" ""a""]  On a failure, note the difference: => (repeated-a ""aaaabaaa"") Parse error at line 1, column 5: aaaabaaa     ^ Expected: ""a"" => (repeated-a ""aaaabaaa"" :total true) [:S ""a"" ""a"" ""a"" ""a"" [:instaparse/failure ""baaa""]]  Note that this kind of total parse result is still considered a ""failure"", and we can test for that and retrieve the failure object using insta/failure? and insta/get-failure, respectively. => (insta/failure? (repeated-a ""aaaabaaa"" :total true)) true => (insta/get-failure (repeated-a ""aaaabaaa"" :total true)) Parse error at line 1, column 5: aaaabaaa     ^ Expected: ""a""  I find that the total parse mode is the most valuable diagnostic tool when the cause of the error is far away from the point where the parser actually fails. A typical example might be a grammar where you are looking for phrases delimited by quotes, and the text neglects to include a closing quote mark around some phrase in the middle of the text. The parser doesn't fail until it hits the end of the text without encountering a closing quote mark. In such a case, a quick look at the total parse tree will show you the context of the failure, making it easy to spot the location where the run-on phrase began. Parsing from another start rule Another valuable tool for interactive debugging is the ability to test out individual rules. To demonstrate this, let's look back at our very first parser: => as-and-bs S = AB* AB = A B A = ""a""+ B = ""b""+  As we've seen throughout this tutorial, by default, instaparse assumes that the very first rule is your ""starting production"", the rule from which parsing initially proceeds. But we can easily set other rules to be the starting production with the :start keyword argument. => (as-and-bs ""aaa"" :start :A) [:A ""a"" ""a"" ""a""] => (as-and-bs ""aab"" :start :A) Parse error at line 1, column 3: aab   ^ Expected: ""a"" => (as-and-bs ""aabb"" :start :AB) [:AB [:A ""a"" ""a""] [:B ""b"" ""b""]] => (as-and-bs ""aabbaabb"" :start :AB) Parse error at line 1, column 5: aabbaabb     ^ Expected: ""b""  The insta/parser function, which builds the parser from the specification, also accepts the :start keyword to set the default start rule to something other than the first rule listed. Review of keyword arguments At this point, you've seen all the keyword arguments that an instaparse-generated parser accepts, :start :rule-name, :partial true, and :total true. All these keyword arguments can be freely mixed and work with both insta/parse and insta/parses. You've also seen both keyword arguments that can be used when building the parser from the specification: :output-format (:enlive or :hiccup) and :start :rule-name to set a different default start rule than the first rule. Transforming the tree A parser's job is to turn a string into some kind of tree structure. What you do with it from there is up to you. It is delightfully easy to manipulate trees in Clojure. There are wonderful tools available: enlive, zippers, match, and tree-seq. But even without those tools, most tree manipulations are straightforward to perform in Clojure with recursion. Since tree transformations are already so easy to perform in Clojure, there's not much point in building a sophisticated transform library into instaparse. Nevertheless, I did include one function, insta/transform, that addresses the most common transformation needs. insta/transform takes a map from tree tags to transform functions. A transform function is defined as a function which takes the children of the tree node as inputs and returns a replacement node. In other words, if you want to turn all nodes in your tree of the form [:switch x y] into [:switch y x], then you'd call: (insta/transform {:switch (fn [x y] [:switch y x])}     my-tree)  Let's make this concrete with an example. So far, throughout the tutorial, we were able to adequately express the tokens of our languages with strings or regular expressions. But sometimes, regular expressions are not sufficient, and we want to bring the full power of context-free grammars to bear on the problem of processing the individual tokens. When we do that, we end up with a bunch of individual characters where we really want a string or a number. To illustrate this, let's revisit the words-and-numbers example, but this time, we'll imagine that regular expressions aren't rich enough to specify the constraints on those tokens and we need our grammar to process the string one character at a time: (def words-and-numbers-one-character-at-a-time   (insta/parser     ""sentence = token (<whitespace> token)*      <token> = word | number      whitespace = #'\\s+'      word = letter+      number = digit+      <letter> = #'[a-zA-Z]'      <digit> = #'[0-9]'""))  => (words-and-numbers-one-character-at-a-time ""abc 123 def"") [:sentence [:word ""a"" ""b"" ""c""] [:number ""1"" ""2"" ""3""] [:word ""d"" ""e"" ""f""]]  We'd really like to simplify these :word and :number terminals. So for :word nodes, we want to concatenate the strings with clojure's built-in str function, and for :number nodes, we want to concatenate the strings and convert the string to a number. We can do this quite simply as follows: => (insta/transform      {:word str,       :number (comp clojure.edn/read-string str)}      (words-and-numbers-one-character-at-a-time ""abc 123 def"")) [:sentence ""abc"" 123 ""def""]  Or, if you're a fan of threading macros, try this version: => (->> (words-and-numbers-one-character-at-a-time ""abc 123 def"")      (insta/transform        {:word str,         :number (comp clojure.edn/read-string str)}))  The insta/transform function auto-detects whether you are using enlive or hiccup trees, and processes accordingly. insta/transform performs its transformations in a bottom-up manner, which means that taken to an extreme, insta/transform can be used not only to rearrange a tree, but to evaluate it. Including a grammar for infix arithmetic math expressions has become nearly obligatory in parser tutorials, so I might as well use that in order to demonstrate evaluation. I've leveraged instaparse's principle of ""one rule per node type"" and the hide notation <> to get a nice clean unambiguous tree that includes only the relevant information for evaluation. (def arithmetic   (insta/parser     ""expr = add-sub      <add-sub> = mul-div | add | sub      add = add-sub <'+'> mul-div      sub = add-sub <'-'> mul-div      <mul-div> = term | mul | div      mul = mul-div <'*'> term      div = mul-div <'/'> term      <term> = number | <'('> add-sub <')'>      number = #'[0-9]+'""))  => (arithmetic ""1-2/(3-4)+5*6"") [:expr  [:add   [:sub    [:number ""1""]    [:div [:number ""2""] [:sub [:number ""3""] [:number ""4""]]]]   [:mul [:number ""5""] [:number ""6""]]]]  With the tree in this shape, it's trivial to evaluate it: => (->> (arithmetic ""1-2/(3-4)+5*6"")      (insta/transform        {:add +, :sub -, :mul *, :div /,         :number clojure.edn/read-string :expr identity})) 33  insta/transform is designed to play nicely with all the possible outputs of insta/parse and insta/parses. So if the input is a sequence of parse trees, it will return a sequence of transformed parse trees. If the input is a Failure object, then the Failure object is passed through unchanged. This means you can safely chain a transform to your parser without taking special cases. To demonstrate this, let's look back at the ambiguous parser from earlier in the tutorial: (def ambiguous   (insta/parser     ""S = A A      A = 'a'*""))  => (->> (insta/parses ambiguous ""aaaaaa"")      (insta/transform {:A str})) ([:S ""a"" ""aaaaa""]  [:S ""aaaaaa"" """"]  [:S ""aa"" ""aaaa""]  [:S ""aaa"" ""aaa""]  [:S ""aaaa"" ""aa""]  [:S ""aaaaa"" ""a""]  [:S """" ""aaaaaa""])   => (->> (ambiguous ""aabaaa"")      (insta/transform {:A str})) Parse error at line 1, column 3: aabaaa   ^ Expected: ""a""  Understanding the tree Character spans The trees produced by instaparse are annotated with metadata so that for each subtree, you can easily recover the start and end index of the input text parsed by that subtree. The convenience function for extracting this metadata is insta/span. To demonstrate, let's revisit our first example. => (as-and-bs ""aaaaabbbaaaabb"") [:S  [:AB [:A ""a"" ""a"" ""a"" ""a"" ""a""] [:B ""b"" ""b"" ""b""]]  [:AB [:A ""a"" ""a"" ""a"" ""a""] [:B ""b"" ""b""]]]  => (meta (as-and-bs ""aaaaabbbaaaabb"")) {:instaparse.gll/start-index 0, :instaparse.gll/end-index 14}  => (insta/span (as-and-bs ""aaaaabbbaaaabb"")) [0 14]  => (count ""aaaaabbbaaaabb"") 14  As you can see, insta/span returns a pair containing the start index (inclusive) and end index (exclusive), the customary way to represent the start and end of a substring. So far, this isn't particularly interesting -- we already knew that the entire string was successfully parsed. But since span works on all the subtrees, this gives us a powerful tool for exploring the provenance of each portion of the tree. To demonstrate this, here's a quick helper function (not part of instaparse's API) that takes a hiccup tree and replaces all the tags with the character spans. (defn spans [t]   (if (sequential? t)     (cons (insta/span t) (map spans (next t)))     t))  => (spans (as-and-bs ""aaaabbbaabbab"")) ([0 13]  ([0 7] ([0 4] ""a"" ""a"" ""a"" ""a"") ([4 7] ""b"" ""b"" ""b""))  ([7 11] ([7 9] ""a"" ""a"") ([9 11] ""b"" ""b""))  ([11 13] ([11 12] ""a"") ([12 13] ""b"")))  insta/span works on all the tree types produced by instaparse. Furthermore, when you use insta/transform to transform your parse tree, insta/span will work on the transformed tree as well -- the span metadata is preserved for every node in the transformed tree to which metadata can be attached. Keep in mind that although most types of Clojure data support metadata, primitives such as strings or numbers do not, so if you transform any of your nodes into such primitive data types, insta/span on those nodes will simply return nil. Line and column information Sometimes, when the input string contains newline characters, it is useful to have the span metadata in the form of line and column numbers. By default, instaparse doesn't do this, because generating line and column information requires a second pass over the input string and parse tree. However, the function insta/add-line-and-column-info-to-metadata performs this second pass, taking the input string and parse tree, returning a parse tree with the additional metadata. Make sure to pass in the same input string from which the parse tree was derived! => (def multiline-text ""This is line 1\nThis is line 2"")  => (words-and-numbers multiline-text) [:sentence [:word ""This""] [:word ""is""] [:word ""line""] [:number ""1""]            [:word ""This""] [:word ""is""] [:word ""line""] [:number ""2""]]  => (def parsed-multiline-text-with-line-and-column-metadata      (insta/add-line-and-column-info-to-metadata         multiline-text         (words-and-numbers multiline-text)))  The additional information is in the metadata, so the tree itself is not visibly changed: => parsed-multiline-text-with-line-and-column-metadata [:sentence [:word ""This""] [:word ""is""] [:word ""line""] [:number ""1""]             [:word ""This""] [:word ""is""] [:word ""line""] [:number ""2""]]  But now let's inspect the metadata for the overall parse tree. => (meta parsed-multiline-text-with-line-and-column-metadata) {:instaparse.gll/end-column 15, :instaparse.gll/end-line 2,  :instaparse.gll/start-column 1, :instaparse.gll/start-line 1,  :instaparse.gll/start-index 0, :instaparse.gll/end-index 29}  And let's take a look at the metadata for the word ""is"" on the second line of the text. => (meta (nth parsed-multiline-text-with-line-and-column-metadata 6)) {:instaparse.gll/end-column 8, :instaparse.gll/end-line 2,  :instaparse.gll/start-column 6, :instaparse.gll/start-line 2,  :instaparse.gll/start-index 20, :instaparse.gll/end-index 22}]  start-line and start-column point to the same character as start-index, and end-line and end-column point to the same character as end-index. So just like the regular span metadata, the line/column start point is inclusive and the end point is exclusive. However, line and column numbers are 1-based counts, rather than 0-based. So, for example, index number 0 of the string corresponds to line 1, column 1. Visualizing the tree Instaparse contains a function, insta/visualize, that will give you a visual overview of the parse tree, showing the tags, the character spans, and the leaves of the tree. => (insta/visualize (as-and-bs ""aaabbab""))  The visualize function, by default, pops open the tree in a new window. To actually save the tree image as a file for this tutorial, I used both of the optional keyword arguments supported by insta/visualize. First, the :output-file keyword argument supplies the destination where the image should be saved. Second, the keyword :options is used to supply an option map of additional drawing parameters. I lowered it to 63dpi so it wouldn't take up so much screen real estate. So my function call looked like: => (insta/visualize (as-and-bs ""aaabbab"") :output-file ""images/vizexample1.png"" :options {:dpi 63})  insta/visualize draws the tree using the rhizome library, which in turn uses graphviz. Unfortunately, Java, and by extension Clojure, has a bit of a weakness when it comes to libraries depending on other libraries. If you want to use two libraries that rely on two different versions of a third library, you're in for a headache. In this instance, rhizome is a particularly fast-moving target. As of the time of this writing, rhizome 0.1.8 is the most current version, released just a few weeks after version 0.1.6. If I were to make instaparse depend on rhizome 0.1.8, then in a few weeks when 0.1.9 is released, it will become more difficult to use instaparse in projects which rely on the most recent version of rhizome. For this reason, I've done something a bit unusual: rather than include rhizome directly in instaparse's dependencies, I've set things up so that insta/visualize will use whatever version of rhizome you've put in your project.clj dependencies (must be version 0.1.8 or greater). On top of that, rhizome assumes that you have graphviz installed on your system. If rhizome is not in your dependencies, or graphviz is not installed, insta/visualize will throw an error with a message reminding you of the necessary dependencies. To find the most current version number for rhizome, and for links to graphviz installers, check out the rhizome github site. If you don't want to use insta/visualize, there is no need to add rhizome to your dependencies and no need to install graphviz. All the other instaparse functions will work just fine. Combinators I truly believe that ordinary EBNF notation is the clearest, most concise way to express a context-free grammar. Nevertheless, there may be times when it is useful to build parsers with parser combinators. If you want to use instaparse in this way, you'll need to use the instaparse.combinators namespace. If you are not interested in the combinator interface, feel free to skip this section -- the combinators provide no additional power or expressiveness over the string representation. Each construct you've seen from the string specification has a corresponding parser combinator. Most are straightforward, but the last few lines of the table will require some additional explanation. String syntax Combinator Mnemonic Epsilon Epsilon Epsilon A | B | C (alt A B C) Alternation A B C (cat A B C) Concatenation A? (opt A) Optional A+ (plus A) Plus A* (star A) Star A / B / C (ord A B C) Ordered Choice &A (look A) Lookahead !A (neg A) Negative lookahead <A> (hide A) Hide ""string"" (string ""string"") String #""regexp"" (regexp ""regexp"") Regular Expression A non-terminal (nt :non-terminal) Non-terminal <S> = ... {:S (hide-tag ...)} Hide tag When using combinators, instead of building a string, your goal is to build a grammar map. So a spec that looks like this: S = ... A = ... B = ...  becomes {:S ... combinators describing right-hand-side of S rule ...  :A ... combinators describing right-hand-side of A rule ...  :B ... combinators describing right-hand-side of B rule ...}  You can also build it as a vector: [:S ... combinators describing right-hand-side of S rule ...  :A ... combinators describing right-hand-side of A rule ...  :B ... combinators describing right-hand-side of B rule ...]  The main difference is that if you use the map representation, you'll eventually need to specify the start rule, but if you use the vector, instaparse will assume the first rule is the start rule. Either way, I'm going to refer to the above structure as a grammar map. Most of the combinators, if you consult the above table, are pretty obvious. Here are a few additional things to keep in mind, and then a concrete example will follow: Literal strings must be wrapped in a call to the string combinator. Regular expressions must be wrapped in a call to the regexp combinator. Any reference on the right-hand side of a rule to a non-terminal (i.e., a name of another rule) must be wrapped in a call to the nt combinator. Angle brackets on the right-hand side of a rule correspond to the hide combinator. Even though the notation for hiding a rule name is to put angle brackets around the name (on the left-hand side), this is implemented by wrapping the hide-tag combinator around the entire right-hand side of the rule expressed as combinators. Hopefully this will all be clarified with an example. Do you remember the parser that looks for equal numbers of a's followed by b's followed by c's? S = &(A 'c') 'a'+ B A = 'a' A? 'b' <B> = 'b' B? 'c'  Well, here's the corresponding grammar map: (use 'instaparse.combinators)  (def abc-grammar-map   {:S (cat (look (cat (nt :A) (string ""c"")))            (plus (string ""a""))            (nt :B))    :A (cat (string ""a"") (opt (nt :A)) (string ""b""))    :B (hide-tag (cat (string ""b"") (opt (nt :B)) (string ""c"")))})  Once you've built your grammar map, you turn it into an executable parser by calling insta/parser. As I mentioned before, if you use map notation, you'll need to specify the start rule. (insta/parser abc-grammar-map :start :S)  The result is a parser that is the same as the one built from the string specification. To my eye, the string is dramatically more readable, but if you need or want to use the combinator approach, it's there for you to utilize. String to combinator conversion Shortly after I published the first version of instaparse, I received a question, ""String specifications can be combined with clojure.string/join and combinator grammar maps can be combined with merge --- is there any way to mix and match string and combinator grammar representations?"" At the time, there wasn't, but now there is. As of version 1.1, there is a new function ebnf in the instaparse.combinators namespace which converts EBNF strings into the same underlying structure that is built by the combinator library, thus allowing for further manipulation by combinators. (EBNF stands for Extended Backus-Naur Form, the technical name for the syntax used by instaparse and described in this tutorial.) For example, (ebnf ""'a'* | 'b'+"")  produces the same structure as if you had typed the combinator version (alt (star (string ""a"")) (plus (string ""b"")))  You can also pass entire rules to ebnf and you'll get back the corresponding grammar map: (ebnf ""A = 'a'*; B = 'b'+"")  produces {:A (star (string ""a""))  :B (plus (string ""b""))}  This opens up the possibility of building a grammar from a mixture of combinators, and strings that have been converted to combinators. Here's a contrived example: (def combo-build-example   (insta/parser     (merge       {:S (alt (nt :A) (nt :B))}       (ebnf ""A = 'a'*"")       {:B (ebnf ""'b'+"")})     :start :S))  ABNF Instaparse's primary input format is based on EBNF syntax, but an alternative input format, ABNF, is available. Most users will not need the ABNF input format, but if you need to implement a parser whose specification was written in ABNF syntax, it is very easy to do. Please read instaparse's ABNF documentation for details. String case sensitivity One interesting difference between EBNF and ABNF grammars is that in EBNF, string terminals are case-sensitive whereas in ABNF, all string terminals are case-insensitive. If you like ABNF's case-insensitive approach, but want to use Instaparse's somewhat richer EBNF syntax, there are a couple options available to you. If you want all of the string terminals in your Instaparse EBNF grammar to be case-insensitive, the simplest solution is to use the :string-ci true keyword argument when calling insta/parser to make the strings case-insensitive: => ((insta/parser ""S = 'a'+"") ""AaaAaa"") Parse error at line 1, column 1: AaaAaa ^ Expected: ""a""  => ((insta/parser ""S = 'a'+"" :string-ci true) ""AaaAaa"") [:S ""a"" ""a"" ""a"" ""a"" ""a"" ""a""]  On the other hand, if you want to cherry-pick certain string tokens to be case-insensitive, simply convert your string tokens into case-insensitive regexes, for example, replacing the string 'select' with #'(?i)select'. Serialization You can serialize an instaparse parser with print-dup, and deserialize it with read. (You can't use clojure.edn/read because edn does not support regular expressions.) Typically, it is more convenient to store and/or transmit the string specification used to generate the parser. The string specification allows the parser to be rebuilt with a different output format; print-dup captures the state of the parser after the output format has been ""baked in"". However, if you have built the parser with the combinators, rather than via a string spec, or if you are storing the parser inside of other Clojure data structures that need to be serialized, then print-dup may be your best option. Performance notes Some of the parsing libraries out there were written as a learning exercise -- monadic parser combinators, for example, are a great way to develop an appreciation for monads. There's nothing wrong with taking the fruits of a learning exercise and making it available to the public, but there are enough Clojure parser libraries out there that it is getting to be hard to tell the difference between those that are ""ready for primetime"" and those that aren't. For example, some of the libraries rely heavily on nested continuations, a strategy that is almost certain to cause a stack overflow on moderately large inputs. Others rely heavily on memoization, but never bother to clear the cache between inputs, eventually exhausting all available memory if you use the parser repeatedly. I'm not going to make any precise performance guarantees -- the flexible, general nature of instaparse means that it is possible to write grammars that behave poorly. Nevertheless, I want to convey that performance is something I have taken seriously. I spent countless hours profiling instaparse's behavior on strange grammars and large inputs, using that data to improve performance. Just as one example, I discovered that for a large class of grammars, the biggest bottleneck was Clojure's hashing strategy, so I implemented a wrapper around Clojure's vectors that uses an alternative hashing strategy, successfully reducing running time on many parsers from quadratic to linear. (A shout-out to Christophe Grand who provided me with valuable guidance on this particular improvement.) I've also worked to remove ""performance surprises"". For example, both left-recursion and right-recursion have sufficiently similar performance that you really don't need to agonize over which one to use -- choose whichever style best fits the problem at hand. If you express your grammar in a natural way, odds are good that you'll find the performance of the generated parser to be satisfactory. An additional performance boost in the form of multithreading is slated for the next release. One performance caveat: instaparse is fairly memory-hungry, relying on extensive caching of intermediate results to keep the computational costs reasonable. This is not unusual -- caching is commonplace in many modern parsers, trading off space for time -- but it's worth bearing in mind. Packrat/PEG parsers and many recursive descent parsers employ a similar memory-intensive strategy, but there are other alternatives out there if that kind of memory usage is unacceptable. As one would expect, instaparse parsers do not hold onto the memory cache once the parse is complete; that memory is made available for garbage collection. The performance notes document contains a deeper discussion of performance and a few helpful hints for getting the best performance out of your parser. Reference All the functionality you've seen in this tutorial is packed into an API of just 9 functions. Here are the doc strings: => (doc insta/parser) ------------------------- instaparse.core/parser ([grammar-specification & {:as options}])   Takes a string specification of a context-free grammar,    or a URI for a text file containing such a specification,    or a map of parser combinators and returns a parser for that grammar.     Optional keyword arguments:    :input-format :ebnf    or    :input-format :abnf     :output-format :enlive    or    :output-format :hiccup     :start :keyword (where :keyword is name of starting production rule)     :string-ci true (treat all string literals as case insensitive)     :no-slurp true (disables use of slurp to auto-detect whether                    input is a URI.  When using this option, input                    must be a grammar string or grammar map.  Useful                    for platforms where slurp is slow or not available.)     :auto-whitespace (:standard or :comma)    or    :auto-whitespace custom-whitespace-parser  => (doc insta/parse) ------------------------- instaparse.core/parse ([parser text & {:as options}])   Use parser to parse the text.  Returns first parse tree found    that completely parses the text.  If no parse tree is possible, returns    a Failure object.     Optional keyword arguments:    :start :keyword  (where :keyword is name of starting production rule)    :partial true    (parses that don't consume the whole string are okay)    :total true      (if parse fails, embed failure node in tree)    :unhide <:tags or :content or :all> (for this parse, disable hiding)    :optimize :memory   (when possible, employ strategy to use less memory)  => (doc insta/parses) ------------------------- instaparse.core/parses ([parser text & {:as options}])   Use parser to parse the text.  Returns lazy seq of all parse trees    that completely parse the text.  If no parse tree is possible, returns    () with a Failure object attached as metadata.     Optional keyword arguments:    :start :keyword  (where :keyword is name of starting production rule)    :partial true    (parses that don't consume the whole string are okay)    :total true      (if parse fails, embed failure node in tree)    :unhide <:tags or :content or :all> (for this parse, disable hiding)  => (doc insta/set-default-output-format!) ------------------------- instaparse.core/set-default-output-format! ([type])   Changes the default output format.  Input should be :hiccup or :enlive  => (doc insta/failure?) ------------------------- instaparse.core/failure? ([result])   Tests whether a parse result is a failure.  => (doc insta/get-failure) ------------------------- instaparse.core/get-failure ([result])   Extracts failure object from failed parse result.  => (doc insta/transform) ------------------------- instaparse.core/transform ([transform-map parse-tree])   Takes a transform map and a parse tree (or seq of parse-trees).    A transform map is a mapping from tags to    functions that take a node's contents and return    a replacement for the node, i.e.,    {:node-tag (fn [child1 child2 ...] node-replacement),     :another-node-tag (fn [child1 child2 ...] node-replacement)}  => (doc insta/span) ------------------------- instaparse.core/span ([tree])   Takes a subtree of the parse tree and returns a [start-index end-index] pair    indicating the span of text parsed by this subtree.    start-index is inclusive and end-index is exclusive, as is customary    with substrings.    Returns nil if no span metadata is attached.  => (doc insta/add-line-and-column-info-to-metadata) ------------------------- instaparse.core/add-line-and-column-info-to-metadata ([text parse-tree])   Given a string `text` and a `parse-tree` for text, return parse tree    with its metadata annotated with line and column info. The info can    then be found in the metadata map under the keywords:    :instaparse.gll/start-line, :instaparse.gll/start-column,   :instaparse.gll/end-line, :instaparse.gll/end-column    The start is inclusive, the end is exclusive. Lines and columns are 1-based.  => (doc insta/visualize) ------------------------- instaparse.core/visualize ([tree & {output-file :output-file, options :options}])   Creates a graphviz visualization of the parse tree.    Optional keyword arguments:    :output-file output-file (will save the tree image to output-file)    :options options (options passed along to rhizome)  Important: This function will only work if you have added rhizome to your dependencies, and installed graphviz on your system. See https://github.com/ztellman/rhizome for more information.  Experimental Features See the Experimental Features page for a discussion of new features under active development, including memory optimization and automatic handling of whitespace. Communication I try to be very responsive to issues posted to the github issues page. But if you have a general question, need some help troubleshooting a grammar, or have something interesting you've done in instaparse that you'd like to share, consider joining the Instaparse Google Group and posting there. Special Thanks My interest in this project began while watching a video of Matt Might's Parsing with Derivatives talk. That video convinced me that the world would be a better place if building parsers were as easy as working with regular expressions, and that the ability to handle arbitrary, possibly-ambiguous grammars was essential to that goal. Matt Might has published a paper about a specific approach to achieving that goal, but I had difficulty getting his Parsing with Derivatives technique to work in a performant way. I probably would have given up, but then Danny Yoo released the Ragg parser generator for the Racket language. The Ragg library was a huge inspiration -- a model for what I wanted instaparse to become. I asked Danny what technique he used, and he gave me more information about the algorithm he used. However, he told me that if he were to do it again from scratch, he'd probably choose to use a GLL algorithm by Adrian Johnstone and Elizabeth Scott, and he pointed me to a fantastic article about it by Vegard �ye, posted on Github with source code in Racket. That article had a link to a paper and Scala code by Daniel Spiewak, which was also extremely helpful. Alex Engelberg coded the first version of instaparse, proving the capabilities of the GLL algorithm. He encouraged me to take his code and build and document a user-friendly API around it. He continues to be a main contributor on the project, most recently developing the ABNF front-end. I studied a number of other Clojure parser generators to help frame my ideas about what the API should look like. I communicated with Eric Normand (squarepeg) and Christophe Grand (parsley), both of whom provided useful advice and encouraged me to pursue my vision. YourKit is kindly supporting open source projects with its full-featured Java Profiler. YourKit, LLC is the creator of innovative and intelligent tools for profiling Java and .NET applications. Take a look at YourKit's leading software products: YourKit Java Profiler and YourKit .NET Profiler. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/lbradstreet/instaparse-cljs"	"– It aims to be the simplest way to build parsers in ClojureScript."	"true"
"Miscellaneous"	"Keybind"	"https://github.com/piranha/keybind"	"Library for handling key bindings (shortcuts) in browser."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"26"	"3"	"4"	"GitHub - piranha/keybind: ClojureScript key bindings (shortcut) library Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 26 Fork 4 piranha/keybind Code Issues 0 Pull requests 1 Pulse Graphs ClojureScript key bindings (shortcut) library 13 commits 1 branch 4 releases 1 contributor Clojure 97.3% Makefile 2.7% Clojure Makefile Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show 2.0.1 2.0.0 1.0 0.1.0 Nothing to show New pull request Latest commit 6e2299c Nov 19, 2015 piranha fix binding to minus Permalink Failed to load latest commit information. src/keybind fix binding to minus Nov 19, 2015 test/keybind fix binding to minus Nov 19, 2015 .gitignore initial commit Jul 30, 2014 Makefile fix binding to minus Nov 19, 2015 README.md fix binding to minus Nov 19, 2015 project.clj fix binding to minus Nov 19, 2015 README.md keybind Small library to handle key bindings (shortcuts) in browser, for ClojureScript. Features Simple format for defining bindings Emacs-like key sequences Default modifier (defmod is parsed as cmd on OS X and ctrl elsewhere) Changelog 2.0.1 fixed binding to - (and minus), now if you need to bind to minus on keypad, use kpminus. 2.0.0 renamed keybind to keybind.core cleaned up code a bit Usage Add this to your :dependencies vector: And then: (require '[keybind.core :as key])  (key/bind! ""ctrl-c"" ::my-trigger #(js/console.log ""Sequence fired properly"")) where ""ctrl-c"" is a button sequence to register on, and ::my-trigger is a key unique for this sequence - you can use this key to remove binding later on. Format description If you know Emacs' format, you're all set (not exactly Emacs', though - I decided to resort to more common format of modifiers). In other case, you have to provide a list of modifiers (some of shift, ctrl, alt, win, cmd, defmod), followed by a key name. All of those should be separated by -, i.e.: ctrl-k, alt-m, shift-r. Combining few such ""chords"" in a sequence, like ctrl-k ctrl-m, will register a key sequence. To trigger you have to press ctrl and k simultaneously, release them and then press ctrl and m simultaneously. Note 1: if you want to register on a big letter, use shift-a. Note 2: ctrl-j in most browsers opens a ""Downloads"" window. I have thoughts how to prevent that (for the sequence ctrl-t ctrl-j k for example), but didn't do anything yet. Report an issue if you have a problem with that. Note 3: looking at the source as a reference for key names makes sense. :) Examples (require '[keybind.core :as key])  (defn some-mount-function [items current-item]   (key/bind! ""j"" ::next #(go-next items current-item))   (key/bind! ""shift-space"" ::prev #(go-prev items current-item))   (key/bind! ""C-c C-x j"" ::chord #(js/alert ""ever heard of emacs chords?"")))  (defn some-unmount-function []   (key/unbind! ""j"" ::next)   (key/unbind! ""shift-space"" ::prev)   (key/unbind! ""C-c C-x j"" ::chord)   ;; or simply:   (key/unbind-all!)) How it works Library binds global key handler to check all keypresses. The reason for this is that focus in browsers is often hard to handle and define properly, and most of the time it makes no sense to bind against some element. Bindings storage Also, you have to be aware that bind! and unbind! use global BINDINGS atom. If you want to use your own atom, just use bind and unbind versions (swap! your atom with them). You'll have to bind dispatcher! on your own though. I was also thinking how would you have more than a single atom - if you want to organize some contexts (on one page you have one set of bindings and another page obviously has different actions and different bindings) - and it seems to me it's easier to just reset! one single atom with necessary bindings when it's necessary. That's why BINDINGS is public. Or just bind!/unbind! all the time, whatever floats your boat. Issues Please notify me if you don't understand something, I would like to improve documentation but not sure exactly what to do. Plus it isn't possible to have custom key modifiers right now. Ideally I'd like to have that, but right now we're limited to Shift/Control/Alt/Command. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/piranha/keybind"	"Library for handling key bindings (shortcuts) in browser."	"true"
"Miscellaneous"	"markdown-clj"	"https://github.com/yogthos/markdown-clj"	"– Markdown parser in Clojure/ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"285"	"11"	"67"	"GitHub - yogthos/markdown-clj: Markdown parser in Clojure Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 11 Star 285 Fork 67 yogthos/markdown-clj Code Issues 10 Pull requests 0 Pulse Graphs Markdown parser in Clojure 423 commits 3 branches 1 release 23 contributors Clojure 77.3% HTML 22.7% Clojure HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags cljc cljx master Nothing to show 0.9.62 Nothing to show New pull request Latest commit e85aedc Jun 23, 2016 yogthos committed on GitHub Update README.md Permalink Failed to load latest commit information. demo added test May 1, 2016 src Inhibiting delimiters (#104) Jun 14, 2016 test Inhibiting delimiters (#104) Jun 14, 2016 .gitignore Ignore lein repl files Oct 6, 2014 .travis.yml Move to Travis newer platform. Dec 23, 2015 README.md Update README.md Jun 23, 2016 example.html updated to only attempt unescaping if escaped strings are present in … Sep 9, 2015 project.clj updated cljs dependency, updated demo May 1, 2016 README.md Markdown parser written in Clojure/Script Demo You can try out the parser here. Installation A markdown parser that compiles to both Clojure and ClojureScript. Note: markdown-clj versions prior to 0.9.68 requires Clojure 1.2+ to run, versions 0.9.68+ require Clojure 1.7. Usage Clojure Markdown-clj can be invoked either by calling md-to-html or md-to-html-string functions. The md-to-html function accepts an input containing Markdown markup and an output where the resulting HTML will be written. The input and output parameters will be passed to a reader and a writer respectively: (ns foo   (:use markdown.core))  (md-to-html ""input.md"" ""output.html"")  (md-to-html (input-stream ""input.md"") (output-stream ""test.txt"")) The md-to-html-string function accepts a string with markdown content and returns a string with the resulting HTML: (md-to-html-string ""# This is a test\nsome code follows\n```clojure\n(defn foo [])\n```"") <h1> This is a test</h1>some code follows<pre><code class=""clojure"">&#40;defn foo &#91;&#93;&#41; </code></pre> Both md-to-html and md-to-html-string accept optional parameters: Specifying :heading-anchors will create anchors for the heading tags, eg: (markdown/md-to-html-string ""###foo bar BAz"" :heading-anchors true)  <h3><a name=\""heading\"" class=\""anchor\"" href=\""#foo&#95;bar&#95;baz\""></a>foo bar BAz</h3> The code blocks default to a highlight.js compatible format of: <pre><code class=""clojure"">some code</code></pre> Specifying :code-style will override the default code class formatting for code blocks, eg: (md-to-html-string ""# This is a test\nsome code follows\n```clojure\n(defn foo [])\n```""                    :code-style #(str ""class=\""brush: "" % ""\"""")) <h1> This is a test</h1>some code follows<pre><code class=""brush: clojure""> &#40;defn foo &#91;&#93;&#41; </code></pre> reference style links The parser defaults to using inline reference for performance reasons, to enable reference style links pass in the :reference-links? true option: (md-to-html-string   ""This is [an example][id] reference-style link.     [id]: http://example.com/ 'Optional Title Here'""    :reference-links? true) footnotes To enable footnotes, pass the :footnotes? true option: (md-to-html-string   ""Footnotes will appear automatically numbered with a link to the footnote at bottom of the page [^footnote1].    [^footnote1]: The footnote will contain a back link to to the referring text.""   :footnotes? true) Metadata The metadata encoded using the syntax described by MultiMarkdown can be optionally extracted from the document. The md-to-html function will attempt to parse the metadata when passed the :parse-meta? true option and return it as its output. Additionally, md-to-html-string-with-meta function can be used to parse string input. The function returns a map with two keys, :html containing the parsed HTML, and :metadata containing a map with the metadata included at the top of the document. The value of each key in the metadata map will be a list of either 0, 1 or many strings. If a metadata value ends in two spaces then the string will end in a newline. If a line does not contain a header and has at least 4 spaces in front of it then it will be considered to be a member of the last key that was found. (let [input    (new StringReader text)       output   (new StringWriter)       metadata (md-to-html input output :parse-meta? true)       html     (.toString output)]   {:metadata metadata :html html})  (md-to-html-string-with-meta   ""Author: Rexella van Imp     Kim Jong-un     Date: October 31, 2015     # Hello!"")  {:metadata {:author [""Rexella van Imp""                      ""Kim Jong-un""],              :date [""October 31, 2015""]},   :html ""<h1>Hello!</h1>""} Selectively inhibiting the Parser *** :inhibit-separator will be available in the upcoming release *** If you pass :inhibit-separator ""some-string"", then any text within occurrences of some-string will be output verbatim, eg: (md-to-html-string ""For all %$a_0, a_1, ..., a_n in R$% there is _at least one_ %$b_n in R$% such that...""                    :inhibit-separator ""%"") For all $a_0, a_1, ..., a_n in R$ there is <i>at least one</i> $b_n in R$ such that... This may be useful to use markdown-clj along with other parsers of languages with conflicting syntax (e.g. asciimath2jax). If you need to output the separator itself, enter it twice without any text inside. Eg: (md-to-html-string ""This is one of those 20%% vs 80%% cases.""                    :inhibit-separator ""%"") This is one of those 20% vs 80% cases. Some caveats: Like other tags, this only works within a single line. If you remove the default transformers with :replacement-transformers (which see below), inhibiting will stop working. Currently, dashes (-- and ---) can't be suppressed this way. Customizing the Parser Additional transformers can be specified using the :custom-transformers key. A transformer function must accept two arguments. First argument is the string representing the current line and the second is the map representing the current state. The default state keys are: :code - inside a code section :codeblock - inside a code block :eof - end of file :heading - in a heading :hr - in a horizontal line :lists - inside a list :blockquote - inside a blockquote :paragraph - in a paragraph :last-line-empty? - was last line an empty line? For example, if we wanted to add a transformer that would capitalize all text we could do the following: (defn capitalize [text state]   [(.toUpperCase text) state])  (markdown/md-to-html-string ""#foo"" :custom-transformers [capitalize]) <H1>FOO</H1> Alternatively, you could provide a custom set of transformers to replace the default transformers using the :replacement-transformers key. (markdown/md-to-html-string ""#foo"" :replacement-transformers [capitalize]) This can also be used to add preprocessor transformers. For example, if we wanted to sanitize any image links we could do the following: (use 'markdown.transformers 'markdown.core)  (defn escape-images [text state]   [(clojure.string/replace text #""(!\[.*?\]\()(.+?)(\))"" """") state])  (markdown/md-to-html-string   ""foo ![Alt text](/path/to/img.jpg \""Optional Title\"") bar [text](http://test)""   :replacement-transformers (cons escape-images transformer-vector)) ""<p>foo  bar <a href='http://test'>text</a></p>"" Another example would be to escape HTML tags: (require '[markdown.core :as md]) (require '[markdown.transformers :as mdtrans])  (defn escape-html [text state]                 (let [sanitized-text (clojure.string/escape text                                        {\& ""&amp;""                                         \< ""&lt;""                                         \> ""&gt;""                                         \"" ""&quot;""                                         \' ""&#39;""})]                 [sanitized-text state]))  (def markdown-with-html                  ""## I am a title <h1></h1> with HTML tags !\n<script src=\""http://bad-url\"">"")  (md/md-to-html-string markdown-with-html                                   :replacement-transformers                                   (cons escape-html mdtrans/transformer-vector)) <h2>I am a title &lt;h1&gt;&lt;/h1&gt; with HTML tags !</h2>&lt;script src=&quot;http://bad-url&quot;&gt; Usage ClojureScript The ClojureScript portion works the same as above except that the entry function is called md->html. It accepts a string followed by the options as its input, and returns the resulting HTML string: (ns myscript   (:require [markdown.core :refer [md->html]]))  (.log js/console   (md->html ""##This is a heading\nwith a paragraph following it""))  (.log js/console   (md->html ""# This is a test\nsome code follows\n```clojure\n(defn foo [])\n```""                :code-style #(str ""class=\"""" % ""\"""")))  (md->html-with-meta ""# This is a test\nsome code follows\n```clojure\n(defn foo [])\n```"")               Usage JavaScript console.log(markdown.core.mdToHtml(""##This is a heading\nwith a paragraph following it"")); Supported syntax Control characters can be escaped using \ \\ backslash \` backtick \* asterisk \_ underscore \{ curly braces \} \[ square brackets \] \( parentheses \) \# hash mark \+ plus sign \- minus sign (hyphen) \. dot \! exclamation mark  Basic Elements Blockquote, Strong, Bold, Emphasis, Italics, Heading, Line, Linebreak, Paragraph, Strikethrough Links Image, Link Automatic Links This is a shortcut style for creating “automatic” links for URLs and email addresses: <http://example.com/>  will be turned this into: <a href=""http://example.com/"">http://example.com/</a>  Automatic links for email addresses work similarly, except that they are hex encoded: <address@example.com&>  will be turned into: <a href=\""&#x61&#x64&#x64&#x72&#x65&#x73&#x73&#x40&#x65&#x78&#x61&#x6d&#x70&#x6c&#x65&#x2e&#x63&#x6f&#x6d\"">&#x61&#x64&#x64&#x72&#x65&#x73&#x73&#x40&#x65&#x78&#x61&#x6d&#x70&#x6c&#x65&#x2e&#x63&#x6f&#x6d</a>  Lists Ordered List, Unordered List Code Code Block, Indented Code, Inline Code Heading the number of hashes indicates the level of the heading # Heading  ##Sub-heading  ### Sub-sub-heading  headings can also be defined using = and - for h1 and h2 respectively Heading 1 =========  Heading 2 ---------  Line ***  * * *  *****  - - -  ______  Linebreak If a line ends with two or more spaces a <br /> tag will be inserted at the end. Emphasis *foo*  Italics _foo_  Strong **foo**  Bold __foo__  Blockquote > prefixes regular blockquote paragraphs. >- prefixes a blockquote footer that can be used for author attribution. >This is a blockquote with some content  >this is another blockquote  > Everyone thinks of changing the world, but no one thinks of changing himself. >- Leo Tolstoy  Paragraph This is a paragraph, it's split into separate lines.  This is another paragraph.   Unordered List indenting an item makes it into a sublist of the item above it, ordered and unordered lists can be nested within one another. List items can be split over multiple lines. * Foo * Bar  * Baz  * foo * bar     * baz      1. foo      2. bar         more content         ## subheading         ***         **strong text** in the list     * fuzz        * blah       * blue * brass  Ordered List 1. Foo 2. Bar 3. Baz  Inline Code Any special characters in code will be escaped with their corresponding HTML codes. Here's some code `x + y = z` that's inlined.  Code block Using three backquotes indicates a start of a code block, the next three backquotes ends the code block section. Optionally, the language name can be put after the backquotes to produce a tag compatible with highlight.js, eg: ```clojure (defn foo [bar] ""baz"") ``` Indented Code indenting by at least 4 spaces creates a code block some code here  note: XML is escaped in code sections Strikethrough ~~foo~~  Superscript a^2 + b^2 = c^2  Link [github](http://github.com)  Reference Link This is [an example][id] reference-style link.  [id]: http://example.com/  ""Optional Title Here""  note: reference links require the :reference-links? option to be set to true Footnote ""Footnotes will appear automatically numbered with a link to the footnote at bottom of the page [^footnote1]. [^footnote1]: The footnote will contain a back link to to the referring text.""  note: to enable footnotes, the :footnotes? option must be set to true. Image ![Alt text](http://server/path/to/img.jpg) ![Alt text](/path/to/img.jpg ""Optional Title"")  Image Reference This is ![an example][id] reference-style image descriptor.  [id]: http://example.com/  ""Optional Title Here""  note: reference links require the :reference-links? option to be set to true Image Link [![Continuous Integration status](https://secure.travis-ci.org/yogthos/markdown-clj.png)](http://travis-ci.org/yogthos/markdown-clj)  Table You can create tables by assembling a list of words and dividing them with hyphens - (for the first row), and then separating each column with a pipe |: | First Header  | Second Header | | ------------- | ------------- | | Content Cell  | Content Cell  | | Content Cell  | Content Cell  |  By including colons : within the header row, you can define text to be left-aligned, right-aligned, or center-aligned: | Left-Aligned  | Center Aligned  | Right Aligned | | :------------ |:---------------:| -----:| | col 3 is      | some wordy text | $1600 | | col 2 is      | centered        |   $12 | | zebra stripes | are neat        |    $1 |  A colon on the left-most side indicates a left-aligned column; a colon on the right-most side indicates a right-aligned column; a colon on both sides indicates a center-aligned column. Limitations The parser reads the content line by line, this means that tag content is not allowed to span multiple lines. License Copyright © 2015 Dmitri Sotnikov Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/yogthos/markdown-clj"	"– Markdown parser in Clojure/ClojureScript."	"true"
"Miscellaneous"	"om-tools"	"https://github.com/plumatic/om-tools"	"– It aims to provide higher-order abstractions and utilities frequently useful when building components with Om's API."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"456"	"43"	"28"	"GitHub - plumatic/om-tools: Tools for building Om applications Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 43 Star 456 Fork 28 plumatic/om-tools Code Issues 7 Pull requests 2 Pulse Graphs Tools for building Om applications 233 commits 2 branches 14 releases 13 contributors Clojure 99.8% Shell 0.2% Clojure Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags default-spec-map master Nothing to show om-tools-0.3.9 om-tools-0.3.8 om-tools-0.3.7 om-tools-0.3.6 om-tools-0.3.5 om-tools-0.3.4 om-tools-0.3.3 om-tools-0.3.2 om-tools-0.3.0 om-tools-0.2.3 om-tools-0.2.2 om-tools-0.2.1 om-tools-0.2.0 om-tools-0.1.1 Nothing to show New pull request Latest commit 74e5f9f Jul 7, 2016 w01fe committed on GitHub Update README.md Permalink Failed to load latest commit information. examples Upgrade to latest Schema & Plumbing Sep 17, 2015 script Add Travis-CI config to test 2 versions of Om Dec 23, 2014 src/om_tools Upgrade to latest Schema & Plumbing Sep 17, 2015 test Moving om-tools.test-utils to src Apr 8, 2015 .gitignore Update gitignore Jun 4, 2014 .travis.yml Travis CI: cache m2 for faster builds Dec 24, 2014 CHANGELOG.md Upgrade to latest Schema & Plumbing Sep 17, 2015 CONTRIBUTING.md Update for org name change Jan 13, 2016 LICENSE Add Eclipse license May 9, 2014 README.md Update README.md Jul 7, 2016 project.clj Update for org name change Jan 13, 2016 README.md om-tools A ClojureScript library of general-purpose tools for building applications with Om and Facebook's React. Leiningen dependency (Clojars): This library does not currently have an active maintainer. If you are interested in becoming one, please post an issue. Introduction om-tools aims to provide higher-order abstractions and utilities frequently useful when building components with Om's API. Contents DOM tools Components tools defcomponent defcomponentk defcomponentmethod Mixin tools DOM tools om-tools.dom mirrors the om.dom namespace while using macros and minimal runtime overhead to make the following improvements: Element attributes are not required to be JavaScript values and are optional. You don't need to use the #js reader macro or nil for no attributes. More natural attribute names. We translate attributes like :class to :className and :on-click to :onClick to stay consistent with Clojure naming conventions. Children can be in collections. You don't need to use apply if you have a sequence of children or use concat for combining sequences of siblings. Example by comparison. First with om.dom: (ns example   (:require [om.dom :as dom :include-macros true]))  (dom/div   nil   (apply dom/ul #js {:className ""a-list""}          (for [i (range 10)]            (dom/li #js {:style #js {:color ""red""}}                    (str ""Item "" i))))) And with om-tools.dom: (ns example   (:require [om-tools.dom :as dom :include-macros true]))  (dom/div   (dom/ul {:class ""a-list""}           (for [i (range 10)]             (dom/li {:style {:color ""red""}}                     (str ""Item "" i))))) Component tools defcomponent The om-tools.core/defcomponent macro defines Om component constructor functions. Advantages over the ordinary defn & reify approach: Removes boilerplate code around using reify to instantiate objects with Om lifecycle methods. Component definitions become much smaller and easier to read. Adds Schema support to specify and validate the data when component is built. One of React's most powerful features is prop validation, which allows a component's author to document and validate which properties a component requires and their types. This functionality is not utilized in Om because we use normal ClojureScript data structures as component inputs. However, with more complex input structures, documentation and validation are even more important. Schema annotations are optional and validation is disabled by default. Automatically implements IDisplayName for better debugging messages. Example of defcomponent including schema annotation: (ns example   (:require     [om-tools.core :refer-macros [defcomponent]]     [om-tools.dom :include-macros true]))  (defcomponent counter [data :- {:init js/Number} owner]   (will-mount [_]     (om/set-state! owner :n (:init data)))   (render-state [_ {:keys [n]}]     (dom/div       (dom/span (str ""Count: "" n))       (dom/button         {:on-click #(om/set-state! owner :n (inc n))}         ""+"")       (dom/button         {:on-click #(om/set-state! owner :n (dec n))}         ""-""))))  (om/root counter {:init 5}          {:target (. js/document -body)}) defcomponentk The om-tools.core/defcomponentk macro is similar to defcomponent, except that it uses Plumbing's fnk destructuring syntax for constructor arguments. This enables succinct and declaritive definition of the structure and requirements of component input data. It also provides additional useful utilities mentioned in Component Inputs. Fnk-style Arguments The args vector of defcomponentk uses Fnk syntax that's optimized for destructuring (nested) maps with keyword keys. It is the similar pattern used in our Fnhouse library to expressively declare HTTP handlers. If you are unfamiliar with this syntax, here are some quick comparisons to default Clojure map destructuring. {:keys [foo bar]}                    :: [foo bar] {:keys [foo bar] :as m}              :: [foo bar :as m] {:keys [foo bar] :or {bar 21}}       :: [foo {bar 21}] {{:keys [baz qux]} :foo :keys [bar]} :: [[:foo baz qux] bar] However, an important distinction between Clojure's default destructuring and Fnk-style is that specified keys are required by default. Rather than defaulting to nil, if a key that's destructured is missing and no default value is specified, an error is thrown. By being explicit about component inputs, we are less error-prone and debugging is often easier because errors happen closer to the source. Component Inputs The map that's passed to defcomponentk arg vector has the following keys: Key Description :data The data (cursor) passed to component when built :owner The backing React component :opts The optional map of options passed when built :shared The map of globally shared data from om.core/get-shared :state An atom-like object for convenience to om.core/get-state and om.core/set-state! Example (ns example   (:require     [om.core :as om]     [om-tools.core :refer-macros [defcomponentk]]     [schema.core :refer-macros [defschema]]))  (defschema ProgressBar   {:value js/Number    (s/optional-key :min) js/Number    (s/optional-key :max) js/Number})  (defcomponentk progress-bar   ""A simple progress bar""   [[:data value {min 0} {max 100}] :- ProgressBar owner]   (render [_]     (dom/div {:class ""progress-bar""}       (dom/span         {:style {:width (-> (/ value (- max min))                             (* 100)                             (int)                             (str ""%""))}})))) ;; Valid (om/root progress-bar {:value 42}   {:target (. js/document (getElementById ""app""))})  ;; Throws error: Key :value not found in (:wrong-data) (om/root progress-bar {:wrong-data true}   {:target (. js/document (getElementById ""app""))})  ;; Throws error: Value does not match schema (schema.core/with-fn-validation   (om/root progress-bar {:value ""42""}     {:target (. js/document (getElementById ""app""))}) State Proxy (experimental) A component using defcomponentk can use the key, :state, to access an atom-like object that conveniently wraps om.core/get-state and om.core/set-state! so that we can read and write state idiomatically with deref, reset! and swap!. (defcomponentk progress-bar   ""A simple progress bar""   [[:data value {min 0} {max 100}] state]   (render [_]     (dom/div {:class ""progress-bar""}       (dom/span         {:style {:width (-> (/ value (- max min))                             (* 100)                             (int)                             (str ""%""))}          :on-mouse-enter #(swap! state assoc :show-value? true)          :on-mouse-leave #(swap! state assoc :show-value? false))}         (when (:show-value? @state)           (str value ""/"" total)))))) It's important to note that while state looks and behaves like an atom, there is at least one minor difference: changes made by swap! and reset! are not immediately available if you deref in the same render phase. defcomponentmethod With Om, multimethods can be used instead of normal functions to create polymorphic components (requires Om version 0.7.0+). The defcomponentmethod macro allows you to register components into a multimethod (created from cljs.core/defmulti), while using the normal om-tools syntax. (defmulti fruit-basket-item   (fn [fruit owner] (:type fruit)))  (defcomponentmethod fruit-basket-item :orange   [orange owner]   (render [_]     (dom/label ""Orange"")))  (defcomponentmethod fruit-basket-item :banana   [banana owner]   (render [_]     (dom/label      {:class (when (:peeled? banana) ""peeled"")}      ""Banana"")))  (defcomponentmethod fruit-basket-item :default   [fruit owner]   (render [_]     (dom/label (str ""Unknown fruit: "" (name (:type fruit))))))  (om/build-all fruit-basket-item               [{:type :banana}                {:type :pineapple}                {:type :orange}]) Mixin tools React provides mixin functionality to handle cross-cutting concerns and allow highly reusable component behaviors. While mixins are possible with Om, it does not provide much functionality to support this React feature. One issue is that you must create a React constructor and specify it each time the component is built. This puts the responsibility of using mixins on both the component (create a constructor) and its parent (specify the constructor). Another issue is having to drop down to raw JavaScript functions, breaking you out of Om's data and state abstractions. om-tools provides a defmixin macro in the om-tools.mixin namespace to define mixins. The syntax of defmixin follows same pattern as the component macros. One last thing: the factory functions created by defcomponent/defcomponentk (ie (->component-name data)) encapsulate any custom constructor automatically. So a parent component no longer needs to be aware when a child uses mixins! Here's how you could reimplement React's mixin example: (ns example   (:require     [om-tools.core :refer-macros [defcomponentk]]     [om-tools.dom :as dom :include-macros true]     [om-tools.mixin :refer-macros [defmixin]]))  (defmixin set-interval-mixin   (will-mount [owner]     (set! (. owner -intervals) #js []))   (will-unmount [owner]     (.. owner -intervals (map js/clearInterval)))   (set-interval [owner f t]     (.. owner -intervals (push (js/setInterval f t)))))  (defcomponentk tick-tock [owner state]   (:mixins set-interval-mixin)   (init-state [_]     {:seconds 0})   (did-mount [_]     (.set-interval owner #(swap! state update-in [:seconds] inc) 1000))   (render [_]     (dom/p       (str ""React has been running for "" (:seconds @state) "" seconds."")))) See example for full version. Community Please feel free to open an issue on GitHub For announcements of new releases, you can also follow on @PrismaticEng on Twitter. We welcome contributions in the form of bug reports and pull requests; please see CONTRIBUTING.md in the repo root for guidelines. License Copyright (C) 2014 Prismatic and Contributors. Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/plumatic/om-tools"	"– It aims to provide higher-order abstractions and utilities frequently useful when building components with Om's API."	"true"
"Miscellaneous"	"Quil"	"https://github.com/quil/quil"	"– A processing and graphics programming library."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"1699"	"79"	"112"	"GitHub - quil/quil: Main repo. Quil source code. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 79 Star 1,699 Fork 112 quil/quil Code Issues 7 Pull requests 0 Wiki Pulse Graphs Main repo. Quil source code. 915 commits 2 branches 20 releases Fetching contributors Clojure 99.1% Other 0.9% Clojure Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags cljc master Nothing to show 2.4.0 2.3.0 2.2.6 2.2.5 2.2.4 2.2.3 2.2.2 2.2.1 2.2.0 2.1.0 2.0.0 1.7.0 1.6.0 1.5.0 1.4.1 1.4.0 1.3.0 1.2.0 1.1.0 1.0.0 Nothing to show New pull request Latest commit 738a549 May 2, 2016 nbeloglazov Update README.md Permalink Failed to load latest commit information. dev-resources Migrate docs generation tool to handle cljc files. Mar 24, 2016 docs/cheatsheet Further update cheatsheet generation with suggestions from @nbeloglazov Dec 7, 2015 src Update release notes with changes from 2.4.0. Mar 23, 2016 test Add real delay to tests. Mar 23, 2016 .gitignore Add tests for Color - Creating & Reading category. Mar 11, 2014 API.txt Update API.txt Mar 6, 2012 LICENSE Update license to EPL. Jul 31, 2014 README.md Update README.md May 2, 2016 RELEASE-NOTES.md Update release notes with changes from 2.4.0. Mar 23, 2016 project.clj Release 2.4.0. Mar 23, 2016 README.md Quil http://quil.info Quil looked up in shock to see Bigelow floating high in the clouds, his balloons rustling merrily in the wind. He gruffed to her from above, ""This truly is a party!"". Image after image, vista after vista, passed furry Bige's wide-open eyes. A deep underlying beauty unfolded before him. A flock of bezier gulls whistled past. Beneath his dangling paws a distant shepherd called his scribbly sheep in for re-sketching. Goading him from the distance, wooden letters of so many different fonts mocked PERLIN-WOULD from the hilltops. This truly was an amazing place. Here, dreams and reality had been drawn together - all in one Process. ""_Why would I ever leave?"" he barked with joy! _Why indeed! (mix Processing Clojure) In one hand Quil holds Processing, a carefully crafted API for making drawing and animation extremely easy to get your biscuit-loving chops around. In the other she clutches Clojure, an interlocking suite of exquisite language abstractions forged by an army of hammocks and delicately wrapped in flowing silky parens of un-braided joy. In one swift, skilled motion, Quil throws them both high into the air. In a dusty cloud of pixels, they bond instantly and fly off into the distance painting their way with immutable trails of brilliant colour. Moments later, you see them swiftly return and hover nearby. Your very own ride to Perlinwould awaits. Summon the winds and ride well, my friend. Requirements Quil works with Clojure 1.7, 1.8 and ClojureScript 1.8.x. Installation Create sample project using Quil lein template: lein new quil hello-quil Then go to hello-quil/src/hello-quil/core.clj file and run it! If you like adding libraries manually - you simply need to add Quil as a dependency to project.clj: [quil ""2.4.0""] Then to pull in all of Quil's silky goodness, just add the following to your ns declaration: (:require [quil.core :as q]) For more detailed instructions head over to the wiki. Getting Started Using Quil is as easy as eating chocolate digestives. You just need to grok three basic concepts: The Setup fn The Draw fn The Sketch If setup and draw are hard working artistic gladiators, sketch is the arena in which they battle for the glory of art. However, they don't actually fight each other - they work as a team - relentlessly spilling colour all over the arena sands. The crowds roar for messy fight. setup lays all the groundwork and is called only once at the start. draw, on the other hand, is called immediately after setup has completed, and then repeatedly until you summon it to stop. When you create a sketch and name your setup and draw fns, the fun automatically starts. A simple example is called for: (ns for-the-glory-of-art   (:require [quil.core :as q]))  (defn setup []   (q/frame-rate 1)                    ;; Set framerate to 1 FPS   (q/background 200))                 ;; Set the background colour to                                       ;; a nice shade of grey. (defn draw []   (q/stroke (q/random 255))             ;; Set the stroke colour to a random grey   (q/stroke-weight (q/random 10))       ;; Set the stroke thickness randomly   (q/fill (q/random 255))               ;; Set the fill colour to a random grey    (let [diam (q/random 100)             ;; Set the diameter to a value between 0 and 100         x    (q/random (q/width))       ;; Set the x coord randomly within the sketch         y    (q/random (q/height))]     ;; Set the y coord randomly within the sketch     (q/ellipse x y diam diam)))         ;; Draw a circle at x y with the correct diameter  (q/defsketch example                  ;; Define a new sketch named example   :title ""Oh so many grey circles""    ;; Set the title of the sketch   :settings #(q/smooth 2)             ;; Turn on anti-aliasing   :setup setup                        ;; Specify the setup fn   :draw draw                          ;; Specify the draw fn   :size [323 200])                    ;; You struggle to beat the golden ratio Feast your eyes on this beauty. You're witnessing setup, draw and sketch working in complete harmony. See how setup turns on anti-aliasing, sets the framerate to 1 FPS and sets the background colour to a nice shade of grey. draw then kicks into action. It chooses random stroke, fill colours as well as a random stroke weight (thickness of the pen). It then chooses some random coordinates and circle size and draws an ellipse. An ellipse with the same height and width is a circle. Finally defsketch a convenience macro around sketch ties everything together, specifies a title and size and starts things running. Don't just watch it though, start modifying it to see immediate effects. Go to town. ClojureScript Quil supports ClojureScript! Check wiki article for more info. Documentation When getting started with Quil, it's always useful to have the Cheatsheet handy. It may be a little bit out-dated but still contains most functions. For up-to-date documentation please check quil.info. If you're new to Processing and graphics programming in general, the Processing.org Learning Pages are an excellent primer and will get you started in no time. Check Quil wiki for more documentation. API Exploration Quil supports an explorable API. For a full list of API categories and subcategories simply type (show-cats) at the REPL. user=> (q/show-cats) 1 Color (0)    1.1 Creating & Reading (11)    1.2 Loading & Displaying (1)    1.3 Pixels (1)    1.4 Setting (12) 2 Data (0)    2.1 Conversion (4)    .    .    . etc  In order to see the fns within a specific category use (show-fns 11.1) if 11.1 is the index of the category you wish to examine. user=> (q/show-fns 11.1) 11.1 2D Primitives     arc ellipse line point quad rect triangle  You can also lookup functions by name of the category or function name. user=> (q/show-fns ""trans"") 14 Transform     apply-matrix pop-matrix print-matrix push-matrix reset-matrix rotate     rotate-x rotate-y rotate-z scale shear-x shear-y translate 14.1 Utility Macros     with-translation  If you know the start of Processing API method name such as bezier, you can use (q/show-meths ""bezier"") to list all Processing API methods starting with bezier alongside their Quil equivalents: user=> (q/show-meths ""bezier"") bezierPoint()    -  bezier-point bezierDetail()   -  bezier-detail bezier()         -  bezier bezierTangent()  -  bezier-tangent bezierVertex()   -  bezier-vertex  Examples Quil comes chock-packed full of examples covering most of the available API. Many of them have been translated from the excellent book ""Generative Art"" by Matt Pearson, with kind permission from the author. Head over to the Gen Art Examples Page. Instructions of how to run examples you can find in README in Quil examples repo. Processing Compatibility Quil provides support for the standard Processing API - currently version 3.0.1 of Processing and 1.4.8 of Processing.js. The majority of fns Processing methods have an equivalent Quil fn. Typically, camelCased methods have been converted to hyphenated-versions. For a full API list (with both Processing and Quil equivalents) see API.txt. Community You can ask questions, get support on our mailing list: https://groups.google.com/forum/?fromgroups#!forum/clj-processing There is also a small number of people that hang out in #quil on freenode. New artworks are show-cased on the @quilist Twitter account: http://twitter.com/quilist License Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. The official Processing.org's jars, used as dependencies, are distributed under LGPL and their code can be found on http://processing.org/ Contributors See list of contributors. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/quil/quil"	"– A processing and graphics programming library."	"true"
"Miscellaneous"	"reforms"	"https://github.com/bilus/reforms"	"Beautiful Bootstrap 3 forms for Om and Reagent."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"137"	"5"	"4"	"GitHub - bilus/reforms: Beautiful Bootstrap 3 forms for Om, Reagent and Rum. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 137 Fork 4 bilus/reforms Code Issues 7 Pull requests 0 Pulse Graphs Beautiful Bootstrap 3 forms for Om, Reagent and Rum. 200 commits 4 branches 6 releases 2 contributors Clojure 97.4% Shell 2.6% Clojure Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags 0.4.0 gh-pages master reagent Nothing to show reforms-0.4.1 reforms-0.4.0 reforms-0.3.0 reforms-0.3.0-SNAPSHOT reforms-0.2.0 reforms-0.2.0-SNAPSHOT Nothing to show New pull request Latest commit fc914fe Dec 6, 2015 bilus Merge branch 'master' of github.com:bilus/reforms Permalink Failed to load latest commit information. doc/images ... Jun 22, 2015 src/reforms Fix reforms.validation/form not handling markup around form elements #11 Dec 6, 2015 test/reforms Fix Error when binding array: gen-dom-id does not allow numeric indic… Sep 13, 2015 .gitignore Library-agnostic interface for table :checkboxes (no :cursor/:korks). Oct 2, 2015 .projectile Support for creating tables with optional selection checkboxes. Sep 27, 2015 LICENSE Initial revision. Jun 16, 2015 README.md fix trivial typo Nov 17, 2015 deploy-docs.sh Update deploy scripts. Oct 18, 2015 deploy.sh Update deploy scripts. Oct 18, 2015 project.clj Fix reforms.validation/form not handling markup around form elements #11 Dec 6, 2015 reforms.iml ... Jun 22, 2015 repl.clj ... Jul 26, 2015 README.md Reforms A Clojurescript library that lets you build beautiful data-binding forms with Om, Reagent and Rum. You can write code that is fully portable between Reagent, Om and Rum making it easier to reuse code and giving you a clear migration path. To help you quickly create beautiful forms without messing with CSS, the generated markup is compatible with Bootstrap 3 CSS and Font Awesome. For quick results simply include Bootstrap and Font Awesome CSS. If you think something useful is missing though, please let me know. A good place to see the available controls: demo. Usage Getting started with Om Getting started with Reagent Getting started with Rum External CSS Quick tutorial Hello, world! Data binding Prettying it up Adding a placeholder Changing orientation Wrapping in a panel Button types Validation Basics Custom validators Forcing errors Tables Simple table Column names Attributes Row selection Assorted topics Hiding labels Element attributes Placeholders for empty text boxes Using radio buttons Showing warnings Configuration options Demos Om Reagent Rum FAQ How do I submit the form when the user presses ENTER? How to affect changes when user clicks a button? How to show an operation is in progress? I'm getting Each child in an array should have a unique ""key"" prop. Why? Can I bind to local component state (Om-specific)? API Reference TBD Credits License Usage Getting started with Om Add om-reforms to :dependencies in project.clj: Minimal requires (including sablono to render the forms): (ns hello-world.core   (:require [reforms.om :include-macros true :as f]             [om.core :as om]             [sablono.core :include-macros true :as sablono])) Here's how you create an Om component with a form with just one text field and a button: (defn simple-view   [data _owner]   (om/component     (sablono/html       (f/form         (f/text ""Your name"" data [:name])         (f/form-buttons            (f/button ""Submit"" #(js/alert (:name @data)))))))) You render it with om/build just like any other component. See https://github.com/omcljs/om for more details. Note that labels are optional, you can render controls without labels, for instance: (f/text data [:name] :placeholder ""Enter your name here"") Getting started with Reagent Add reagent-reforms to :dependencies in project.clj: (ns hello-world.core   (:require [reforms.reagent :include-macros true :as f]             [reagent.core :refer [atom render-component])) Here's how you create a Reagent component with a form with just one text field and a button: (defn simple-view   [data]   (f/form     (f/text ""Your name"" data [:name])     (f/form-buttons        (f/button ""Submit"" #(js/alert (:name @data)))))) You render it just like any other component by either mounting it using render-component or inside another component using the [simple-view some-data] syntax. See https://github.com/reagent-project/reagent for more details. Note that labels are optional, you can render controls without labels, for instance: (f/text data [:name] :placeholder ""Enter your name here"") Getting started with Rum Add rum-reforms to :dependencies in project.clj: (ns hello-world.core   (:require [reforms.rum :include-macros true :as f]             [rum.core :include-macros true :as rum]) Here's how you create a Rum component with a form with just one text field and a button: (rum/defc simple-view < rum/cursored rum/cursored-watch [data horizontal-orientation]   [data]   (f/form     (f/text ""Your name"" data [:name])     (f/form-buttons        (f/button ""Submit"" #(js/alert (:name @data)))))) You render it just like any other component by either mounting it using rum-mount or inside another component. See https://github.com/tonsky/rum for more details. Note that labels are optional, you can render controls without labels, for instance: (f/text data [:name] :placeholder ""Enter your name here"") External CSS The library does not use Bootstrap JavaScript so just link to bootstrap css from your html page, e.g.: <link href=""https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css"" rel=""stylesheet""/> Optionally, to use Font Awesome icons to use features such as progress spinner, warning icons etc., link to it as well: <link href=""https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"" rel=""stylesheet""> Quick tutorial The tutorial shows library-agnostic code. For code specific to Om or React, see ""Getting started with ..."" above or the examples. Hello, world! Here's how you create a form with just one text field and a button: (f/form     (f/text ""Your name"" data [:name])     (f/form-buttons         (f/button ""Submit"" #(js/alert (:name @data))))) Note that form returns a Hiccup-like data structure. The example below, though a bit simplified and scrubbed for clarity, should give you an idea: [:form [:div {:class ""form-group""               :key ""data-name""}         [:label {:for ""data-name""                  :class ""control-label ""} ""Your name""]         [:input {:value ""My name""                  :type ""text""                  :class ""form-control""                  :id ""data-name""                  :placeholder ""Type your name here""}]]  [:div.form-group.form-buttons   [:button {:type ""button""             :class ""btn btn-primary""             :onClick #(js/alert (:name @data))} ""Submit""]]] Data binding The controls bind directly to data (Om cursors or Reagent ratoms). For example, as the user types text into the text box below, data is automatically updated: (f/text ""Your name"" data [:name]) (prn @data) ;; => {:name ""John Wayne} Prettying it up Adding a placeholder You can add a placeholder shown when the text box is empty using a :placeholder option: (f/text ""Your name"" data [:name] :placeholder ""Enter your name here"") Changing orientation To change the orientation use with-options: (f/with-options {:form {:horizontal true}}     (f/form      (f/text ""Your name"" data [:name] :placeholder ""Enter your name here"")      (f/form-buttons        (f/button ""Submit"" #(js/alert (:name @data)))))) Wrapping in a panel To wrap the form in a panel use panel: (f/panel     ""Hello, world""     (f/form       (f/text ""Your name"" data [:name] :placeholder ""Enter your name here"")       (f/form-buttons         (f/button ""Submit"" #(js/alert (:name @data)))))) Button types Finally, let's take make the button clearly a primary one and add a cancel button and, just for the fun of it, a checkbox that toggles the orientation: (f/form   (f/text ""Your name"" data [:name] :placeholder ""Enter your name here"")   (f/form-buttons     (f/button-primary ""Submit"" #(js/alert (:name @data)))     (f/button-default ""Cancel"" #(js/alert ""Cancel!"")))   (f/checkbox ""Horizontal form"" data [:orientation-horizontal])) Click! The complete example: Om (demo) Reagent (demo). For the list of available controls, see the API Reference. Validation The library supports client-side data validation. Basics To use validators, require reforms.validation, use form and form field helpers from this namespace instead of reforms.core and use validate!: (ns my-validation-example   (:require ...              [reforms.validation :include-macros true :as v])) Apart from form, the helpers have an identical interface to ones in reforms.core. (v/form                                                           ;; 1   ui-state                                                        ;; 2   (v/text ""Login"" data [:login])                                  ;; 3   (v/password ""Password"" data [:password1])    (v/password ""Confirm password"" data [:password2])   (f/form-buttons     (f/button-primary ""Sign up"" #(sign-up! data ui-state))))      ;; 4 We use reforms.validation/form. Note that it takes an extra argument (2). This is the cursor used to store validation errors. We're using data to bind the form fields to and ui-state to store validation results in. There's no technical reason we cannot use data for this but separating this makes it cleaner. Again, we use the helpers from reforms.validation. Here we call our function which will perform validation Here's the sign up function. It shows an alert if data validates: (defn sign-up!   [data ui-state]   (when (v/validate!                                                      ;; 1            data                                                           ;; 2            ui-state                                                       ;; 3            (v/present [:login] ""Enter login name"")                        ;; 4            (v/equal [:password1] [:password2] ""Passwords do not match"")            (v/present [:password1] ""Choose password"")            (v/present [:password2] ""Re-enter password""))     (js/alert ""Signed up!"")) validate! returns a truthy value if data is valid. This is data to validate. Cursor to store validation results. Validators. Here's what happens after you click ""Sign up"" while all fields are empty: To satisfy your curiosity, here are the contents of ui-state: {:validation-errors [{:korks #{[:login]}, :error-message ""Enter login name""}                       {:korks #{[:password1]}, :error-message ""Choose password""}                       {:korks #{[:password2]}, :error-message ""Re-enter password""}]} A slightly richer example: Om (demo) Reagent (demo). For the list of available validators, see the API Reference. Custom validators A validator is a function that returns a lambda that takes some data and returns nil or a validation error. Let's create a custom validation that checks if data is a positive number: (defn positive-number?   [s]   (pos? (js/parseInt s)))  (defn positive-number   [korks error-message]                                       ;; 1   (fn [cursor]                                                ;; 2     (when-not (positive-number? (get-in cursor korks))        ;; 3       (v/validation-error [korks] error-message))))           ;; 4 The arguments here are up to you. In this example we pass korks pointing to data we want to validate and the error message. This is a typical pattern. The actual function our validator returns takes cursor. Check if it's a positive number. Build and return an error if it's not. While we're at it, we could make it more readable with the built-in is-true validator: (defn positive-number   [korks error-message]   (v/is-true korks positive-number? error-message)) Either way, you can use your brand new validator like a pro: (validate!      data     ui-state     (positive-number [:age] ""Age must be a positive number"")) Forcing errors Validation errors may be forced which comes useful when using external APIs etc. Observe: (v/validate!     customer     ui-state     (v/force-error [:server-error] ""An error has occurred"")) You'd normally call it from an asynchronous error handler, go block etc. You can either have a form field show the error if it makes sense by passing its korks to force-error or use the error-alert helper to render the error: (v/error-alert [:server-error]) Note that error-alert can render any number of custom errors like so: (v/error-alert [:auth-error] [:twitter-error]) Tables Starting with version 0.4.0 Reforms support HTML tables with optional row selection fully stylable using CSS and compatible with Bootstrap table classes (if you use Bootstrap in the first place). For live example see this demo (source). Simple table This is how you create a simple table, just provide a vector with map per each row: (t/table [{:name ""Tom""} {:name ""Jerry""} {:name ""Mickey""} {:name ""Minnie""}]) Here we create just one column. Column names It's usually a good idea to give columns human-friendly titles: (t/table [{:name ""Tom""} {:name ""Jerry""} {:name ""Mickey""} {:name ""Minnie""}]          :columns {:name ""Hero name""}) Attributes As with all controls, you can specify optional attributes; they will be applied to the element (see https://github.com/r0man/sablono#html-attributes): (t/table {:key ""hero-table""       ;; Unique React key to avoid warnings.           :class ""table-striped""} ;; Bootstrap table style, see http://getbootstrap.com/css/#tables          [{:name ""Tom""} {:name ""Jerry""} {:name ""Mickey""} {:name ""Minnie""}]          :columns {:name ""Hero name""}) Row selection As an option, you can enable row selection using checkboxes. Current selection is stored in an atom/cursor (as a set of unique row ids). These row ids are provided through a user-defined function, here we use a separate :id column (which isn't visible to the user): (t/table {:key ""rs-table""}          [{:name ""Tom"" :id 1} {:name ""Jerry"" :id 2} {:name ""Mickey"" :id 3} {:name ""Minnie"" :id 4}]          :columns {:name ""Hero name""}          :checkboxes {:selection data                       :path      [:selected]                       :row-id    :id}) Each selected row gets class ""table-row-selected"" which you can use for styling. See the API Reference. Assorted topics Hiding labels Starting with version 0.4.0 labels are optional; for example the text box below will be displayed without a label: (f/text data [:name]) Element attributes Each form helper accepts React attributes as the first argument. These attributes will be handed over to React (see https://github.com/r0man/sablono#html-attributes) (text {:key ""name-1""} ""Name"" user [:name]) Attributes are optional, this form will work as well. (text ""Name"" user [:name]) Placeholders for empty text boxes You can add a placeholder shown when the text box is empty using a :placeholder option: (f/text ""Your name"" data [:name] :placeholder ""Enter your name here"") It also works for textarea and other controls based on html5-input such as password, datetime-local, email and others. Using radio buttons When using radio buttons remember to provide a value, for instance: (f/form   (f/radio ""Data"" app-state [:current-view] :data)   (f/radio ""Groups"" app-state [:current-view] :groups)) Showing warnings In addition to validation proper, text, password and other controls based on html5-input support warnings: (text ""City"" [:city] :warn-fn #(when-not (= ""Kansas"" %) ""We're not in Kansas anymore"") Note that by default a Font Awesome icon is used to show the warning icon. You can override this using (set-options! [:icon-warning] ""...""). Configuration options You can configure global options using set-options!. See this for details. Here's a quick example: ;; Set background of every form to red color. (set-options! {:form {:attrs {:style {:background-color ""red""}}}}) Demos Om Hello world source demo Dynamic form with customizations source demo Available controls source demo Validation source demo Background operations source demo Reagent Hello world source demo Dynamic form with customizations source demo Available controls source demo Validation source demo Background operations source demo Rum Hello world source demo Dynamic form with customizations source demo Available controls source demo Validation source demo Background operations source demo FAQ How do I submit the form when the user presses ENTER? Use the :on-submit attribute and pass the same function you use to handle clicks: (form     {:on-submit #(do-something customer)}     (text ""First name"" ""Enter first name"" customer [:first])     ...     (f/form-buttons       (f/button-primary ""Save"" #(do-something customer)))) Note: If :on-submit is set, the resulting form will include a hidden submit button. How to affect changes when user clicks a button? Because form helpers bind to data, everything user types in is automatically synchronized. If this isn't what you need, create a copy of data before handing it over to the form and then copy it back on save. How to show an operation is in progress? Buttons and most form helpers accept an :in-progress option you can use like this: (button ""Start"" #(...) :in-progress true) In addition, in case of buttons it's usually a good idea to disable them: (button ""Start"" #(...) :in-progress true :disabled true) See this example: Om (demo) Reagent (demo) Rum (demo) I'm getting Each child in an array should have a unique ""key"" prop. Why? If you use Om, it's likely the warning is sabl0no-related (see this). In your own code avoid passing child elements as a sequence whenever possible: [:ul   (for [item items]     [:li item])] with: (into   [:ul]   (for [item items]     [:li item])) If you need to pass a sequence, use attributes to set React key. For example, use code similar to this: (let [items [{:title ""foo"" :id 1} {:title ""bar"" :id 2}]]   [:ul     (for [{:keys [title id]} items]       [:li {:key id} title])]) On the other hand, if you do find a bug in Reforms, please do report it here. Can I bind to local component state (Om-specific)? Yes, there's experimental support for this, just remember to use render-state instead of render: (defn simple-view   [_ owner]   (reify     om/IRenderState     (render-state [_ _]       (f/text ""Your name"" owner [:name] :placeholder ""Type your name here"")))) You can also store validation data in local state which may be useful even if you store the actual data in an atom. A slightly more complete example: source demo ** This is an experimental feature. Please report any bugs. ** API Reference Please feel free to tweet me @martinbilski or drop me an email: gyamtso at gmail dot com. TBD Keep Readme short, move most of it to wiki. Contact library authors. Add tabs. Update 'controls' example. Blog post. Port tests. Credits Aspasia Beneti is the author and maintainer of Rum bindings for Reforms. License Copyright © 2015 Designed.ly, Marcin Bilski The use and distribution terms for this software are covered by the Eclipse Public License which can be found in the file LICENSE at the root of this distribution. By using this software in any fashion, you are agreeing to be bound by the terms of this license. You must not remove this notice, or any other, from this software. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/bilus/reforms"	"Beautiful Bootstrap 3 forms for Om and Reagent."	"true"
"Miscellaneous"	"reagent-forms"	"https://github.com/reagent-project/reagent-forms/"	"– Bootstrap form components for Reagent."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"192"	"13"	"56"	"GitHub - reagent-project/reagent-forms: Bootstrap form components for Reagent Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 13 Star 192 Fork 56 reagent-project/reagent-forms Code Issues 10 Pull requests 2 Pulse Graphs Bootstrap form components for Reagent 293 commits 2 branches 2 releases 23 contributors HTML 77.9% Clojure 18.9% CSS 3.2% HTML Clojure CSS Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags 0.5-release master Nothing to show 0.4.1 0.3.9 Nothing to show New pull request Latest commit 049dcbd Jun 24, 2016 spradnyesh committed with yogthos (.initializeTouchEvents js/React true) not needed (#108) … facebook/react#3442 Permalink Failed to load latest commit information. forms-example Datepicker label (#106) May 26, 2016 resources Fix datepicker css Mar 2, 2016 src/reagent_forms Datepicker label (#106) May 26, 2016 test/reagent_forms updated test to cljs Aug 31, 2014 .gitignore Datepicker label (#106) May 26, 2016 README.md (.initializeTouchEvents js/React true) not needed (#108) Jun 24, 2016 example.html added example Aug 31, 2014 project.clj bumped up version May 26, 2016 README.md reagent-forms A ClojureScript library to provide form data bindings for Reagent, see here for a live demo. Install Usage The library uses a Reagent atom as the document store. The components are bound to the document using the :field attribute. This key will be used to decide how the specific type of component should be bound. The component must also provide a unique :id attribute that is used to correlate it to the document. While the library is geared towards usage with Twitter Bootstrap, it is fairly agnostic about the types of components that you create. The :id can be a keyword, e.g: {:id :foo}, or a keywordized path {:id :foo.bar} that will map to {:foo {:bar ""value""}}. Alternatively, you can specify a vector path explicitly [:foo 0 :bar]. The following types of fields are supported out of the box: :input An input field can be of type :text, :numeric, :range, :password, :email, and :textarea. The inputs behave just like regular HTML inputs and update the document state when the :on-change event is triggered. [:input.form-control {:field :text :id :first-name}] [:input.form-control {:field :numeric :id :age}] The input fields can have an optional :fmt attribute that can provide a format string for the value: [:input.form-control   {:field :numeric :fmt ""%.2f"" :id :bmi :disabled true}] :typeahead The typeahead field uses a :data-source key bound to a function that takes the current input and returns a list of matching results. The control uses an input element to handle user input and renders the list of choices as an unordered list element containing one or more list item elements. Users may specify the css classes used to render each of these elements using the keys :input-class, :list-class and :item-class. Users may additionally specify a css class to handle highlighting of the current selection with the :highlight-class key. Reference css classes are included in the resources/public/css/reagent-forms.css file. (defn friend-source [text]   (filter     #(-> % (.toLowerCase %) (.indexOf text) (> -1))     [""Alice"" ""Alan"" ""Bob"" ""Beth"" ""Jim"" ""Jane"" ""Kim"" ""Rob"" ""Zoe""]))  [:div {:field :typeahead        :id :ta        :input-placeholder ""pick a friend""        :data-source friend-source        :input-class ""form-control""        :list-class ""typeahead-list""        :item-class ""typeahead-item""        :highlight-class ""highlighted""}] The typeahead field supports both mouse and keyboard selection. :checkbox The checkbox field creates a checkbox element: [:div.row   [:div.col-md-2 ""does data binding make you happy?""]   [:div.col-md-5    [:input.form-control {:field :checkbox :id :happy-bindings}]]] The checkbox accepts an optional :checked attribute. When set the checkbox will be selected and the document path pointed to by the :id key will be set to true. [:div.row   [:div.col-md-2 ""does data binding make you happy?""]   [:div.col-md-5    [:input.form-control {:field :checkbox :id :happy-bindings :checked true}]]] :range Range control uses the :min and :max keys to create an HTML range input: [:input.form-control  {:field :range :min 10 :max 100 :id :some-range}] :radio Radio buttons do not use the :id key since it must be unique and are instead grouped using the :name attribute. The :value attribute is used to indicate the value that is saved to the document: [:input {:field :radio :value :a :name :radioselection} ""foo""] [:input {:field :radio :value :b :name :radioselection} ""bar""] [:input {:field :radio :value :c :name :radioselection} ""baz""] The radio button accepts an optional :checked attribute. When set the checkbox will be selected and the document path pointed to by the :name key will be set to true. [:input {:field :radio :value :a :name :radioselection} ""foo""] [:input {:field :radio :value :b :name :radioselection :checked true} ""bar""] [:input {:field :radio :value :c :name :radioselection} ""baz""] :file The file field binds the File object of an <input type=""file""/>. [:input {:field :file :type :file}] :files Same as file, except it works with <input type=""file"" multiple/> and binds the entire FileList object. [:input {:field :file :type :file :multiple true}] Lists List fields contain child elements whose values are populated in the document when they are selected. The child elements must each have a :key attribute pointing to the value that will be saved in the document. The value of the element must be a keyword. The elements can have an optional :visible? keyword that points to a predicate function. The function should accept the document and return a boolean value indicatiing whether the field should be shown. :list The :list field is used for creating HTML select elements containing option child elements: [:select.form-control {:field :list :id :many-options}   [:option {:key :foo} ""foo""]   [:option {:key :bar} ""bar""]   [:option {:key :baz} ""baz""]]  (def months   [""January"" ""February"" ""March"" ""April"" ""May"" ""June""    ""July"" ""August"" ""September"" ""October"" ""November"" ""December""])  [:select {:field :list :id :dob.day}       (for [i (range 1 32)]         [:option          {:key (keyword (str i))           :visible? #(let [month (get-in % [:dob :month])]                        (cond                         (< i 29) true                         (< i 31) (not= month :February)                         (= i 31) (some #{month} [:January :March :May :July :July :October :December])                         :else false))}           i])] [:select {:field :list :id :dob.month}   (for [month months]     [:option {:key (keyword month)} month])] [:select {:field :list :id :dob.year}   (for [i (range 1950 (inc (.getFullYear (js/Date.))))]     [:option {:key (keyword (str i))} i])] :single-select The single-select field behaves like the list, but supports different types of elements and allows the fields to be deselected: [:h3 ""single-select buttons""] [:div.btn-group {:field :single-select :id :unique-position}   [:button.btn.btn-default {:key :left} ""Left""]   [:button.btn.btn-default {:key :middle} ""Middle""]   [:button.btn.btn-default {:key :right} ""Right""]]  [:h3 ""single-select list""] [:ul.list-group {:field :single-select :id :pick-one}   [:li.list-group-item {:key :foo} ""foo""]   [:li.list-group-item {:key :bar} ""bar""]   [:li.list-group-item {:key :baz} ""baz""]] :multi-select The multi-select field allows multiple values to be selected and set in the document: [:h3 ""multi-select list""] [:div.btn-group {:field :multi-select :id :position}   [:button.btn.btn-default {:key :left} ""Left""]   [:button.btn.btn-default {:key :middle} ""Middle""]   [:button.btn.btn-default {:key :right} ""Right""]] :label Labels can be associated with a key in the document using the :id attribute and will display the value at that key. The lables can have an optional :preamble and :postamble keys with the text that will be rendered before and after the value respectively. The :placeholder key can be used to provide text that will be displayed in absence of a value: [:label {:field :label :id :volume}] [:label {:field :label :preamble ""the value is: "" :id :volume}] [:label {:field :label :preamble ""the value is: "" :postamble ""ml"" :id :volume}] [:label {:field :label :preamble ""the value is: "" :postamble ""ml"" :placeholder ""N/A"" :id :volume}]  :alert Alerts are bound to an id of a field that triggers the alert and can have an optional :event key. The event key should point to a function that returns a boolean value. An optional :closeable? true/false can be provided to control if a close button should be rendered (defaults to true). When an event is supplied then the body of the alert is rendered whenever the event returns true: [:input {:field :text :id :first-name}] [:div.alert.alert-success {:field :alert :id :last-name :event empty?} ""first name is empty!""] When no event is supplied, then the alert is shown whenever the value at the id is not empty and displays the value: (def doc (atom {}))  ;;define an alert that watches the `:errors.first-name` key for errors [:div.alert.alert-danger {:field :alert :id :errors.first-name}]  ;;trigger the alert by setting the error key [:button.btn.btn-default   {:on-click     #(if (empty? (:first-name @doc))       (swap! doc assoc-in [:errors :first-name] ""first name is empty!""))}   ""save""] :datepicker [:div {:field :datepicker :id :birthday :date-format ""yyyy/mm/dd"" :inline true}] The date is stored in the document using the following format: {:year 2014 :month 11 :day 24} The datepicker can also take an optional :auto-close? key to indicate that it should be closed when the day is clicked. This defaults to false. Datepicker takes an optional :lang key which you can use to set the locale of the datepicker. There are currently English, Russian, German, French, Spanish, Portuguese, Finnish and Dutch built in translations. To use a built-in language pass in :lang with a keyword as in the following table: Language Keyword English :en-US (default) Russian :ru-RU German :de-DE French :fr-FR Spanish :es-ES Portuguese :pt-PT Finnish :fi-FI Dutch :nl-NL Example of using a built in language locale: {:field :datepicker :id :date :date-format ""yyyy/mm/dd"" :inline true :lang :ru-RU} You can also provide a custom locale hash-map to the datepicker. :first-day marks the first day of the week starting from Sunday as 0. All of the keys must be specified. Example of using a custom locale hash-map: {:field :datepicker :id :date :date-format ""yyyy/mm/dd"" :inline true :lang  {:days        [""First"" ""Second"" ""Third"" ""Fourth"" ""Fifth"" ""Sixth"" ""Seventh""]   :days-short  [""1st"" ""2nd"" ""3rd"" ""4th"" ""5th"" ""6th"" ""7th""]   :months      [""Month-one"" ""Month-two"" ""Month-three"" ""Month-four"" ""Month-five"" ""Month-six""                 ""Month-seven"" ""Month-eight"" ""Month-nine"" ""Month-ten"" ""Month-eleven"" ""Month-twelve""]   :months-short [""M1"" ""M2"" ""M3"" ""M4"" ""M5"" ""M6"" ""M7"" ""M8"" ""M9"" ""M10"" ""M12""]   :first-day 0}} The datepicker requires additional CSS in order to be rendered correctly. The default CSS is provided in reagent-forms.css in the resource path. Simply make sure that it's included on the page. The File can be read using: (-> ""reagent-forms.css"" clojure.java.io/resource slurp) :container The container element can be used to group different element. The container can be used to set the visibility of multiple elements. :valid? key accepts a function which takes the current state of the document as the sole argument. This function returns a class to be concatenated to the class list of the element. [:div.form-group  {:field :container   :visible? #(:show-name? %)}  [:input {:field :text :id :first-name}]  [:input {:field :text :id :last-name}]] Setting component visibility The components may supply an optional :visible? key in their attributes that points to a decision function. The function is expected to take the current value of the document and produce a truthy value that will be used to decide whether the component should be rendered, eg: (def form   [:div    [:input {:field :text             :id :foo}]    [:input {:field :text             :visible? #(empty? (:foo %))             :id :bar}]]) Binding the form to a document The field components behave just like any other Reagent components and can be mixed with them freely. A complete form example can be seen below. Form elements can be bound to a nested structure by using the . as a path separator. For example, the following component [:input {:field :text :id :person.first-name}] binds to the following path in the state atom {:person {:first-name <field-value>}} (defn row [label input]   [:div.row     [:div.col-md-2 [:label label]]     [:div.col-md-5 input]])  (def form-template   [:div    (row ""first name"" [:input {:field :text :id :first-name}])    (row ""last name"" [:input {:field :text :id :last-name}])    (row ""age"" [:input {:field :numeric :id :age}])    (row ""email"" [:input {:field :email :id :email}])    (row ""comments"" [:textarea {:field :textarea :id :comments}])]) important note The templates are eagerly evaluated, and you should always call the helper functions as in the example above instead of putting them in a vector. These will be replaced by Reagent components when the bind-field is called to compile the template. Once a form template is created it can be bound to a document using the bind-fields function: (ns myform.core   (:require [reagent-forms.core :refer [bind-fields]]             [reagent.core :as r]))  (defn form []   (let [doc (r/atom {})]     (fn []       [:div        [:div.page-header [:h1 ""Reagent Form""]]        [bind-fields form-template doc]        [:label (str @doc)]])))  (reagent/render-component [form] (.getElementById js/document ""container"")) The form can be initialized with a populated document, and the fields will be initialize with the values found there: (def form-template   [:div    (row ""first name""         [:input.form-control {:field :text :id :first-name}])    (row ""last name""         [:input.form-control {:field :text :id :last-name}])    (row ""age""         [:input.form-control {:field :numeric :id :age}])    (row ""email""         [:input.form-control {:field :email :id :email}])    (row ""comments""         [:textarea.form-control {:field :textarea :id :comments}])])  (defn form []   (let [doc (atom {:first-name ""John"" :last-name ""Doe"" :age 35})]     (fn []       [:div        [:div.page-header [:h1 ""Reagent Form""]]        [bind-fields form-template doc]        [:label (str @doc)]]))) Adding events The bind-fields function accepts optional events. Events are triggered whenever the document is updated, and will be executed in the order they are listed. Each event sees the document modified by its predecessor. The event must take 3 parameters, which are the id, the value, and the document. The id and the value represent the value that was changed in the form, and the document is the atom that contains the state of the form. The event can either return an updated document or nil, when nil is returned then the state of the document is unmodified. The following is an example of an event to calculate the value of the :bmi key when the :weight and :height keys are populated: (defn row [label input]   [:div.row     [:div.col-md-2 [:label label]]     [:div.col-md-5 input]])  (def form-template  [:div    [:h3 ""BMI Calculator""]    (row ""Height"" [:input {:field :numeric :id :height}])    (row ""Weight"" [:input {:field :numeric :id :weight}])    (row ""BMI"" [:input {:field :numeric :id :bmi :disabled true}])])  [bind-fields   form-template   doc   (fn [id value {:keys [weight height] :as doc}]     (when (and (some #{id} [:height :weight]) weight height)       (assoc-in doc [:bmi] (/ weight (* height height)))))] Adding custom fields Custom fields can be added by implementing the reagent-forms.core/init-field multimethod. The method must take two parameters, where the first parameter is the field component and the second is the options. By default the options will contain the get and the save! keys. The get key points to a function that accepts an id and returns the document value associated with it. The save! function accepts an id and a value that will be associated with it. Using adapters Adapters can be provided to fields so as to create custom storage formats for field values. These are a pair of functions passed to the field through the keys :in-fn and :out-fn. :in-fn modifies the stored item so that the field can make use of it while :out-fn modifies the output of the field before it is stored. For example, in order to use a native js/Date object as the storage format, the datepicker can be initialized thusly: [:div {:field :datepicker :id :birthday :date-format ""yyyy/mm/dd"" :inline true        :in-fn #(when % {:year (.getFullYear %) :month (.getMonth %) :day (.getDate %)})        :out-fn #(when % (js/Date (:year %) (:month %) (:day %)))}] Adapters may be passed nulls so they must be able to handle those. Mobile Gotchas Safari on iOS will have a 300ms delay for :on-click events, it's possible to set a custom trigger event using the :touch-event key. See here for the list of events available in React. For example, if we wanted to use :on-touch-start instead of :on-click to trigger the event then we could do the following: [:input.form-control {:field :text :id :first-name :touch-event :on-touch-start}] Note that you will also have to set the style of cursor: pointer for any elements other than buttons in order for events to work on iOS. The TapEventPlugin for react is another option for creating responsive events, until the functionality becomes available in React itself. License Copyright © 2014 Yogthos Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/reagent-project/reagent-forms/"	"– Bootstrap form components for Reagent."	"true"
"Miscellaneous"	"Truss"	"https://github.com/ptaoussanis/truss"	"– An opinionated assertions API for Clojure/ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"143"	"11"	"4"	"GitHub - ptaoussanis/truss: Assertions API for Clojure/Script Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 11 Star 143 Fork 4 ptaoussanis/truss Code Issues 0 Pull requests 0 Pulse Graphs Assertions API for Clojure/Script https://www.taoensso.com 31 commits 2 branches 6 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show v1.3.3 v1.2.0 v1.1.2 v1.1.1 v1.1.0 v1.0.0 Nothing to show New pull request Latest commit 66bd60b Jul 11, 2016 ptaoussanis Bump deps, update README for clojure.spec Permalink Failed to load latest commit information. src/taoensso BREAKING: refactor, change `*error-fn*` args (allow low-cost pass thr… Jun 15, 2016 .gitignore Initial project.clj, README, etc. Dec 24, 2015 CHANGELOG.md v1.3.3 Jun 15, 2016 LICENSE Initial project.clj, README, etc. Dec 24, 2015 README.md Bump deps, update README for clojure.spec Jul 12, 2016 benchmarks.jpg Bump deps, update README for clojure.spec Jul 12, 2016 hero.png Initial project.clj, README, etc. Dec 24, 2015 project.clj Bump deps, update README for clojure.spec Jul 12, 2016 talk.jpg Project, README housekeeping Feb 17, 2016 README.md CHANGELOG | API | current Break Version: [com.taoensso/truss ""1.3.3""] ; Stable Please consider helping to support my continued open-source Clojure/Script work? Even small contributions can add up + make a big difference to help sustain my time writing, maintaining, and supporting Nippy and other Clojure/Script libraries. Thank you! - Peter Taoussanis Truss Great Clojure/Script error messages where you need them most Or: A lightweight alternative to static typing, clojure.spec, core.typed, @plumatic/Schema, etc. Or: (have set? x) => (if (set? x) x (throw-detailed-assertion-error!)) Truss is a micro library for Clojure/Script that provides fast, flexible runtime condition assertions with great error messages. It can be used to get many of the most important benefits of static/gradual typing without the usual rigidity or onboarding costs. A doubtful friend is worse than a certain enemy. Let a man be one thing or the other, and we then know how to meet him. - Aesop Features Tiny cross-platform codebase with zero external dependencies Trivial to understand and use Use just when+where you need it (incl. libraries) Minimal (or zero) runtime performance cost A practical 80% solution (focus on improving error messages) Fast. Truss outperforms all similar libraries that I'm aware of. How does it compare to clojure.spec? I have a truly marvellous comparison to share, which this Tweet is unfortunately too narrow to contain... There's a lot that I like about clojure.spec, and think that it's a wonderful addition to Clojure that makes some really smart choices. But, invariably, writing software is about making trade-offs; and nothing can be optimized for every case. As I see it, clojure.spec takes a balanced view that emphasizes the ability to use one tool (specs) to do a number of useful things: Provide documentation Provide runtime conformance testing and destructuring Provide generative testing That's great leverage for one concept, and I think the big-picture emphasis makes sense for clojure.spec's role in the ecosystem. It's the right choice. But, as I see it, tying some of these things together also makes clojure.spec suboptimal for some of the things for which I like to use Truss. Some of Truss's comparative benefits as I see them: Inline assertions of arbitrary forms - easily check your assumptions about the arbitrary internal state of your functions Zero setup or ceremony; only need to define concepts if you're expecting to reuse them often Well suited to throwaway dev/debugging work Arbitrarily complex, real-world predicates without worrying about how they'll interact with generative testing or doc generation [1] Very fast assertion runtime checking [1] Writing a valid-customer? predicate is often much, much easier than writing a valid-customer generator. It might still be useful to write the generator at some point, but I may like being able to choose if/when to invest in doing that. All of this is of course subjective, and a little difficult to express w/o a lengthy post and detailed non-toy examples. Suffice it to say: I like clojure.spec a lot and will be using it. It's good. At the same time, I think it serves a very different sweet spot to Truss, so I'm going to be using them together and letting them complement one another. I'd summarize like so: clojure.spec is a relatively high-level way to formally specify and help verify the shape of your Clojure data and functions. Truss is a fast, low-ceremony, low-level way of encoding assumptions about arbitrary Clojure forms, directly into the forms. The use cases overlap, but not massively (and not as much as you might think). When/where you'd reach for each is subjective and unfortunately a little nuanced so quite beyond the scope of this. Ultimately it's not too important; use whatever you feel most productive with. If/when you start feeling frustrated by aspects of what you're using- that's when you'll best be able to define what you'd like to be different, and so when you'll best be prepared to look for the right complementary tools. UPDATE: clojure.spec seems to still be undergoing pretty aggressive development, so comments here may/not go stale by the time you read this. Will try update after Clojure v1.9 is stable. Performance Truss is highly optimized, and doesn't try to do too much. In most cases, it'll expand to no more than (if (pred arg) arg (throw-detailed-assertion-error!)) - about as lightweight as you can get for an assertion. All the good stuff happens during macro-expansion time, to populate the assertion error with useful compile-time info. More details on Truss's performance available here. Graph generated by @muhuk/validation-benchmark Quickstart Add the necessary dependency to your project: [com.taoensso/truss ""1.3.3""] And setup your namespace imports: (ns my-clj-ns ; Clojure namespace   (:require [taoensso.truss :as truss :refer (have have! have?)]))  (ns my-cljs-ns ; ClojureScript namespace   (:require [taoensso.truss :as truss :refer-macros (have have! have?)])) Truss uses a simple (predicate arg) pattern that should immediately feel familiar to Clojure users: (defn square [n]   (let [n (have integer? n)] ; <- A Truss assertion [1]     (* n n)))  ;; [1] This basically expands to (if (integer? n) n (throw-detailed-assertion-error!))  (square 5)   ; => 25 (square nil) ; => ;; Invariant violation in `taoensso.truss.examples:11` [pred-form, val]: ;; [(integer? n), <nil>] ;; {:instant 1450937904762, ;;  :ns ""taoensso.truss.examples"", ;;  :elidable? true, ;;  :val nil, ;;  :val-type nil, ;;  :?err nil, ;;  :*assert* true, ;;  :?data nil, ;;  :?line 11, ;;  :form-str ""(integer? n)""} And that's it, you know the Truss API. The (have <pred> <arg>) annotation is a standard Clojure form that both documents the intention of the code in a way that cannot go stale, and provides a runtime check that throws a detailed error message on any unexpected violation. When to use a Truss assertion You use Truss to formalize assumptions that you have about your data (e.g. function arguments, intermediate values, or current application state at some point in your execution flow). So any time you find yourself making implementation choices based on implicit information (e.g. the state your application should be in if this code is running) - that's when you might want to reach for Truss instead of a comment or Clojure assertion. Use Truss assertions like salt in good cooking; a little can go a long way. Motivation Feel free to skim/skip this section :-) Clojure is a beautiful language full of smart trade-offs that tends to produce production code that's short, simple, and easy to understand. But every language necessarily has trade-offs. In the case of Clojure, dynamic typing leads to one of the more common challenges that I've observed in the wild: debugging or refactoring large codebases. Specifically: Undocumented type assumptions changing (used to be this thing was never nil; now it can be) Documented type assumptions going stale (forgot to update comments) Unhelpful error messages when a type assumption is inevitably violated (it crashed in production? why?) Thankfully, this list is almost exhaustive; in my experience these few causes often account for 80%+ of real-world incidental difficulty. So Truss targets these issues with a practical 80% solution that emphasizes: Ease of adoption (incl. partial/precision adoption) Ease of use Flexibility The first is particularly important since the need for assertions in a good Clojure codebase is surprisingly rare. Every codebase has trivial parts and complex parts. Parts that suffer a lot of churn, and parts that haven't changed in years. Mission-critical parts (bank transaction backend), and those that aren't so mission-critical (prototype UI for the marketing department). Having the freedom to reinforce code only where and when you judge it worthwhile: Let's you (/ your developers) easily evaluate the lib Makes it more likely that you (/ your developers) will actually use the lib Eliminates upfront buy-in costs Allows you to retain control over long-term cost/benefit trade-offs Examples! All examples are from src/taoensso/truss/examples.cljc Truss's sweet spot is often in longer, complex code (difficult to show here). So these examples are mostly examples of syntax, not use case. In particular, they mostly focus on simple argument type assertions since those are the easiest to understand. In practice, you'll often find more value from assertions about your application state or intermediate let values within a larger piece of code. Inline assertions and bindings A Truss (have <pred> <arg>) form will either throw or return the given argument. This lets you use these forms within other expressions and within let bindings, etc. ;; You can add an assertion inline (println (have string? ""foo""))  ;; Or you can add an assertion to your bindings (let [s (have string? ""foo"")]   (println s))  ;; Anything that fails the predicate will throw an error (have string? 42) ; => ;; Invariant violation in `taoensso.truss.examples:44` [pred-form, val]: ;; [(string? 42), 42] ;; {:instant 1450937836680, ;;  :ns ""taoensso.truss.examples"", ;;  :elidable? true, ;;  :val 42, ;;  :val-type java.lang.Long, ;;  :?err nil, ;;  :*assert* true, ;;  :?data nil, ;;  :?line 44, ;;  :form-str ""(string? 42)""}  ;; Truss also automatically traps and handles exceptions (have string? (/ 1 0)) ; => ;; Invariant violation in `taoensso.truss.examples:59` [pred-form, val]: ;; [(string? (/ 1 0)), <undefined>] ;; `val` error: java.lang.ArithmeticException: Divide by zero ;; {:instant 1450938025898, ;;  :ns ""taoensso.truss.examples"", ;;  :elidable? true, ;;  :val undefined/threw-error, ;;  :val-type undefined/threw-error, ;;  :?err #error { ;;  :cause ""Divide by zero"" ;;  :via ;;  [{:type java.lang.ArithmeticException ;;    :message ""Divide by zero"" ;;    :at [clojure.lang.Numbers divide ""Numbers.java"" 158]}] ;;  :trace [...]}] ;;  :*assert* true, ;;  :?data nil, ;;  :?line 59, ;;  :form-str ""(string? (/ 1 0))""} Destructured bindings ;; You can assert against multipe args at once (let [[x y z] (have string? ""foo"" ""bar"" ""baz"")]   (str x y z)) ; => ""foobarbaz""  ;; This won't compromise error message clarity (let [[x y z] (have string? ""foo"" 42 ""baz"")]   (str x y z)) ; =>   ;; Invariant violation in `taoensso.truss.examples:91` [pred-form, val]: ;; [(string? 42), 42] ;; {:instant 1450938267043, ;;  :ns ""taoensso.truss.examples"", ;;  :elidable? true, ;;  :val 42, ;;  :val-type java.lang.Long, ;;  :?err nil, ;;  :*assert* true, ;;  :?data nil, ;;  :?line 91, ;;  :form-str ""(string? 42)""} Attaching debug data You can attach arbitrary debug data to be displayed on violations: (defn my-handler [ring-req x y]   (let [[x y] (have integer? x y :data {:ring-req ring-req})]     (* x y)))  (my-handler {:foo :bar} 5 nil) ; => ;; Invariant violation in `taoensso.truss.examples:146` [pred-form, val]: ;; [(integer? y), <nil>] ;; {:instant 1450939196719, ;;  :ns ""taoensso.truss.examples"", ;;  :elidable? true, ;;  :val nil, ;;  :val-type nil, ;;  :?err nil, ;;  :*assert* true, ;;  :?data {:ring-req {:foo :bar}}, ; <--- This got included ;;  :?line 146, ;;  :form-str ""(integer? y)""} Attaching dynamic debug data And you can attach shared debug data at the binding level: (defn wrap-ring-dynamic-assertion-data   ""Returns Ring handler wrapped so that assertion violation errors in handler   will include `(data-fn <ring-req>)` as debug data.""   [data-fn ring-handler-fn]   (fn [ring-req]     (truss/with-dynamic-assertion-data (data-fn ring-req)       (ring-handler-fn ring-req))))  (defn ring-handler [ring-req]   (have? string? 42) ; Will always fail   {:status 200 :body ""Done""})  (def wrapped-ring-handler   (wrap-ring-dynamic-assertion-data     ;; Include Ring session with all handler's assertion errors:     (fn data-fn [ring-req] {:ring-session (:session ring-req)})     ring-handler))  (comment   (wrapped-ring-handler     {:method :get :uri ""/"" :session {:user-name ""Stu""}}) ; =>    ;; Invariant violation in `taoensso.truss.examples:136` [pred-form, val]:    ;; [(string? 42), 42]    ;; {:*?data* {:ring-session {:user-name ""Stu""}}, ; <--- This got included    ;;  :elidable? true,    ;;  :dt #inst ""2015-12-28T05:57:49.759-00:00"",    ;;  :val 42,    ;;  :ns-str ""taoensso.truss.examples"",    ;;  :val-type java.lang.Long,    ;;  :?err nil,    ;;  :*assert* true,    ;;  :?data nil,    ;;  :?line 136,    ;;  :form-str ""(string? 42)""}   ) Assertions within data structures ;;; Compare (have vector?      [:a :b :c]) ; => [:a :b :c] (have keyword? :in [:a :b :c]) ; => [:a :b :c] Assertions within :pre/:post conditions Just make sure to use the have? variant which always returns a truthy val on success: (defn square [n]   ;; Note the use of `have?` instead of `have`   {:pre  [(have? #(or (nil? %) (integer? %)) n)]    :post [(have? integer? %)]}   (let [n (or n 1)]     (* n n)))  (square 5)   ; => 25 (square nil) ; => 1 Special predicates Truss offers some shorthands for your convenience. These are all optional: the same effect can always be achieved with an equivalent predicate fn: ;; A predicate can be anything (have #(and (integer? %) (odd? %) (> % 5)) 7) ; => 7  ;; Omit the predicate as a shorthand for #(not (nil? %)) (have ""foo"") ; => ""foo"" (have nil)   ; => Error  ;;; There's a number of other optional shorthands  ;; Combine predicates (or) (have [:or nil? string?] ""foo"") ; => ""foo""  ;; Combine predicates (and) (have [:and integer? even? pos?] 6) ; => 6  ;; Element of (have [:el #{:a :b :c :d}] :b) ; => :b (have [:el #{:a :b :c :d}] :e) ; => Error  ;; Superset (have [:set>= #{:a :b}] #{:a :b :c}) ; => #{:a :b :c}  ;; Key superset (have [:ks>= #{:a :b}] {:a ""A"" :b nil :c ""C""}) ; => {:a ""A"" :b nil :c ""C""}  ;; Non-nil keys (have [:ks-nnil? #{:a :b}] {:a ""A"" :b nil :c ""C""}) ; => Error Writing custom validators No need for any special syntax or concepts, just define a function as you'd like: ;; A custom predicate: (defn pos-int? [x] (and (integer? x) (pos? x)))  (defn have-person   ""Returns given arg if it's a valid `person`, otherwise throws an error""   [person]   (truss/with-dynamic-assertion-data {:person person} ; (Optional) setup some extra debug data     (have? map? person)     (have? [:ks>= #{:age :name}] person)     (have? [:or nil? pos-int?] (:age person)))   person ; Return input if nothing's thrown   )  (have-person {:name ""Steve"" :age 33})   ; => {:name ""Steve"", :age 33} (have-person {:name ""Alice"" :age ""33""}) ; => Error FAQ How can I report/log violations? By default, Truss just throws an exception on any invariant violations. You can adjust that behaviour with the set-error-fn! and with-error-fn utils. Some common usage ideas: Use with-error-fn to capture violations during unit testing Use set-error-fn! to log violations with something like Timbre Should I annotate my whole API? Please don't! I'd encourage you to think of Truss assertions like salt in good cooking; a little can go a long way, and the need for too much salt can be a sign that something's gone wrong in the cooking. Another useful analogy would be the Clojure STM. Good Clojure code tends to use the STM very rarely. When you want the STM, you really want it - but many new Clojure developers end up surprised at just how rarely they end up wanting it in an idiomatic Clojure codebase. Do the interns keep getting that argument wrong despite attempts at making the code as clear as possible? By all means, add an assertion. More than anything, I tend to use Truss assertions as a form of documentation in long/hairy or critical bits of code to remind myself of any unusual input/output contracts/expectations. E.g. for performance reasons, we need this to be a vector; throw if a list comes in since it means that some consumer has a bug. I very rarely use Truss for library code, though I wouldn't hesitate to in cases that might inherently be confusing or to guard against common error cases that'd otherwise be hard to debug. What's the performance cost? Usually insignificant. Truss has been highly tuned to minimize both code expansion size[1] and runtime costs. In many common cases, a Truss expression expands to no more than (if (pred arg) arg (throw-detailed-assertion-error!)). (quick-bench 1e5   (if (string? ""foo"") ""foo"" (throw (Exception. ""Assertion failure"")))   (have string? ""foo"")) ;; => [4.19 4.17] ; ~4.2ms / 100k iterations [1] This can be important for ClojureScript codebases So we're seeing zero overhead against a simple predicate test in this example. In practice this means that predicate costs dominate. For simple predicates (including instance? checks), modern JITs work great; the runtime performance impact is almost always completely insignificant even in tight loops. In rare cases where the cost does matter (e.g. for an unusually expensive predicate), Truss supports complete elision in production code. Disable clojure.core/*assert* and Truss forms will noop, passing their arguments through with zero performance overhead. An extra macro is provided (have!) which ignores *assert* and so can never be elided. This is handy for implementing (and documenting) critical checks like security assertions that you never want disabled. (defn get-restricted-resource [ring-session]   ;; This is an important security check so we'll use `have!` here instead of   ;; `have` to make sure the check is never elided (skipped):   (have! string? (:auth-token ring-session))    ""return-restricted-resource-content"") Tip: when in doubt just use have! instead of have How do I disable clojure.core/*assert*? If you're using Leiningen, you can add the following to your project.clj: :global-vars {;; *warn-on-reflection* true               *assert*                true               ;; *unchecked-math*     :warn-on-boxed               } Wouldn't you rather just have static typing? Every conceivable type system necessarily provides trade-offs. Sometimes you'll want a static type system, sometimes a dynamic, and sometimes a gradual. Truss is a tool to help folks who've decided that a dynamic or gradual type system makes sense for their current team and objectives. Wouldn't you rather just have unit tests? Unit tests are one common way of dealing with some of the challenges that large Clojure codebases face. In my experience, Truss can cover a lot of (but not all) the same ground. In cases of overlap, choose whichever you feel would be more productive for your team and objectives. Personally, I tend to favour Truss when possible because an assertion: Is present precisely where it's relevant Acts as a form of documentation Tends to be quicker to write and keep up-to-date than a test Offers runtime protection Any related/similar/alternative libraries you could recommend? Confession: I wrote the first versions of Truss back in 2012. Since it satisfied my own needs, haven't spent much time since then looking too closely at any alternatives besides core.typed. Would definitely encourage interested folks to take a good look at all the tools available today, experiment, and find the option/s that best suit your particular goals and preferred work style. Link Description core.typed An optional type system for Clojure @plumatic/schema Clojure(Script) library for declarative data description and validation @marick/structural-typing Structural typing for Clojure by the creator of Midje, somewhat inspired by Elm How does Truss compare to gradual typing / core.typed? Typed Clojure is awesome and something I'd definitely recommend considering. As with all type systems though, it necessarily provides trade-offs. Some of the challenges I've noticed with gradual typing: Buy-in cost can sometimes be high (often all-or-nothing adoption) Difficulty evaluating benefits (because of the buy-in cost) Difficulty with inclusion in libraries (forces downstream requirements) Difficulty educating developers (new syntax, type theory, etc.) Added complexity (lots of code, extra tools, possible bugs, library incompatibilities, etc.) Sometimes clumsy/difficult to define nuanced types (e.g. transducers) Low control over long-term cost/benefit trade-offs (can be difficult to apply with precision where it'd most help) To be clear: there's absolutely times when gradual typing provides a wonderful fit. Indeed, I've found the practical overlap between core.typed and Truss small and the two often complimentary. Experiment, weigh your options, choose whatever makes sense for your team and objectives. Why isn't there something like this for <other programming language>? Short answer: Lisp macros. You could write something similar to Truss in most languages but you'd have a tough time getting the same balance of brevity, flexibility, and performance. Some things are just much easier in a Lisp. Logging's one of them, this is another. What's your view on static vs dynamic typing? I've used and enjoyed aspects of a number of type systems at one point or another. What I reach for on a particular job is entirely dependent on what I expect would be the most productive for that job. Likewise, the tools you'll find most productive will necessarily depend on you: your objectives and your preferred style of working. Trying to argue that one kind of programming is strictly better than another is like trying to argue that a chisel is strictly better than a wrench. I'd advocate using whatever tools help you meet your objectives, and regularly trying new stuff to get a sense of your options. Use what you like, skip the rest. Contacting me / contributions Please use the project's GitHub issues page for all questions, ideas, etc. Pull requests welcome. See the project's GitHub contributors page for a list of contributors. Otherwise, you can reach me at Taoensso.com. Happy hacking! - Peter Taoussanis License Distributed under the EPL v1.0 (same as Clojure). Copyright © 2015-2016 Peter Taoussanis. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/ptaoussanis/truss"	"– An opinionated assertions API for Clojure/ClojureScript."	"true"
"React.js Interface"	"React.js"	"https://facebook.github.io/react/"	"– An opinionated assertions API for Clojure/ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"45428"	"3247"	"7888"	"GitHub - facebook/react: A declarative, efficient, and flexible JavaScript library for building user interfaces. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3,247 Star 45,428 Fork 7,888 facebook/react Code Issues 491 Pull requests 87 Wiki Pulse Graphs A declarative, efficient, and flexible JavaScript library for building user interfaces. https://facebook.github.io/react/ 6,966 commits 21 branches 48 releases 746 contributors JavaScript 96.8% C++ 1.7% TypeScript 0.6% CoffeeScript 0.4% Python 0.3% C 0.2% JavaScript C++ TypeScript CoffeeScript Python C Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags 0.3-stable 0.4-stable 0.5-stable 0.8-stable 0.9-stable 0.10-stable 0.11-stable 0.12-stable 0.13-stable 0.14-stable 15-dev 15-stable 15.0.2-dev 15.0.3-dev 15.1.0-dev Daniel15-patch-1 gaearon-patch-1 gh-pages master revert-6661-master revert-6921-remove-set-props-and-replace-props Nothing to show v15.2.1 v15.2.0 v15.1.0 v15.0.2 v15.0.1 v15.0.0 v15.0.0-rc.2 v15.0.0-rc.1 v0.14.8 v0.14.7 v0.14.6 v0.14.5 v0.14.4 v0.14.3 v0.14.2 v0.14.1 v0.14.0 v0.14.0-rc1 v0.14.0-beta3 v0.14.0-beta2 v0.14.0-beta1 v0.13.3 v0.13.2 v0.13.1 v0.13.0 v0.13.0-rc2 v0.13.0-rc1 v0.12.2 v0.12.1 v0.12.0 v0.12.0-rc1 v0.11.2 v0.11.1 v0.11.0 v0.11.0-rc1 v0.10.0 v0.10.0-rc1 v0.9.0 v0.9.0-rc1 v0.8.0 v0.5.2 v0.5.1 v0.5.0 v0.4.2 v0.4.1 v0.4.0 v0.3.3 v0.3.0 Nothing to show New pull request Latest commit dc11e61 Jul 14, 2016 gaearon committed on GitHub Minor tweaks to Design Principles (#7283) Permalink Failed to load latest commit information. .github Add basic issue and PR templates (#6597) May 11, 2016 docs Minor tweaks to Design Principles (#7283) Jul 14, 2016 eslint-rules Year-agnostic copyright message, like React Native uses, to prevent t… Dec 29, 2015 examples Rudimentary DOM Renderer with Example Jun 30, 2016 flow Remove duplicate line (#7210) Jul 7, 2016 grunt Gulp: lint, flow, and version-check (#7174) Jul 5, 2016 gulp/tasks Gulp: lint, flow, and version-check (#7174) Jul 5, 2016 mocks Year-agnostic copyright message, like React Native uses, to prevent t… Dec 29, 2015 packages Setup grunt flow task and run on travis (#6684) May 3, 2016 scripts Update benchmarks to be more realistic polymorphically (#7255) Jul 12, 2016 src Fix TestUtils crash with NODE_ENV=production (#7246) Jul 14, 2016 starter Fix file reference typo in starter Nov 29, 2015 vendor Add semicolon for react-dom source files. Jan 20, 2016 .babelrc Add reactProdInvariant and corresponding babel rewrite pass (#6948) Jun 7, 2016 .editorconfig Add insert_final_newline to editorconfig Sep 3, 2015 .eslintignore Add (failing) React ART tests May 24, 2016 .eslintrc.js Fix function declaration in if statement (#6963) Jun 4, 2016 .flowconfig Apply side-effects to host containers Jun 30, 2016 .gitattributes .gitattributes to ensure LF line endings when we should Jan 17, 2014 .gitignore update zh-docs (v0.14.3+) Dec 24, 2015 .mailmap Update authors for v15 Apr 4, 2016 .travis.yml Add a gulp script for extracting error codes (#6882) Jun 1, 2016 AUTHORS Update authors for v15 Apr 4, 2016 CHANGELOG.md Fixed PR link Jul 5, 2016 CONTRIBUTING.md Add link to video chat with @spicyj (#7252) Jul 12, 2016 Gruntfile.js Gulp: lint, flow, and version-check (#7174) Jul 5, 2016 LICENSE Year-agnostic copyright message, like React Native uses, to prevent t… Dec 29, 2015 LICENSE-docs Update licenses for docs and examples Oct 22, 2014 LICENSE-examples Update licenses for docs and examples Oct 22, 2014 PATENTS Update Patent Grant Apr 10, 2015 README.md Update readme for 15.2.0 Jul 1, 2016 gulpfile.js Gulp: lint, flow, and version-check (#7174) Jul 5, 2016 package.json Gulp: lint, flow, and version-check (#7174) Jul 5, 2016 README.md React React is a JavaScript library for building user interfaces. Declarative: React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes. Declarative views make your code more predictable, simpler to understand, and easier to debug. Component-Based: Build encapsulated components that manage their own state, then compose them to make complex UIs. Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and keep state out of the DOM. Learn Once, Write Anywhere: We don't make assumptions about the rest of your technology stack, so you can develop new features in React without rewriting existing code. React can also render on the server using Node and power mobile apps using React Native. Learn how to use React in your own project. Examples We have several examples on the website. Here is the first one to get you started: var HelloMessage = React.createClass({   render: function() {     return <div>Hello {this.props.name}</div>;   } });  ReactDOM.render(   <HelloMessage name=""John"" />,   document.getElementById('container') ); This example will render ""Hello John"" into a container on the page. You'll notice that we used an HTML-like syntax; we call it JSX. JSX is not required to use React, but it makes code more readable, and writing it feels like writing HTML. A simple transform is included with React that allows converting JSX into native JavaScript for browsers to digest. Installation The fastest way to get started is to serve JavaScript from the CDN (also available on cdnjs and jsdelivr): <!-- The core React library --> <script src=""https://fb.me/react-15.2.0.js""></script> <!-- The ReactDOM Library --> <script src=""https://fb.me/react-dom-15.2.0.js""></script> We've also built a starter kit which might be useful if this is your first time using React. It includes a webpage with an example of using React with live code. If you'd like to use bower, it's as easy as: bower install --save react And it's just as easy with npm: npm i --save react Contribute The main purpose of this repository is to continue to evolve React core, making it faster and easier to use. If you're interested in helping with that, then keep reading. If you're not interested in helping right now that's ok too. :) Any feedback you have about using React would be greatly appreciated. Building Your Copy of React The process to build react.js is built entirely on top of node.js, using many libraries you may already be familiar with. Prerequisites You have node installed at v4.0.0+ and npm at v2.0.0+. You have gcc installed or are comfortable installing a compiler if needed. Some of our npm dependencies may require a compliation step. On OS X, the Xcode Command Line Tools will cover this. On Ubuntu, apt-get install build-essential will install the required packages. Similar commands should work on other Linux distros. Windows will require some additional steps, see the node-gyp installation instructions for details. You are familiar with npm and know whether or not you need to use sudo when installing packages globally. You are familiar with git. Build Once you have the repository cloned, building a copy of react.js is really easy. # grunt-cli is needed by grunt; you might have this installed already npm install -g grunt-cli npm install grunt build At this point, you should now have a build/ directory populated with everything you need to use React. The examples should all work. Grunt We use grunt to automate many tasks. Run grunt -h to see a mostly complete listing. The important ones to know: # Build and run tests with PhantomJS grunt test # Lint the code with ESLint grunt lint # Wipe out build directory grunt clean Good First Bug To help you get your feet wet and get you familiar with our contribution process, we have a list of good first bugs that contain bugs which are fairly easy to fix. This is a great place to get started. License React is BSD licensed. We also provide an additional patent grant. React documentation is Creative Commons licensed. Examples provided in this repository and in the documentation are separately licensed. More… There's only so much we can cram in here. To read more about the community and guidelines for submitting pull requests, please read the Contributing document. Troubleshooting See the Troubleshooting Guide Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/facebook/react"	"– An opinionated assertions API for Clojure/ClojureScript."	"true"
"React.js Interface"	"Brutha"	"https://github.com/weavejester/brutha"	"– A simple and functional ClojureScript interface to React."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"116"	"14"	"1"	"GitHub - weavejester/brutha: Simple ClojureScript interface to React Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 14 Star 116 Fork 1 weavejester/brutha Code Issues 0 Pull requests 0 Pulse Graphs Simple ClojureScript interface to React 64 commits 1 branch 8 releases Fetching contributors Clojure 96.7% HTML 3.3% Clojure HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show 0.2.1 0.2.0 0.1.5 0.1.4 0.1.3 0.1.2 0.1.1 0.1.0 Nothing to show New pull request Latest commit c8652e5 Jun 6, 2016 weavejester Release 0.2.1 Permalink Failed to load latest commit information. example Release 0.2.1 Jun 6, 2016 src/brutha Update React to 15.1.0 Jun 6, 2016 test/brutha Remove clojurescript.test plugin Jun 6, 2016 .gitignore Add example project Apr 25, 2015 README.md Release 0.2.1 Jun 6, 2016 project.clj Release 0.2.1 Jun 6, 2016 README.md Brutha A simple and functional ClojureScript interface to React. Rationale Unlike Om and Reagent, Brutha is unopinionated on how you handle your application state. It doesn't include cursors or specialized atoms, instead relying on you to call a mount function with new state data. This is useful when you want to manage your application state yourself. Installation Add the following to your project :dependencies: [brutha ""0.2.1""]  Usage Brutha doesn't include a dom namespace like Om, so you'll need to use a library like Flupot, Sablono or Kioo. In the examples we'll use Flupot. First we'll require Brutha and Flupot: (ns brutha.example   (:require [brutha.core :as br]             [flupot.dom :as dom])) You can use the brutha.core/mount function to attach a React element to a DOM node. (def app (js/document.getElementById ""app""))  (br/mount (dom/p ""Hello World"") app) When you want to update, just call the mount function again. React will efficiently work out what needs to be changed and update only those elements. (br/mount (dom/p ""Goodbye World"") app) If you want to remove the associated component from a DOM node, use the brutha.core/unmount function: (br/unmount app) A Brutha component is a pure function that takes in an immutable data structure, and returns a React element. The most straightforward way to write a component is to pass a function to brutha.core/component: (def unixtime   (br/component (fn [date] (dom/p (str (.getTime date))))))  (br/mount (unixtime (js/Date.)) app) By wrapping the function in a component, React knows only to update the DOM when the value passed to the function changes. For debugging purposes, particularly when working with React Developer Tools, it often helps to give a component a display name by passing an extra argument when creating the component. (def unixtime   (br/component 'UnixTime (fn [date] (dom/p (str (.getTime date)))))) When using the same component multiple times with a collection of data, it's important to give React a key to identify the component. You can do this by passing a :key option to the component: (foo-component data {:key (:id data)}) Sometimes it's useful to know when a component is mounted onto the DOM. Brutha supports this too. Instead of supplying a function to component, you can supply a reified type: (def noisy-component   (br/component    (reify      br/IShouldUpdate      (should-update? [_ a b]        (not= a b))       br/IWillMount      (will-mount [_ value]        (js/console.log ""will-mount""))       br/IDidMount      (did-mount [_ value dom-node]        (js/console.log ""did-mount""))       br/IWillUpdate      (will-update [_ value next-value dom-node]        (js/console.log ""will-update""))       br/IDidUpdate      (did-update [_ value prev-value dom-node]        (js/console.log ""did-update""))       br/IWillUnmount      (will-unmount [_ value dom-node]        (js/console.log ""will-unmount""))       br/IRender      (render [_ value]        (dom/p ""Hello World""))))) A component is mounted once, and updated many times. The update methods will not be called on the initial render. For development, particularly with hot loading systems like Figwheel, it's often useful to force an update of a component after code has been reloaded. This can be done by binding the *force-update* var to true. (binding [br/*force-update* true]   (br/mount (some-component data) app)) License Copyright © 2016 James Reeves Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/weavejester/brutha"	"– A simple and functional ClojureScript interface to React."	"true"
"React.js Interface"	"Om"	"https://github.com/omcljs/om"	"— A powerful interface to React, makes use of its object oriented structures."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"5534"	"331"	"325"	"GitHub - omcljs/om: ClojureScript interface to Facebook's React Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 331 Star 5,534 Fork 325 omcljs/om Code Issues 26 Pull requests 7 Wiki Pulse Graphs ClojureScript interface to Facebook's React 1,784 commits 2 branches 90 releases 11 contributors Clojure 95.7% HTML 4.2% Other 0.1% Clojure HTML Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master om-528 Nothing to show show 1.0.0-alpha40 1.0.0-alpha39 1.0.0-alpha38 1.0.0-alpha37 1.0.0-alpha36 1.0.0-alpha35 1.0.0-alpha34 1.0.0-alpha33 1.0.0-alpha32 1.0.0-alpha31 1.0.0-alpha30 1.0.0-alpha28 1.0.0-alpha27 1.0.0-alpha26 1.0.0-alpha25 1.0.0-alpha24 1.0.0-alpha23 1.0.0-alpha22 1.0.0-alpha21 1.0.0-alpha20 1.0.0-alpha19 1.0.0-alpha18 1.0.0-alpha17 1.0.0-alpha16 1.0.0-alpha15 1.0.0-alpha14 1.0.0-alpha13 1.0.0-alpha12 1.0.0-alpha11 1.0.0-alpha10 1.0.0-alpha8 1.0.0-alpha7 1.0.0-alpha6 1.0.0-alpha5 1.0.0-alpha4 1.0.0-alpha3 0.9.0 0.8.8 0.8.7 0.8.6 0.8.4 0.8.3 0.8.2 0.8.1 0.8.0 0.8.0-rc1 0.8.0-beta5 0.8.0-beta4 0.8.0-beta3 0.8.0-beta2 0.8.0-beta1 0.8.0-alpha2 0.8.0-alpha1 0.7.3 0.7.2 0.7.1 0.7.0 0.6.5 0.6.3 0.6.2 0.6.1 0.6.0 0.5.3 0.5.2 0.5.1 0.5.0 0.5.0-rc1 0.4.2 0.4.1 0.4.0 0.3.6 0.3.5 0.3.4 0.3.3 0.3.2 0.3.1 0.3.0 0.2.3 0.2.2 0.2.1 0.2.0 0.1.7 0.1.6 0.1.5 0.1.4 0.1.3 0.1.2 0.1.1 0.1.0 Nothing to show New pull request Latest commit 40c51fd Jul 14, 2016 swannodette revert accidental pom.xml changes Permalink Failed to load latest commit information. bin enabling running tests at the commandline Jan 8, 2016 examples 0.8.6 Jan 26, 2015 resources devcards config Sep 27, 2015 script enabling running tests at the commandline Jan 8, 2016 src OM-673: Defaulting key to undefined in build Jul 13, 2016 .gitignore stop ignoring pom.xml Dec 4, 2015 CHANGES.md 0.8.8 Feb 1, 2015 README.md fix link Jul 7, 2016 epl.html license Dec 29, 2013 pom.xml revert accidental pom.xml changes Jul 14, 2016 project.clj OM-673: Defaulting key to undefined in build Jul 13, 2016 README.md Om A ClojureScript interface to Facebook's React. Om allows users to represent their UIs simply as EDN. Because ClojureScript data is immutable data, Om can always rapidly re-render the UI from the root. Thus Om UIs are out of the box snapshotable and undoable and these operations have no implementation complexity and little overhead. See for yourself. Unique Features Om supports features not currently present in React: Global state management facilities built in Components may have arbitrary data dependencies, not limited to props & state Component construction can be intercepted via :instrument. Simplifies debugging components and generic editors. Provides stream of all application state change deltas via :tx-listen. Simplifies synchronization online and offline. Customizable semantics. Fine grained control over how components store state, even for components outside of your control. Simplifies using Om components outside the Om framework, debugging, and adding event hooks not anticipated by original component designer. Tutorials There is an in-depth tutorial that will introduce you to the core concepts of Om here and a real-world integration example here. The community maintained om-cookbook covers many common idioms and patterns. Examples (ns example   (:require [om.core :as om]             [om.dom :as dom]))  (defn widget [data owner]   (reify     om/IRender     (render [this]       (dom/h1 nil (:text data)))))  (om/root widget {:text ""Hello world!""}   {:target (. js/document (getElementById ""my-app""))}) The repo includes several simple examples you can build yourself. If you view the project.clj you will see their build identifiers. Assuming you have Leiningen installed, to build an example run: lein cljsbuild once <build-id>  Then open the corresponding index.html in your favorite browser. For a more fleshed-out example, please see the Om implementation of TodoMVC exists here. Documentation There is documentation here. There is also a conceptual overview that we recommend reading as there are some design choices in Om that make it quite different from other client side solutions and even React itself. Reusable Components Om emphasizes building modular and adaptable components. Some examples: om-bootstrap, Bootstrap 3 Om Components ankha, an EDN inspector view om-draggable, generic draggable om-autocomplete, customizable autocompleter ff-om-draggable om-widgets om-dev-component, add dev features (e.g. state history navigation) to your component om-sync, keep client and server in sync (experimental) Applications built with Om Project FiFo, a SmartOS cloud orchestration platform Recurse Center Community Framed Netrunner CircleCI, source here Precursor Assistant Fitsme Goya, pixel editor with undo/redo and visual history AppShare, a Clojure web framework wordsmith, a markdown editor omchaya BVCA Private Equity Map session pOModoro Dakait, a web-based tool to manage downloads Mega Super Mario World, a detailed review of the classic video game and a SNES video editor Time for Coffee!, a handy website to display the next departures at public transport stops in Switzerland Omingard, a Solitaire-like card game. Making-of: My Way into Clojure. Horizon Alpha, a quick Hack and slash game using the Noob universe Solari Architects, portfolio for architecture firm. Using it The current version depends on React 0.13.3. Make sure you have Leiningen installed. Your project.clj should include something like the following: (defproject foo ""0.1.0""   ...   :dependencies [[org.clojure/clojure ""1.6.0""]                  [org.clojure/clojurescript ""0.0-2760""]                  [org.omcljs/om ""0.9.0""]]   ...) React with Add-Ons If you would rather use React with Add-Ons you can configure this with Maven's exclusions feature: (defproject foo ""0.1.0""   ...   :dependencies [[org.clojure/clojure ""1.6.0""]                  [org.clojure/clojurescript ""0.0-2760""]                  [org.omcljs/om ""0.9.0"" :exclusions [cljsjs/react]]                  [cljsjs/react-with-addons ""0.13.3-0""]]   ...) Build configuration For local development your lein-cljsbuild settings should look something like this: :cljsbuild {   :builds [{:id ""dev""             :source-paths [""src""]             :compiler {               :main main.core               :output-to ""main.js""               :output-dir ""out""               :optimizations :none               :source-map true}}]} Your markup should look something like the following: <html>     <body>        <div id=""my-app""></div>        <script src=""main.js"" type=""text/javascript""></script>     </body> </html> For production your lein-cljsbuild settings should look something like this: :cljsbuild {   :builds [{:id ""release""             :source-paths [""src""]             :compiler {               :main main.core               :output-to ""main.js""               :optimizations :advanced               :pretty-print false}}]} Contributing Please contact me via email to request an electronic Contributor Agreement. Once your electronic CA has been signed and returned to me I will accept pull requests. FAQ Can I use a different HTML Syntax? Om is not opinionated about HTML syntax, third parties can provide the preferred flavors over the React.DOM api. Alternative syntaxes will be listed here: sablono, Hiccup-style kioo, Enlive-style Does Om provide routing? Om does not ship with a router and is unlikely to. However ClojureScript routing libraries exist that handle this problem quite well: secretary silk bidi How do I test Om programs? Sean Grove's omchaya is a good starting point for understanding common testing patterns There are some notes here References Worlds: Controlling the Scope of Side Effects A Functional I/O System Directness and Liveness in the Morphic User Interface Construction Environment Learnable Programming Copyright and license Copyright © 2013-2015 David Nolen Licensed under the EPL (see the file epl.html). Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/omcljs/om"	"— A powerful interface to React, makes use of its object oriented structures."	"true"
"React.js Interface"	"Quiescent"	"https://github.com/levand/quiescent"	"— It favors functional style, fully stateless."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"540"	"23"	"35"	"GitHub - levand/quiescent: A lightweight ClojureScript abstraction over ReactJS Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 23 Star 540 Fork 35 levand/quiescent Code Issues 0 Pull requests 2 Pulse Graphs A lightweight ClojureScript abstraction over ReactJS 114 commits 3 branches 6 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: release Switch branches/tags Branches Tags master release shyblower-react-extensions Nothing to show 0.3.1 0.3.0 0.1.3 0.1.2 0.1.1 0.1.0 Nothing to show New pull request Latest commit 2063ebc May 24, 2016 levand version bump Permalink Failed to load latest commit information. doc add diagram Feb 10, 2014 examples Version 0.3.0 Feb 19, 2016 src/quiescent Ignoring mask from cljs.core. Feb 22, 2016 .gitignore update gitignore to exclude intellij files May 23, 2014 LICENSE Initial commit Feb 3, 2014 README.md version bump May 24, 2016 docs.md Document uncontrolled inputs Mar 8, 2015 project.clj version bump May 24, 2016 README.md Quiescent A lightweight ClojureScript abstraction over ReactJS, emphasizing its ability to (re)render immutable values efficiently. An obligatory TodoMVC implementation is available. See the documentation for instructions and examples of how to use Quiescent. Rationale ReactJS is an extremely interesting approach to UI rendering for HTML-based web applications. Its core value proposition is to make it possible to write one set of UI rendering code that works for both initial creation and any future updates. Updates are extremely efficient, because only the minimal set of necessary deltas are actually sent to the DOM. In other words, React lets you write your UI code once, and still have a dynamic, data-driven application. Ideally, it eliminates any need to write explicit UI manipulation code. Instead, you are responsible only for supplying a specification of what the UI should look like, given certain data. The ReactJS implementation takes care of all the details of how to morph the existing DOM to correspond to changes in the input data. Quiescent is intended to expose this feature and only this feature in a way that is convenient and idiomatic to ClojureScript, while remaining highly efficient. It has the following design goals: single concern: Quiescent is designed to do one thing: render and re-render HTML from immutable values. It does not attempt to participate in state management, inform how you organize your application, or force the use of any specific technique for managing state updates. Feel free to use atoms, watchers, core.async, compilation-based models, message-passing, etc. The only requirement is that values passed to Quiescent components are immutable value types. avoid OO idioms: ReactJS is itself highly object-oriented, with stateful objects that may implement a variety of behaviors. Quiescent provides a purely functional interface, allowing users to construct a ReactJS component tree using only the basic tools of functional programming: function definition and composition. top-down rendering: All renders and updates are initiated by instructing Quiescent to render a particular value to a particular location in the DOM. Individual tree components do not maintain their own state and do not re-render themselves unless explicitly directed to do so. This is intended to emulate classical 'rendering' semantics for 2D or 3D bitmapped applications, where the entirety of a scene is re-drawn from scratch for every frame. Of course, React/Quiescent does not actually do this, for performance reasons, but the fact that it does not is an implementation detail; the conceptual model is the same. leverage immutability: By assuming that any value provided to a rendered component is immutable, Quiescent can prevent ReactJS from even calculating if it needs to render sub-trees that have not changed from the last time the application was updated. Since equality checks are highly efficient in ClojureScript, large application structures can be re-rendered frequently with almost no performance hit apart from that necessary to re-render leaf nodes that actually did change. compatibility: Although you will hopefully be able to write the vast majority of your application using Quiescent's model, you can, if necessary, always fall back and use a raw ReactJS component (or, for that matter, a ReactJS component constructed using another ClojureScript interface). This is possible at any level of the rendering component tree. These goals differ slightly from other ClojureScript interfaces to React, as described below. Comparison with Om Om is another ClojureScript interface to ReactJS, highly capable and well-designed. It provides categorically more features than Quiescent, at the cost of taking more control and specifying more rigidly the way application state is modeled, updated and re-rendered. The most important conceptual distinctions are: To create an Om component you must implement a protocol; due to its relative lack of capability, Quiescent only requires components to provide a single render function. Om controls the primary application state atom and how it is updated. In Quiescent this is entirely the responsibility of the consumer. Om explicitly allows components to maintain local state, while Quiescent forbids this. In my opinion the benefits of requiring components to account for local state do not justify the pervasive cost to implementation. Specifically, addressing the two reasons David Nolen gives for allowing application state: ""Local state pollutes application data."" An alternative view is that all data is application data, whether it is transient or persistent, important or insignificant, wherever it is actually located. There is little harm in including it in the top-level data structure, and if your application does demand a hierarchy of data (persistent vs. transient, etc) for different purposes, it is better to model that relationship explicitly rather than leaving transient data tucked invisibly away in component state. ""Local state is always up-to-date."" This is not relevant in Quiescent's render model because Quiescent does not manage state. Om components are always aware of their location in the primary application state, via a cursor (a hybrid of functional zippers and lenses). Quiescent components are not. This means that Om components can dispatch updates to ""themselves"", whereas a DOM event handler function attached to a Quiescent component can only effect change by reaching back and doing something to the top-level application state (e.g., by sending a core.async message, swapping the top-level atom, etc). This does, somewhat, negate the concept of component modularity; Quiescent's contention is that the benefit of top-down, value-based rendering exceeds that of truly modular components. Ultimately, though, Om is an excellent, well-thought-out library, and if your needs or design goals more closely align with its capabilities than with Quiescent, you should absolutely use it. Comparison with Reagent Reagent is another ClojureScript wrapper for ReactJS. It is, perhaps, easier than either Om or Quiescent and certainly the most readable of the three. The key differences between Reagent and Quiescent (or Om, for that matter) are: Reagent defaults to a Hiccup-like syntax for component definitions. Reagent handles updates via a special version of an atom (a reactive atom or ratom). Whenever a component references a ratom, watches are established such that the component will re-render when the value of the ratom changes. As such, Reagent components are not driven by top-down data or a singular application state, but by whatever ratoms are referenced in their definition. Reagent, like Om, maintains full control of the render/re-render cycle. Although I do not have as much first-hand experience with Reagent, it seems to be a very convenient approach, and if it meets your needs you should definitely give it a try. Implementation This section presumes familiarity with how ReactJS works. In short, basic Quiescent components implement only two of ReactJS's component lifecycle events: shouldComponentUpdate is always predicated exclusively on whether the immutable value passed to the component constructor function has changed. If so, the component re-renders. If not, it doesn't. The implementation of render is provided as a function supplied by the user. The output of this render function is presumed to be a single ReactJS component, as it is in vanilla ReactJS. The function, however, is passed the immutable value that was used to construct the function. It is also passed any additional arguments that were provided to the component constructor. See Also The ReactJS website for information on ReactJS and how it works. CHANGE LOG 0.3.2 Upgrade to React 15.1.0 (#58) Ignore mask from cljs.core to avoid compiler warning (#57) 0.3.1 Add newly supported SVG tags which React supports (#43) 0.3.0 Upgrade to React 0.14 (#56) Use symbol name for defcomponent as default React component name (#46) Make it easier to idiomatically use React components defined elsewhere (for example, React Bootstrap). (Inspired by #40) 0.2.0 Warning: This release contains breaking changes. breaking change: The primary namespace has been renamed from quiescent to quiescent.core to avoid a single-segment namespace, which could cause a variety of problems. breaking change: Quiescent now includes a transitive dependency to ReactJS using ClojureScript's new, expanded foreign library support (https://github.com/clojure/clojurescript/wiki/Foreign-Dependencies). You do not need to, and should not, include ReactJS either in your ClojureScript preamble nor in your HTML. Support for new versions of ReactJS. The ""wrapper"" functionality is deprecated (see explanation below). Instead, you can now supply explicit lifecycle hooks when defining components. Keys are now supported on custom components. Added support for naming custom components, which will be helpful for debugging (including the debugging browser extensions provided by ReactJS). Added support for ReactJS' animation extensions (http://facebook.github.io/react/docs/animation.html) Added an examples directory Added support for uncontrolled inputs (fixes #32 and #36). motivation for wrapper deprecation As it turns out, there is no way in the current model that wrappers can provide the desired functionality in all cases. A wrapper component can only modify its own lifecycle methods, not truly those of its child. But neither can it access the ""shouldComponentUpdate"" of the child - it must have a ""shouldComponentUpdate"" that constantly returns true. Therefore, an ""onRender"" wrapper would fire even if the wrapped component explicitly did not render due to an unchanged value (or otherwise overriding ""shouldComponentUpdate""). 0.1.2 Issue #20 - Wrapper components now copy the ""key"" property from their wrappee. Issue #18 - Define a map of generated DOM functions. This useful for programmatically generated UIs. Issue #16 - Allow specification of multiple lifecycle handler functions using the same wrapper component. See documentation on quiescent/wrapper. Project no longer has ReactJS as a leiningen dependency; clients are responsible for obtaining the most recent version of ReactJS and incorporating that in their own projects. License Copyright © 2014-2015 Luke VanderHart Distributed under the Eclipse Public License (see LICENSE file). Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/levand/quiescent"	"— It favors functional style, fully stateless."	"true"
"React.js Interface"	"re-com"	"https://github.com/Day8/re-com"	"– A ClojureScript library of reusable components for Reagent."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"313"	"36"	"54"	"GitHub - Day8/re-com: A ClojureScript library of reusable components for Reagent Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 36 Star 313 Fork 54 Day8/re-com Code Issues 22 Pull requests 6 Wiki Pulse Graphs A ClojureScript library of reusable components for Reagent 830 commits 2 branches 26 releases 9 contributors Clojure 93.8% CSS 5.2% HTML 1.0% Clojure CSS HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags develop master Nothing to show v0.3.0 v0.2.9 v0.2.8 v0.2.2 v0.2.1 v0.2.0 v0.1.2-alpha v0.1.1-alpha 0.8.3 0.8.2 0.8.1 0.8.0 0.7.0 0.7.0-alpha2 0.7.0-alpha1 0.6.2 0.6.1 0.6.0 0.6.0-SNAPSHOT 0.5.4 0.5.3 0.5.2 0.5.1 0.5.0 0.2.6 0.2.5 Nothing to show New pull request Latest commit 96be031 May 2, 2016 Gregg8 Merge branch 'release/0.8.3' Permalink Failed to load latest commit information. docs Changes: Aug 5, 2015 run Various fixes: Dec 16, 2015 src Bump Reagent to 0.6.0-SNAPSHOT and make the demo app compatible... May 2, 2016 test Bumped Reagent to 0.5.1-rc3 Sep 8, 2015 .gitignore Brought recent dj-scratchpad changes back inot re-com. e.g.: Feb 5, 2015 CONTRIBUTING.md Bumped to 0.6.0 & added CONTRIBUTIONS.md Aug 12, 2015 README.md Updated README. Aug 14, 2015 license.txt Add license Mar 31, 2015 project.clj Bump to 0.8.3 May 2, 2016 README.md re-com A ClojureScript library of UI components. It is built on top of Dan Holmsand's terrific Reagent which, in turn, is a layer over Facebook's trailblazing React. Just to be clear: this library is 100% ClojureScript. We're not wrapping jQuery plugins here. Re-com has: familiar UI widgetry components such as dropdowns, date pickers, popovers, tabs, etc. layout components, which arrange widgets vertically and horizontally, within splitters, etc. Plus components which put borders around their children. These various pieces can be arbitrarily nested to create sophisticated layouts. a mostly Bootstrap look, mixed with some Material Design Icons. In short, re-com attempts to provide the kind of UI basics you'd need to build a desktop-class app. Warning: re-com Might Not Be For You (just yet) We build desktop-class apps to run in controlled browser environments like atom-shell. So, we know we're dealing with Chrome. If you are similar, or if you work on Intranet apps where you can mandate a modern browser, re-com could be ideal for you, right now. On the other hand, if you target the retail web, you might have to wait till early 2016 (5 months away, at the time of writing). Why? Well, here's the thing: the entire layout side of this library plus a few of the widgets rely on Flexbox which only works on modern browsers, and specifically not IE 9 and 10. Now, the grinding pain and longevity of IE6 has conditioned many to expect 8, 9 and 10 to hang around forever too. But, this time around, there's quite a different dynamic. Microsoft itself is very actively forcing their demise - come Jan 12th 2016 corporates will have to be on IE11 So, by Q1 2016, the market share of IE9 and IE10 will have diminished sufficiently that they could be ignored. Probably. Maybe. If so, a modern flexbox implementation will be available on all the browsers you then care about. So that's surprisingly soon, but not now! Even when it comes to modern browsers, there will be teething issues. Based on 5 minutes of testing once a month, re-com appears to work reasonably on IE11 and Safari. On the other hand, Firefox (pre version 38) has all the speed of a snail on performance reducing drugs. Version 38 and beyond have a fix for the performance problems caused by nested flexboxes, however as per issue #49 it is still not as fast as Chrome if you are using deeply nested flexbox layouts (much more nested than our demo app). We can also confirm that none of the components have been designed with mobile in mind, and that there's no attempt to handle media queries. We said we had a desktop app focus, right? Neither have we been worried too much about code size because other design goals have taken precedence. Our main demo app which includes every component, plus all demo code and plenty of yadda yadda, comes to about 167K compressed when using :optimizations :advanced (700K pre-compress). That number includes ReactJS plus the ClojureScript libs and runtime. So, everything. So, Without Ado Being Any Furthered ... Still here? Good. I'm glad we got all that negative stuff out the way. I think you're going to like re-com. Start by looking at the demo. Navigating The Source When you are running the demo app, you'll see hyperlinks, to the right of page titles, which take you to the associated source code. That's a convenient way to navigate to either the components themselves or the demo code. When browsing more generally, look in the src directory or this repo, you'll notice two sub-directories: re-com - the library itself - the components re-demo - the demo app, which shows how to use the components Useful Commands Getting The Repo git clone https://github.com/Day8/re-com.git cd re-com Compiling And Running The Demo lein run This will run the demo, by doing: a clean a compile a load of the right index.html into your default browser Debugging The Demo We love using figwheel to debug. To begin a debug session, do this: lein debug This will: clean start the figwheel server & compiler (a terminal window will be started) load the right index.html (specialised for figwheel use) start a ClojureScript repl in the terminal window (actually, figwheel does this for you) Your part to play in the process: the initial load of index.html will fail because the figwheel compile hasn't yet finished. be patient - the initial compile might take anything from 10 seconds to 3 mins depending on how many dependencies need to be downloaded (how many are not yet in your local Maven repo). keep an eye on the terminal started by figwheel, waiting for a green Successfully compiled message, at which point, figwheel will immediately move on and try to start the repl. In response, you should refresh the HTML page. This refresh is needed for figwheel to complete the repl kick-off. to quit figwheel and stop the server/compiler, type :cljs/quit into the repl started by figwheel. Run The (erm, modest) Tests lein run-test This will: clean compile the tests load the required test.html into your default browser, so you can see the results. Debug the tests: lein debug-test Unlike debug which uses figwheel, debug-test uses cljsbuild's auto for recompilation. This probably isn't a good idea, but that's the way it is right now. Deploy The Demo App To S3 bucket This will only work if you have the right credentials in your env: lein deploy-aws Using re-com re-com is available from clojars. Add it to your project.clj dependencies: You'll then need to include these asset folders in your app: https://github.com/Day8/re-com/tree/master/run/resources/public/assets As far as your index.html is concerned, take inspiration from here: https://github.com/Day8/re-com/tree/master/run/resources/public In particular, you'll need bootstrap (assumedly via a CDN): <link rel=""stylesheet"" href=""//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.css""> And a reference to these two CSS files (make sure re-com.css appears after bootstrap.css): <link rel=""stylesheet"" href=""assets/css/material-design-iconic-font.min.css""> <link rel=""stylesheet"" href=""assets/css/re-com.css""> And a reference to the Roboto fonts (but this can be overridden relatively easily): <link href=""http://fonts.googleapis.com/css?family=Roboto:300,400,500,700,400italic"" rel=""stylesheet"" type=""text/css""> <link href='http://fonts.googleapis.com/css?family=Roboto+Condensed:400,300' rel='stylesheet' type='text/css'> Reagent comes bundled with a matching version of ReactJS, so you don't need to include it explicitly. MVC If you decide to use re-com, consider also using re-frame (an MVC-ish framework). Although both re-frame and re-com can be used independently of each other, they dovetail well. Lein Template See re-frame-template. The Missing Components tree (not hard, just haven't needed one yet) menus - there's a dropdown, but no cascading menus accordion maybe a dockable LHS navbar virtual grid. Straight v-box is good enough at small grids, so no problem there. But when the number of rows gets huge, you need a widget which does virtual rows, otherwise there's just too much DOM and there's performance problems. Can we use Fixed Data Tables for React? drag and drop. animations / transitions. We have ideas. They seem clunky. Focus management - When the user presses tab, to which field does focus move? Helping Where the docs are wrong or fall short, write up something better. Because our docs take the form of an app written in ClojureScrip using re-com, you're actually exercising your knowledge of re-com as you do this. See the list of missing components above. You'll have to produce the component itself, including a params spec, plus the extra page in the demo app. Test re-com on new browsers and iron out any quirks. Our focus is strictly Chrome. When creating new components, we have found it useful to use the CSS from existing JavaScript projects (assuming their licence is compatible with MIT) and then replace the JavaScript with ClojureScript. Reagent really is is very nice. Also, please refer to CONTRIBUTING.md for further details on creating issues and pull requests. License Copyright © 2015 Michael Thompson Distributed under The MIT License (MIT) - See LICENSE.txt Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Day8/re-com"	"– A ClojureScript library of reusable components for Reagent."	"true"
"React.js Interface"	"Reagent"	"http://reagent-project.github.io/"	"— Minimalistic, feature complete."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Reagent: Minimalistic React for ClojureScript Reagent: Intro News GitHub Reagent: Minimalistic React for ClojureScript Introduction to Reagent Reagent provides a minimalistic interface between ClojureScript and React. It allows you to define efficient React components using nothing but plain ClojureScript functions and data, that describe your UI using a Hiccup-like syntax. The goal of Reagent is to make it possible to define arbitrarily complex UIs using just a couple of basic concepts, and to be fast enough by default that you rarely have to care about performance. A very basic Reagent component may look something like this: hide Example I am a component! I have bold and red text. Source (defn simple-component []   [:div    [:p ""I am a component!""]    [:p.someclass     ""I have "" [:strong ""bold""]     [:span {:style {:color ""red""}} "" and red ""] ""text.""]]) You can build new components using other components as building blocks. Like this: hide Example I include simple-component. I am a component! I have bold and red text. Source (defn simple-parent []   [:div    [:p ""I include simple-component.""]    [simple-component]]) Data is passed to child components using plain old Clojure data types. Like this: hide Example Hello, world! Source (defn hello-component [name]   [:p ""Hello, "" name ""!""])  (defn say-hello []   [hello-component ""world""]) Note: In the example above, hello-component might just as well have been called as a normal Clojure function instead of as a Reagent component, i.e with parenthesis instead of square brackets. The only difference would have been performance, since ”real” Reagent components are only re-rendered when their data have changed. More advanced components though (see below) must be called with square brackets. Here is another example that shows items in a seq: hide Example Here is a list: Item 0 Item 1 Item 2 Source (defn lister [items]   [:ul    (for [item items]      ^{:key item} [:li ""Item "" item])])  (defn lister-user []   [:div    ""Here is a list:""    [lister (range 3)]]) Note: The ^{:key item} part above isn’t really necessary in this simple example, but attaching a unique key to every item in a dynamically generated list of components is good practice, and helps React to improve performance for large lists. The key can be given either (as in this example) as meta-data, or as a :key item in the first argument to a component (if it is a map). See React’s documentation for more info. Managing state in Reagent The easiest way to manage state in Reagent is to use Reagent’s own version of atom. It works exactly like the one in clojure.core, except that it keeps track of every time it is deref’ed. Any component that uses an atom is automagically re-rendered when its value changes. Let’s demonstrate that with a simple example: hide Example The atom click-count has value: 0. Source (ns example   (:require [reagent.core :as r])) (def click-count (r/atom 0))  (defn counting-component []   [:div    ""The atom "" [:code ""click-count""] "" has value: ""    @click-count "". ""    [:input {:type ""button"" :value ""Click me!""             :on-click #(swap! click-count inc)}]]) Sometimes you may want to maintain state locally in a component. That is easy to do with an atom as well. Here is an example of that, where we call setTimeout every time the component is rendered to update a counter: hide Example Seconds Elapsed: 0 Source (defn timer-component []   (let [seconds-elapsed (r/atom 0)]     (fn []       (js/setTimeout #(swap! seconds-elapsed inc) 1000)       [:div        ""Seconds Elapsed: "" @seconds-elapsed]))) The previous example also uses another feature of Reagent: a component function can return another function, that is used to do the actual rendering. This function is called with the same arguments as the first one. This allows you to perform some setup of newly created components without resorting to React’s lifecycle events. By simply passing an atom around you can share state management between components, like this: hide Example The value is now: foo Change it here: Source (ns example   (:require [reagent.core :as r])) (defn atom-input [value]   [:input {:type ""text""            :value @value            :on-change #(reset! value (-> % .-target .-value))}])  (defn shared-state []   (let [val (r/atom ""foo"")]     (fn []       [:div        [:p ""The value is now: "" @val]        [:p ""Change it here: "" [atom-input val]]]))) Note: Component functions can be called with any arguments – as long as they are immutable. You could use mutable objects as well, but then you have to make sure that the component is updated when your data changes. Reagent assumes by default that two objects are equal if they are the same object. Essential API Reagent supports most of React’s API, but there is really only one entry-point that is necessary for most applications: reagent.core/render-component. It takes two arguments: a component, and a DOM node. For example, splashing the very first example all over the page would look like this: Source (ns example   (:require [reagent.core :as r])) (defn simple-component []   [:div    [:p ""I am a component!""]    [:p.someclass     ""I have "" [:strong ""bold""]     [:span {:style {:color ""red""}} "" and red ""] ""text.""]])  (defn render-simple []   (r/render-component [simple-component]                       (.-body js/document))) Putting it all together Here is a slightly less contrived example: a simple BMI calculator. Data is kept in a single reagent.core/atom: a map with height, weight and BMI as keys. hide Example BMI calculator Height: 180cm Weight: 80kg BMI: 24 normal Source (ns example   (:require [reagent.core :as r])) (def bmi-data (r/atom {:height 180 :weight 80}))  (defn calc-bmi []   (let [{:keys [height weight bmi] :as data} @bmi-data         h (/ height 100)]     (if (nil? bmi)       (assoc data :bmi (/ weight (* h h)))       (assoc data :weight (* bmi h h)))))  (defn slider [param value min max]   [:input {:type ""range"" :value value :min min :max max            :style {:width ""100%""}            :on-change (fn [e]                         (swap! bmi-data assoc param (.-target.value e))                         (when (not= param :bmi)                           (swap! bmi-data assoc :bmi nil)))}])  (defn bmi-component []   (let [{:keys [weight height bmi]} (calc-bmi)         [color diagnose] (cond                           (< bmi 18.5) [""orange"" ""underweight""]                           (< bmi 25) [""inherit"" ""normal""]                           (< bmi 30) [""orange"" ""overweight""]                           :else [""red"" ""obese""])]     [:div      [:h3 ""BMI calculator""]      [:div       ""Height: "" (int height) ""cm""       [slider :height height 100 220]]      [:div       ""Weight: "" (int weight) ""kg""       [slider :weight weight 30 150]]      [:div       ""BMI: "" (int bmi) "" ""       [:span {:style {:color color}} diagnose]       [slider :bmi bmi 10 50]]])) Performance React itself is very fast, and so is Reagent. In fact, Reagent will be even faster than plain React a lot of the time, thanks to optimizations made possible by ClojureScript. Mounted components are only re-rendered when their parameters have changed. The change could come from a deref’ed atom, the arguments passed to the component or component state. All of these are checked for changes with identical? which is basically only a pointer comparison, so the overhead is very low. Maps passed as arguments to components are compared the same way: they are considered equal if all their entries are identical. This also applies to built-in React components like :div, :p, etc. All this means that you simply won’t have to care about performance most of the time. Just define your UI however you like – it will be fast enough. There are a couple of situations that you might have to care about, though. If you give Reagent a big seq of components to render, you might have to supply all of them with a unique :key attribute to speed up rendering (see above). Also note that anonymous functions are not, in general, equal to each other even if they represent the same code and closure. But again, in general you should just trust that React and Reagent will be fast enough. This very page is composed of a single Reagent component with thousands of child components (every single parenthesis etc in the code examples is a separate component), and yet the page can be updated many times every second without taxing the browser the slightest. Incidentally, this page also uses another React trick: the entire page is pre-rendered using Node, and reagent.core/render-component-to-string. When it is loaded into the browser, React automatically attaches event-handlers to the already present DOM tree."	"null"	"null"	"— Minimalistic, feature complete."	"true"
"React.js Interface"	"Rum"	"https://github.com/tonsky/rum"	"— Decomplected, extensible, simple."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"634"	"69"	"52"	"GitHub - tonsky/rum: Simple, decomplected, isomorphic HTML UI library for Clojure and ClojureScript Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 69 Star 634 Fork 52 tonsky/rum Code Issues 9 Pull requests 0 Wiki Pulse Graphs Simple, decomplected, isomorphic HTML UI library for Clojure and ClojureScript 212 commits 1 branch 29 releases 24 contributors HTML 83.6% Clojure 16.3% JavaScript 0.1% HTML Clojure JavaScript Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: gh-pages Switch branches/tags Branches Tags gh-pages Nothing to show 0.10.4 0.10.3 0.10.2 0.10.1 0.10.0 0.9.1 0.9.0 0.8.4 0.8.3 0.8.2 0.8.1 0.8.0 0.7.0 0.6.0 0.5.0 0.4.2 0.4.1 0.4.0 0.3.0 0.2.7 0.2.6 0.2.5 0.2.4 0.2.3 0.2.2 0.2.1 0.2.0 0.1.1 0.1.0 Nothing to show New pull request Latest commit c781501 Jul 12, 2016 madstap committed with tonsky Move derived-atom docstring (#85) … * Move derived-atom docstring  From rum.derived-atom/derived-atom to rum.core/derived-atom, so it can be seem by the end-user.  * Add indentation metadata to derived-atom Permalink Failed to load latest commit information. examples/rum removed separate style.css Jul 4, 2016 perf Added rum/render-static-markup Apr 26, 2016 src/rum Move derived-atom docstring (#85) Jul 12, 2016 target Version 0.10.4 Jul 6, 2016 test/rum/test check for conditions in compile-body (#81) Jul 6, 2016 .gitignore Fixed self-referencing component Jun 14, 2015 LICENSE Initial Dec 20, 2014 README.md Added tenzing Jul 11, 2016 index.html removed separate style.css Jul 4, 2016 project.clj Version 0.10.4 Jul 6, 2016 README.md Rum is a client/server library for HTML UI. In ClojureScript, it works as React wrapper, in Clojure, it is a static HTML generator. Principles Simple semantics: Rum is arguably smaller, simpler and more straightforward than React itself. Decomplected: Rum is a library, not a framework. Use only the parts you need, throw away or replace what you don’t need, combine different approaches in a single app, or even combine Rum with other frameworks. No enforced state model: Unlike Om, Reagent or Quiescent, Rum does not dictate where to keep your state. Instead, it works well with any storage: persistent data structures, atoms, DataScript, JavaScript objects, localStorage or any custom solution you can think of. Extensible: the API is stable and explicitly defined, including the API between Rum internals. It lets you build custom behaviours that change components in significant ways. Minimal codebase: You can become a Rum expert just by reading its source code (~900 lines). Comparison to other frameworks Rum: does not dictate how to store your state, has server-side rendering, is much smaller. Who’s using Rum? Cognician, coaching platform Attendify, mobile app builder PartsBox.io, inventory management modnaKasta, online shopping ChildrensHeartSurgery.info, heart surgery statistics TourneyBot, frisbee tournament app Using Rum Add to project.clj: [rum ""0.10.4""] Defining a component Use rum.core/defc (short for “define component”) to define a function that returns component markup: (require [rum.core :as rum])  (rum/defc label [text]   [:div {:class ""label""} text]) Rum uses Hiccup-like syntax for defining markup: [<tag-n-selector> <attrs>? <children>*] <tag-n-selector> defines a tag, its id and classes:   :span   :span#id   :span.class   :span#id.class   :span.class.class2 By default, if you omit the tag, div is assumed:   :#id    === :div#id   :.class === :div.class  <attrs> is an optional map of attributes: Use kebab-case keywords for attributes (e.g. :allow-full-screen for allowFullScreen) You can include :id and :class there as well :class can be a string or a sequence of strings :style, if needed, must be a map with kebab-case keywords event handlers should be arity-one functions [:input { :type      ""text""           :allow-full-screen true           :id        ""comment""           :class     [""input_active"" ""input_error""]           :style     { :background-color ""#EEE""                        :margin-left      42 }           :on-change (fn [e]                        (js/alert (.. e -target -value))) }] <children> is a zero, one or many elements (strings or nested tags) with the same syntax:   [:div {} ""Text""]         ;; tag, attrs, nested text   [:div {} [:span]]        ;; tag, attrs, nested tag   [:div ""Text""]            ;; omitted attrs   [:div ""A"" [:em ""B""] ""C""] ;; 3 children, mix of text and tags Children can include lists or sequences which will be flattened:   [:div (list [:i ""A""] [:b ""B""])] === [:div [:i ""A""] [:b ""B""]] By default all text nodes are escaped. To embed an unescaped string into a tag, add the :dangerouslySetInnerHTML attribute and omit children:   [:div { :dangerouslySetInnerHTML {:__html ""<span></span>""}}] Rendering component Given this code: (require [rum.core :as rum])  (rum/defc repeat-label [n text]   [:div (repeat n [:.label text])]) First, we need to create a component instance by calling its function: (repeat-label 5 ""abc"")  Then we need to pass that instance to (rum.core/mount comp dom-node): (rum/mount (repeat-label 5 ""abc"") js/document.body) And we will get this result:   <body>     <div>       <div class=""label"">abc</div>       <div class=""label"">abc</div>       <div class=""label"">abc</div>       <div class=""label"">abc</div>       <div class=""label"">abc</div>     </div>   </body> Usually, mount is used just once in an app lifecycle to mount the top of your component tree to a page. After that, for a dynamic applications, you should either update your components or rely on them to update themselves. Updating components manually The simplest way to update your app is to mount it again: (rum/defc timer []   [:div (.toISOString (js/Date.))])  (rum/mount (timer) js/document.body)  (js/setInterval   #(rum/mount (timer) js/document.body)   1000) Reactive components Rum offers mixins as a way to hook into a component’s lifecycle and extend its capabilities or change its behaviour. One very common use-case is for a component to update when some reference changes. Rum has a rum.core/reactive mixin just for that: (def count (atom 0))  (rum/defc counter < rum/reactive []   [:div { :on-click (fn [_] (swap! count inc)) }     ""Clicks: "" (rum/react count)])  (rum/mount (counter) js/document.body) Two things are happening here: We’re adding the rum.core/reactive mixin to the component. We’re using rum.core/react instead of deref in the component body. This will set up a watch on the count atom and will automatically call rum.core/request-render on the component each time the atom changes. Component’s local state Sometimes you need to keep track of some mutable data just inside a component and nowhere else. Rum provides the rum.core/local mixin. It’s a little trickier to use, so hold on: Each component in Rum has internal state associated with it, normally used by mixins and Rum internals. rum.core/local creates a mixin that will put an atom into the component’s state. rum.core/defcs is used instead of rum.core/defc. It allows you to get hold of the components’s state in the render function (it will be passed as a first argument). You can then extract that atom from the component’s state and deref/swap!/reset! it as usual. Any change to the atom will force the component to update. In practice, it’s quite convenient to use: (rum/defcs stateful < (rum/local 0 ::key)   [state label]   (let [local-atom (::key state)]     [:div { :on-click (fn [_] (swap! local-atom inc)) }       label "": "" @local-atom]))  (rum/mount (stateful ""Click count"") js/document.body) Optimizing with shouldComponentUpdate If your component accepts only immutable data structures as arguments, it may be a good idea to add the rum.core/static mixin: (rum/defc label < rum/static [n text]   [:.label (repeat n text)]) rum.core/static will check if the arguments of a component’s constructor have changed (using Clojure’s -equiv semantic), and if they are the same, avoid re-rendering. (rum/mount (label 1 ""abc"") body) (rum/mount (label 1 ""abc"") body) ;; render won’t be called (rum/mount (label 1 ""xyz"") body) ;; this will cause a re-render (rum/mount (label 1 ""xyz"") body) ;; this won’t Note that this is not enabled by default because a) comparisons can be expensive, and b) things will go wrong if you pass a mutable reference as an argument. Writing your own mixin Many applications have very specific requirements and custom optimization opportunities, so odds are you’ll be writing your own mixins. Let’s see what a Rum component really is. Each Rum component has: A render function One or more mixins An internal state map A corresponding React component For example, if we have this component defined: (rum/defc input [label value]   [:label label "": ""     [:input { :value value }]])  (input ""Your name"" """") It will have the following state: { :rum/args [""Your name"" """"]   :rum/react-component <react-component> } You can read the internal state by using the rum.core/defcs (short for “define component [and pass] state”) macro instead of rum.core/defc. It will pass state to the render function as the first argument: (rum/defcs label [state label value]   [:div ""My args:"" (pr-str (:rum/args state))])  (label ""A"" 3) ;; => <div>My args: [""A"" 3]</div> The internal state cannot be directly manipulated, except at certain stages of a component’s lifecycle. Mixins are functions that are invoked at these stages to give you and opportunity to modify the state and/or do side effects to the world. The following mixin will record the component’s mount time: (rum/defcs time-label < { :did-mount (fn [state]                                        (assoc state ::time (js/Date.))) }   [state label]   [:div label "": "" (::time state)]) As you can see, :did-mount is a function from state to state. It gives you a chance to populate, clean or modify state map after the component has been mounted. Another useful thing you can do in a mixin is to decide when to update a component. If you can get ahold of React component (notice that that’s different from Rum component, unfortunately; sorry), you can call rum.core/request-render to schedule this component’s update at next frame (Rum uses requestAnimationFrame to batch and debounce component update calls). To get React component, just look up :rum/react-component key in a state. This mixin will update a component each second: (def periodic-update-mixin   { :did-mount    (fn [state]                     (let [comp      (:rum/react-component state)                           callback #(rum/request-render comp)                           interval  (js/setInterval callback 1000)]                        (assoc state ::interval interval)))     :will-unmount (fn [state]                     (js/clearInterval (::interval state))                     (dissoc state ::interval)) })  (rum/defc timer < periodic-update-mixin []   [:div (.toISOString (js/Date.))])  (rum/mount (timer) js/document.body) Here’s a full list of callbacks you can define in a mixin: { :init                 ;; state, props     ⇒ state   :will-mount           ;; state            ⇒ state   :before-render        ;; state            ⇒ state   :wrap-render          ;; render-fn        ⇒ render-fn   :render               ;; state            ⇒ [pseudo-dom state]   :did-mount            ;; state            ⇒ state   :after-render         ;; state            ⇒ state   :did-remount          ;; old-state, state ⇒ state   :should-update        ;; old-state, state ⇒ boolean   :will-update          ;; state            ⇒ state   :did-update           ;; state            ⇒ state   :will-unmount }       ;; state            ⇒ state Each component can have any number of mixins: (rum/defcs component < rum/static                         rum/reactive                        (rum/local 0 ::count)                        (rum/local """" ::text)   [state label]   (let [count-atom (::count state)         text-atom  (::text state)]     [:div]) One gotcha: don’t forget to return state from the mixin functions. If you’re using them for side-effects only, just return an unmodified state. Working with atoms Since Rum relies a lot at components being able to efficiently update themselves in reaction to events, it includes two facilities to build architectures around Atoms and watchers. Cursors If you have a complex state and need a component to interact with only a part of it, create a cursor using (rum.core/cursor-in ref path). Given atom with deep nested value and path inside it, cursor-in will create an atom-like structure that can be used separately from main atom, but will sync changes both ways: (def state (atom { :color ""#cc3333""                    :user { :name ""Ivan"" } }))  (def user-name (rum/cursor-in state [:user :name]))  @user-name ;; => ""Ivan""  (reset! user-name ""Oleg"") ;; => ""Oleg""  @state ;; => { :color ""#cc3333""        ;;      :user  { :name ""Oleg"" } } Cursors implement IAtom and IWatchable and interface-wise are drop-in replacement for regular atoms. They work well with rum/reactive and rum/react too. Derived atoms Use derived atoms to create “chains” and acyclic graphs of dependent atoms. derived-atom will: Take N “source” refs Set up a watch on each of them Create “sink” atom When any of source refs changes: re-run function f, passing N dereferenced values of source refs reset! result of f to the sink atom return sink atom   (def *a (atom 0))   (def *b (atom 1))   (def *x (derived-atom [*a *b] ::key             (fn [a b]               (str a \"":\"" b))))   (type *x) ;; => clojure.lang.Atom   @*x     ;; => 0:1   (swap! *a inc)   @*x     ;; => 1:1   (reset! *b 7)   @*x     ;; => 1:7 Derived atoms are like cursors, but can “depend on” multiple references and won’t sync changes back to the source if you try to update derived atom (don’t). Interop with React Native React component You can access the raw React component by reading the state’s :rum/react-component attribute: { :did-mount (fn [state]                (let [comp     (:rum/react-component state)                      dom-node (js/ReactDOM.findDOMNode comp)]                  (set! (.-width (.-style dom-node)) ""100px""))                state) } React keys and refs There’re three ways to specify React keys: If you need a key on Sablono tag, put it into attributes: [:div { :key ""x"" }] If you need a key on Rum component, use with-key: (rum/defc my-component [str]   ...)  (rum/with-key (my-component ""args"") ""x"") or, you can specify :key-fn in a mixin to calculate key based on args at component creation time: (rum/defc my-component < { :key-fn (fn [x y z]                                      (str x ""-"" y ""-"" z)) }   [x y z]   ...)  (my-component 1 2 3) ;; => key == ""1-2-3"" :key-fn must accept same arguments your render function does. Refs work the same way as options 1 and 2 for keys work: [:div { :ref ""x"" }] (rum/with-ref (my-component) ""x"") Accessing DOM There’re couple of helpers that will, given state map, find stuff in it for you: (rum/dom-node state)     ;; => top-level DOM node (rum/ref      state ""x"") ;; => ref-ed React component (rum/ref-node state ""x"") ;; => top-level DOM node of ref-ed React component Custom class properties To define arbitrary properties and methods on a component class, specify a :class-properties map in a mixin: (rum/defc comp < { :class-properties { ... } }   [:div])) React context To define child context, specify a :child-context function taking state and returning context map in a mixin: (rum/defc theme < { :child-context                     (fn [state]                       (let [[color] (:rum/args state)]                         { :color color }))                     :class-properties                     { :childContextTypes {:color js/React.PropTypes.string} } }   [color child]   child) Server-side rendering If used from clj/cljc, Rum works as a traditional template engine à la Hiccup: Import rum.core as usual. Define components using rum/defc or other macros as usual. Instead of mounting, call rum/render-html to render into a string. Generate the HTML page using that string. On the client side, mount the same component over the node where you rendered your server-side component. (require '[rum.core :as rum])  (rum/defc my-comp [s]   [:div s])  ;; on a server (rum/render-html (my-comp ""hello"")) ;; => ""<div data-reactroot=\""\"" data-reactid=\""1\"" data-react-checksum=\""-857140882\"">hello</div>""  ;; on a client (rum/mount (my-comp ""hello"") (js/document.querySelector ""[data-reactroot]"")) Use rum/render-static-markup if you’re not planning to connect your page with React later: (rum/render-static-markup (my-comp ""hello"")) ;; => <div>hello</div> Rum server-side rendering does not use React or Sablono, it runs completely in JVM, without involving JavaScript at any stage. As of [rum ""0.8.3""] and [hiccup ""1.0.5""], Rum is ~3× times faster than Hiccup. Server-side components do not have full lifecycle support, but :init and :will-mount from mixins would be called at the component’s construction time. Resources Ask for help on Gitter chat Check out our wiki Talks Rum workshop at Cognician, by me Norbert Wójtowicz talk at Lambda Days 2015 where he explains benefits of web development with ClojureScript and React, and how Rum emulates all main ClojureScript frameworks Hangout about Rum (in Russian) App templates Tenzing Libraries Reforms, Bootstrap 3 forms rum-mdl, Material design lite components derivatives, creates chains of derived values from an atom Examples In this repo see examples/rum/examples/. Live version DataScript Chat app DataScript ToDo app DataScript Menu app Changes 0.10.4 Ability to use :pre and :post checks in rum.core/defc (thx Martin Klepsch, PR #81) 0.10.3 Fixed regression of displayName in 0.10.0 Bumped React to 15.2.0 0.10.2 Fixed a bug when :before-render and :will-update weren’t called on subsequent renders 0.10.1 Made rum.core/state public again :before-render should be called on server-side rendering too (thx Alexander Solovyov, PR #79) 0.10.0 A big cleanup/optmization/goodies release with a lot breaking changes. Read carefully! [ BREAKING ] cursor got renamed to cursor-in. New cursor method added that takes single key (as everywhere in Clojure) [ BREAKING ] rum/mount returns nil (because you shouldn’t rely on return value of ReactDOM.render) [ BREAKING ] :transfer-state is gone. All of component’s state is now transferred by default. If you still need to do something fancy on componentWillReceiveProps, new callback is called :did-remount callback [ BREAKING ] removed cursored and cursored-watch mixins. They felt too unnatural to use [ BREAKING ] removed rum/with-props (deprecated since 0.3.0). Use rum/with-key and rum/with-ref instead [ BREAKING ] server-side rendering no longer calls :did-mount (obviously, that was a mistake) [ BREAKING ] :rum/id is gone. If you need an unique id per component, allocate one in :init as store it in state under namespaced key When upgrading to 0.10.0, check this migration checklist: Change all rum/cursor calls to rum/cursor-in Find all :transfer-state mixins. If the only thing they were doing is something like (fn [old new] (assoc new ::key (::key old))), just delete them. If not, rename to :did-remount Check if you were using rum/mount return value. If yes, find another way to obtain component (e.g. via ref, defcc etc) Replace rum/with-props with rum/with-key, rum/with-ref or :key-fn Check that you weren’t relying on :did-mount in server-side rendering Now for the good stuff: Cursors now support metadata, alter-meta! etc Cursors can be used from Clojure Added :key-fn to mixins. That function will be called before element creation, with same arguments as render fn, and its return value will be used as a key on that element Mixins can specify :before-render (triggered at componentWillMount and componentWillUpdate) and :after-render (componentDidMount and componentDidUpdate) callback Added rum/ref and rum/ref-node helpers, returning backing component and DOM node Some client-side API functions added to server version (dom-node, unmount, request-render etc). Their implementation just throws an exception. This is to help you write less conditional directives in e.g. :did-mount or :will-unmount mixins. They will never be called, but won’t stop code from compiling either. And couple of optimizations: Rum now makes use of staless components (nothing for you to do, if your component is defined via defc with no mixins, it’ll be automatically compiled to stateless component) Rum will use React’s batched updates to perform rendering on requestAnimationFrame in a single chunk Streamlined internals of component construction, removed render->mixin, args->state, element and ctor->class 0.9.1 Added rum.core/derived-atom, a function that let you build reactive chains and directed acyclic graphs of dependent atoms. E.g. you want *c to always contain a value of *a plus a value of *b and update whenever any of them changes Added rum.core/dom-node helper that takes state and finds corresponding top DOM node of a component. Can be called in mixins after initial render only Fixed compatibility of with-key on nil-returning component in server rendering (thx Alexander Solovyov, PR #73) 0.9.0 Better support for server-side rendering of SVG [ BREAKING ] Rum used to support multiple ways to specify attributes. You would expect that both :allow-full-screen, :allowFullScreen and ""allowFullScreen"" would be normalized to allowfullscreen. As a result, you have to face three problems: how do I decide which variant to use? how do I ensure consistency accross my team and our codebase? find & replace become harder Starting with 0.9.0, Rum will adopt “There’s Only One Way To Do It” policy. All attributes MUST be specified as kebab-cased keywords: Attribute What to use What not to use class :class :class-name :className for :for :html-for :htmlFor unescaped innerHTML :dangerouslySetInnerHTML { :__html { ""..."" }} uncontrolled value :default-value :defaultValue uncontrolled checked :default-checked :defaultChecked itemid, classid :item-id, :class-id :itemID :itemId :itemid xml:lang etc :xml-lang :xml/lang :xmlLang ""xml:lang"" xlink:href etc :xlink-href :xlink/href :xlinkHref ""xlink:href"" xmlns not supported To migrate to 0.9.0 from earlier versions, just do search-and-replace for non-standard variants and replace them with recommended ones. 0.8.4 Improved server-side rendering for inputs (issue #67 & beyond) Compatible server-side rendering of components that return nil (issue #64) Upgraded React to 15.1.0 0.8.3 rum/render-static-markup call for pure HTML templating. Use it if you’re not planning to connect your page with React later rum/def* macros now correctly retain metadata that already exists on a symbol (thx aJchemist, PR #62) 0.8.2 Add rum.core/unmount function (thx emnh, issue #61) 0.8.1 Retain :arglists metadata on vars defined by rum/def* macros (thx aJchemist, PR #60) 0.8.0 Migrated to React 15.0.1 Optimized server-side rendering (~4× faster than Rum 0.7.0, ~2-3× faster than Hiccup 1.0.5) 0.7.0 Server-side rendering via rum/render-html (thx Alexander Solovyov) 0.6.0 [ BREAKING ] Updated to React 0.14.3 (thx Andrey Antukh, PR #53) 0.5.0 Added :class-properties to define arbitrary properties on a React class (thx Karanbir Toor, PR #44) [ BREAKING ] Removed support for :child-context-types and :context-types. Use { :class-properties { :childContextTypes ..., :contextTypes ... } } instead. 0.4.2 Check for setTimeout in global scope instead of in window (thx Alexander Solovyov, PR #43) 0.4.1 Fixed bug with rum macros emitting wrong namespace. You can now require rum.core under any alias you want (thx Stuart Hinson, PR #42) 0.4.0 [ BREAKING ] Core namespace was renamed from rum to rum.core to supress CLJS warnings 0.3.0 Upgraded to React 0.13.3, Sablono 0.3.6, ClojueScript 1.7.48 New API to access context: child-context, child-context-types, context-types (thx Karanbir Toor, PR #37) New defcc macro for when you only need React component, not the whole Rum state [ BREAKING ] Component inner state (:rum/state) was moved from props to state. It doesn’t change a thing if you were using Rum API only, but might break something if you were relaying on internal details Deprecated rum/with-props macro, use rum/with-key or rum/with-ref fns instead 0.2.7 Allow components to refer to themselves (thx Kevin Lynagh, pull request #30) Support for multi-arity render fns (issue #23) 0.2.6 Added local mixin 0.2.5 Fixed argument destructuring in defc macro (issue #22) 0.2.4 will-update and did-update lifecycle methods added (thx Andrey Vasenin, pull request #18) 0.2.3 Components defined via defc/defcs will have displayName defined (thx Ivan Dubrov, pull request #16) Not referencing requestAnimationFrame when used in headless environment (thx @whodidthis, pull request #14) 0.2.2 Compatibility with clojurescript 0.0-2758, macros included automatically when (:require rum) 0.2.1 Updated deps to clojurescript 0.0-2727, react 0.12.2-5 and sablono 0.3.1 0.2.0 [ BREAKING ] New syntax for mixins: (defc name < mixin1 mixin2 [args] body...) New defcs macro that adds additional first argument to render function: state Ability to specify key and ref to rum components via with-props 0.1.1 Fixed a bug when render-loop tried to .forceUpdate unmounted elements Fixed a cursor leak bug in reactive mixin Removed :should-update from reactive, it now will be re-rendered if re-created by top-level element Combine reactive with static to avoid re-rendering if component is being recreated with the same args Acknowledgements Rum was build on inspiration from Quiescent, Om and Reagent. All heavy lifting done by React, Ŝablono and ClojureScript. License Copyright © 2014–2016 Nikita Prokopov Licensed under Eclipse Public License (see LICENSE). Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/tonsky/rum"	"— Decomplected, extensible, simple."	"true"
"Reactive Programming"	"Javelin"	"https://github.com/hoplon/javelin"	"– A Functional Reactive Programming library for ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"533"	"28"	"28"	"GitHub - hoplon/javelin: Spreadsheet-like dataflow programming in ClojureScript. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 28 Star 533 Fork 28 hoplon/javelin Code Issues 5 Pull requests 0 Pulse Graphs Spreadsheet-like dataflow programming in ClojureScript. 274 commits 4 branches 31 releases Fetching contributors Clojure 82.7% HTML 15.1% Shell 1.1% JavaScript 1.1% Clojure HTML Shell JavaScript Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags 1.0.0-maintenance adding-meta caching-propagate master Nothing to show 3.8.4 3.8.3 3.8.2 3.8.1 3.8.0 3.7.2 3.7.1 3.7.0 3.6.3 3.6.2 3.6.1 3.6.0 3.5.0 3.4.0 3.3.2 3.3.1 3.3.0 3.2.0 3.1.1 3.1.0 3.0.0 2.4.0 2.3.0 2.2.1 2.2.0 2.1.1 2.1.0 2.0.3 2.0.2 2.0.1 2.0.0 Nothing to show New pull request Latest commit dbfb10b Jun 11, 2016 alandipert committed on GitHub Merge pull request #28 from mhr/patch-1 … Minor spelling fix Permalink Failed to load latest commit information. img init Feb 15, 2013 script deploy to clojars issues Oct 8, 2014 src/javelin 3.8.4 -- correct handling of catch, finally Sep 8, 2015 test 3.8.4 -- correct handling of catch, finally Sep 8, 2015 .gitignore 3 additions to .gitignore to keep me out of trouble. :-) Jan 2, 2016 .travis.yml ... Mar 16, 2015 CHANGES.md 3.6.0 -- Create lenses via cell= and defc= macros Aug 8, 2014 FAQ.md rollback unquote fix in 2.0.3---bump version Oct 20, 2013 README.md Minor spelling fix Jun 11, 2016 build.boot 3.8.4 -- correct handling of catch, finally Sep 8, 2015 epl-v10.html init Feb 15, 2013 README.md Javelin Spreadsheet-like dataflow programming in ClojureScript. [hoplon/javelin ""3.8.4""] ;; latest release Example (ns your-ns   (:require [javelin.core :refer [cell] :refer-macros [cell=]]))  (defn start []   (let [a (cell 0)              ;; input cell with initial value of 0.         b (cell= (inc a))       ;; formula cell of a+1.         c (cell= (+ 123 a b))]  ;; formula cell of a+b+123.     (cell= (.log js/console c)) ;; anonymous formula cell for side effects.     ;; c's initial value, 124, is printed.     (swap! a inc)     ;; a was incremented, and its new value propagated (consistently)     ;; through b and c.  c's new value, 126, is printed to the console.     )) There are many more examples in the Javelin tests. Demos Javelin with Domina and Dommy Javelin with Hoplon Overview Javelin provides a spreadsheet-like computing environment consisting of input cells and formula cells and introduces the Cell reference type to represent both. All Cells contain values. implement the IWatchable interface. are dereferenced with deref or the @ reader macro. Input Cells are created by the cell function or defc macro. are updated explicitly using swap! or reset!. Formula Cells are created with the formula function or the cell= and defc= macros. are updated reactively according to a formula. are read-only—updating a formula cell via swap! or reset! is an error (unless it's a lens). Some examples of cells: (defc a 42)               ;; cell containing the number 42 (defc b '(+ 1 2))         ;; cell containing the list (+ 1 2) (defc c (+ 1 2))          ;; cell containing the number 3 (defc d {:x @a})          ;; cell containing the map {:x 42}  (defc= e {:x a})          ;; cell with formula {:x a}, updated when a changes (defc= f (+ a 1))         ;; cell with formula (+ a 1), updated when a changes (defc= g (+ a ~(inc @a))) ;; cell with formula (+ a 43), updated when a changes (defc= h [e f g])         ;; cell with formula [e f g], updated when e, f, or g change  @h                        ;;=> [{:x 42} 43 85] (reset! a 7)              ;;=> 7 @h                        ;;=> [{:x 7} 8 50] (swap! f inc)             ;;=> ERROR: f is a formula cell, it updates itself! Note the use of ~ in the definition of g. The expression (inc @a) is evaluated and the resulting value is used when creating the formula, rather than being recomputed each time the cell updates. See the Formulas section below. Cells can be microbeasts... (defc test-results   {:scores [74 51 97 88 89 91 72 77 69 72 45 63]    :proctor ""Mr. Smith""    :subject ""Organic Chemistry""    :sequence ""CHM2049""})  (defc= test-results-with-mean   (let [scores (:scores test-results)         mean   (/ (reduce + scores) (count scores))         grade  (cond (<= 90 mean) :A                      (<= 80 mean) :B                      (<= 70 mean) :C                      (<= 60 mean) :D                      :else        :F)]     (assoc test-results :mean mean :grade grade))) Formulas All macros in formula expressions are fully expanded. The resulting expression is then interpreted according to the following rules: The unquote form causes its argument to be evaluated in place and not walked. The unquote-splicing form is interpreted as the composition of unquote as above and deref. Some things don't make sense in formulas and cause errors: Unsupported forms def, ns, deftype*, and defrecord*. Circular dependencies between cells result in infinite loops at runtime. Transactions The dosync macro facilitates atomic, transactional updates to cells. This can be used to coordinate or batch updates such that propagation occurs only once for the entire transaction instead of once for each individual cell update. For example, consider the following program: (defc a 100) (defc b 200)  (cell= (print ""a + b ="" (+ a b))) ;=> LOG: a + b = 300  (do   (swap! a inc)   (swap! a inc)   (swap! b inc)) ;=> LOG: a + b = 301 ;=> LOG: a + b = 302 ;=> LOG: a + b = 303 Notice how calling swap! on cells a and b individually causes the anonymous cell to print the sum three times–once for each update to a and b. Using dosync these updates can be made inside of a transaction during which propagation is suspended: (defc a 100) (defc b 200)  (cell= (print ""a + b ="" (+ a b))) ;=> LOG: a + b = 300  (dosync   (swap! a inc)   (swap! a inc)   (swap! b inc)) ;=> LOG: a + b = 303 The sum is only logged a single time, even though a and b were updated multiple times. Note: During a transaction the effects of swap! and reset! are immediately visible for input cells, but not for formula cells. Formula cells are updated and watchers are notified only after the transaction is complete. Lenses A lens is a tool for extracting and updating a part of a data structure. A lens then is defined by a complementary pair of getter and setter functions. Moreover lenses are composable, in that multiple lenses can be combined to access and alter the contents of structures of structures. Formula cells can easily be defined with a getter method for accessing some selected content of a data structure. Formula cells as we have defined them are read-only. but simply by providing a setter function as a second argument they become bi-directional lenses. Lenses still serve as formula cells, allowing you to access the content of a data structure. But you can do a swap! or reset! on a lens to update that same structure. For example: (defn path-cell [c path]   (cell= (get-in c path) (partial swap! c assoc-in path)))  (defc a {:a [1 2 3], :b [4 5 6]}) (def  c (path-cell a [:a]))  @c                       ;=> [1 2 3] (swap! c pop)            ;=> [1 2] @c                       ;=> [1 2] @a                       ;=> {:a [1 2], :b [4 5 6]}  @c                       ;=> [1 2] (reset! c :x)            ;=> :x @c                       ;=> :x @a                       ;=> {:a :x, :b [4 5 6]}  @c                       ;=> :x (swap! a assoc :a [1 2]) ;=> {:a [1 2], :b [4 5 6]} @c                       ;=> [1 2] The path-cell function returns a converging lens whose formula focuses in on a part of the underlying collection using get-in. The provided callback takes the desired new value and updates the underlying collection accordingly using assoc-in. The update propagates to the lens formula, thereby updating the value of the lens cell itself. Interestingly, transactions can be used to create diverging lenses, inverting the above relationship between lens and underlying collection. Instead of focusing the lens on a single collection to extract a part it, the lens can be directed toward a number of individual cells to combine them into a single collection. For example: (defc  a 100) (defc  b 200) (defc= c {:a a, :b b} #(dosync (reset! a (:a %)) (reset! b (:b %))))  @a                       ;=> 100 @c                       ;=> {:a 100, :b 200} (swap! c assoc :a 200)   ;=> {:a 200, :b 200} @a                       ;=> 200 The c lens encapsulates the machinery of atomically updating both a and b in the standard cell interface. Converging and diverging lenses can be useful for low-impact, surgical refactoring. They encapsulate the value and mutation semantic, eliminating the need to modify existing code that references the underlying cells. Javelin API Requiring the namespace and macros: (ns my-ns   (:require     [javelin.core      :refer [cell? input? cell formula lens set-cell! alts! destroy-cell! cell-map]      :refer-macros [cell= defc defc= set-cell!= dosync cell-doseq]])) API functions and macros: (cell? c) ;; Returns c if c is a Cell, nil otherwise.  (input? c) ;; Returns c if c is an input cell, nil otherwise.  (formula? c) ;; Returns c if c is a formula cell, nil otherwise.  (lens? c) ;; Returns c if c is a lens cell, nil otherwise.  (cell expr) ;; Create new input cell with initial value expr.  ((formula f) x y z) ;; Create a new formula cell with the formula function. ;; Analogous to (cell= (f x y z)) but is a function, not a macro.  (cell= expr) ;; Create new fomula cell with formula expr.  (cell= expr f) ;; Create new lens cell with formula expr and callback f. When swap! or reset! ;; is applied to the cell the callback is fired with the requested new value ;; provided as an argument. The callback does not manipulate the lens cell's ;; value directly, but it can swap! or reset! input cells (or do anything else), ;; possibly resulting in a new value being computed by the lens formula.  (defc symbol doc-string? expr) ;; Creates a new input cell and binds it to a var with the name symbol and ;; the docstring doc-string if provided.  (defc= symbol doc-string? expr) ;; Creates a new formula cell with formula expr and binds it to a var with the ;; name symbol and the docstring doc-string if provided.  (defc= symbol doc-string? expr f) ;; Creates a new lens cell with formula expr and callback f, and binds it to a ;; var with the name symbol and the docstring doc-string if provided.  (set-cell! c expr) ;; Convert c to input cell (if necessary) with value expr.  (set-cell!= c expr) ;; Convert c to formula cell (if necessary) with formula expr.  (set-cell!= c expr f) ;; Convert c to lens cell (if necessary) with formula expr and callback f.  (destroy-cell! c) ;; Disconnects c from the propagation graph so it can be GC'd.  (dosync exprs*) ;; Evaluates exprs (in an implicit do) in a transaction that encompasses exprs ;; and any nested calls. Cell propagation occurs only after all exprs have been ;; run, and propagation occurs only once. Only the final values of cells updated ;; within the transaction are propagated.  (alts! cs*) ;; Creates a formula cell whose value is a list of changed values in the cells cs.  (cell-map f c) ;; Given a cell c containing a seqable value of size n and a function f, returns ;; a sequence of n formula cells such that the ith cell's formula is (f (nth c i)).  (cell-let [binding-form c] body*) ;; Given a cell c and a binding form, binds names in the binding form to formula ;; cells containing the destructured values (these values will update as the ;; value of c changes) and evaluates the body expressions.  (cell-doseq seq-exprs body*) ;; Repeatedly executes the body expressions for side effects as doseq does, with ;; bindings as provided by ""for"", except that the binding forms are bound to ;; javelin cells, not values. The :while and :when filters are not supported at ;; this time.  (prop-cell prop-expr) ;; Returns a formula cell whose value is synced to the prop-expr, which is a ;; JavaScript property access expression, like (.-foo js/bar) for example.  (prop-cell prop-expr setter-cell callback?) ;; Given a property access expression (see above) prop-expr, a formula cell ;; setter-cell, and optionally a callback function, the JavaScript object ;; property specified by prop-expr is kept synced to the value in setter-cell ;; at all times. If the callback was provided it will be called whenever an ;; attempt is made to change the value of the property by means other than via ;; the setter-cell. Building and Running Tests To build Javelin with advanced optimizations and run tests in PhantomJS: boot test-javelin --advanced  For development you may want to forgo optimizations and test continuously: boot watch speak test-javelin  License Copyright (c) Alan Dipert and Micha Niskin. All rights reserved. The use and distribution terms for this software are covered by the Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php) which can be found in the file epl-v10.html at the root of this distribution. By using this software in any fashion, you are agreeing to be bound by the terms of this license. You must not remove this notice, or any other, from this software.  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/hoplon/javelin"	"– A Functional Reactive Programming library for ClojureScript."	"true"
"Reactive Programming"	"Reagi"	"https://github.com/weavejester/reagi"	"– An FRP library for Clojure and ClojureScript, built on top of core.async."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"197"	"21"	"11"	"GitHub - weavejester/reagi: An FRP library for Clojure and ClojureScript Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 21 Star 197 Fork 11 weavejester/reagi Code Issues 2 Pull requests 5 Wiki Pulse Graphs An FRP library for Clojure and ClojureScript 292 commits 5 branches 33 releases 4 contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags async better-events clojurescript gh-pages master Nothing to show 0.10.1 0.10.0 0.9.1 0.9.0 0.8.5 0.8.4 0.8.3 0.8.2 0.8.1 0.8.0 0.7.1 0.7.0 0.6.3 0.6.2 0.6.1 0.6.0 0.5.1 0.5.0 0.4.1 0.4.0 0.3.1 0.3.0 0.2.1 0.2.0 0.1.2 0.1.1 0.1.0 0.0.6 0.0.5 0.0.4 0.0.3 0.0.2 0.0.1 Nothing to show New pull request Latest commit 8e43708 May 22, 2014 weavejester Released 0.10.1 Permalink Failed to load latest commit information. src/cljx/reagi Subscribed channels keep their base streams from GC May 7, 2014 test Fixed flatten GC bug May 7, 2014 .gitignore Added Austin plugin for Clojurescript REPL Dec 21, 2013 .travis.yml Moved cljs test dependencies to test profile Feb 15, 2014 README.md Released 0.10.1 May 22, 2014 project.clj Released 0.10.1 May 22, 2014 README.md Reagi Reagi is an FRP library for Clojure and ClojureScript, built on top of core.async. It provides tools to model and manipulation values that change over time. Installation Add the following dependency to your project.clj file: [reagi ""0.10.1""]  Overview Reagi introduces two new reference types, behaviors and event streams, which are collectively known as signals. user=> (require '[reagi.core :as r]) nil A behavior models continuous change, and is evaluated each time you dereference it. user=> (def t (r/behavior (System/currentTimeMillis))) #'user/t user=> @t 1380475144266 user=> @t 1380475175587 An event stream models a series of discrete changes. Events must be expicitly delivered to the stream. Dereferencing the event stream returns the last value pushed onto the stream. user=> (def e (r/events)) #'user/e user=> (r/deliver e 1) #<Events@66d278af: 1> user=> @e 1 If the event stream is empty (i.e. unrealized), dereferencing it will block the running thread, much like a promise. Unlike promises, event streams can have more than one value delivered to them, and may be constructed with an initial value: user=> (def e (r/events 1)) #'user/e user=> @e 1 Reagi provides a number of functions for transforming event streams, which mimic many of the standard Clojure functions for dealing with seqs: user=> (def incremented (r/map inc e)) #'user/m user=> (r/deliver e 2) #<Events@66d278af: 2> user=> @incremented 3 For a full list, see the API docs. Event streams can interoperate with core.async channels using port and subscribe. The port function returns a write-only stream that will deliver values to the stream: user=> (>!! (r/port e) 3) true user=> @e 3 The subscribe function allows an existing channel to be registered as an output for the stream. user=> (def ch (async/chan 1)) #'user/ch user=> (r/subscribe e ch) #<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@3b4df45f> user=> (r/deliver e 4) #<Events@66d278af: 4> user=> (<!! ch) 4 Note that this may cause the source stream to block if you don't consume the items in the channel, or provide a sufficient buffer. Behaviors can be converted to event streams by sampling them at a specified interval in milliseconds: user=> (def et (r/sample 1000 t)) #'user/et user=> @et 1380475969885 Signals can be completed with the completed function, which acts in a similar fashion to clojure.core/reduced. Signals that are completed will always deref to the same value. Any values pushed to a completed event stream will be ignored. user=> (def e (r/events)) #'user/e user=> (r/deliver e (r/completed 1)) #<Events@66d278af: 1> user=> (r/deliver e 2) #<Events@66d278af: 1> user=> @e 1 user=> (r/complete? e) true Documentation API Docs Differences in ClojureScript version The ClojureScript version of Reagi has two main differences from the Clojure version: Trying to deref an unrealized stream blocks the current thread in Clojure, but returned js/undefined in ClojureScript. Event streams that fall out of scope in Clojure are automatically cleaned up. In ClojureScript, the reagi.core/dispose function must be manually called on streams before they fall out of scope. License Copyright © 2014 James Reeves Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/weavejester/reagi"	"– An FRP library for Clojure and ClojureScript, built on top of core.async."	"true"
"Reactive Programming"	"rx-cljs"	"https://github.com/leonardoborges/rx-cljs"	"– A ClojureScript wrapper for Reactive Extensions (Rx) for Javascript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"34"	"2"	"4"	"GitHub - leonardoborges/rx-cljs: A ClojureScript wrapper for RxJS Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 34 Fork 4 leonardoborges/rx-cljs Code Issues 0 Pull requests 0 Pulse Graphs A ClojureScript wrapper for RxJS 14 commits 1 branch 0 releases 1 contributor Clojure 89.7% JavaScript 10.3% Clojure JavaScript Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit c862ab8 May 21, 2013 leonardoborges Making sure my cljs namespace ends up in the jar Permalink Failed to load latest commit information. resources/private Added Rx dependencies for tests. May 20, 2013 runners Switched testing frameworks to bodil/error due to async tests. Also h… May 21, 2013 src-cljs/rx_cljs New functions and tests May 21, 2013 test-cljs/rx_cljs New functions and tests May 21, 2013 .gitignore Switched testing frameworks to bodil/error due to async tests. Also h… May 21, 2013 README.md bumped version May 21, 2013 project.clj Making sure my cljs namespace ends up in the jar May 21, 2013 README.md rx-cljs A ClojureScript wrapper for Reactive Extensions (Rx) for Javascript. Motivation The aim of this wrapper is to let developers write this: (defn project-range [n]     (return-value (range n)))  (-> (from-array [4 6 8])     (select-many project-range)     (subscribe #(.log js/console (clj->js %)))) Instead of: (defn project-range [n]   (.returnValue js/Rx.Observable (range n)))  (-> (.fromArray js/Rx.Observable                 (clj->js [1 2 3]))     (.selectMany project-range)     (.subscribe #(.log js/console (clj->js %)))) Usage Be warned: it's very early days and this wrapper is still very much incomplete. For the brave amongst you, add this to your project.clj: [com.leonardoborges/rx-cljs ""0.0.2-SNAPSHOT""] Or if you're using maven: <dependency>   <groupId>com.leonardoborges</groupId>   <artifactId>rx-cljs</artifactId>   <version>0.0.2-SNAPSHOT</version> </dependency> For a sample app that uses this wrapper, check out this repository. What's in the package Creating observables create return-value from-array interval Working with Observables take map reduce skip zip select-many subscribe start-with buffer-with-count Working with Connectable observables publish connect ref-count Working with Observers on-next on-completed Working with Subscriptions dispose Running the tests From the project root: $ lein cljsbuild test TODO Everything else. (but mainly other arities of functions already in here.) Contributing Bug reports and pull requests are much welcome. If submitting code, please add a test to it. License Copyright (C) 2013 Leonardo Borges Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/leonardoborges/rx-cljs"	"– A ClojureScript wrapper for Reactive Extensions (Rx) for Javascript."	"true"
"Reactive Programming"	"Yolk"	"https://github.com/Cicayda/yolk"	"– A thin ClojureScript wrapper around bacon.js."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"43"	"12"	"5"	"GitHub - Cicayda/yolk: A thin Clojurescript wrapper around bacon.js Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 12 Star 43 Fork 5 Cicayda/yolk Code Issues 1 Pull requests 1 Pulse Graphs A thin Clojurescript wrapper around bacon.js 67 commits 4 branches 1 release Fetching contributors JavaScript 75.2% Clojure 19.4% CSS 5.4% JavaScript Clojure CSS Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: develop Switch branches/tags Branches Tags bacon-jquery combine-template develop master Nothing to show 0.3.0 Nothing to show New pull request Latest commit 37a2d05 Dec 13, 2013 potetm Fixed some typos. Fixed zip-with and combine-with. Permalink Failed to load latest commit information. externs sync with bacon 0.6.22 Nov 19, 2013 resources sync with bacon 0.6.22 Nov 19, 2013 src/yolk Fixed some typos. Fixed zip-with and combine-with. Dec 13, 2013 test sync with bacon 0.6.22 Nov 19, 2013 .gitignore Fixed a few typos. Breaking change! Dec 9, 2013 CHANGES.md sync with bacon.js 0.5.1 Jun 28, 2013 README.md added epl-v10.html Mar 25, 2013 epl-v10.html added epl-v10.html Mar 25, 2013 project.clj Fixed some typos. Fixed zip-with and combine-with. Dec 13, 2013 README.md yolk The best part of the egg. License Copyright © 2013 Wilkes Joiner Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Cicayda/yolk"	"– A thin ClojureScript wrapper around bacon.js."	"true"
"Routing"	"Bidi"	"https://github.com/juxt/bidi"	"– A Clojure(script) data driven routing library."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"551"	"24"	"62"	"GitHub - juxt/bidi: Bidirectional URI routing Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 24 Star 551 Fork 62 juxt/bidi Code Issues 20 Pull requests 2 Pulse Graphs Bidirectional URI routing 491 commits 3 branches 82 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags cljc master revert-101-querystring Nothing to show bidi-1.10.6-20141029.094639-1 bidi-1.10.5 bidi-1.10.4 bidi-1.10.3 bidi-1.10.2 bidi-1.10.1 bidi-1.10.0 bidi-1.9.5 bidi-1.9.4 bidi-1.9.3 bidi-1.9.2 bidi-1.9.1 2.0.8 2.0.7 2.0.6 2.0.5 2.0.4 2.0.3 2.0.2 2.0.1 2.0.0 1.25.1 1.25.0 1.24.0 1.23.2 1.23.1 1.23.0 1.22.1 1.22.0 1.21.1 1.21.0 1.20.3 1.20.2 1.20.1 1.20.0 1.19.1 1.19.0 1.18.11 1.18.10 1.18.9 1.18.8 1.18.7 1.18.6 1.18.5 1.18.4 1.18.3 1.18.2 1.18.1 1.18.0 1.17.1 1.17.0 1.16.0 1.15.1 1.15.0 1.14.0 1.13.0 1.12.2 1.12.0 1.11.0 1.10.61 1.10.6 1.10.5 1.10.4 1.10.3 1.10.2 1.10.1 1.10.0 1.9.5 1.9.4 1.9.3 1.9.2 1.9.1 1.9.0 1.8.0 1.7.0 1.6.0 1.5.0 1.4.0 1.3.0 1.2.0 1.1.0 1.0.0 Nothing to show New pull request Latest commit 2f541b2 Jul 6, 2016 malcolmsparks From Paul deGrandis Permalink Failed to load latest commit information. doc Update patterns.md Dec 17, 2014 src/bidi Dispatch on host regardless of scheme Apr 27, 2016 test-resources Fix #84 Mar 7, 2016 test/bidi Add test for relativize Apr 26, 2016 .gitignore Ignore ClojureScript artefacts Aug 11, 2014 .travis.yml add to travis ci Jan 27, 2015 LICENSE Move from EPL to MIT license Dec 22, 2014 README.md From Paul deGrandis Jul 6, 2016 circle.yml Add circleci settings. Dec 28, 2015 project.clj Ready for release Apr 27, 2016 README.md bidi ""bidi bidi bidi"" -- Twiki, in probably every episode of Buck Rogers in the 25th Century In the grand tradition of Clojure libraries we begin with an irrelevant quote. Bi-directional URI dispatch. Like Compojure, but when you want to go both ways. If you are serving REST resources, you should be providing links to other resources, and without full support for forming URIs from handlers your code will become coupled with your routing. In short, hard-coded URIs will eventually break. In bidi, routes are data structures, there are no macros here. Generally speaking, data structures are to be preferred over code structures. When routes are defined in a data structure there are numerous advantages - they can be read in from a configuration file, generated, computed, transformed by functions and introspected - all things which macro-based DSLs make harder. For example, suppose you wanted to use the same set of routes in your application and in your production Nginx or HAProxy configuration. Having your routes defined in a single data structure means you can programmatically generate your configuration, making your environments easier to manage and reducing the chance of discrepancies. bidi also avoids 'terse' forms for the route definitions- reducing the number of parsing rules for the data structure is valued over convenience for the programmer. Convenience can always be added later with macros. Finally, the logic for matching routes is separated from the responsibility for handling requests. This is an important architectural principle. So you can match on things that aren't necessarily handlers, like keywords which you can use to lookup your handlers, or whatever you want to do. Separation of concerns and all that. Comparison with other routing libraries There are numerous Clojure(Script) routing libraries. Here's a table to help you compare. Library clj cljs Syntax Isomorphic? Self-contained? Extensible? Compojure ✔ Macros ✔ Moustache ✔ Macros ✔ RouteOne ✔ Macros ✔ ✔ Pedestal ✔ Data ✔ ✔ ✔ gudu ✔ Data ✔ ✔ secretary ✔ Macros ✔ ✔ ✔ silk ✔ ✔ Data ✔ ✔ ✔ fnhouse ✔ Macros ✔ bidi ✔ ✔ Data ✔ ✔ ✔ bidi is written to do 'one thing well' (URI dispatch and formation) and is intended for use with Ring middleware, HTTP servers (including Jetty, http-kit and aleph) and is fully compatible with Liberator. Installation Add the following dependency to your project.clj file As bidi uses Clojure's reader conditionals, bidi is dependent on both Clojure 1.7 and Leiningen 2.5.3 or later. Version 2.x Version 2.x builds on 1.x by providing a mechanism to envelope multiple virtual hosts with a single route map. The idea is to eventually create a route map which defines routes across multiple services and helps with the construction of URIs to other services, a process which is traditionally error-prone. Version 2.x is backward compatible and forward compatible with version 1.x. If you are upgrading from 1.x to 2.x you will not need to change your existing route definitions. Take 5 minutes to learn bidi (using the REPL) Let's create a route that matches /index.html. A route is simply a pair, containing a pattern and a result. user> (def route [""/index.html"" :index]) #'user/route Let's try to match that route to a path. user> (use 'bidi.bidi) nil user> (match-route route ""/index.html"") {:handler :index} We have a match! A map is returned with a single entry with a :handler key and :index as the value. We could use this result, for example, to look up a Ring handler in a map mapping keywords to Ring handlers. What happens if we try a different path? user> (match-route route ""/another.html"") nil We get a nil. Nil means 'no route matched'. Now, let's go in the other direction. user> (path-for route :index) ""/index.html"" We ask bidi to use the same route definition to tell us the path that would match the :index handler. In this case, it tells us /index.html. So if you were forming a link to this handler from another page, you could use this function in your view logic to create the link instead of hardcoding in the view template (This gives your code more resilience to changes in the organisation of routes during development). Multiple routes Now let's suppose we have 2 routes. We match partially on their common prefix, which in this case is ""/"" but we could use """" if there were no common prefix. The patterns for the remaining path can be specified in a map (or vector of pairs, if order is important). user> (def my-routes [""/"" {""index.html"" :index                         ""article.html"" :article}]) #'user/my-routes Since each entry in the map is itself a route, you can nest these recursively. user> (def my-routes [""/"" {""index.html"" :index                         ""articles/"" {""index.html"" :article-index                                      ""article.html"" :article}}]) #'user/my-routes We can match these routes as before :- user> (match-route my-routes ""/index.html"") {:handler :index} user> (match-route my-routes ""/articles/article.html"") {:handler :article} and in reverse too :- user> (path-for my-routes :article-index) ""/articles/index.html"" Route patterns It's common to want to match on a pattern or template, extracting some variable from the URI. Rather than including special characters in strings, we construct the pattern in segments using a Clojure vector [:id ""/article.html""]. This vector replaces the string we had in the left hand side of the route pair. user> (def my-routes [""/"" {""index.html"" :index                         ""articles/"" {""index.html"" :article-index                                      [:id ""/article.html""] :article}}]) #'user/my-routes Now, when we match on an article path, the keyword values are extracted into a map. user> (match-route my-routes ""/articles/123/article.html"") {:handler :article, :route-params {:id ""123""}} user> (match-route my-routes ""/articles/999/article.html"") {:handler :article, :route-params {:id ""999""}} To form the path we need to supply the value of :id as extra arguments to the path-for function. user> (path-for my-routes :article :id 123) ""/articles/123/article.html"" user> (path-for my-routes :article :id 999) ""/articles/999/article.html"" If you don't specify a required parameter an exception is thrown. Apart from a few extra bells and whistles documented in the rest of this README, that's basically it. Your five minutes are up! Going further Here are some extra topics you'll need to know to use bidi in a project. Wrapping as a Ring handler Match results can be any value, but are typically functions (either in-line or via a symbol reference). You can easily wrap your routes to form a Ring handler (similar to what Compojure's routes and defroutes does) with the make-handler function. (ns my.handler   (:require [bidi.ring :refer (make-handler)]             [ring.util.response :as res]))  (defn index-handler   [request]   (res/response ""Homepage""))  (defn article-handler   [{:keys [route-params]}]   (res/response (str ""You are viewing article: "" (:id route-params))))  (def handler   (make-handler [""/"" {""index.html"" index-handler                       [""articles/"" :id ""/article.html""] article-handler}])) To chain this with middleware is simple. (ns my.app   (:require [my.handler :refer [handler]]             [ring.middleware.session :refer [wrap-session]             [ring.middleware.flash :refer [wrap-flash])) (def app   (-> handler       wrap-session       wrap-flash)) Regular Expressions We've already seen how keywords can be used to extract segments from a path. By default, keywords only capture numbers and simple identifiers. This is on purpose, in a defence against injection attacks. Often you'll want to specify exactly what you're trying to capture using a regular expression. If we want :id to match a number only, we can substitute the keyword with a pair, containing a regular expression followed by the keyword. For example, instead of this :-     [ [ ""foo/"" :id ""/bar"" ] :handler ] we write this :-     [ [ ""foo/"" [ #""\d+"" :id ] ""/bar"" ] :handler ] which would match the string foo/123/bar but not foo/abc/bar. Advanced topics These features are optional, you don't need to know about them to use bidi, but they may come in useful. Guards By default, routes ignore the request method, behaving like Compojure's ANY routes. That's fine if your handlers deal with the request methods themselves, as Liberator's do. However, if you want to limit a route to a request method, you can wrap the route in a pair (or map entry), using a keyword for the pattern. The keyword denotes the request method (:get, :put, etc.) [""/"" {""blog"" {:get {""/index"" (fn [req] {:status 200 :body ""Index""})}}}] You can also restrict routes by any other request criteria. Guards are specified by maps. Map entries can specify a single value, a set of possible values or even a predicate to test a value. In this example, the /zip route is only matched if the server name in the request is juxt.pro. You can use this feature to restrict routes to virtual hosts or HTTP schemes. [""/"" {""blog"" {:get                 {""/index"" (fn [req] {:status 200 :body ""Index""})}}               {:request-method :post :server-name ""juxt.pro""}                 {""/zip"" (fn [req] {:status 201 :body ""Created""})}}] Values in the guard map can be values, sets of acceptable values, or even predicate functions to give fine-grained control over the dispatch criteria. Keywords Sometimes you want segments of the URI to be extracted as keywords rather than strings, and in the reverse direction, to use keywords as values to be encoded into URIs. You can construct a pattern similarly to how you specify regular expressions but instead of the regex you use specify keyword core function.    [ ""foo/"" [ keyword :db/ident ] ""/bar"" ] When matching the path foo/bidi/bar, the :route-params of the result would be {:db/ident :bidi}. To construct the path, you would use (path-for my-routes handler :db/ident :bidi), which results in foo/bidi/bar (the colon of the stringified keyword is omitted). Namespaced keywords are also supported. Note that in the URI the / that separates the keyword's namespace from its name is URL encoded to %2F, rather than /. Catch-All Routes Note that you can use the pattern true to match anything. This is useful for writing catch-all routes. For example, if we'd like to match a certain set of routes and return 404 Not Found for everything else, we can do the following: (def my-routes [""/"" [[""index.html"" :index]                   [true         :not-found]]]) We used vectors rather than maps to define the routes because the order of the definitions is significant (i.e. true will completely subsume the other routes if we let it). Now let's try to match on that: user> (match-route my-routes ""/index.html"") {:handler :index} user> (match-route my-routes ""/other.html"") {:handler :not-found} Note that :not-found doesn't have any special significance here--we still need to provide a hander function that implements the desired 404 behavior. Route definitions A route is formed as a pair: [ <pattern> <matched> ] The left-hand-side of a pair is the pattern. It can match a path, either fully or partially. The simplest pattern is a string, but other types of patterns are also possible, including segmented paths, regular expressions, records, in various combinations. The right-hand-side indicates the result of the match (in the case that the pattern is matched fully) or a route sub-structure that attempts to match on the remainder of the path (in the case that the pattern is matched partially). The route structure is a recursive structure. This BNF grammar formally defines the basic route structure, although it is possible extend these definitions by adding types that satisfy the protocols used in bidi (more on this later). RouteStructure := RoutePair  RoutePair ::= [ Pattern Matched ]  Pattern ::= Path | [ PatternSegment+ ] | MethodGuard | GeneralGuard | true | false  MethodGuard ::= :get :post :put :delete :head :options  GeneralGuard ::= [ GuardKey GuardValue ]* (a map)  GuardKey ::= Keyword  GuardValue ::= Value | Set | Function  Path ::= String  PatternSegment ::= String | Regex | Keyword | [ (String | Regex) Keyword ]  Matched ::= Function | Symbol | Keyword | [ RoutePair+ ] { RoutePair+ }  In case of confusion, refer to bidi examples found in this README and in the test suite. A schema is available as bidi.schema/RoutePair. You can use this to check or validate a bidi route structure in your code. (require '[schema.core :as s] bidi.schema)  (def route [""/index.html"" :index])  ;; Check that the route is properly structured - returns nil if valid; ;; otherwise, returns a value with 'bad' parts of the route. (s/check bidi.schema/RoutePair route)  ;; Throw an exception if the route is badly structured (s/validate bidi.schema/RoutePair route) Virtual Hosts If you are serving multiple virtual hosts with the same server, you may want to create a super-structure that allows routing across virtual host boundaries. Here's a virtual-host structure: [""https://example.org:8443""  [""/index.html"" :index]  [""/login"" :login]  [""/posts"" […]] It's just like the vector-of-vectors syntax we've seen before in bidi, but this time the first element is a virtual-host declaration. This is usually a string but can also be a java.net.URI or java.net.URL, or a map like {:scheme :https :host ""example.org:8443""}. A virtual-hosts super-structure is created with the bidi.vhosts/vhosts.model variadic function, each argument is a virtual-host structure. (require '[bidi.vhosts :refer [vhosts-model])  (def my-vhosts-model   (vhosts-model [""https://example.org:8443""                  [""/index.html"" :index]                  [""/login"" :login]]                  [""https://blog.example.org""                  [""/posts.html"" […]]]))  uri-for When using virtual hosts, use the bidi.vhosts/uri-for to generate URIs. For example: (uri-for my-vhosts-model :index {:query-params {""q"" ""juxt""}})  would return {:uri ""https://example.org:8443/index.html?q=juxt""  :path ""/index.html""  :host ""example.org:8443""  :scheme :https  :href ""https://example.org:8443/index.html?q=juxt""}  A partially applied uri-for function is available in bidi's matching context and returns a map of the following elements. This partial applies the vhosts-model which can help with dependency cycles in your code (where your bidi router requires knowledge of resources, which have views that require knowledge of the bidi router's routes). When called via bidi's match-context, the :href entry in the result may not contain the scheme, host and port, if these are redundant, whereas the :uri entry always contains an absolute URI. If you are creating HTML content for a browser, :href is safe to use. If, for example, you are creating an API returning a JSON-formatted response body, prefer :uri. Synonymous virtual-hosts The virtual-host declaration can itself be a vector, if you need to match multiple possibilities. Here's another example, which matches two hosts: [[""https://example.org:8443"" ""http://example.org:8000""]  [""/index.html"" :index]  [""/login"" :login]] The rules for uri-for are that the first virtual-host in the vector is used. When the request is known to bidi (i.e. in the partially applied uri-for function in the match-context) the algorithm chooses the first virtual host that matches the request URI's scheme. Composability As they are simply nested data structures (strings, vectors, maps), route structures are highly composable. They are consistent and easy to generate. A future version of bidi may contain macros to reduce the number of brackets needed to create route structures by hand. Extensibility The implementation is based on Clojure protocols which allows the route syntax to be extended outside of this library. Built-in records are available but you can also create your own. Below is a description of the built-in ones and should give you an idea what is possible. If you add your own types, please consider contributing them to the project. Make sure you test that your types in both directions (for URI matching and formation). Redirect The Redirect record is included which satisfies the Matched protocol. Consider the following route definition. (defn my-handler [req] {:status 200 :body ""Hello World!""})  [""/articles"" {""/new"" my-handler               ""/old"" (->Redirect 307 my-handler)}] Any requests to /articles/old yield 307 Temporary Redirect responses with a Location header of /articles/new. This is a robust way of forming redirects in your code, since it guarantees that the Location URI matches an existing handler, both reducing the chance of broken links and encouraging the practise of retaining old URIs (linking to new ones) after refactoring. You can also use it for the common practice of adding a welcome page suffix, for example, adding index.html to a URI ending in /. Resources and ResourcesMaybe The Resources and ResourcesMaybe record can be used on the right-hand side of a route. It serves resources from the classpath. After the pattern is matched, the remaining part of the path is added to the given prefix. [""/resources"" (->ResourcesMaybe {:prefix ""public/""}) There is an important difference between Resources and ResourcesMaybe. Resources will return a 404 response if the resource cannot be found, while ResourcesMaybe will return nil, allowing subsequent routes to be tried. Files Similar to Resources, Files will serve files from a file-system. [""pics/"" (->Files {:dir ""/tmp/pics""})] WrapMiddleware You can wrap the target handler in Ring middleware as usual. But sometimes you need to specify that the handlers from certain patterns are wrapped in particular middleware. For example :- (match-route [""/index.html"" (->WrapMiddleware handler wrap-params)]              ""/index.html"") Use this with caution. If you are using this you are probably doing it wrong. Bidi separates URI routing from request handling. Ring middleware is something that should apply to handlers, not routes. If you have a set of middleware common to a group of handlers, you should apply the middleware to each handler in turn, rather than use ->WrapMiddleware. Better to map a middleware applying function over your handlers rather than use this feature. Alternates Sometimes you want to specify a list of potential candidate patterns, which each match the handler. The first in the list is considered the canonical pattern for the purposes of URI formation. [#{""/index.html"" ""/index""} :index] Any pattern can be used in the list. This allows quite sophisticated matching. For example, if you want to match on requests that are either HEAD or GET but not anything else. [#{:head :get} :index] Or match if the server name is juxt.pro or localhost. [#{{:server-name ""juxt.pro""}{:server-name ""localhost""}}  {""/index.html"" :index}] Tagged Match Sometimes you need to apply a tag to a route, so you can use the tag (rather than the handler) in a path-for function. This is very convenient when forming routes, because you don't need to have a reference to the handler itself. You can use the tag function to construct these records. (tag my-handler :my-tag) It's common to use the single threaded macro, so wrapping handlers in tags is just like wrapping them in Ring middleware. For example :- [""/"" [[""foo"" (-> foo-handler (tag :foo)]       [[""bar/"" :id] (-> bar-handler (tag :bar)]]] Paths can now be created like this :- (path-for my-routes :foo) (path-for my-routes :bar :id ""123"")  Route sequences It's possible to extract all possible routes from a route structure with route-seq. Call route-seq on a route structure returns a sequence of all the possible routes contained in the route structure. This is useful to generating a site map. Each route is a map containing a path and a handler entry. If you use keywords to extract route parameters, they will be contained in the path. If you wish to control the expansion, use a custom record that satisfies both bidi/Pattern and bidi/Matches. Contributing We welcome pull requests. If possible, please run the tests and make sure they pass before you submit one. $ lein test  lein test bidi.bidi-test  lein test bidi.perf-test Time for 1000 matches using Compojure routes ""Elapsed time: 17.645077 msecs"" Time for 1000 matches using uncompiled bidi routes ""Elapsed time: 66.449164 msecs"" Time for 1000 matches using compiled bidi routes ""Elapsed time: 21.269446 msecs""  Ran 9 tests containing 47 assertions. 0 failures, 0 errors.  A big thank you to everyone involved in bidi so far, including Alexander Kiel Bobby Calderwood Cameron Desautels Chris Price David Thomas Hume Dene Simpson Dominic Monroe Elben Shira James Henderson Jeff Rose John Cowie Julian Birch Malcolm Sparks Martin Trojer Matt Mitchell Michael Sappler Nate Smith Neale Swinnerton Nicolas Ha Oliver Hine Philipp Meier Rob Mather Sebastian Bensusan Thomas Crowley Thomas Mulvaney Tom Crayford Andrew Phillips Copyright & License The MIT License (MIT) Copyright © 2014-2015 JUXT LTD. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/juxt/bidi"	"– A Clojure(script) data driven routing library."	"true"
"Routing"	"Secretary"	"https://github.com/gf3/secretary"	"– A client-side router for ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"563"	"30"	"46"	"GitHub - gf3/secretary: A client-side router for ClojureScript. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 30 Star 563 Fork 46 gf3/secretary Code Issues 12 Pull requests 5 Wiki Pulse Graphs A client-side router for ClojureScript. 170 commits 3 branches 11 releases 19 contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags defroutes master v2.0.0 Nothing to show v1.0.4 v1.0.3 v1.0.2 v1.0.1 v1.0.0 v0.7.1 v0.7.0 v0.6.0 v0.5.0 v0.4.0 v0.3.0 Nothing to show New pull request Latest commit 9a8c3b9 Oct 29, 2015 noprompt Merge pull request #79 from anmonteiro/SEC-53 … Add note about macro refer syntax and cljs versions Permalink Failed to load latest commit information. dev Update dev environment Mar 6, 2015 examples/example-01 Fixed warning in example compile by making two-part namespace example… Mar 2, 2015 src/secretary Fix the syntax for extend-protocol to avoid warnings in latest cljs r… Mar 16, 2015 test/secretary/test Truncate test to t Mar 6, 2015 .gitignore Update gitignore Oct 2, 2013 README.md Add note about macro refer syntax and cljs versions Oct 19, 2015 project.clj Set development version Mar 31, 2015 README.md secretary A client-side router for ClojureScript. Contents Installation Guide Basic routing and dispatch Route matchers Parameter destructuring Query parameters Named routes Example with history Available protocols Contributors Committers Installation Add secretary to your project.clj :dependencies vector: [secretary ""1.2.3""] For the current SNAPSHOT version use: [secretary ""1.2.4-SNAPSHOT""] Guide To get started :require secretary somewhere in your project. (ns app.routes   (:require [secretary.core :as secretary :refer-macros [defroute]])) Note: starting ClojureScript v0.0-2371, :refer cannot be used to import macros into your project anymore. The proper way to do it is by using :refer-macros as above. When using ClojureScript v0.0-2755 or above, if (:require [secretary.core :as secretary]) is used, macros will be automatically aliased to secretary, e.g. secretary/defroute. Basic routing and dispatch Secretary is built around two main goals: creating route matchers and dispatching actions. Route matchers match and extract parameters from URI fragments and actions are functions which accept those parameters. defroute is Secretary's primary macro for defining a link between a route matcher and an action. The signature of this macro is [name? route destruct & body]. We will skip the name? part of the signature for now and return to it when we discuss named routes. To get clearer picture of this let's define a route for users with an id. (defroute ""/users/:id"" {:as params}   (js/console.log (str ""User: "" (:id params)))) In this example ""/users/:id"" is route, the route matcher, {:as params} is destruct, the destructured parameters extracted from the route matcher result, and the remaining (js/console.log ...) portion is body, the route action. Before going in to more detail let's try to dispatch our route. (secretary/dispatch! ""/users/gf3"") With any luck, when we refresh the page and view the console we should see that User: gf3 has been logged somewhere. Route matchers By default the route matcher may either be a string or regular expression. String route matchers have special syntax which may be familiar to you if you've worked with Sinatra or Ruby on Rails. When secretary/dispatch! is called with a URI it attempts to find a route match and it's corresponding action. If the match is successful, parameters will be extracted from the URI. For string route matchers these will be contained in a map; for regular expressions a vector. In the example above, the route matcher ""/users/:id"" successfully matched against ""/users/gf3"" and extracted {:id ""gf3} as parameters. You can refer to the table below for more examples of route matchers and the parameters they return when matched successfully. Route matcher URI Parameters ""/:x/:y"" ""/foo/bar"" {:x ""foo"" :y ""bar""} ""/:x/:x"" ""/foo/bar"" {:x [""foo"" ""bar""]} ""/files/*.:format"" ""/files/x.zip"" {:* ""x"" :format ""zip""} ""*"" ""/any/thing"" {:* ""/any/thing""} ""/*/*"" ""/n/e/thing"" {:* [""n"" ""e/thing""]} ""/*x/*y"" ""/n/e/thing"" {:x ""n"" :y ""e/thing""} #""/[a-z]+/\d+"" ""/foo/123"" [""/foo/123""] #""/([a-z]+)/(\d+)"" ""/foo/123"" [""foo"" ""123""] Parameter destructuring Now that we understand what happens during dispatch we can look at the destruct argument of defroute. This part is literally sugar around let. Basically whenever one of our route matches is successful and extracts parameters this is where we destructure them. Under the hood, for example with our users route, this looks something like the following. (let [{:as params} {:id ""gf3""}]   ...) Given this, it should be fairly easy to see that we could have have written (defroute ""/users/:id"" {id :id}   (js/console.log (str ""User: "" id))) and seen the same result. With string route matchers we can go even further and write (defroute ""/users/:id"" [id]   (js/console.log (str ""User: "" id))) which is essentially the same as saying {:keys [id]}. For regular expression route matchers we can only use vectors for destructuring since they only ever return vectors. (defroute #""/users/(\d+)"" [id]   (js/console.log (str ""User: "" id))) Query parameters If a URI contains a query string it will automatically be extracted to :query-params for string route matchers and to the last element for regular expression matchers. (defroute ""/users/:id"" [id query-params]   (js/console.log (str ""User: "" id))   (js/console.log (pr-str query-params)))  (defroute #""/users/(\d+)"" [id {:keys [query-params]}]   (js/console.log (str ""User: "" id))   (js/console.log (pr-str query-params)))  ;; In both instances... (secretary/dispatch! ""/users/10?action=delete"") ;; ... will log ;; User: 10 ;; ""{:action \""delete\""}"" Named routes While route matching and dispatch is by itself useful, it is often necessary to have functions which take a map of parameters and return a URI. By passing an optional name to defroute Secretary will define this function for you. (defroute users-path ""/users"" []   (js/console.log ""Users path""))  (defroute user-path ""/users/:id"" [id]   (js/console.log (str ""User "" id ""'s path""))  (users-path) ;; => ""/users"" (user-path {:id 1}) ;; => ""/users/1"" This also works with :query-params. (user-path {:id 1 :query-params {:action ""delete""}}) ;; => ""/users/1?action=delete"" If the browser you're targeting does not support HTML5 history you can call (secretary/set-config! :prefix ""#"") to prefix generated URIs with a ""#"". (user-path {:id 1}) ;; => ""#/users/1"" Available protocols You can extend Secretary's protocols to your own data types and records if you need special functionality. IRenderRoute IRouteMatches IRenderRoute Most of the time the defaults will be good enough but on occasion you may need custom route rendering. To do this implement IRenderRoute for your type or record. (defrecord User [id]   secretary/IRenderRoute   (render-route [_]     (str ""/users/"" id))    (render-route [this params]     (str (secretary/render-route this) ""?""          (secretary/encode-query-params params))))  (secretary/render-route (User. 1)) ;; => ""/users/1"" (secretary/render-route (User. 1) {:action :delete}) ;; => ""/users/1?action=delete"" IRouteMatches It is seldom you will ever need to create your own route matching implementation as the built in String and RegExp routes matchers should be fine for most applications. Still, if you have a suitable use case then this protocol is available. If your intention is to is to use it with defroute your implementation must return a map or vector. Example with goog.History (ns example   (:require [secretary.core :as secretary :refer-macros [defroute]]             [goog.events :as events]             [goog.history.EventType :as EventType])   (:import goog.History))  (def application   (js/document.getElementById ""application""))  (defn set-html! [el content]   (aset el ""innerHTML"" content))  (secretary/set-config! :prefix ""#"")  ;; /#/ (defroute home-path ""/"" []   (set-html! application ""<h1>OMG! YOU'RE HOME!</h1>""))  ;; /#/users (defroute users-path ""/users"" []   (set-html! application ""<h1>USERS!</h1>""))  ;; /#/users/:id (defroute user-path ""/users/:id"" [id]   (let [message (str ""<h1>HELLO USER <small>"" id ""</small>!</h1>"")]     (set-html! application message)))  ;; /#/777 (defroute jackpot-path ""/777"" []   (set-html! application ""<h1>YOU HIT THE JACKPOT!</h1>""))  ;; Catch all (defroute ""*"" []   (set-html! application ""<h1>LOL! YOU LOST!</h1>""))  ;; Quick and dirty history configuration. (let [h (History.)]   (goog.events/listen h EventType/NAVIGATE #(secretary/dispatch! (.-token %)))   (doto h (.setEnabled true))) Contributors @gf3 (Gianni Chiappetta) @noprompt (Joel Holdbrooks) @joelash (Joel Friedman) @james-henderson (James Henderson) @the-kenny (Moritz Ulrich) @timgilbert (Tim Gilbert) @bbbates (Brendan) @travis (Travis Vachon) Committers @gf3 (Gianni Chiappetta) @noprompt (Joel Holdbrooks) @joelash (Joel Friedman) License Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/gf3/secretary"	"– A client-side router for ClojureScript."	"true"
"Routing"	"Silk"	"https://github.com/DomKM/silk"	"– An isomorphic routing library for Clojure & ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"194"	"9"	"9"	"GitHub - DomKM/silk: Routing for Clojure & ClojureScript Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 9 Star 194 Fork 9 DomKM/silk Code Issues 5 Pull requests 1 Pulse Graphs Routing for Clojure & ClojureScript 54 commits 2 branches 4 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags fsm master Nothing to show v0.0.2 v0.0.1 0.1.1 0.1.0 Nothing to show New pull request Latest commit 6284b82 Feb 10, 2016 DomKM Bump version. Permalink Failed to load latest commit information. bin initial Jun 27, 2014 spec/domkm Merge pull request #20 from jeluard/master Aug 16, 2015 src/domkm Merge pull request #20 from jeluard/master Aug 17, 2015 .gitignore Bump version. Feb 10, 2016 README.md Update README query example to be more realistic Dec 18, 2015 project.clj Bump version. Feb 11, 2016 README.md Silk Isomorphic Clojure[Script] Routing Design Goals and Solutions Compatible with Clojure and ClojureScript The core functionality of Silk in domkm.silk is fully compatible with both Clojure and ClojureScript and was designed to be so from the ground up. Server-specific code for use with Ring is in domkm.silk.serve. There is currently no browser-specific code, though there probably will be in the future. Extensible Routes An isomorphic routing library must be extensible for environment-specific constraints. For example, on the server-side we may want a route to only respond to GET HTTP requests, while on the browser-side we want that same route to work even though there is no concept of incoming HTTP requests. This is easy to do with Silk's core protocol, domkm.silk/Pattern, and is shown below. Bidirectional Routes Routes should be bidirectional (commonly referred to as named). If you are serving resources, the likelihood is that you are also providing links to other resources. Your code and routes quickly become coupled and brittle without support for URL formation. Unidirectional routes (like Compojure) will, eventually, break; bidirectional routes will not. Silk routes are named and a specific route can be retrieved from a collection of routes by its name. Decoupled Matching and Handling This architectural principle is especially important in isomorphic applications. Matching will probably be similar on the server-side and browser-side (except for extensions mentioned above) but handling will likely be completely different. Names are not restricted to strings or keywords, so a name could be a handler function. Or you could store handler functions elsewhere and look them up by route name. Silk does not impose restrictions. Data, Not Functions/Macros Data structures can be generated, transformed, and analyzed at runtime and, perhaps more importantly, can be inspected and printed in meaningful ways. Macro DSLs and function composition make these things very difficult. Silk routes are data structures. They are not nested functions and are not created with complex macros. They are easy to create, manipulate, and inspect from Clojure and ClojureScript. Reasonably Convenient Silk has a few special rules to make route definition and use fairly terse. However, since routes are just data and are therefore easy to create and compose, users can easily define more convenient syntax for their specific use cases. Reasonably Performant This goal is not yet met. Well, it may be, but there are no benchmarks yet. Use Take a few minutes to learn Silk Patterns can be matched and unmatched with domkm.silk/match and domkm.silk/unmatch respectively. Strings only match themselves. (silk/match ""foo"" ""foo"") ;=> {} (silk/unmatch ""foo"" {}) ;=> ""foo"" Keywords are wildcards. (silk/match :foo ""bar"") ;=> {:foo ""bar""} (silk/unmatch :foo {:foo ""bar""}) ;=> ""bar"" There are also built in patterns for common use cases. (silk/match (silk/int :answer) ""42"") ;=> {:answer 42} (silk/unmatch (silk/int :answer) {:answer 42}) ;=> ""42""  (silk/match (silk/uuid :id) ""c11902f0-21b6-4645-a218-9fa40ef69333"") ;=> {:id #uuid ""c11902f0-21b6-4645-a218-9fa40ef69333""} (silk/unmatch (silk/uuid :id) {:id #uuid ""c11902f0-21b6-4645-a218-9fa40ef69333""}) ;=> ""c11902f0-21b6-4645-a218-9fa40ef69333""  (silk/match (silk/cat ""user-"" (silk/int :id)) ""user-42"") ;=> {:id 42} (silk/unmatch (silk/cat ""user-"" (silk/int :id)) {:id 42}) ;=> ""user-42""  (silk/match (silk/? :this {:this ""that""}) ""foo"") ;=> {:this ""foo""} (silk/match (silk/? :this {:this ""that""}) nil) ;=> {:this ""that""} Patterns can be data structures. (silk/match [""users"" (silk/int :id)] [""users"" ""42""]) ;=> {:id 42} A route can be created with a 2-tuple. The first element is a route name and the second element is something that can be turned into a URL pattern. If the second element is a vector, the first and second elements are associated into the third element under :path and :query keys respectively. If the second element is a map, it is left unchanged. (silk/url-pattern [[""users"" ""list""] {""filter"" :filter ""limit"" :limit} {:scheme ""https""}]) ;=> {:path [""users"" ""list""], :query {""filter"" :filter, ""limit"" :limit}, :scheme ""https""}  (silk/url-pattern {:path [""users"" ""list""] :query {""filter"" :filter ""limit"" :limit} :scheme ""https""}) ;=> {:path [""users"" ""list""], :query {""filter"" :filter, ""limit"" :limit}, :scheme ""https""}  (silk/route [:route-name [[""users"" ""list""] {""filter"" :filter ""limit"" :limit} {:scheme ""https""}]]) ;=> #<Route domkm.silk.Route@6ebe4324> Routes are patterns. (silk/match (silk/route [:route-name [[""users"" :username]]]) {:path [""users"" ""domkm""]}) ;=> {:username ""domkm"", :domkm.silk/name :route-name, :domkm.silk/pattern {:path [""users"" :username]}} (silk/unmatch (silk/route [:route-name [[""users"" :username]]]) {:username ""domkm""}) ;=> #domkm.silk.URL{:scheme nil, :user nil, :host nil, :port nil, :path [""users"" ""domkm""], :query nil, :fragment nil} None of that is particularly useful unless you can match and unmatch route collections. Fortunately, a collection of routes is also a pattern. (def user-routes   (silk/routes [[:users-index [[""users""]]]                 [:users-show [[""users"" (silk/int :id)]]]]))  (silk/match user-routes {:path [""users"" ""42""]}) ;=> {:id 42, :domkm.silk/name :users-show, :domkm.silk/routes #<Routes domkm.silk.Routes@c6f8bbc>, ...} (silk/unmatch user-routes {:id 42 :domkm.silk/name :users-show}) ;=> #domkm.silk.URL{:scheme nil, :user nil, :host nil, :port nil, :path [""users"" ""42""], :query nil, :fragment nil} If you don't care about the match order, you can create routes with a map. (def page-routes   (silk/routes {:home-page [[]] ; match ""/""                 :other-page [[""pages"" :title]]})) Routes can be constrained by request methods. (def api-routes   (silk/routes {:api-data [[""api""] {""limit"" (silk/? (silk/int :limit) {:limit 100})                                     ""offset"" (silk/? (silk/int :offset) {:offset 0})} (serve/POST)]}))   (silk/match api-routes {:path [""api""]}) ;=> nil (silk/match api-routes {:path [""api""] :request-method :post}) ;=> {:limit 100, :offset 0, :domkm.silk/name :api-data, ...} Routes can be combined. (def all-routes   (silk/routes [user-routes                 page-routes                 [:comments [[""comments""] {""id"" (silk/uuid :id)}]]                 api-routes])) All matching and unmatching is pure and bidirectional. Matching and unmatching patterns is powerful and pure but quite verbose. Silk provides a higher-level interface via domkm.silk/arrive and domkm.silk/depart (silk/arrive all-routes ""/pages/about"") ;=> {:title ""about"", :domkm.silk/name :other-page, ...} You can also provide a handler function. (silk/arrive all-routes ""/pages/about"" :title) ;=> ""about"" Unmatching is almost as easy. (silk/depart all-routes :other-page {:title ""about""}) ;=> ""/pages/about"" As with domkm.silk/arrive, you can provide a handler function. (silk/depart all-routes :other-page {:title ""about""} clojure.string/upper-case) ;=> ""/PAGES/ABOUT"" Go forth and route! Status Silk is very much a work-in-progress. Everything is subject to change. If you have suggestions, please do share them. License Copyright © 2014 Dom Kiva-Meyer Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/DomKM/silk"	"– An isomorphic routing library for Clojure & ClojureScript."	"true"
"State Management"	"hodgepodge"	"http://funcool.github.io/hodgepodge/"	"– A idiomatic ClojureScript interface to HTML5 Storage."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"hodgepodge hodgepodge Table of Contents 1. Rationale 1.1. Alternatives 2. Installation 3. Storages 4. Low-level API 5. Transient storage 5.1. Storing and retrieving custom data types 6. License A idiomatic ClojureScript interface to HTML5 Storage. 1. Rationale This library is intended as a thin wrapper around the browser’s storage API for making it more Clojurey. Furthermore, it extends the Storage type for treating storage like a transient map for inserting and retrieving ClojureScript data structures. The serialization is done via pr-str and it uses the reader for deserializing strings into ClojureScript or JavaScript data structures. 1.1. Alternatives storage-atom provides an atom backed by local or session storage: https://github.com/alandipert/storage-atom plato incrementally persist atom state to local storage: https://github.com/eneroth/plato 2. Installation The simplest way to use hodgepodge in a Clojure project is by including it as a dependency in your project.clj: [hodgepodge ""0.1.3""] 3. Storages At the moment hodgepodge supports local and session storage. (require '[hodgepodge.core :refer [local-storage                                    session-storage]]) 4. Low-level API hodgepodge has an API that mimics that of web storage, which can be used for writing and reading raw strings. (require '[hodgepodge.core :refer [local-storage                                    get-item                                    set-item                                    remove-item                                    clear!                                    length]])  (clear! local-storage)  (length local-storage) ;; => 0  (set-item local-storage ""foo"" ""bar"") (length local-storage) ;; => 1  (get-item local-storage ""foo"") ;; => ""bar""  (remove-item local-storage ""foo"") (length local-storage) ;; => 0 get-item also supports passing a default argument to return when the given key is missing. (require '[hodgepodge.core :refer [local-storage                                    get-item                                    set-item                                    clear!]])  (clear! local-storage)  (get-item local-storage ""foo"" 42) ;; => 42  (set-item local-storage ""foo"" ""bar"")  (get-item local-storage ""foo"" 42) ;; => ""bar"" 5. Transient storage Besides the low-level, raw-string API, storages implement several ClojureScript core protocols. The keys and values that are inserted in the storage are serialized with pr-str and deserialized with the reader. Storages can be treated as an ITransientAssociative and ITransientMap, thus supporting assoc! and dissoc!. They also implement ICounted so you can use count on them. (require '[hodgepodge.core :refer [local-storage clear!]])  (clear! local-storage) (def val {:bar 42 :timestamp (js/Date.)}) (assoc! local-storage :foo val) (count local-storage) ;; => 1  (dissoc! local-storage :foo) (count local-storage) ;; => 0 The implementation of the ILookup protocol let’s us extract values from the storage. (require '[hodgepodge.core :refer [local-storage clear!]])  (clear! local-storage) (assoc! local-storage :foo {:bar 42}) (:foo local-storage) ;; => {:bar 42}  (dissoc! local-storage :foo) (count local-storage) (get local-storage :foo :missing) ;; => :missing Storage objects can be transformed into persistent data structures calling persistent! on them. (require '[hodgepodge.core :refer [local-storage clear!]])  (clear! local-storage) (assoc! local-storage :foo {:bar 42}) (= (persistent! local-storage)    {:foo {:bar 42}}) ;; => true 5.1. Storing and retrieving custom data types Since storage serialization is done with pr-str, we can make a custom type serializable implementing the cljs.core/IPrintWithWriter protocol and making it output a tagged literal. For a contrived example, let’s implement a Action type which is of a ceratin kind and has a payload associated with it. (deftype Action [kind payload]   IEquiv   (-equiv [_ other]     (and (instance? Action other)          (= kind (.-kind other))          (= payload (.-payload other))))) First, we are going to make its representation a tagged literal. (extend-type Action   IPrintWithWriter   (-pr-writer [a writer _]     (-write writer (str ""#action \""""                          (pr-str {:kind (.-kind a)                                   :payload (.-payload a)})                          ""\""""))))  (enable-console-print!) (print (Action. :write-code {:language :clojurescript})) ; #action ""{:kind :write-code, :payload {:language :clojurescript}}"" Now that our type is serializable we can make it deserializable by writing a function that is able to read its literals and create an instance of Action. After doing this we will extend the reader to be able to read our custom type’s tagged literals. (require '[cljs.reader :as reader])  (defn read-action   [a]   (let [values (reader/read-string a)]     (Action. (:kind values) (:payload values))))  (reader/register-tag-parser! ""action"" read-action) Now we’re able to store and retrieve actions from storages and to use them as keys. (require '[hodgepodge.core :as h])  (def a (Action. :write-code {:language :clojure}))  (assoc! h/local-storage :action a) (assert (= a (:action h/local-storage)))  (assoc! h/local-storage a :action) (assert (= :action (get h/local-storage a))) 6. License Licensed under the BSD 2-clause license. Copyright (c) 2014, Alejandro Gómez. Last updated 2015-01-20 14:36:45 CET"	"null"	"null"	"– A idiomatic ClojureScript interface to HTML5 Storage."	"true"
"State Management"	"plato"	"https://github.com/eneroth/plato"	"– Incrementally persists atom state to Local Storage in ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"24"	"3"	"1"	"GitHub - eneroth/plato: Incrementally persists atom state to Local Storage in ClojureScript Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 24 Fork 1 eneroth/plato Code Issues 1 Pull requests 0 Pulse Graphs Incrementally persists atom state to Local Storage in ClojureScript 59 commits 1 branch 0 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src/plato .gitignore LICENSE README.md project.clj README.md Plato Our object in the construction of the state is the greatest happiness of the whole, and not that of any one class. Plato This is why we should try to keep the state separate from the rest of the code. Purpose The purpose of Plato is to store and restore data to (and from) Local Storage. There are also a couple of quite useful functions for persisting state held within atoms. This library grew out of the need to keep storage of application state separate from the application logic. I noticed that I interspersed my application logic with a lot of storage related function calls. Storage and persistence is arguably orthogonal to application logic, and therefore those functions were extracted and put in a separate library. Plato parses arbitrarily nested hash-maps in atoms and constructs local storage keys from their relative paths. For example, given the base-key (base-keys are explained below) ""myproject"", the hash-map {:a 1 :b {:c 2 :d 3} is stored in local storage as:   Key: ""myproject:a"",   value: ""1""   Key: ""myproject:b:c"", value: ""2""   Key: ""myproject:b:d"", value: ""3""  Due to limitations in the local storage API, everything except hash-maps is stored as strings in the value field, including vectors and so on. Hash-maps are stored in the formatting of the keys, as shown above. Usage Add the following to your project.clj dependencies: [plato ""0.1.12""] Almost all Plato functions take a base-key as the first argument. The reason for this is to make sure that there are no collisions between keys stored in local storage. Make sure you use a different base-key for every atom you intend to persist. If you're only using a single atom, and wish to omit the base-key, you can use partial, like this: (ns myproject.core   (:require [plato.core :as plato]))  (def base-key ""myproject"")  (def store-atom! (partial plato/store-atom! base-key)) Storing and restoring state Two of the main functions in Plato are keep-updated! and restore-atom!. They are used to store and restore the state of an atom, respectively. There are also a number of functions that can be used to store data more manually. In particular, you may need to run store-atom! once before running keep-updated!, if you have state in the atom that is not currently in Local Storage. This is due to the fact that keep-updated! works incrementally, and only will persist the changes made to the atom. Storing state keep-updated! adds a watch to an atom. This watch reacts to changes in the atom and updates Local Storage accordingly. Only those parts that are changed will be updated. The size of the state held in the atom is irrelevant, only the parts that are changed will be written to Local Storage. If large parts of the state held in the atom is changed, then a larger number of writes to Local Storage will take place. (plato/keep-updated! base-key an-atom) If you wish to see when and what it is being written to local storage, you can supply a third argument (being a boolean) to keep-updated! in order to turn on console logging. Use it thusly: (def my-atom (atom {:coords {:x 0                              :y 0}}))  (plato/keep-updated! ""myproject"" my-atom true) keep-updated! will only write to local storage once the atom changes, so if you want to store everything currently in the atom, you have to use store-atom!. Something like this would do, (def my-atom (atom {:coords {:x 0                              :y 0}}))  (def my-base-key ""myproject"")                         (plato/store-atom! my-base-key my-atom)  (plato/keep-updated! my-base-key my-atom true) Restoring state restore-atom! resets the atom to the state stored in Local Storage, given that there is any. (plato/restore-atom! base-key an-atom) For example, (def my-atom (atom {:coords {:x 0                               :y 0}}))  (plato/restore-atom! ""myproject"" my-atom) ;; Will overwrite current atom content Full function list Storing store! (store! base-key path-vector value) Updates a particular key stored in local storage. For example, (store! ""com.example.my-atom"" [:foo :bar] ""Hello World!"") will update the key ""com.example.my-atom:foo:bar"" to have value ""Hello World!"" in local storage. store-many! (store-many! base-key path-vectors) Stores a collection of path vectors in local storage. The path vectors should be on format: [[:a :b :c] 1] For example, (def path-vectors [[[:a] 1]                    [[:b :c] 2]                    [[:b :d] 3]])  (store-many! ""com.example.my-atom"" path-vectors) store-state! (store-state! base-key state) Takes a hash-map and stores it in local storage. For example, (store-state! ""com.example.my-state"" {:a {:b {:c 1}}}) store-atom! (store-atom! base-key an-atom) Stores the contents of an atom (typically a hash-map) in local storage. For example, (store-atom! ""com.example.my-atom"" my-atom) Retrieving and restoring restore (restore base-key path-vector) Get the value associated with the specified base-key from local storage. For example, (restore ""com.example.my-atom"" [:a :b :c]) restore-state (restore-state base-key) Get all localStorage entries beginning with the given base-key. For example, (restore-state ""com.example.my-state"") restore-atom! (restore-atom! base-key an-atom) Get stored state from local storage and reset the given atom with it. For example, (restore-atom! ""com.example.my-atom"" my-atom) Erasing erase! (erase! base-key path-vector) Remove a key and corresponding value from local storage. For example, (erase! ""com.example.my-state"" [:a :b :c]) erase-many! (erase-many! base-key path-vectors) Remove all entries as specified by path vectors, belonging to the given base-key, from local storage. For example, (erase-many! ""com.example.my-atom"" [[:a :b :c]                                      [:d :e]]) erase-all! (erase-all! base-key) Remove all keys belonging to the given base-key from local storage. For example, (erase-all! ""com.example.my-atom"") Maintaining state in sync keep-updated! (keep-updated! base-key an-atom log-update) Updates local storage with all changes made to an atom. Call with true as third arg to switch on logging. For example, (keep-updated! ""com.example.my-atom"" my-atom) (keep-updated! ""com.example.my-atom"" my-atom true) ;; Console logging turned on Example of logging output when logging is turned on, … Updating in localStorage [:coords :x] to 561 Updating in localStorage [:coords :y] to 174, [:coords :x] to 570 …  Diffing diff-states (diff-states old-state new-state) Takes a map representing an old state, and a map representing a new state and returns a vector representing the difference between the two. The first item in the vector details what has been removed and the second what has been added or changed. As opposed to clojure.data/diff, this diffing algorithm considers everything that is not a map to be a value. This is in order to prepare the data for Local Storage, which is just a simple string based key-value store. For example, (diff-states {:a 1                :b {:c 2                    :d [1 2 3]}                :e ""same""                :f ""removed""}               {:a 2                :b {:c 3                    :d [4 5 6]}                :e ""same""}) Outputs: [{:f ""removed""}   {:a 2   :b {:c 3        :d [4 5 6]}}] License Copyright © 2014 Henrik Eneroth Distributed under the Eclipse Public License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/eneroth/plato"	"– Incrementally persists atom state to Local Storage in ClojureScript."	"true"
"State Management"	"storage-atom"	"https://github.com/alandipert/storage-atom"	"– ClojureScript atoms backed by HTML5 web storage."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"126"	"12"	"12"	"GitHub - alandipert/storage-atom: ClojureScript atoms backed by HTML5 web storage. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 12 Star 126 Fork 12 alandipert/storage-atom Code Issues 2 Pull requests 0 Pulse Graphs ClojureScript atoms backed by HTML5 web storage. 51 commits 1 branch 6 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show 2.0.1 2.0.0 1.2.4 1.2.2 1.1.2 1.1.1 Nothing to show New pull request Latest commit 97a8024 Apr 12, 2016 alandipert added type preservation tests, refs #8 Permalink Failed to load latest commit information. src/alandipert Merge pull request #13 from petterik/master Apr 12, 2016 test/alandipert/storage_atom added type preservation tests, refs #8 Apr 12, 2016 .gitignore init Jan 26, 2013 .travis.yml Back to normal Travis builds Oct 20, 2015 README.md 2.0.1 Apr 12, 2016 build.boot 2.0.1 Apr 12, 2016 README.md storage-atom storage-atom is a ClojureScript library that provides an easy way to create atoms backed by HTML5 Web Storage. Any change in the atom will be saved into the web storage. The reverse is also true. This means that an atom modified in a tab or a window will also be modified in all of them. Usage Dependency [alandipert/storage-atom ""1.2.4""] Or, to try the latest version that uses Transit: [alandipert/storage-atom ""2.0.1""] Example ;; Require or use alandipert.storage-atom in your namespace. ;; The primary functions it provides are html-storage and local-storage. ;; It also provides the IStorageBackend protocol.  (ns your-ns   (:require [alandipert.storage-atom :refer [local-storage]]))  ;; Persist atom to HTML localStorage. The local-storage function takes an ;; atom and a key to store with, and returns the atom. If the key in storage ;; isn't set it will be initialized with the value obtained by dereferencing ;; the provided atom. Otherwise the atom's value will be reset! with the value ;; obtained from localStorage. All subsequent swap! and reset! operations on ;; the atom will cause the value in localStorage to be updated.  (def prefs (local-storage (atom {}) :prefs))  ;; You can use the atom normally now - values are transparently persisted.  (add-watch prefs            :new            (fn [_ _ _ v]              (.log js/console ""new preference"" v)))  (swap! prefs assoc :bg-color ""red"")  (:bg-color @prefs) ;=> ""red""  ;; Check that current value has been stored in localStorage.  (.getItem js/localStorage "":prefs"") ;=> ""{:bg-color \""red\""}""  ;; To remove an item or clear all storage, use the provided methods instead ;; of calling the js method. This ensures that affected atoms are updated.  (alandipert.storage-atom/remove-local-storage! :prefs) ;; remove single value (alandipert.storage-atom/clear-local-storage!)         ;; clear all values  ;; Note: clearing a value will reset it to the initial value of the atom passed ;; to `local-storage`, not nil. This is probably what you want. Notes Because web storage keys and values are stored as strings, only values that can be printed readably may be used as storage keys or values. I haven't done any performance testing, but this approach is much slower than using web storage directly because the entire atom contents are written on every swap!. To prevent superfluous writes to the local storage, there is a 10 ms debounce (when a bunch of changes happen quickly, the last value is committed). It can be modified with the storage-delay atom or the *storage-delay* dynamic var. : (reset! alandipert.storage-atom/storage-delay 100) ;; permanently                                                    ;; increase                                                    ;; debounce to 100                                                    ;; ms  (binding [alandipert.storage-atom/*storage-delay* 500]      ... do some stuff ... ) ;; temporarily increase debounce to                                  ;; 500 ms  enduro is a Clojure library that provides similar functionality by using files or a database for storage. The cross-window propagation doesn't always work if browsing the .html directly instead of passing throught a webserver. (Yes Chrome, I'm looking at you...) Testing PhantomJS 1.7.0 is used for unit testing. With it installed, you can run the tests like so: boot test-cljs  License Copyright © Alan Dipert & Contributors Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/alandipert/storage-atom"	"– ClojureScript atoms backed by HTML5 web storage."	"true"
"State Management"	"Waltz"	"https://github.com/ibdknox/waltz"	"– A ClojureScript library that helps manage state in client-side applications using non-deterministic finite state machines."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"94"	"1"	"12"	"GitHub - ibdknox/waltz: A ClojureScript library for keeping your state in step Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 1 Star 94 Fork 12 ibdknox/waltz Code Issues 0 Pull requests 3 Pulse Graphs A ClojureScript library for keeping your state in step 8 commits 1 branch 0 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src/waltz test/waltz .gitignore README.md project.clj README.md waltz Waltz is a ClojureScript library that helps manage state in client-side applications using non-deterministic finite state machines. Usage Here's an example using waltz, crate, jayq, and fetch: (ns metrics.client.main   (:require [waltz.state :as state]             [crate.core :as crate]             [fetch.lazy-store :as store])   (:use [jayq.core :only [append $ find show hide inner add-class remove-class]]         [waltz.state :only [trigger]])   (:use-macros [waltz.macros :only [in out defstate defevent]]                [crate.macros :only [defpartial]]))  (defn wait [ms func]   (js* ""setTimeout(~{func}, ~{ms})""))  (def $container ($ :#metricsContainer))  (defpartial metric [{:keys [klass label]}]   [:div {:class (str ""metric "" klass)}    [:p.loading ""Loading...""]    [:h1.value ""...""]    [:h2 label]])  (defn add-metric [params]   (let [$elem ($ (metric params))         $loading (find $elem :.loading)         $value (find $elem :.value)         delay (or (:delay params) 10000)         me (state/machine (:label params))]      (defstate me :loading       (in [] (show $loading))       (out [] (hide $loading)))      (defstate me :normal       (in [v]         (inner $value v)         (wait delay #(trigger me :update))))      (defevent me :update []       (state/set me :loading)       (store/latest [:metrics (:metric params)]                     #(trigger me :set %)))      (defevent me :set [v]       (state/unset me :loading)       (state/set me :normal v))      (trigger me :update)      (append $container $elem)     me))  (add-metric {:label ""Views today"" :klass ""gray""}) (add-metric {:label ""Signups today"" :delay 30000 :klass ""gray""}) (add-metric {:label ""Signups today"" :delay 30000 :klass ""gray""}) (add-metric {:label ""Signups today"" :delay 30000 :klass ""gray""}) (add-metric {:label ""Signups today"" :delay 30000 :klass ""gray big""}) (add-metric {:label ""Signups today"" :delay 30000 :klass ""gray big""}) License Copyright (C) 2011 Chris Granger Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/ibdknox/waltz"	"– A ClojureScript library that helps manage state in client-side applications using non-deterministic finite state machines."	"true"
"Testing"	"clojurescript.test"	"https://github.com/cemerick/clojurescript.test"	"– A maximal port of clojure.test to ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"172"	"8"	"33"	"GitHub - cemerick/clojurescript.test: A maximal port of `clojure.test` to ClojureScript. DEPRECATED Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 8 Star 172 Fork 33 cemerick/clojurescript.test Code Issues 0 Pull requests 1 Pulse Graphs A maximal port of `clojure.test` to ClojureScript. DEPRECATED 159 commits 3 branches 12 releases Fetching contributors Clojure 75.5% HTML 15.3% JavaScript 9.2% Clojure HTML JavaScript Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags develop/0.2.0 develop/0.3.x master Nothing to show 0.3.3 0.3.2 0.3.1 0.3.0 0.2.3 0.2.2 0.2.1 0.2.0 0.0.4 0.0.3 0.0.2 0.0.1 Nothing to show New pull request Latest commit e8f42c2 Sep 15, 2015 cemerick deprecated … everyone should go use cljs.test + https://github.com/bensu/doo instead Permalink Failed to load latest commit information. resources/cemerick/cljs/test issue useful warning if source file to be loaded doesn't exist Dec 13, 2014 src print helpful error message when `is` is used without a test context,… Dec 16, 2014 test/cemerick/cljs/test add test that previously caused errors in cljs 2234 (ref gh-70) Dec 11, 2014 .gitignore Supporting async testing, fixes gh-34: Mar 17, 2014 .travis.yml set up slimerjs in travis Dec 12, 2014 CHANGES.md 0.3.3 Dec 13, 2014 README.md deprecated Sep 15, 2015 epl-v10.html add EPL Feb 27, 2013 project.clj 0.3.4-SNAPSHOT Dec 16, 2014 README.md clojurescript.test DEPRECATED I strongly suggest migrating to use the official core cljs.test + https://github.com/bensu/doo for test-runners and leiningen/boot integration. Thanks to all contributors for helping make testing ClojureScript workable until those tools arrived/matured! A maximal port of clojure.test to ClojureScript. Why? I want to be able to write portable tests to go along with my portable Clojure[Script], and clojure.test's model is Good Enough™ (it's better than that, actually). Combine with something like cljx to make your ClojureScripting a whole lot more pleasant. Installation clojurescript.test is available in Maven Central. Add it to your :plugins in your Leiningen project.clj: [com.cemerick/clojurescript.test ""0.3.3""] (clojurescript.test is actually a project dependency and a Leiningen plugin; adding it as the latter just helps simplify test configuration, as you see below.) Or, add this to your Maven project's pom.xml: <dependency>   <groupId>com.cemerick</groupId>   <artifactId>clojurescript.test</artifactId>   <version>0.3.3</version> </dependency> Usage clojurescript.test provides roughly the same API as clojure.test, thus making writing portable tests possible. (Note that clojurescript.test doesn't take any responsibility for any hosty or otherwise-unportable things you do in your tests, e.g. js/... or naming JVM types or Clojure- or ClojureScript-only functions; either don't do that, or use something like cljx to include both Clojure and ClojureScript code in the same file.) Here's a simple ClojureScript namespace that uses clojurescript.test: (ns cemerick.cljs.test.example   (:require-macros [cemerick.cljs.test                     :refer (is deftest with-test run-tests testing test-var)])   (:require [cemerick.cljs.test :as t]))  (deftest somewhat-less-wat   (is (= ""{}[]"" (+ {} []))))  (deftest javascript-allows-div0   (is (= js/Infinity (/ 1 0) (/ (int 1) (int 0)))))  (with-test   (defn pennies->dollar-string     [pennies]     {:pre [(integer? pennies)]}     (str ""$"" (int (/ pennies 100)) ""."" (mod pennies 100)))   (testing ""assertions are nice""     (is (thrown-with-msg? js/Error #""integer?"" (pennies->dollar-string 564.2))))) Note: each test namespace in your project must (:require cemerick.cljs.test) even if you only use macros. Otherwise, the ClojureScript compilation process won't include clojurescript.test in its output, resulting in an error similar to ""ReferenceError: Can't find variable: cemerick"". You can load this into a ClojureScript REPL, and run its tests using familiar functions: => (t/test-ns 'cemerick.cljs.test.example)  Testing cemerick.cljs.test.example {:fail 0, :pass 3, :test 3, :error 0}  => (test-var #'cemerick.cljs.test.example/somewhat-less-wat) {:fail 0, :pass 1, :test 1, :error 0} All of the test-definition macros (deftest and with-test, as well as the set-test utility) add to a global registry of available tests (necessary given ClojureScript's lack of namespaces), so you can also define, redefine, and run tests interactively: => (deftest dumb-test      (is (empty? (filter even? (range 20))))) #<[object Object]> nil => (t/test-ns 'cemerick.cljs.test.example)  Testing cemerick.cljs.test.example  FAIL in (dumb-test) (:0) expected: (empty? (filter even? (range 20)))   actual: (not (empty? (0 2 4 6 8 10 12 14 16 18))) {:fail 1, :pass 3, :test 4, :error 0} Writing portable tests Because clojurescript.test has (approximately) the same API as clojure.test, writing portable tests with it is easy. For example, the test namespace above can be made portable using cljx like so: (ns cemerick.cljs.test.example   #+clj (:require [clojure.test :as t                    :refer (is deftest with-test run-tests testing)])   #+cljs (:require-macros [cemerick.cljs.test                            :refer (is deftest with-test run-tests testing test-var)])   #+cljs (:require [cemerick.cljs.test :as t]))  #+cljs (deftest somewhat-less-wat   (is (= ""{}[]"" (+ {} []))))  #+cljs (deftest javascript-allows-div0   (is (= js/Infinity (/ 1 0) (/ (int 1) (int 0)))))  (with-test   (defn pennies->dollar-string     [pennies]     {:pre [(integer? pennies)]}     (str ""$"" (int (/ pennies 100)) ""."" (mod pennies 100)))   (testing ""assertions are nice""     (is (thrown-with-msg? #+cljs js/Error #+clj Error #""integer?""           (pennies->dollar-string 564.2))))) Note that test-var is a macro in clojurescript.test; this allows you to portably write code like (test-var #'name-of-test), even though ClojureScript doesn't support #' or the (var ...) special form. test-var forms macroexpand to calls to cemerick.cljs.test/test-function, which is the corollary to clojure.test's test-var. Using with lein-cljsbuild Most people use lein-cljsbuild to automate their ClojureScript builds. Using clojurescript.test within that context is easy. Here is an excerpt of the lein-cljsbuild configuration that this project uses to run its own clojurescript.test tests (look in the project.clj file for examples using phantomjs, slimerjs, node, and rhino): :plugins [[lein-cljsbuild ""1.0.0""]           [com.cemerick/clojurescript.test ""0.2.3""]] :cljsbuild {:builds [{:source-paths [""src"" ""test""]                       :compiler {:output-to ""target/cljs/testable.js""                                  :optimizations :whitespace                                  :pretty-print true}}]             :test-commands {""unit-tests"" [""phantomjs"" :runner                                           ""this.literal_js_was_evaluated=true""                                           ""target/cljs/testable.js""                                           ""test/cemerick/cljs/test/extra_test_command_file.js""]}} (Note that the extra_command_file.js reference and literal_js_was_evaluated expression are examples, and not necessary for your usage. Please continue reading below.) Everything here is fairly basic, except for the :test-commands entries, which describes the shell command that will be executed when lein-cljsbuild's test phase is invoked (either via lein cljsbuild test, or just lein test because its hook is registered). In this case, it's going to run phantomjs, passing as arguments: The path to the clojurescript.test test runner script (denoted by :runner, which I'll explain momentarily…), and Either paths to ClojureScript compiler output (a lein-cljsbuild :output-to value defined elsewhere in the project.clj), or paths to other arbitrary JavaScript files (useful for injecting external libraries, polyfills, etc), or arbitrary JavaScript expressions (useful for e.g. configuring runtime test properties...see the subsection below on using this capability, especially in conjunction with advanced compilation). clojurescript.test bundles test runner scripts for various environments (currently, phantomjs and slimerjs, node.js, and rhino). As long as you add clojurescript.test to your project.clj as a :plugin, then it will replace any occurrences of :runner, :node-runner and :rhino-runner in your :test-commands vectors with the path to the corresponding test runner script. Outside of the :test-commands vector in your :cljsbuild configuration, clojurescript.test will replace namespaced corollaries to these test runner keywords (:cljs.test/runner, :cljs.test/node-runner, and :cljs.test/rhino-runner). This allows you to have paths to clojurescript.test runner scripts injected anywhere into your project.clj you like. SlimerJS and PhantomJS Though the :runner test runner is compatible with both of these scriptable browser environments, SlimerJS is currently recommended because: It can use effectively any version of Firefox / XULRunner (PhantomJS has been stuck on a very old version of webkit for years now), and so effectively all of the ""modern"" browser/web platform APIs are available to test. It is reasonably fast (faster than phantomjs, though still ~40% slower than node) It can easily be run headlessly, via xvfb In general, you should download and use the latest ""lightweight"" slimerjs build. Check out the SlimerJS :test-commands in project.clj for examples of how to best use xvfb and slimerjs together, and look at .travis.yml for an example of how to arrange your TravisCI configuration such that both of these tools are available there (analogous configuration can be applied in any other CI or automated environment of your choice). Node.js To run your tests with node.js instead of phantomjs, just change the executable name and the :runner keyword in your :test-commands vectors like so: :test-commands {""unit-tests"" [""node"" :node-runner                               ; extra code/files here...                              ]}  Note that you must compile your ClojureScript code with :advanced or :simple `:optimizations to run it on node.js. Rhino To run your tests with rhino, change the executable name and the :runner keyword in your :test-commands vectors like so: :test-commands {""unit-tests"" [""rhino"" ""-opt"" ""-1"" :rhino-runner                               ; extra code/files here...                              ]}  Note that rhino doesn't support any HTML or DOM related functions and objects so it can be used mainly for business-only logic or you have to mock all DOM functions by yourself. All test runner scripts load the output of the ClojureScript compilation, run all of the tests found therein, reports on them, and fails the build if necessary. clojurescript.test supports all of Google Closure's compilation modes, including :advanced, but it does NOT support :none cljsbuild optimization option. Configuring tests via JavaScript files/expressions in :test-commands As noted above, you can have arbitrary JavaScript files and/or expressions loaded before or after your compiled ClojureScript. One of the most useful aspects of this is that you can configure properties of your tests; for example, when using double-check, you can control the number of iterations checked by each defspec test by setting a Java system property. While JavaScript doesn't have a corollary of system properties, you can add a JavaScript expression to your :test-commands vector(s) that sets a property on some globally-accessible object, e.g.: :test-commands {""rigorous"" [""phantomjs"" :runner                             ""this.defspec_iters=10000000""                             ""target/cljs/testable.js""]} Then, in your ClojureScript test file(s), you can look up this dynamically-set value, using a default if it's not set: (def iteration-count (or (this-as this (aget this ""defspec_iters"")) 1000)) The use of aget and a string property lookup is necessary to ensure that the property name will not be renamed/obfuscated by Google Closure when run with :advanced optimizations. Prior examples of this practice touched window, but that name is undefined in node.js; using this when setting and looking up the test configuration value makes it so that the same code (and configuration) can be used in any test environment. Asynchronous testing Problem: various operations in JavaScript are necessarily asynchronous, from things as simple as DOM event callbacks to more involved activity like querying or modifying IndexedDB databases or interacting with core.async channels. This means that the testing ""context"" may have moved on (and your JavaScript environment's execution may have completed entirely) before your callbacks/go blocks/etc have fired/completed…a big problem if those asynchronous constructs contained assertions. Starting with version 0.3.0, clojurescript.test provides ways to explicitly control when each test is complete. First, an example of a test that will not perform the intended (asynchronous) assertion: (ns async-example   (:require-macros [cemerick.cljs.test :refer (is deftest)])   (:require [cemerick.cljs.test :as t]))  (deftest timeout   (let [now #(.getTime (js/Date.))         t (now)]     (js/setTimeout       (fn [] (is (>= (now) (+ t 2000))))       2000))) In the best case, the is assertion's results will be attributed to some other test; in the worst case, the JavaScript environment will have exited before the setTimeout callback is scheduled to be invoked, and the asynchronous assertion will never be run at all. Modifying this example as follows will yield useful/correct behaviour: Add ^:async metadata to the deftest name. You must call (done) using the asynchronous deftest's testing context in order for that test to finish, and cause the next test in the current run to start. (ns async-example   (:require-macros [cemerick.cljs.test :refer (is deftest done)])   (:require [cemerick.cljs.test :as t]))  (deftest ^:async timeout   (let [now #(.getTime (js/Date.))         t (now)]     (js/setTimeout       (fn []         (is (>= (now) (+ t 2000)))         (done))       2000))) Compared to the first example: This test will be run after any synchronous tests in the same namespace that are included in the current test run. Control exiting the lexical scope of deftest will have no effect upon the wider test run (compared to synchronous tests, the ""completion"" of which cause the next test in a run to be started). When the setTimeout callback is invoked, the assertion therein will be run, and properly attributed to the timeout test. The (done) call will close the timeout test context, and start the next test in the run. Note that you have complete control over when a test is done; the setTimeout callback above could just as well spin off another setTimeout call (or use any other callback-based API), or send or block on a core.async channel, etc. If you don't explicitly close a test's context via (done), the clojurescript.test test runner will never move on to the next test, and your test run will be permanently stalled. You can unwedge yourself from this situation at the REPL in a couple of different ways, see ""Canceling asynchronous tests"". The rest of this section will dig into the finer details of using the asynchronous testing facilities. Test contexts Each test defined by clojurescript.test carries its own test context. This is defined implicitly by deftest and other test-creation macros. The body of each test is also wrapped within a cemerick.cljs.test/with-test-ctx form. This macro does a couple of things: It implicitly binds the test context provided to it to -test-ctx within its scope. If the test context is asynchronous (i.e. the corresponding deftest was marked with ^:async metadata), then with-test-ctx will wrap any containing body of code with a try/catch form that will call (done) with any error thrown in the course of the body's execution. This ensures that the test context associated with an asynchronous test that fails with an exception is automatically closed, starting the next test. The is assertion macro will pick up the anaphoric -test-ctx binding automatically when provided with one or two arguments (the form to evaluate/test, and an optional message). Alternatively, you can explicitly pass a test context to is. Putting this all together allows you to define asynchronous tests that use common functions that contain asynchronous processing and/or assertions, passing the test context around explicitly in order to properly tie test results to the ""source"" tests. For example, here's the example from before, refactored to put the asynchronous call and assertion in a helper function: (ns async-example   (:require-macros [cemerick.cljs.test :refer (is deftest done with-test-ctx)])   (:require [cemerick.cljs.test :as t]))  (defn- timeout-helper   [test-context delay]   (with-test-ctx test-context     (let [now #(.getTime (js/Date.))         t (now)]       (js/setTimeout         (fn []           (is (>= (now) (+ t delay)))           (done))         delay))))  (deftest ^:async timeout   (timeout-helper 2000)) Because is and done are within with-test-ctx's lexical scope, they'll pick up the implicit test context binding automatically. Alternatively, you could write timeout-helper like so, always passing the test context explicitly: (defn- timeout-helper   [test-context delay]   (let [now #(.getTime (js/Date.))         t (now)]     (js/setTimeout       (fn []         (is test-context (>= (now) (+ t delay))           ""an assertion message is required when explicitly passing test context to `is`"")         (done test-context))       delay))) A final variation is to establish the -test-ctx binding that is and done look for yourself: (defn- timeout-helper   [-test-ctx delay]   (let [now #(.getTime (js/Date.))         t (now)]     (js/setTimeout       (fn []         (is (>= (now) (+ t delay)))         (done))       delay))) This is somewhat less verbose than other options, but necessitates very careful naming of -test-ctx (if you call done or done* without a test context, you'll have a bad time), and does not provide the asynchronous error-handling benefits of with-test-ctx. Reporting errors with-test-ctx will automatically catch and report errors that occur in asynchronous tests. However, if you're not using with-test-ctx, or want/need to catch certain errors manually, you can report them via the done macro (e.g. (done error)) if you are nevertheless within a with-test-ctx body, or via the done* function (e.g. (done* test-context error)). As with any other done invocation, this will close the test context and start the next test in the run. core.async You can use all of the facilities described here to test core.async code just as you would test callback-based APIs of all sorts. Under the covers, the asynchrony provided by core.async in ClojureScript is also mediated by callbacks, so all the same semantics apply: declare your tests to be asynchronous via the ^:async metadata, and be sure to call (done) one way or the other when each test's context should be closed. Here's an example of core.async (and a profligate use of go blocks) used in conjunction with clojurescript.test, pulled from clojurescript.test's own test suite: (deftest ^:async core-async-test   (let [inputs (repeatedly 10000 #(go 1))]     (go (is (= 10000 (<! (reduce                            (fn [sum in]                              (go (+ (<! sum) (<! in))))                            inputs))))       (done)))) Portably testing core.async code with clojurescript.test and clojure.test Clojure's clojure.test does not provide any control over test lifecycle to accommodate assertions being performed in asynchronously-executed code paths, i.e. there is no done to call when we want a test to be considered complete. To work around this, clojurescript.test includes cemerick.cljs.test/block-or-done macro, which enables one to test code that uses the only Clojure/ClojureScript portable asynchrony option, core.async. In Clojure, block-or-done will block the completion of the enclosing clojure.test deftest until the provided channel is yields a value; in ClojureScript, block-or-done will call (done) when the provided channel yields a value. This allows us to write the above core.async-using test in a portable way, that will work on either Clojure or ClojureScript: (deftest ^:async pointless-counting   (let [inputs (repeatedly 10000 #(go 1))         complete (async/chan)]     (go (is (= 10000 (<! (reduce                            (fn [sum in]                              (go (+ (<! sum) (<! in))))                            inputs))))         (>! complete true))      (block-or-done complete))) Canceling asynchronous tests Every function or macro that starts a clojurescript.test test run (e.g. run-tests, test-ns, etc) will return a map of the test environment that summarizes the results of the synchronous tests included in that run. Within that environment's map is an :async entry, the value of which is an atom containing another test environment, dedicated to the asynchronous portion of the test run. In ClojureScript If you run a set of tests which appear to have wedged on the asynchronous portion (perhaps because one of your tests failed to close its testing context via (done) or (done* ...), or maybe a bug is causing a test run to carry on longer than desired), you can cancel the further processing of the test run by calling (cemerick.cljs.test/stop ...), passing the value of the :async slot of the top-level test environment described above. This will not cancel any outstanding asynchronous processing your tests have provoked in the JavaScript environment (e.g. callbacks, pending core.async puts or takes, etc), but it will stop the test run corresponding to the test environment from continuing if and when the wedged asynchronous test does close its testing context. In Clojure Assuming your asynchronous tests are using block-or-done (discussed above), test running functions and macros will block until all tests are complete. If you suspect those tests will not complete, the only solution to this is to interrupt the blocked REPL evaluation, supported by various nREPL clients and tools. Limitations Bug: filenames and line numbers are not currently reported properly. Differences from clojure.test TODO the differences noted here are out of date, and do not account for the additional differences (esp. w.r.t. the test runtime maintenance bits) introduced by supporting asynchronous testing starting in 0.3.0. docstrings bear little to no semblence to the library's actual operation Namespace test hooks must be defined using the deftesthook macro Runtime *report-counters* is now bound to an atom, not a ref *testing-vars* now holds symbols naming the top-levels under test, not vars *test-out* is replaced by *test-print-fn*, which defaults to nil, and is only bound to cljs.core/*print-fn* if it is bound to a non-nil value. run-tests is now a macro; run-tests* does the same, but does not offer a no-arg arity use-fixtures is now a macro, and there is no underlying multimethod to extend as in clojure.test. Errors Stack traces from caught exceptions are obtained via Error.stack, which appears to only be supported in Chrome, FF, Safari, and IE 10+. The value of Error.stack in Rhino (at least, the version specified for use by ClojureScript) is always an empty string; other JavaScript environments may be similar. File and line numbers of reported exception failures may be missing in JavaScript environments that do not support the lineNumber or fileName properties of Error. Removed *load-tests* is now private, and will probably be removed. The use case for Clojure (which is rarely taken advantage of AFAICT) seems irrelevant for ClojureScript; if you do or don't want tests in production, you just change your cljsc/lein-cljsbuild configuration. file-position was already deprecated and unused Not applicable get-possibly-unbound-var function? *stack-trace-depth* Need Help? Send a message to the ClojureScript mailing list, or ping cemerick on freenode irc or twitter if you have questions or would like to contribute patches. License Copyright © 2013-* Chas Emerick and other contributors. Known contributors to clojure.test (which was the initial raw ingredient for this project) at the time of this project's inception were: Stuart Sierra Rich Hickey Stuart Halloway Phil Hagelberg Tassilo Horn Mike Hinchey Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/cemerick/clojurescript.test"	"– A maximal port of clojure.test to ClojureScript."	"true"
"Testing"	"Expectations"	"http://jayfields.com/expectations/"	"– A minimalist's unit testing framework."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"308"	"10"	"21"	"GitHub - jaycfields/expectations: a minimalist's unit testing framework Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 10 Star 308 Fork 21 jaycfields/expectations Code Issues 2 Pull requests 0 Pulse Graphs a minimalist's unit testing framework http://jaycfields.github.com/expectations/ 558 commits 2 branches 9 releases Fetching contributors Clojure 95.5% Java 4.0% Other 0.5% Clojure Java Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show 2.1.1 2.1.0 2.0.16 2.0.16-SNAPSHOT 2.0.13 2.0.12 2.0.11 2.0.10 2.0.9 Nothing to show New pull request Latest commit f81af96 Jul 8, 2016 Jay Version 2.1.10-SNAPSHOT Permalink Failed to load latest commit information. scripts cljx wip Feb 23, 2015 src Fix #80 by allowing predicates on exceptions Jul 7, 2016 test Add a `more-of` test for exceptions for #81 Jul 7, 2016 .gitignore .gitignore /*-init.clj Feb 23, 2015 CHANGELOG.md update changelog Nov 15, 2015 README.md moar Jan 25, 2015 package.fig kill erajure Feb 18, 2014 project.clj Version 2.1.10-SNAPSHOT Jul 8, 2016 README.md expectations visit the expectations website for all of the expectation docs. http://jayfields.com/expectations/ donate Donate Bitcoins Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/jaycfields/expectations"	"– A minimalist's unit testing framework."	"true"
"Testing"	"Speclj"	"https://github.com/slagyr/speclj"	"– A TDD/BDD framework for Clojure and ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"337"	"18"	"51"	"GitHub - slagyr/speclj: pronounced ""speckle"": a TDD/BDD framework for Clojure. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 18 Star 337 Fork 51 slagyr/speclj Code Issues 24 Pull requests 3 Wiki Pulse Graphs pronounced ""speckle"": a TDD/BDD framework for Clojure. 427 commits 9 branches 38 releases Fetching contributors Clojure 96.4% JavaScript 1.7% HTML 1.4% Other 0.5% Clojure JavaScript HTML Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags 1_3_declare_first 1_3_with_raw_data 117-around-safety async clj17 cljs clojure_1_3 gh-pages master Nothing to show 3.3.2 3.3.0 3.2.0 3.1.0 3.0.2 3.0.1 2.9.1 2.9.0 2.8.1 2.8.0 2.7.4 2.7.3 2.7.2 2.7.1 2.7.0 2.6.1 2.5.0 2.4.0 2.3.1 2.3.0 2.2.0 2.1.3 2.1.2 2.1.1 2.1.0 2.0.1 2.0.0 1.5.3 1.5.2 1.5.1 1.5.0 1.4.0 1.3.1 1.3.0 1.2 1.1.0 1.0.3 1.0.2 Nothing to show New pull request Latest commit a549329 Apr 7, 2016 slagyr Merge pull request #155 from reup-distribution/bugs/throwable-type … Correctly check throwable type Permalink Failed to load latest commit information. bin WORKING with reader conditionals. no more cljsbuild or cljx. Jun 19, 2015 dev/speclj/dev mergins clj17 Jun 19, 2015 examples removed example/project. was a silly idea. Mar 9, 2015 spec/speclj working on new release... got one cljs error to figure out Apr 7, 2016 src Correctly check throwable type Apr 7, 2016 .gitignore WORKING with reader conditionals. no more cljsbuild or cljx. Jun 19, 2015 .travis.yml updates projects.clj and travis config Feb 26, 2014 CHANGES.md working on new release... got one cljs error to figure out Apr 7, 2016 LICENSE updating copyright Feb 26, 2014 README.md adds note about requiring Clojure 1.7 Jun 22, 2015 TODO.md adds should-not-contain and documents it along with should-contain Dec 5, 2012 project.clj working on new release... got one cljs error to figure out Apr 7, 2016 README.md speclj (pronounced ""speckle"" [spek-uhl]) It's a TDD/BDD framework for Clojure and Clojurescript, based on RSpec. Installation | Clojure | ClojureScript Installation NOTE: Speclj 3.3+ requires Clojure 1.7+. From Scratch lein new speclj YOUR_PROJECT_NAME @trptcolin's speclj template will generate all the files you need. Or, if you're using ClojureScript: lein new specljs YOUR_PROJECT_NAME @ecmendenhall's specljs template will save you lots of time by getting you started with a running Clojure & ClojureScript setup. Using Leiningen (2.0 or later) Include speclj in your :dev profile :dependencies and:plugins. Then change the :test-paths to ""spec"" ; - snip :dependencies [[org.clojure/clojure ""1.6.0""]] :profiles {:dev {:dependencies [[speclj ""3.3.0""]]}} :plugins [[speclj ""3.3.0""]] :test-paths [""spec""] Manual installation Check out the source code: https://github.com/slagyr/speclj Install it: $ lein install Usage API Documentation Start with the speclj.core namespace. That is Speclj's API and it's very unlikely you'll need anything else. Clojure File Structure All your speclj code should go into a directory named spec at the root of your project. Conventionally, the spec directory will mirror the src directory structure except that all the spec files will have the '_spec.clj' postfix. | sample_project |-- project.clj |-- src     |-- sample         |-- core.clj         | (All your other source code) |-- spec     |-- sample         |-- core_spec.clj         | (All your other test code)  A Sample Spec File Checkout this example spec file. It would be located at sample_project/spec/sample/core_spec.clj. Below we'll look at it piece by piece. (ns sample.core-spec   (:require [speclj.core :refer :all]             [sample.core :refer :all]))  (describe ""Truth""    (it ""is true""     (should true))    (it ""is not false""     (should-not false)))  (run-specs) speclj.core namespace Your spec files should :require the speclj.core in it's entirety. It's a clean namespace and you're likely going to use all the definitions within it. Don't forget to pull in the library that you're testing as well (sample.core in this case). (require '[speclj.core :refer :all]) (require '[sample.core :refer :all]) describe describe is the outermost container for specs. It takes a String name and any number of spec components. (describe ""Truth"" ...) it it specifies a characteristic of the subject. This is where assertions go. Be sure to provide good names as the first parameter of it calls. (it ""is true"" ...) should and should-not Assertions. All assertions begin with should. should and should-not are just two of the many assertions available. They both take expressions that they will check for truthy-ness and falsy-ness respectively. (should ...) (should-not ...) run-specs At the very end of the file is an invocation of (run-specs). This will invoke the specs and print a summary. When running a suite of specs, this call is benign. (run-specs) should Variants (Assertions) There are many ways to make assertions. Check out the API Documentation. Take note of everything that starts with should. Spec Components it or characteristics are just one of several spec components allowed in a describe. Others like before, with, around, etc are helpful in keeping your specs clean and dry. The same API Documentation lists the spec component (everything that doesn't start with should). Running Specs With Leiningen Speclj includes a Leiningen task. $ lein spec <OPTIONS> Using lein run Speclj also includes a Clojure main namespace: $ lein run -m speclj.main <OPTIONS> As a Java command And sometimes it's just easier to run a Java command, like from an IDE. $ java -cp <...> speclj.main <OPTIONS> $ java -cp `lein classpath` speclj.main Autotest The -a options invokes the ""vigilant"" auto-runner. This command will run all your specs, and then wait. When you save any test(ed) code, it will run all the affected specs, and wait again. It's HIGHLY recommended. $ lein spec -a Options There are several options for the runners. Use the --help options to see them all. $ lein spec --help :eval-in When using lein spec you can get a little faster startup by adding :speclj-eval-in :leiningen to your project map. It will prevent Leiningen from spinning up another Java process and instead run the specs in Leiningen's process. Use at your own risk. ClojureScript File Structure All your speclj code should go into a a directory named spec at the root of your project. Conventionally, the spec directory will mirror the src directory structure except that all the spec files will have the '_spec.cljs' postfix. | sample_project |-- project.clj |-- bin     |-- speclj.js |-- src     |-- cljs         |-- sample             |-- core.cljs             | (All your other source code) |-- spec     |-- cljs         |-- sample             |-- core_spec.cljs             | (All your other test code)  1. Configure Your project.clj File lein-cljsbuild is a Leiningen plugin that'll get you up and running with ClojureScript. You'll need to add a :cljsbuild configuration map to your project.clj. :plugins [[lein-cljsbuild ""1.0.3""]] :cljsbuild {:builds        {:dev  {:source-paths [""src/cljs"" ""spec/cljs""]                                    :compiler     {:output-to ""path/to/compiled.js""}                                    :notify-command [""phantomjs"" ""bin/speclj"" ""path/to/compiled.js""]}                             :prod {:source-paths  [""src/cljs""]                                    :compiler      {:output-to ""path/to/prod.js""                                                    :optimizations :simple}}}             :test-commands {""test"" [""phantomjs""  ""bin/speclj"" ""path/to/compiled.js""]}} Speclj works by operating on your compiled ClojureScript. The :notify-command will execute the bin/speclj command after your cljs is compiled. The bin/speclj command will use speclj to evaluate your compiled ClojureScript. 2. Create test runner executable Create a file named speclj in your bin directory and copy the code below: #! /usr/bin/env phantomjs  var fs = require(""fs""); var p = require('webpage').create(); var sys = require('system');  p.onConsoleMessage = function (x) {     fs.write(""/dev/stdout"", x, ""w""); };  p.injectJs(phantom.args[0]);  var result = p.evaluate(function () {   speclj.run.standard.armed = true;   return speclj.run.standard.run_specs(      cljs.core.keyword(""color""), true   ); });  phantom.exit(result); A Sample Spec File Checkout this example spec file. It would be located at sample_project/spec/cljs/sample/core_spec.cljs. Below we'll look at it piece by piece. (ns sample.core-spec   (:require-macros [speclj.core :refer [describe it should should-not run-specs]])   (:require [speclj.core]             [sample.core :as my-core]))  (describe ""Truth""    (it ""is true""     (should true))    (it ""is not false""     (should-not false)))  (run-specs) speclj.core namespace You'll need to :require-macros the speclj.core namespace and :refer each speclj test word that you want to use. In the example below, we are using describe, it, should, should-not, and run-spec. Yes, this is unfortunate, but unavoidable. If you wanted to use context you would simply add it to the current :refer collection. For a list of speclj test words go to the API Documentation Your spec files must :require the speclj.core too, even though we don't alias it or refer anything. Don't forget this! It loads all the needed speclj namespaces. Also pull in the library that you're testing (sample.core in this case). As a final note, when requiring your tested namespaces (sample.core in this case), you'll probabaly want to alias it using :as. (:require-macros [speclj.core :refer [describe it should should-not run-specs]) (:require [speclj.core]           [sample.core :as my-core])) Running ClojureScript Specs With Leiningen We defer to cljsbuild to run our test command. $ lein cljsbuild test Bash The command below will start a process that will watch the source files and run specs for any updated files. $ bin/speclj path/to/compiled.js Community API Documentaiton http://micahmartin.com/speclj/ Source code: https://github.com/slagyr/speclj Wiki: https://github.com/slagyr/speclj/wiki Email List: http://groups.google.com/group/speclj Contributing speclj uses Leiningen version 2.0.0 or later. Clone the master branch, build, and run all the tests: $ git clone https://github.com/slagyr/speclj.git $ cd speclj $ lein spec To make sure tests pass ClojureScript too, make sure you have phantomjs installed and then run: lein cljsbuild clean lein cljsbuild once Make patches and submit them along with an issue (see below). Issues Post issues on the speclj github project: https://github.com/slagyr/speclj/issues Compatibility Speclj 2.* requires Clojure 1.4.0+ Clojure 1.3 is not supported by any version of Speclj due to a bug in Clojure 1.3. License Copyright (C) 2010-2014 Micah Martin All Rights Reserved. Distributed under the The MIT License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/slagyr/speclj"	"– A TDD/BDD framework for Clojure and ClojureScript."	"true"
"Testing"	"test.check"	"https://github.com/clojure/test.check"	"– A generative property-based testing tool inspired by QuickCheck."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"641"	"68"	"54"	"GitHub - clojure/test.check: QuickCheck for Clojure Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 68 Star 641 Fork 54 clojure/test.check Code Pull requests 0 Pulse Graphs QuickCheck for Clojure 483 commits 23 branches 39 releases 23 contributors Clojure 99.3% Other 0.7% Clojure Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags CLJS-1594 TCHECK-77 TCHECK-79 bind-plus-pure-equals-fmap choose-reform cljs-namespace-renaming cljs-random-perf feature/deterministic-scheduler-sketch feature/distinct-generators feature/immutable-RNG feature/parallel-testing feature/result-map feature/specs gfredericks/pasted-aes gfredericks/pfprng-no-alloc gfredericks/pfprng gfredericks/prng-comparison gfredericks/user-guide gh-pages master recursive-redux reducers-rose-tree unchunking Nothing to show v0.8.0-alpha v0.7.0 v0.6.2 v0.6.1 v0.6.0 v0.5.9 v0.5.8 v0.5.7 v0.5.6 v0.5.5 v0.5.4 v0.5.3 v0.5.2 v0.5.1 v0.5.0 v0.4.1 v0.4.0 v0.3.0 v0.2.1 v0.2.0 v0.1.0 test.check-0.9.0 test.check-0.8.2 test.check-0.8.1 test.check-0.8.0 test.check-0.8.0-alpha3 test.check-0.8.0-alpha2 test.check-0.8.0-RC3 test.check-0.8.0-RC2 test.check-0.8.0-RC1 test.check-0.8.0-ALPHA test.check-0.7.0 test.check-0.6.2 test.check-0.6.1 test.check-0.6.0 test.check-0.5.9 test.check-0.5.8 test.check-0.5.7 0.0.1 Nothing to show New pull request Latest commit 3968dcf Apr 16, 2016 nberger committed with gfredericks Implement test about report-trial-periodic in cljs … Adds an implementation for the report-trial-periodic tests that instead of trying to do a sleep like the clj version it just does some busy waiting Permalink Failed to load latest commit information. doc Add cheatsheet Nov 12, 2015 resources Rename ""cljs"" in namespaces to ""clojure"" Aug 9, 2015 src Implement test about report-trial-periodic in cljs Jun 6, 2016 .gitignore Don't ignore the doc directory Nov 7, 2015 CHANGELOG.markdown How could I forget gen/let Nov 12, 2015 CONTRIBUTING.md More detailed contribution instructions Mar 4, 2014 Makefile Update Makefile with test.check name change Feb 13, 2014 README.md Add cheatsheet Nov 13, 2015 pom.xml [maven-release-plugin] prepare for next development iteration Nov 12, 2015 project.clj Remove cider-nrepl plugin Jan 13, 2016 README.md test.check test.check is a Clojure property-based testing tool inspired by QuickCheck. The core idea of test.check is that instead of enumerating expected input and output for unit tests, you write properties about your function that should hold true for all inputs. This lets you write concise, powerful tests. test.check used to be called simple-check. Releases and Dependency Information As of version 0.9.0, test.check requires Clojure >= 1.7.0. Please note a breaking change for ClojureScript in the 0.8.* releases. Leiningen [org.clojure/test.check ""0.9.0""] Maven <dependency>   <groupId>org.clojure</groupId>   <artifactId>test.check</artifactId>   <version>0.9.0</version> </dependency> If you'd like to try a SNAPSHOT version, add the sonatype repository to your project. Version numbers test.check version numbers start where simple-check left off: 0.5.7. Documentation API Docs Cheatsheet Generator writing guide Examples (some of these may refer to simple-check): core.matrix byte-streams byte-transforms collection-check Blog posts and videos (some of these may refer to simple-check): Powerful Testing with test.check - Clojure/West -- Slides Check your work - 8th Light Writing simple-check - Reid Draper Generative testing in Clojure - Youtube Using simple-check with Expectations - Curtis Gagliardi Migrating from simple-check See migrating from simple-check. Useful libraries test.chuck collection-check herbert Examples Let's say we're testing a sort function. We want to check that that our sort function is idempotent, that is, applying sort twice should be equivalent to applying it once: (= (sort a) (sort (sort a))). Let's write a quick test to make sure this is the case: (require '[clojure.test.check :as tc]) (require '[clojure.test.check.generators :as gen]) (require '[clojure.test.check.properties :as prop])  (def sort-idempotent-prop   (prop/for-all [v (gen/vector gen/int)]     (= (sort v) (sort (sort v)))))  (tc/quick-check 100 sort-idempotent-prop) ;; => {:result true, :num-tests 100, :seed 1382488326530} In prose, this test reads: for all vectors of integers, v, sorting v is equal to sorting v twice. What happens if our test fails? test.check will try and find 'smaller' inputs that still fail. This process is called shrinking. Let's see it in action: (def prop-sorted-first-less-than-last   (prop/for-all [v (gen/not-empty (gen/vector gen/int))]     (let [s (sort v)]       (< (first s) (last s)))))  (tc/quick-check 100 prop-sorted-first-less-than-last) ;; => {:result false, :failing-size 0, :num-tests 1, :fail [[3]],        :shrunk {:total-nodes-visited 5, :depth 2, :result false,                 :smallest [[0]]}} This test claims that the first element of a sorted vector should be less-than the last. Of course, this isn't true: the test fails with input [3], which gets shrunk down to [0], as seen in the output above. As your test functions require more sophisticated input, shrinking becomes critical to being able to understand exactly why a random test failed. To see how powerful shrinking is, let's come up with a contrived example: a function that fails if it's passed a sequence that contains the number 42: (def prop-no-42   (prop/for-all [v (gen/vector gen/int)]     (not (some #{42} v))))  (tc/quick-check 100 prop-no-42) ;; => {:result false,        :failing-size 45,        :num-tests 46,        :fail [[10 1 28 40 11 -33 42 -42 39 -13 13 -44 -36 11 27 -42 4 21 -39]],        :shrunk {:total-nodes-visited 38,                 :depth 18,                 :result false,                 :smallest [[42]]}} We see that the test failed on a rather large vector, as seen in the :fail key. But then test.check was able to shrink the input down to [42], as seen in the keys [:shrunk :smallest]. To learn more, check out the documentation links. clojure.test Integration The macro clojure.test.check.clojure-test/defspec allows you to succinctly write properties that run under the clojure.test runner, for example: (defspec first-element-is-min-after-sorting ;; the name of the test          100 ;; the number of iterations for test.check to test          (prop/for-all [v (gen/not-empty (gen/vector gen/int))]            (= (apply min v)               (first (sort v))))) ClojureScript ClojureScript support was added in version 0.7.0. The first test.check example needs only minor modifications for ClojureScript: (ns cljs.user   (:require [clojure.test.check :as tc]             [clojure.test.check.generators :as gen]             [clojure.test.check.properties :as prop :include-macros true]))  (def sort-idempotent-prop   (prop/for-all [v (gen/vector gen/int)]     (= (sort v) (sort (sort v)))))  (tc/quick-check 100 sort-idempotent-prop) ;; => {:result true, :num-tests 100, :seed 1382488326530} The remaining examples need no further changes. Integrating with cljs.test is via the clojure.test.check.clojure-test/defspec macro, in the same fashion as integration with clojure.test on the jvm. Release Notes Release notes for each version are available in CHANGELOG.markdown. Remember that prior to version 0.5.7, test.check was called simple-check. See also... Other implementations QC for Haskell The significantly more advanced QC for Erlang Papers QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs Contributing We can not accept pull requests. Please see CONTRIBUTING.md for details. YourKit YourKit is kindly supporting test.check and other open source projects with its full-featured Java Profiler. YourKit, LLC is the creator of innovative and intelligent tools for profiling Java and .NET applications. Take a look at YourKit's leading software products: YourKit Java Profiler and YourKit .NET Profiler License Copyright © 2014 Rich Hickey, Reid Draper and contributors Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/clojure/test.check"	"– A generative property-based testing tool inspired by QuickCheck."	"true"
"Validation"	"Bouncer"	"https://github.com/leonardoborges/bouncer"	"– A validation DSL for Clojure & Clojurescript applications."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"277"	"17"	"25"	"GitHub - leonardoborges/bouncer: A validation DSL for Clojure & Clojurescript applications Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 17 Star 277 Fork 25 leonardoborges/bouncer Code Issues 2 Pull requests 1 Pulse Graphs A validation DSL for Clojure & Clojurescript applications 135 commits 4 branches 17 releases 9 contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master multifield-validation no-macros Nothing to show 1.0.0 0.3.3 0.3.2 0.3.1 0.3.1-beta1 0.3.0 0.3.0-alpha1 0.2.4-alpha1 0.2.3 0.2.3-beta4 0.2.3-beta3 0.2.3-beta2 0.2.3-beta1 0.2.2 0.2.2-RC2 0.2.2-RC1 0.2.1 Nothing to show New pull request Latest commit 8396e00 Dec 21, 2015 leonardoborges Update docs for 1.0.0 Permalink Failed to load latest commit information. docs Update docs for 1.0.0 Dec 21, 2015 src/bouncer All validators are optional by default Oct 24, 2015 test/bouncer All validators are optional by default Oct 24, 2015 .gitignore Ignore .nrepl-port Sep 29, 2013 .travis.yml Added Java8 as travis test target Jan 13, 2015 CHANGELOG.md Prepare 1.0.0 release Dec 21, 2015 README.md Prepare 1.0.0 release Dec 21, 2015 project.clj Prepare 1.0.0 release Dec 21, 2015 README.md bouncer A validation DSL for Clojure & Clojurescript applications Table of Contents Annotated Source Motivation Setup Usage Basic validations Validating nested maps Multiple validation errors Validating collections Validation threading Pre-conditions Validator sets Customization support Custom validators using arbitrary functions Writing validators Validators and arbitrary number of arguments Internationalization and customised error messages Built-in validators Contributing TODO CHANGELOG CONTRIBUTORS License Motivation Check this blog post where I explain in detail the motivation behind this library Setup Stable release: Development release: [bouncer ""1.0.0""] Check out the CHANGELOG to see what's new. Then, require the library: (ns some.ns   (:require [bouncer.core :as b]             [bouncer.validators :as v])) bouncer provides two main validation functions, validate and valid? valid? is a convenience function built on top of validate: (b/valid? {:name nil}     :name v/required)  ;; false validate takes a map and one or more validation forms and returns a vector. The first element in this vector contains a map of the error messages, whereas the second element contains the original map, augmented with the error messages. Let's look at a few examples: Usage Basic validations Below is an example where we're validating that a given map has a value for both the keys :name and :age. (def person {:name ""Leo""})  (b/validate person     :name v/required     :age  v/required)  ;; [{:age (""age must be present"")} ;;  {:name ""Leo"", :bouncer.core/errors {:age (""age must be present"")}}] As you can see, since age is missing, it's listed in the errors map with the appropriate error messages. Error messages can be customized by providing a :message option - e.g: in case you need them internationalized: (b/validate person     :age [[v/required :message ""Idade é um atributo obrigatório""]])  ;; [{:age (""Idade é um atributo obrigatório"")} ;;  {:name ""Leo"", :bouncer.core/errors {:age (""Idade é um atributo obrigatório"")}}] Note the double vector: the inner one wraps a single validation where the first element is the validating function and the rest are options for that validation. the outer vector simply denotes a list of validations to be applied Below is an example of date-time validation. A clj-time formatter may optionally be supplied. (ns some.ns   (:require [bouncer.core :as b]             [bouncer.validators :as v]             [clj-time.format :as f])) ;; cljs-time for clojurescript users  (def person {:name ""Jeb"" :last-login ""2014-10-21 18:00:00""})  (b/validate person     :name v/required     :last-login v/datetime (:mysql f/formatters))  ;; [nil {:name ""Jeb"" :last-login ""2014-10-21 18:00:00""}] Validating nested maps Nested maps can easily be validated as well, using the built-in validators: (def person-1     {:address         {:street nil          :country ""Brazil""          :postcode ""invalid""          :phone ""foobar""}})  (b/validate person-1     [:address :street]   v/required     [:address :postcode] v/number     [:address :phone]    [[v/matches #""^\d+$""]])   ;;[{:address ;;              {:phone (""phone must match the given regex pattern""), ;;               :postcode (""postcode must be a number""), ;;               :street (""street must be present"")}} ;;   {:bouncer.core/errors {:address { ;;                          :phone (""phone must match the given regex pattern""), ;;                          :postcode (""postcode must be a number""), ;;                          :street (""street must be present"")}}, ;;                          :address {:country ""Brazil"", :postcode ""invalid"", :street nil, ;;                          :phone ""foobar""}}] In the example above, the vector of keys is assumed to be the path in an associative structure. Multiple validation errors bouncer features a short circuit mechanism for multiple validations within a single field. For instance, say you're validating a map representing a person and you expect the key :age to be required, a number and also be positive: (b/validate {:age nil}     :age [v/required v/number v/positive])  ;; [{:age (""age must be present"")} {:bouncer.core/errors {:age (""age must be present"")}, :age nil}] As you can see, only the required validator was executed. That's what I meant by the short circuit mechanism. As soon as a validation fails, it exits and returns that error, skipping further validators. However, note this is true within a single map entry. Multiple map entries will have all its messages returned as expected: (b/validate person-1     [:address :street] v/required     [:address :postcode] [v/number v/positive])  ;; [{:address {:postcode (""postcode must be a number""), :street (""street must be present"")}} {:bouncer.core/errors {:address {:postcode (""postcode must be a number""), :street (""street must be present"")}}, :address {:country ""Brazil"", :postcode ""invalid"", :street nil, :phone ""foobar""}}] Also note that if we need multiple validations against any keyword or path, we need only provide them inside a vector, like [v/number v/positive] above. Validating collections Sometimes it's useful to perform simple, ad-hoc checks in collections contained within a map. For that purpose, bouncer provides every. Its usage is similar to the validators seen so far. This time however, the value in the given key/path must be a collection (vector, list etc...) Let's see it in action: (def person-with-pets {:name ""Leo""                        :pets [{:name nil}                               {:name ""Gandalf""}]})  (b/validate person-with-pets           :pets [[v/every #(not (nil? (:name %)))]])  ;;[{:pets (""All items in pets must satisfy the predicate"")} ;; {:name ""Leo"", :pets [{:name nil} {:name ""Gandalf""}], ;; :bouncer.core/errors {:pets (""All items in pets must satisfy the predicate"")}}] All we need to do is provide a predicate function to every. It will be invoked for every item in the collection, making sure they all pass. Validation threading Note that if a map is threaded through multiple validators, bouncer will leave it's errors map untouched and simply add new validation errors to it: (-> {:age ""NaN""}     (b/validate :name v/required)     second     (b/validate :age v/number)     second     ::b/errors)  ;; {:age (""age must be a number""), :name (""name must be present"")} Pre-conditions Validators can take a pre-condition option :pre that causes it to be executed only if the given pre-condition - a truthy function - is met. Consider the following: (b/valid? {:a -1 :b ""X""}            :b [[v/member #{""Y"" ""Z""} :pre (comp pos? :a)]])  ;; true As you can see the value of b is clearly not in the set #{""Y"" ""Z""}, however the whole validation passes because the v/member check states is should only be run if :a is positive. Let's now make it fail: (b/valid? {:a 1 :b ""X""}            :b [[v/member #{""Y"" ""Z""} :pre (comp pos? :a)]])  ;; false Validator sets If you find yourself repeating a set of validators over and over, chances are you will want to group and compose them somehow. Validator sets are simply plain Clojure maps: ;; first we define the set of validators we want to use (def address-validations   {:postcode [v/required v/number]    :street    v/required    :country   v/required})  ;;just something to validate (def person {:address {                 :postcode """"                 :country ""Brazil""}})  ;;now we compose the validators (b/validate person             :name    v/required             :address address-validations)  ;;[{:address ;;    {:postcode (""postcode must be a number"" ""postcode must be present""), ;;     :street (""street must be present"")}, ;;     :name (""name must be present"")} ;; ;; {:bouncer.core/errors {:address {:postcode (""postcode must be a number"" ""postcode must be present""), ;;  :street (""street must be present"")}, :name (""name must be present"")}, ;;  :address {:country ""Brazil"", :postcode """"}}] You can also compose validator sets together and use them as top level validations: (def address-validator   {:postcode v/required})  (def person-validator   {:name v/required    :age [v/required v/number]    :address address-validator})  (b/validate {}             person-validator)  ;;[{:address {:postcode (""postcode must be present"")}, :age (""age must be present""), :name (""name must be present"")} {:bouncer.core/errors {:address {:postcode (""postcode must be present"")}, :age (""age must be present""), :name (""name must be present"")}}] Customization Support Custom validations using plain functions Using your own functions as validators is simple: (defn young? [age]     (< age 25))  (b/validate {:age 29}             :age [[young? :message ""Too old!""]])  ;; [{:age (""Too old!"")} ;;  {:bouncer.core/errors {:age (""Too old!"")}, :age 29}] Writing validators As shown above, validators as just functions. The downside is that by using a function bouncer will default to a validation message that might not make sense in a given scenario: (b/validate {:age 29}                :age young?)  ;; [{:age (""Custom validation failed for age"")} ;; {:bouncer.core/errors {:age (""Custom validation failed for age"")}, :age 29}] You could of course use the message keyword as in previous examples but if you reuse the validation in several places, you'd need a lot of copying and pasting. Another way - and the preferred one - to provide custom validations is to use the macro defvalidator in the bouncer.validators namespace. The advantage of this approach is that it attaches the needed metadata for bouncer to know which message to use. As an example, here's a simplified version of the bouncer.validators/number validator: (use '[bouncer.validators :only [defvalidator]])  (defvalidator my-number-validator   {:default-message-format ""%s must be a number""}   [maybe-a-number]   (number? maybe-a-number)) defvalidator takes your validator name, an optional map of options and the body of your predicate function. Options is a map of key/value pairs where: :default-message-format - to be used when clients of this validator don't provide one :optional - a boolean indicating if this validator should only trigger for keys that have a value different than nil. Defaults to true. That's all syntactic sugar for: (def my-number-validator   (with-meta (fn my-number-validator                ([maybe-a-number]                   (number? maybe-a-number)))     {:default-message-format ""%s must be a number"", :optional false})) Using it is then straightforward: (b/validate {:postcode ""NaN""}           :postcode my-number-validator)   ;; [{:postcode (""postcode must be a number"")} ;;  {:bouncer.core/errors {:postcode (""postcode must be a number"")}, :postcode ""NaN""}] As you'd expect, the message can be customized as well: (b/validate {:postcode ""NaN""}           :postcode [[my-number-validator :message ""must be a number""]]) Validators and arbitrary number of arguments Your validators aren't limited to a single argument though. Since v0.2.2, defvalidator takes an arbitrary number of arguments. The only thing you need to be aware of is that the value being validated will always be the first argument you list - this applies if you're using plain functions too. Let's see an example with the member validator: (defvalidator member   [value coll]   (some #{value} coll)) Yup, it's that simple. Let's use it: (def kid {:age 10})  (b/validate kid             :age [[member (range 5)]]) In the example above, the validator will be called with 10 - that's the value the key :age holds - and (0 1 2 3 4) - which is the result of (range 5) and will be fed as the second argument to the validator. Internationalization and customised error messages In some cases the default behaviour might not be enough. Perhaps you'd like to customise your error messages with the value that has been provided. Or maybe you need access to the options that were given to a specific validator. And what if you need to know which validator generated a specific error message? Since 0.3.1-beta1, this is possible. validate takes as an optional first argument a function - called a message-fn - that is applied to a map containing validation metadata that allows you to customise error messages in any way you like - or even return other data structures instead. This map has the following keys: :path - where in the map has the error ocurred? :value - what was the value at the time of the validation? :args - which arguments - if any - were passed to the validator? :metadata - what is the metadata associated with this validation? :message - what - if any - is the message passed to this validator instance? Let's see how this works in practice. For the first example, we'll simply use identity as our message-fn: (def person {:name ""Leo"" :age ""NaN""})  (b/validate identity             person             :name v/required             :age  v/number) As you can see we simply supply identity as the first argument. This is what gets returned: [{:age   ({:path [:age],     :value ""NaN"",     :args nil,     :metadata     {:optional true,      :default-message-format ""%s must be a number"",      :validator :bouncer.validators/number},     :message nil})}  {:age ""NaN"",   :name ""Leo"",   :bouncer.core/errors   {:age    ({:path [:age],      :value ""NaN"",      :args nil,      :metadata      {:optional true,       :default-message-format ""%s must be a number"",       :validator :bouncer.validators/number},      :message nil})}}] Contrast this with what the function would have returned by default: [{:age (""age must be a number"")}  {:age ""NaN"",   :name ""Leo"",   :bouncer.core/errors {:age (""age must be a number"")}}] This opens a number of possibilities around customising errors messages. Let's create a simple message-fn to illustrate: (defn custom-message-fn [{:keys [path value metadata]}]   (format ""'%s' in field %s should be a %s"" value path (:validator metadata)))  (b/validate custom-message-fn             person             :name v/required             :age  v/number) This time we get a much more informative message: [{:age (""'NaN' in field [:age] should be a :bouncer.validators/number"")}  {:age ""NaN"",   :name ""Leo"",   :bouncer.core/errors   {:age    (""NaN in field [:age] should be a :bouncer.validators/number"")}}] Hats off to @dm3 for this pull request. Built-in validations I didn't spend a whole lot of time on bouncer so it only ships with the validations I've needed myself. At the moment they live in the validators namespace: bouncer.validators/required bouncer.validators/number bouncer.validators/integer bouncer.validators/string bouncer.validators/boolean bouncer.validators/email bouncer.validators/positive bouncer.validators/in-range bouncer.validators/member bouncer.validators/max-count bouncer.validators/min-count bouncer.validators/matches (for matching regular expressions) bouncer.validators/every (for ad-hoc validation of collections. All items must match the provided predicate) bouncer.validators/datetime (uses clj-time formatters) Contributing Pull requests of bug fixes and new validators are most welcome. Note that if you wish your validator to be merged and considered built-in you must implement it using the macro defvalidator shown above. Feedback to both this library and this guide is welcome. Running the tests Bouncer is assumed to work with Clojure 1.4 and up, as well as ClojureScript. There is a leiningen alias that makes it easy to run the tests against multiple Clojure versions: λ lein all-tests It'll run all tests against Clojure 1.4, 1.5 and 1.6, as well as Clojurescript - make sure all tests pass before submitting a pull request. TODO Add more validators (help is appreciated here) Docs are getting a bit messy. Fix that. License Copyright © 2012-2014 Leonardo Borges Distributed under the MIT License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/leonardoborges/bouncer"	"– A validation DSL for Clojure & Clojurescript applications."	"true"
"Validation"	"Validateur"	"http://clojurevalidations.info/"	"– A Clojure validation library inspired by Ruby's ActiveModel."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Validateur, a Clojure validations library | Clojure data validation library Validateur Home API reference Community Code on Github More Clojure libraries Validateur Validateur is a Clojure validation library inspired by Ruby's ActiveModel Get Started! » See API Reference » Contribute » Small Validateur is small: validators are functions, validation sets are higher-order functions, validation results are returned as values. Flexible With Validateur, you can create custom validators the most natural way: by defining functions. This website was developed by the  ClojureWerkz Team. Follow us on Twitter:  ClojureWerkz, Michael Klishin, Alex P"	"null"	"null"	"– A Clojure validation library inspired by Ruby's ActiveModel."	"true"
"Web Framework & Template"	"atw-om"	"https://github.com/zaiste/atw-om"	"– A web application template with Clojure/Compojure, ClojureScript/Om & core.async."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"41"	"2"	"6"	"GitHub - zaiste/atw-om: Web application template with Clojure/Compojure, ClojureScript/Om & core.async. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 41 Fork 6 zaiste/atw-om Code Issues 0 Pull requests 0 Pulse Graphs Web application template with Clojure/Compojure, ClojureScript/Om & core.async. 10 commits 1 branch 0 releases Fetching contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit b121b9e Dec 27, 2014 zaiste fix: clojars deployment issue Permalink Failed to load latest commit information. src/leiningen/new improv: update deps Dec 27, 2014 .gitignore initial commit Feb 7, 2014 README.md Update README.md Aug 10, 2014 project.clj fix: clojars deployment issue Dec 27, 2014 README.md atw-om A web application template with Clojure/Compojure on the backend, ClojureScript/Om on the frontend and core.async in-between: simply put, Clojure All The Way. Usage lein new atw-om foo cd foo lein up  Wait till ClojureScript is compiled, then go to localhost:3000. License Copyright © 2014 Zaiste Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/zaiste/atw-om"	"– A web application template with Clojure/Compojure, ClojureScript/Om & core.async."	"true"
"Web Framework & Template"	"Chestnut"	"https://github.com/plexus/chestnut"	"– An Application template for ClojureScript/Om with live reloading."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"962"	"42"	"84"	"GitHub - plexus/chestnut: Application template for ClojureScript/Om with live reloading. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 42 Star 962 Fork 84 plexus/chestnut Code Issues 2 Pull requests 0 Pulse Graphs Application template for ClojureScript/Om with live reloading. 363 commits 6 branches 14 releases 39 contributors Clojure 96.3% Shell 2.1% HTML 1.2% CSS 0.4% Clojure Shell HTML CSS Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master test update-readme v0.7.x v0.9 Nothing to show v0.12.0 v0.11.0 v0.10.0 v0.9.1 v0.9.0 v0.7.0 v0.7.0-SNAPSHOT-20150103 v0.7.0-SNAPSHOT-20141226 v0.7.0-SNAPSHOT-20141207 v0.6.0 v0.5.0 v0.4.0 v0.3.0 v0.2.0 Nothing to show New pull request Latest commit bbfaba8 Jun 27, 2016 plexus Add missing space in generated commit message Permalink Failed to load latest commit information. doc cljc documentation Jun 19, 2016 resources Add a favicon version Mar 6, 2015 src Add missing space in generated commit message Jun 27, 2016 .gitignore Add figwheel, make sure Austin/CIDER still work. Aug 24, 2014 LICENSE Minimal ClojureScript project that works with Emacs/Cider Aug 24, 2014 README.md Bump to 0.14.0 and release Jun 23, 2016 build_docs.sh Trying to get gitbook to work again Jan 29, 2016 code_of_conduct.md Add code of conduct Dec 17, 2014 project.clj Bump to 0.14.0 and release Jun 23, 2016 README.md chestnut Chestnut is a Leiningen template for a Clojure/ClojureScript app based on Om or Reagent, featuring a great dev setup, and easy deployment. For smooth development you get instant reloading of Clojure, ClojureScript, and CSS. A browser-connected REPL is also included. For deployment you get uberjar support, meaning you can get all your code compiled, optimized, and packaged in a single executable JAR file. It also contains the necessary artifacts to work on Heroku out of the box. Need help? Ask on the mailing list (please do not open an issue on GitHub): http://chestnut.aren.io/ Go to the documentation This README may describe unreleased features. Please compare the version number on Clojars to the changelog below, and check the README in your generated project for instructions pertaining to your version. Documentation Go to the documentation Usage lein new chestnut <name>  After that open the README of your generated project for detailed instructions, or consult the Documentation Lighttable Lighttable provides a tighter integration for live coding with an inline browser-tab. Rather than evaluating cljs on the command line with weasel repl, evaluate code and preview pages inside Lighttable. Steps: After running (run), open a browser tab in Lighttable. Open a cljs file from within a project, go to the end of an s-expression and hit Cmd-ENT. Lighttable will ask you which client to connect. Click 'Connect a client' and select 'Browser'. Browse to http://localhost:3449 View LT's console to see a Chrome js console. Hereafter, you can save a file and see changes or evaluate cljs code (without saving a file). Note that running a weasel server is not required to evaluate code in Lighttable. Emacs/Cider Start a repl in the context of your project with M-x cider-jack-in. Switch to repl-buffer with C-c C-z and start web and figwheel servers with (run), and weasel server with (browser-repl). Load http://localhost:3449 on an external browser, which connects to weasel, and start evaluating cljs inside Cider. List of Contents This template gives you everything you need to start developing Clojure/ClojureScript apps effectively. It comes with Figwheel Automatically reload your ClojureScript and CSS as soon as you save the file, no need for browser refresh. Om ClojureScript interface to Facebook's React. Alternatively you can use Reagent (--reagent), or use --vanilla to do without a React wrapper. Ring Clojure's de facto HTTP interface. Chestnut uses a Jetty or HttpKit server to serve the Clojurescript app. This way you already have an HTTP server running in case you want to add server-side functionality. Chestnut also inserts a Ring middleware to reload server-side Clojure files. Heroku support. Chestnut apps have all the bits and pieces to be deployable to Heroku. Getting your app on the web is as simple as git push. Unit tests for both Clojure and CLJS. Both specs and CLJS tests can be run in ""auto"" mode. Options --reagent Use Reagent instead of Om --vanilla Don't include Om, use this if you intend to use some other view library --http-kit Use HTTP Kit instead of Jetty --site-middleware Use the ring.middleware.defaults.site-defaults middleware (session, CSRF), instead of ring.middleware.defaults.api-defaults (see ring.defaults documentation) --less Use less for compiling Less CSS files. Use -- to separate these options from Leiningen's options, e.g. lein new chestnut foo --snapshot -- --http-kit Local copy If you want to customize Chestnut, or try unreleased features, you can run directly from master like this: git clone https://github.com/plexus/chestnut.git cd chestnut lein install Note that master may be partially or wholly broken. I try to do extensive manual testing before releasing a new stable version, so if you don't like surprises then stick to the version on Clojars. Issue reports and pull requests are very welcome. Requirements Java 1.7 or later Leiningen 2 FAQ Q: How can I get the features in the SNAPSHOT version? A: Use leiningen's --snapshot flag, e.g. lein new chestnut my-project --snapshot Q: I'm seeing warnings while compiling ClojureScript. A: There are a few known warnings, but they should not affect the functioning of your app. Q: I changed the {:text ""Hello Chestnut!""} portion and saved the file, but the changes don't show up. A: It's a feature. The app-state is defined with defonce, so your application state doesn't reset every time you save a file. If you do want to reset after every change, change (defonce app-state ..) to (def app-state ...). Q: I just want to compile ClojureScript to fully optimized JavaScript, so I can use it in a static HTML site. A: Invoke cljsbuild with the uberjar profile active, like this: lein with-profile -dev,+uberjar cljsbuild once, then look for resources/public/js/app.js. Q: I'm getting CompilerException java.lang.IllegalAccessError: in-seconds does not exist when using Spyscope 0.1.4 or earlier. A: Upgrade to Spyscope 0.1.5, this issue is caused by an outdated dependency on cljs-time. Q: I upgraded the version of Om in project.clj, but it seems I'm still using the old version, what's up? A: If you already did a build before, cljsbuild/figwheel won't pick up on the updated version automatically. Do a lein cljsbuild clean, then start Figwheel again. Q: The Figwheel output is cluttering up my REPL, can I get rid of it? A: Not as such, but instead of calling (run), you can call (run-web-server) and (run-auto-reload) in separate repls. Q: I gave my project a very generic name like cljs or clojure and now it's not working. A: This is due to namespace clashes. Try picking a more unique name. In particular avoid namespace prefixes used by Clojure, Clojurescript, or existing libraries. Changelog 0.14.0 Add cljc support ClojureScript 1.9.89 Figwheel 0.5.4-4 0.13.0 Clojurescript 1.9.36 Include Transit for faster ClojureScript compilation Figwheel 0.5.4-2 Reagent 0.6.0-rc Om 1.0.0-alpha36 0.13.0-SNAPSHOT Avoid using Leiningen profile merging for :cljsbuild configs 0.12.0 Upgrades org.omcljs/om 1.0.0-alpha31 => 1.0.0-alpha35 lein-auto 0.1.1 => 0.1.2 lein-less 1.7.3 => 1.7.5 org.clojure/clojurescript 1.8.40 => 1.8.51 environ 1.0.2 => 1.0.3 lein-cljsbuild 1.1.1 => 1.1.3 lein-environ 1.0.1 => 1.0.3 figwheel 0.5.2 => 0.5.3-2 Only add ""dev"" to the classpath in dev mode, fixes an issue with lein jar 0.11.0 Upgrade ClojureScript 1.7.228 => 1.8.40 Upgrade Figwheel 0.5.1 => 0.5.2 0.10.1 Fix missing dependency when using --http-kit 0.10.0 Add switches for --reagent and --vanilla Upgrade Figwheel to 0.5.1 Upgrade to Clojure 1.8.0, Om 1.1.0-alpha31, ring-defaults 0.2.0, compojure 1.5.0 v0.9.1 Upgrade Figwheel to 0.5.0-6 Upgrade Environ to 1.0.2 Upgrade internal dependencies to play better with Boot v0.9.0 Use Figwheel for REPL and Ring server Remove boilerplate that's no longer needed Drop Enlive and simplify the dev setup Drop CLJX support Better inline documentation Upgrade all dependencies v0.8.2-SNAPSHOT Version upgrades: clojurescript: 1.7.145 => 1.7.189, om: 1.0.0-alpha15 => 1.0.0-alpha28, figwheel => 0.4.1, figwheel-sidecar 0.4.1 => 0.5.0-2, lein-figwheel 0.4.1 => 0.5.0-2 Version upgrades: clojurescript: 1.7.122 => 1.7.145, om: 0.9.0 => 1.0.0-alpha15, tools.nrepl => 0.2.12, figwheel => 0.4.1, figwheel-sidecar => 0.4.1, lein-figwheel => 0.4.1,environ => 1.0.1, lein-environ => 1.0.1 Fix allowing projects to have - in their names. Fix allowing groupID/artifactID naming convention. Fix ""No such namespace"" when using om via the REPL. Fix specljs auto testing. Added gzip compression using ring.middleware.gzip. Added browser cache-control hinting using ring.middleware.browser-caching. Version upgrades: clojure: 1.6.0 => 1.7.0, clojurescript: 0.0-3058 => 1.7.48, ring: 1.3.2 => 1.4.0, ring-defaults: 0.1.4 => 0.1.5, compojure: 1.3.2 => 1.4.0, om: 0.8.8 => 0.9.0, figwheel: 0.2.5 => 0.3.7, piggieback: 0.1.5 => 0.2.1, weasel: 0.6.0 => 0.7.0 v0.8.1 Restore working lein repl for cljx projects (Josh Daghlian) Use latest version of enlive to fix windows issue (Justin Squirek) v0.8.0 Update Om: 0.8.0-rc1 => 0.8.8 (Anna Pawlicka) Make Uberjar executable (Børge Svingen) Remove react.js injection in dev html (Jamie English) Fix how Less and Sassc are invoked (Daryl Lau) Fix in figwheel config (Tim Gilbert), (Philip Joseph), (Antony Woods) Fix in test setup (Geoff Shannon) Doc fixes (Anthony Rosequist) Version upgrades: clojurescript: 0.0-2511 => 0.0-3058 ; figwheel: 0.2.1-SNAPSHOT => 0.2.5 ; weasel: 0.4.2 => 0.6.0 and more v0.7.0 Added Clojure{,script} unit testing support with Phantom JS. (Rory Gibson) Update om-tools: 0.3.9 => 0.3.10 Update ring-defaults: 0.1.2 => 0.1.3 Use figwheel-sidecar, drop the dependency on leiningen renamed the per-env namespace from dev to main give a proper error message when trying to invoke less in production v0.7.0-SNAPSHOT-20150103 Validate command line arguments Mention Chestnut version in the generated README Fix om-tools support SASSC support has been fixed, but is considered undocumented and unsupported Update Om: 0.7.0 => 0.8.0-rc1 Add Code of Conduct to generated projects Update CLJX: 0.4.0 => 0.5.0 Update Clojurescript: 0.0-2496 => 0.0-2644 Fixes for regressions: #71 v0.7.0-SNAPSHOT-20141226 Update Clojurescript: 0.0-2371 => 0.0-2496 Update Compojure: 1.2.0 => 1.3.1 Update Om: 0.7.0 => 0.8.0-beta3 Fixes for regressions: #65 #57 v0.7.0-SNAPSHOT-20141207 Make weasel print both to the REPL and the browser console (Marcus Lewis) Add support for the LESS CSS pre-processor (Denis Golovnev) Enable auto-reload of enlive templates in dev mode (Ray H) Add support for the SASS CSS pre-processor (Edward Wible) Add suport for Speclj (Edward Wible) Switch from the deprecated compojure.handler to ring-defaults zakak) Keep dev dependencies (Leiningen, Figwheel, Weasel, Speclj) out of the Uberjar Automatically switch the browser-repl to the right namespace after starting up, instead of cljs.user No longer include lein-ancient, easy enough to add for those that want it Update Ring: 1.3.1 => 1.3.2 Update Figwheel: 0.1.4-SNAPSHOT => 0.1.6-SNAPSHOT Update Weasel: 0.4.0-SNAPSHOT => 0.4.2 v0.6.0 Add optional support for CLJX (Olli Piepponen) Support generation of projects named using the groupId/artifactId convention (e.g. com.example/foo) (Steeve Beliveau) v0.5.0 Run figwheel inside (run) so we only need one process Configure figwheel's CSS reloading and load a placeholder style.css Refresh Om when Figwheel reloads Update ClojureScript: 0.0-2342 => 0.0-2371 Update Compojure: 1.1.9 => 1.2.0 Update Om: 0.7.1 => 0.7.3 No longer depend on Weasel in production mode v0.4.0 Option to switch to HTTP Kit for a web server Add reloading middleware Add default compojure.handler.site middleware v0.3.0 Switched to Weasel for Austin Optimized uberjar Fix usage of {{name}}/{{sanitized}} Load react from the jar, instead of from Facebook's CDN Update dependencies (Clojurescript, Ring, Compojure, Environ) v0.2.0 Uberjar support Heroku support (Procfile, system.properties) added .gitignore First version of development/production modes v0.1.0 First release, containing Austin, Figwheel, Om Sources I used the browser-connected-repl that's included with Austin as a starting point, then pulled in bits from cljs-liveedit-webapp until things worked. Figwheel's Flappy Bird Demo app also provided some ideas. The concept of refreshing Om when Figwheel reloads was taken from this blog post by Michiel Borkent. For Heroku support I looked at Heroku's clojure-getting-started example app. License Copyright © 2014-2016 Arne Brasseur Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/plexus/chestnut"	"– An Application template for ClojureScript/Om with live reloading."	"true"
"Web Framework & Template"	"Clops"	"https://github.com/sveri/closp"	"– An opinionated, full stack and easy to use web framework."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"117"	"6"	"4"	"GitHub - sveri/closp: Leiningen template combining luminus, chestnut plus some goodies Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 6 Star 117 Fork 4 sveri/closp Code Issues 4 Pull requests 0 Pulse Graphs Leiningen template combining luminus, chestnut plus some goodies 271 commits 1 branch 0 releases 3 contributors Clojure 76.8% HTML 21.8% CSS 1.4% Clojure HTML CSS Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit a32b94c Jun 27, 2016 sveri committed on GitHub Merge pull request #25 from dijonkitchen/patch-1 … Fix spelling Permalink Failed to load latest commit information. resources/leiningen/new/closp prepare next version with new closp-crud May 29, 2016 src/leiningen/new cleanup Apr 1, 2016 .gitignore * Removing piggyback and nrepl dependency Jun 7, 2015 CHANGES.MD prepare next version with new closp-crud May 29, 2016 Dockerfile crudify done in cljs Jan 17, 2016 LICENSE inital commit (cloned from luminusweb) Jan 19, 2015 README.md Fix spelling Jun 26, 2016 intro.gif add intro.gif Apr 14, 2016 project.clj bugfix May 22, 2016 README.md closp A Leiningen template combining luminus, chestnut plus some goodies. Mailing List: These five steps are all it takes to get up and running. Documentation with Tutorial Goals Provide a full stack to get started with Provide generated code which can be changed easily Provide an opiniated predefined set of libraries Easily start side projects Differences to luminus System integration from the start - wrapper on top of sierras components User management with login/logout/registration and email activation (provided by postal) Conditional Reader support closp-crud integration Live reloading for both clojurescript and clojure out of the box. Clojure miniprofiler enabled. Recaptcha for Signup Rationale Starting sideprojects in web development for fun I find myself repeating the same patterns over and over again. While luminus http://www.luminusweb.net/ and chestnut https://github.com/plexus/chestnut provide a great start they miss some features for me that I do again and again (authentication / signup processes / ...). So I pulled together the libraries I use to provide a general and opinionated starting point with at least trouble as possible (at least that's the goal). Usage Run lein new closp _projectname_ -n foo.bar in a different folder Run lein migrate in the newly created project (This will add an admin user with username: admin@localhost.de and password: admin to a new database) Run lein figwheel to start figwheel and compile the clojurescript. Run lein rel-jar to generate a runnable jar file. Features closp-crud integration SQlite database on filesystem as a default Joplin for database migrations Selmer as templating solution http-kit as a server cljc support Figwheel with clojurescript live reloading Reloading support for templates and clojure code Configuration with nomad User management with login/logout/registration and email activation (provided by postal) Recaptcha support for signup form Authentication provided by buddy reagent and datascript on frontend side Ring Antiforgery middleware Clojure miniprofiler example Componentized application Datascript with reagent example Booststrap css styles Example for clj-webdriver tests Internationalization support with tower Showcase See it live at: http://sveri.de:3124 Username: admin@localhost.de Password: admin Docker There is a dockerfile attached which will fetch the latest version and run an example project. Configuration There is a closp.edn file in the resources folder which should be adapted accordingly. Closp uses nomad https://github.com/james-henderson/nomad, so you can configure everything as you can do with nomad. When you start your project from the repl it will load the default closp.edn from resources folder, which fits for development. For a different config in another environment you can pass in a file path via system environment setting like so: java -jar -Dclosp-config-path=C:\\path\\to\\iwf-prod.edn closp.jar. Please think of changing the :env key in the config to :prod instead of :dev when changing to a different environment. closp-crud This is a module that generates html, routing and sql files for a given table definition. For more information please look here: https://github.com/sveri/closp. Short Intro: Create a new definition in env/dev/entities/example.edn (Look at env/dev/entities/user.edn for an example) Run lein run -m de.sveri.clospcrud.closp-crud/closp-crud -f env/dev/entities/example.edn Run lein migrate to create the new database Add the new routes handler to components.handler namespace Reset the server Browse to /example Database Closp per default is configured to connect to a file SQlite database. Additionally I added support for joplin https://github.com/juxt/joplin to handle migration of sql scripts. To get started run lein migrate in the project folder. This is enough to get running. Changing the jdbc url in the closp.edn file will switch to another database. But keep in mind you will have to run the migration step again and change the jdbc url in the joplin.edn too. The connection is handled by jdbc https://github.com/clojure/java.jdbc so everything that jdbc supports is supported by closp out of the box. Closp comes with korma https://github.com/korma/Korma for an abstraction layer over jdbc. See db\users.clj for how it is used. Authentication and Authorization We use the buddy (https://github.com/funcool/buddy) library for this. Configuration is done in ns.service.auth There is a concept of roles, admin and none are alreaded provided, you can add more in the auth namespace. Or, create a database storage for this. Next you can find a rules def in the auth namespace which defines the access rules for every available link. For more information please look at the buddy documentation. Templating Closp ships with selmer https://github.com/yogthos/Selmer (django inspired) templating solution. Signup There is a signup workflow implemented that sends out an email after regristration with a link to activate the account. Until the account is activated the user won't be able to login. Recaptcha The signup form is protected by recaptcha. To make it work open your closp.edn file and fill these values properly: :captcha-public-key :private-recaptcha-key :recaptcha-domain Admin user interface Closp ships with an administrator interface (/admin/users) to activate / deactivate users and set roles accordingly. There is also an option to add new users. Reloading of clojure code and templates In dev mode changes the clojure code will be recompiled and reloaded on page refresh. The same is true for the templates. Theoretically this results development without server restarts. Clojurescript with figwheel When running in dev mode cljs files will be auto compiled and sent to the browser via figwheel https://github.com/bhauman/lein-figwheel. If you want to autoload a different cljs function you have to adapt dev.cljs and the project.clj file at [:cljsbuild :dev :figwheel]. Email system Closp uses postal https://github.com/drewr/postal for sending authentication links. This can be configured in closp.edn. Components Closp comes with some predefined components https://github.com/danielsz/system Handler component Configuration component Database component Webserver component To restart the components just hit (reset) in the running repl. Ring antiforgery https://github.com/weavejester/ring-anti-forgery is enabled per default for every shipped form. If you use ajax post / put / ... calls you need to provide a :X-CSRF-Token in the header. With cljs-ajax for example it would look like this: (ajax/ajax-request     {:uri             url      :method          method      :params          content      :headers         {:X-CSRF-Token (get-value ""glob_anti_forgery"")}})  Transit and cljs-ajax There is an example on how to use cljs-ajax for doing ajax requests to the server. The request will use transit as a transport format. You can find that at the uri: ""/ajax/page/init"" and in the ajax.cljs file. You need to run lein figwheel at least once to compile the clojurescript. And finally open the dev.cljs namespace and change the requiring namespace from (:require [f.d.core :as core]) to (:require [f.d.ajax :as core]) Reagent and Datascript Closp includes a reagent https://github.com/reagent-project/reagent and datascript https://github.com/tonsky/datascript example taken from https://gist.github.com/allgress/11348685 to get started with frontend development. Production There is a leiningen task defined in the project.clj to generate an uberjar. Just execute lein uberjar. By default this will include your closp.edn config file in the build from resources folder. You should at least change the :env entry to :prod or something else than :dev. There are several ways to setup a more separated dev / staging / prod environment. Please lookup nomad for that. CLJ-Webdriver Closp comes with some examples on how to use clj webdriver in your projects for integration tests. They reside in integtest\clj. Per default the tests are run with the :htlmunit driver, which is fast, but not that good on javascript. To change that, open: {{ns}}.web.setup and adapt the driver in browser-setup to :firefor or :chrome. Internationalization Closp uses https://github.com/ptaoussanis/tower for internationalization. It is configured as a component in your.ns.components.locale. You have to add additional strings / translations there to use them in your web application. For examples look at your.ns.routes.user. Minor features. Miniprofiler https://github.com/yeller/clojure-miniprofiler example in routes\user.clj -> admin-page function. The profiler is enabled in development only Namspace support: Add -n name.space option to lein new closp projectname to provide a namespace for the source files. Support for flash messages with global flash div Self registration can be turned on or off in the closp.edn file in the resources folder. Test2junit plugin to create parseable test results. Planned features Currently working on a webui for closp crud Whatever seems useful in the future. Contributors Henrik Lundahl - https://github.com/henriklundahl FAQ Running lein figwheel fails with ...No such var: ana/forms-seq*... The complete error message is: clojure.lang.Compiler$CompilerException: java.lang.RuntimeException: No such var: ana/forms-seq*, compiling:(figwheel_sidecar/utils.clj:49:21)  This issue is tracked in https://github.com/sveri/closp/issues/20. According to the reporter upgrading to leiningen 2.5.3 fixed it for him. If it does not for you, please reopen the issue. Could not find template closp on the classpath. This occurs when you run lein new closp ... with an older leiningen version. Please upgrade to the latest one. I get this warning: Uncaught Error: Invariant Violation: _registerComponent(...): Target container is not a DOM element. This will happen only in dev mode for every page where you did not explicitly register your clojurescript with. Look at dev.cljs for this line :jsload-callback (fn [] (core/main)) and change the call to (core/main) how you need it for the page you are working on right now. When I change a route definition, the change is not applied after a page reload You have to reset the system, by calling ({{ns}}.user/reset) in the repl. I included prismatic/schema and on repl start I get an compile error The error looks like this: #<CompilerException java.lang.RuntimeException: No such var: sm/protocol, compiling:(plumbing/fnk/schema.clj:22:13)> The problem is that ring-transit imports schema/plumbing which interfers with schema. Please look here for a quick solution and explanation: <https://github.com/Prismatic/schema/issues/194 Changes License Copyright © 2015 Sven Richter Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/sveri/closp"	"– An opinionated, full stack and easy to use web framework."	"true"
"Web Framework & Template"	"Coils"	"http://coils.cc/"	"Build enterprise ready web apps with Clojurescript and React.js, faster than ever."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Build enterprise ready web apps with Clojurescript and React.js, faster than ever."	"false"
"Web Framework & Template"	"descjop"	"https://github.com/karad/lein_template_descjop"	"A template for Web based desktop application with Electron."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"205"	"16"	"7"	"GitHub - karad/lein_template_descjop: A Leiningen template(Clojure/ClojureScript Project) for Web based desktop application with Electron (atom-shell). Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 16 Star 205 Fork 7 karad/lein_template_descjop Code Issues 1 Pull requests 0 Pulse Graphs A Leiningen template(Clojure/ClojureScript Project) for Web based desktop application with Electron (atom-shell). http://descjop.org 72 commits 4 branches 20 releases 5 contributors Clojure 92.3% HTML 6.1% JavaScript 1.6% Clojure HTML JavaScript Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master v0.5.2 v0.5.3 v0.5.4 Nothing to show v0.6.4 v0.6.3 v0.6.2 v0.5.3 v0.5.2 v0.5.1 v0.5.0 v0.4.0 v0.3.2 v0.3.0 v0.2.1 v0.2.0 v0.1.8 v0.1.7 v0.1.6 v0.1.5 v0.1.4 v0.1.3 v0.1.2 v0.1.1 Nothing to show New pull request Latest commit 636fc32 Jul 8, 2016 karad committed on GitHub Merge pull request #21 from karad/v0.6.4 … V0.6.4 Permalink Failed to load latest commit information. .idea update electron 0.26.0 to 0.26.1 May 22, 2015 docs update to electron 0.25.3 May 8, 2015 man/images add logo Apr 20, 2015 resources/leiningen/new/descjop update electron version -> 1.2.5 Jul 3, 2016 src/leiningen/new update windows support Apr 10, 2016 .gitignore update electron and clojurescript version Oct 22, 2015 README.md update version no and credit Jul 7, 2016 project.clj update version no and credit Jul 7, 2016 README.md lein-template-descjop A Leiningen template for Web based desktop application with Electron(atom-shell) and others. (now Electron(atom-shell) based only. will build nw.js based later...) Website : descjop.org/ Requirements leiningen 2.6.x + node v6.x + grunt v0.1.13 + important : not support leiningen 2.5.x (if you don't install grunt yet.) $ npm install -g grunt-cli  Help You can display help how to use descjop. $ lein new descjop help  and you can use alias in project directory. $ lein descjop-help  New project from leiningen template Minimum project $ lein new descjop YOUR_APP_NAME $ cd YOUR_APP_NAME  Om based project $ lein new descjop YOUR_APP_NAME +om $ cd YOUR_APP_NAME  reagent based project $ lein new descjop YOUR_APP_NAME +reagent $ cd YOUR_APP_NAME  Project Directory see your app dir. looks like . +-- Gruntfile.js +-- README.md +-- app |   +-- dev // deveropment mode dir |   |   +-- index.html // entry html file |   |   +-- js |   |   |   +-- externs_front.js |   |   |   +-- externs.js |   |   |   +-- main.js |   |   +-- package.json // for Desktop app |   +-- prod // production mode dir |       +-- index.html // entry html file |       +-- js |       |   +-- externs_front.js |       |   +-- externs.js |       |   +-- main.js |       +-- package.json // for Desktop app +-- package.json // for Compile +-- project.clj // compile settings desktop app +-- resources +-- src |   +-- NAMESPACE |       +-- core.cljs // ClojureScript for Electron in here +-- src_front |   +--NAMESPACE_front |      +-- core.cljs // Frontend clojureScript in here +-- src_front_profile     +--NAMESPACE_front        +-- dev        |   +-- conf.cljs        |   +-- init.cljs        +-- prod            +-- conf.cljs            +-- init.cljs  Usage step 1 run descjop-init (windows user should use descjop-init-win) alias below. OSX/Linux user $ lein descjop-init  ...  Running ""download-electron"" task  Done, without errors.  Windows user $ lein descjop-init-win  ...  Running ""download-electron"" task  Done, without errors.  step 2 you have to change src/PROJECT_NAME/core.cljs about :companyName and submitURL. (defn -main []   (.start crash-reporter (clj->js {:companyName ""Your Company Name""                                    :submitURL   ""http://example.com/""}))   ...  step 3 and run extern alias descjop-externs, $ lein descjop-externs  run cljsbuild lein descjop-once. $ lein descjop-once  Compiling ClojureScript. Compiling ""app/js/cljsbuild-main.js"" from [""src""]... Successfully compiled ""app/js/cljsbuild-main.js"" in 10.812 seconds. ... Successfully compiled ""app/dev/js/front.js"" in 10.588 seconds. ... Successfully compiled ""app/prod/js/cljsbuild-main.js"" in 19.333 seconds. ... Successfully compiled ""app/prod/js/front.js"" in 29.94 seconds.  step 4 You can run Desctop application. development mode development mode use figwheel. run alias descjop-figwheel. before run application. Open other terminal window. $ lein descjop-figwheel  and you can run Electron(Atom-Shell) app. On Windows: $ .\electron\electron.exe app/dev  On Linux: $ ./electron/electron app/dev  On OS X: $ ./electron/Electron.app/Contents/MacOS/Electron app/dev  production mode you can run Electron(Atom-Shell) app. On Windows: $ .\electron\electron.exe app/prod  On Linux: $ ./electron/electron app/prod  On OS X: $ ./electron/Electron.app/Contents/MacOS/Electron app/prod  Aliases you can use aliases in project directory. $ lein descjop-help          # descjop help $ lein descjop-init          # init project $ lein descjop-init-win      # init project for windows user $ lein descjop-externs       # output externs for develop and production $ lein descjop-externs-dev   # output externs for develop $ lein descjop-externs-prod  # output externs for production $ lein descjop-figwheel      # start figwheel $ lein descjop-once          # build JavaScript for develop and production $ lein descjop-once-dev      # build JavaScript for develop $ lein descjop-once-prod     # build JavaScript for production  Milestones descjop cli command add CSS test suite Change log 0.6.4 (2016-07-07) update electron -> 1.2.5 0.6.3 (2016-04-11) fixed namespace problem. 0.6.2 (2016-04-10) Changes: update clojurescript 1.7.122 -> 1.7.228 update electron -> 0.37.5 add descjop command help alias lein descjop-help add descjop command init alias lein descjop-init add descjop command externs alias lein descjop-externs lein descjop-externs-dev lein descjop-externs-prod add descjop command compile alias lein descjop-once lein descjop-once-dev lein descjop-once-prod add descjop command figwheel alias lein descjop-figwheel support development and production mode. re-design directories. some bug fix 0.5.4 (2015-12-29) Changes: update document update electron -> 0.36.1 update lein-cljsbuild -> 1.1.2 update lein-externs -> 0.1.5 0.5.3 (2015-12-19) Changes: update electron -> 0.36.1 change deprecated method .loadUrl() to .loadURL() add downloadDir Gruntfile settings. if you want to download electron on current project directory. delete atom-shell in app__index.html change .gitignore exclude electron/* change crash-reporter.start() in resources/leiningen/new/descjop/src__core.cljs that require companyName and submitURL 0.5.2 (2015-11-19) Changes: update electron -> 0.35.0 0.5.1 (2015-10-22) Changes: update electron -> 0.34.0 update clojurescript -> 1.7.145 0.5.0 (2015-10-09) Changes: om also support figwheel. great job @dvcrn! update electron -> 0.33.6 0.4.0 (2015-09-29) Changes: reagent support (with figwheel). good job @mopemope! update electron -> 0.33.3 0.3.2 (2015-09-19) Changes: add help command update electron -> 0.33.0 0.3.1 (2015-09-10) Changes: update electron -> 0.32.2 0.3.0 (2015-09-05) Changes: add +om option. Om based template support. 0.2.1 (2015-09-03) Changes: update clojurescript -> 1.7.48 update electron -> 0.31.2 update grunt-download-electron -> 2.1.2 0.2.0 (2015-08-03) Changes: support :optimization :none update clojure -> 1.7.0 update clojurescript -> 1.7.28 update electron -> 0.30.2 0.1.8 (2015-06-22) Changes: update Electron version 0.28.1 to 0.28.2 0.1.7 (2015-06-16) Changes: update Electron version 0.27.3 to 0.28.1 0.1.6 (2015-06-08) Changes: update Electron version 0.26.1 to 0.27.3 0.1.5 (2015-05-22) Changes: update Electron version 0.26.0 to 0.26.1 0.1.4 (2015-05-16) Changes: update Electron version 0.25.3 to 0.26.0 0.1.3 (2015-05-08) Changes: update Electron version 0.24.0 to 0.25.3 update grunt-download-electron to 2.1.1 0.1.2 (2015-04-22) Bugfixes: change calling how to index.html path (#2, @karad) 0.1.1 (2015-04-20) Bugfixes: change grunt task from atom-shell to electron (#1, @karad) License Copyright © Kazuhiro Hara (Greative LLC http://greative.jp/) {:mail kazuhiroh@gmail.com :twitter https://twitter.com/kara_d} Distributed under the MIT License http://opensource.org/licenses/MIT . Thanks @kara_d @mopemope @dvcrn @toku345 Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/karad/lein_template_descjop"	"A template for Web based desktop application with Electron."	"true"
"Web Framework & Template"	"electron-template"	"https://github.com/ducky427/electron-template"	"A template for creating web based desktop applications with Electron, ClojureScript and Reagent."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"73"	"10"	"4"	"GitHub - ducky427/electron-template: A Leiningen template for projects using Electron with ClojureScript. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 10 Star 73 Fork 4 ducky427/electron-template Code Issues 2 Pull requests 0 Pulse Graphs A Leiningen template for projects using Electron with ClojureScript. 27 commits 2 branches 0 releases 1 contributor JavaScript 56.7% Clojure 23.0% NSIS 16.0% Shell 2.0% HTML 1.3% Batchfile 1.0% JavaScript Clojure NSIS Shell HTML Batchfile Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags develop master Nothing to show Nothing to show New pull request Latest commit dd39c0c Mar 15, 2016 ducky427 Bump version Permalink Failed to load latest commit information. resources/leiningen/new/electron Upgraded various dependencies Mar 15, 2016 src/leiningen/new Added live reloading of css to figwheel Aug 9, 2015 .gitignore Some cleanup Jul 23, 2015 LICENSE Initial commit Jul 23, 2015 README.md Updated dependencies and documented how to use nREPL with figwheel Dec 1, 2015 project.clj Bump version Mar 15, 2016 README.md electron A Leiningen template for creating Electron based clojurescript project with support for Reagent. This template is heavily based on the work done by Shaun LeBron and Chris Oakman on the cuttle project. Usage Create a new application project: lein new electron <name>  Features Figwheel support. For production, platform specific binary produced for Mac OSX (.app) and Windows (.exe). Its further possible to creat a Setup exe and an installer DMG. Bower support for front-end dependencies and NPM support for node dependencies. Basic application menu in the generated electron app. Grunt task for checking of outdated cljs/node/bower dependencies. See app's README.md for more details. Requirements JDK 1.7+ Leiningen 2.5.3+ License Copyright © 2015 Rohit Aggarwal Distributed under the The MIT License (MIT). Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/ducky427/electron-template"	"A template for creating web based desktop applications with Electron, ClojureScript and Reagent."	"true"
"Web Framework & Template"	"Hoplon"	"http://hoplon.io"	"– Write everything in Clojure and ClojureScript, clientside and serverside."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"82"	"11"	"16"	"GitHub - hoplon/castra: HTTP remote procedure call handler for Clojure. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 11 Star 82 Fork 16 hoplon/castra Code Issues 6 Pull requests 0 Pulse Graphs HTTP remote procedure call handler for Clojure. 178 commits 3 branches 16 releases 9 contributors Clojure 98.2% Shell 1.8% Clojure Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master micha-docs micha-readme Nothing to show 3.0.0-alpha4 3.0.0-alpha3 3.0.0-alpha2 3.0.0-alpha1 2.2.2 2.2.1 2.2.0 2.1.1 2.1.0 2.0.0 1.3.0 1.2.0 1.0.1 1.0.0 0.1.1 0.1.0 Nothing to show New pull request Latest commit dccbc85 May 24, 2016 micha 3.0.0-alpha4 (actual) Permalink Failed to load latest commit information. img basic docs in the readme Dec 22, 2015 script add push script Oct 30, 2013 src/castra Merge branch 'master' into state-fn May 24, 2016 test/castra tailrecursion/ to hoplon/ migration Aug 30, 2015 .gitignore We can generate project.clj locally Dec 21, 2015 README.md 3.0.0-alpha4 (actual) May 24, 2016 build.boot 3.0.0-alpha4 May 24, 2016 README.md Castra Web application RPC library for Clojure/Script and Ring. [hoplon/castra ""3.0.0-alpha4""] ;; latest release The Big Picture The purpose of Castra is to make async server calls feel like expression evaluation, providing a more cohesive programming experience across the front end and back end of your system. Instead of thinking ""I'm going to send this data bag in a POST to the /xyz endpoint,"" supports you in thinking thoughts like ""I'm going to evaluate the expression (update-record 123 {:x 1 :y 2}) on the server."" Castra's front-end and back-end libraries implement this RPC pattern. RPC does come with baggage, though. Implementing an RPC framework that provides a seamless and transparent remote execution model is a very difficult distributed systems problem. Castra does not attempt this. Instead, Castra's RPC model embraces the asynchronous nature of client server communication. Applicable buzzwords, if you're not into the whole brevity thing, are unidirectional dataflow and the CQRS pattern. Overview Castra spans the gap between server and client. This makes documentation a bit more difficult. This section will jump back and forth between client and server code — it should be understood that the server code is Clojure and client is ClojureScript. Server Most of the magic happens in Castra's castra.middleware/wrap-castra ring middleware. This middleware looks for an expression under the :body key of the ring request map. It looks for a request that looks something like: {:request-method :post  :body ""(my.app/update-record 123 {:x 1 :y 2})""} The Castra middleware deserializes the body to obtain Clojure forms. It then dispatches the expression (my.app/update-record 123 {:x 1 :y 2}) by resolving and attempting to call the function my.app/update-record. (This function should be created with castra.core/defrpc, explained below.) The Castra middleware then returns a ring response map with the serialized result in the :body and a 200 status. You can think of the response as if it were this: {:status 200  :body (pr-str (my.app/update-record 123 {:x 1 :y 2}))} Obviously, we don't want the client to be able to evaluate arbitrary expressions on the server (we already have nREPL for that). We want to be able to mark certain functions as part of our application's RPC interface. This is accomplished with castra.core/defrpc: (ns my.app   (:require     [castra.core :as c]     [some.database :as db]))  (c/defrpc get-record   [id]   (first (db/query ""SELECT * FROM record WHERE id = ?"" id)))  (c/defrpc update-record   [id {:keys [x y]}]   (db/execute ""UPDATE IN record SET x = ?, y = ? WHERE id = ?"" x y id)   (get-record id)) Client Castra provides a ClojureScript library for creating the RPC stub functions the client will call. These are constructed by the castra.core/mkremote function. (ns my.app.client   (:require     [castra.core :as c]     [javelin.core :as j :include-macros true]))  (j/defc record  nil) (j/defc error   nil) (j/defc loading nil)  (def get-record    (c/mkremote 'my.app/get-record    record error loading)) (def update-record (c/mkremote 'my.app/update-record record error loading)) The mkremote function takes four arguments, three of which are Javelin cells: The fully qualified symbol associated with the defrpc on the server. The state cell, where the result will go if the operation succeeded. The error cell, where the exception will go if the operation failed. The loading cell, which will contain a vector of all in-flight RPC requests. This defines the get-record and update-record functions in the client, which can be called like any other ClojureScript function. Hoplon Example: Using the server and client code above, we can make a little webapp that shows us the contents of a record. The user interface will display the current record at the top of the page. The user may enter an id into a text input to view a different record. The interface displays an indication when remote operations are in progress. The interface displays error messages when remote operations fail. Here is a simple Hoplon page that satisfies these requirements: (page ""index.html""   (:require     [my.app.client :as c]))  (defc= loading?      (some-> c/loading seq count))      ; contains count of in-flight commands (defc= error-message (some-> c/error .-message))        ; contains the last command's error message  (c/get-record 1)                                        ; get record 1 when page first loads  (html   (head)   (body     (p :toggle loading?                                 ; show when things are being processed       (text ""Processing ~{loading?} requests...""))      (p :toggle error-message                            ; show when an operation fails       (text ""Error: ~{error-message}""))      (p (text ""Record: ~{c/record}""))                    ; display the current record      (let [id (cell nil)]       (form :submit #(c/get-record @id)                 ; edit and submit form to load record         (p (label ""Record ID: "")             (input :value id :keyup #(reset! id @%)))         (p (button :type ""submit"" ""submit"")))))) There are a few things to notice about this application: Commands to change state do not return a value — the value is updated in a Javelin cell asynchronously when the command completes successfully. Dataflow is unidirectional (i.e. getting and changing state are via separate constructs) — getting via formula cells, and setting via RPC functions. The place that commands the change (eg. the form above) does not need to know or care which places will respond to the change (eg. the p displaying the current record), and vice versa. Dataflow The diagram to the right illustrates the flow of data through the application. There are actually two dataflow loops in the program: A local loop for editing the record id form value, and a remote loop which sends commands to the server. Local Loop The user types in the input element. The keyup DOM event fires, triggering a state transition (callback). The callback calls reset! on the id cell, updating its value. The value property of the input element is bound to the id cell, so it is automatically updated when id changes. The user sees the new value in the input element. Remote Loop The user submits the form. The submit DOM event fires, triggering the callback. The callback performs an RPC command, get-record. When the RPC command completes the c/record cell is automatically updated with the new current record. The textContent property of the text node displaying the current record is bound to a formula cell that updates when c/record changes. The user sees the new record's value in the page. Notice how similar the two cases are. The main difference is at step 3. In the local loop the callback directly updates the id cell with the synchronously with reset!. In the remote loop the c/record cell is updated asynchronously with Castra. Examples The Hoplon Demos repo contains demo apps using Castra. TODO explain defrpc and endpoints. explain validation License Copyright © 2013 FIXME Distributed under the Eclipse Public License, the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/hoplon/castra"	"– Write everything in Clojure and ClojureScript, clientside and serverside."	"true"
"Web Framework & Template"	"Luminus"	"http://www.luminusweb.net/"	"– It aims to provide a robust, scalable, and easy to use platform."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Luminus - a Clojure web framework Home Docsumentation Get Involved Luminus is a Clojure micro-framework based on a set of lightweight libraries. It aims to provide a robust, scalable, and easy to use platform. With Luminus you can focus on developing your app the way you want without any distractions. Clojure Web Development Made Simple Quick Start Guide  $ lein new luminus my-app $ cd my-app $ lein run Started server on port 3000                         Get started in seconds using Leiningen. Developer Friendly Start hacking immediately with the REPL and embedded development server Simple and easy to learn REPL driven development Powerful build tools Productive Choose productivity and performance by leveraging Clojure on the JVM Built on top of the JVM Low overhead Compiled for production Modern Web & Mobile Luminus is built for needs of modern web & mobile apps ClojureScript support Stateless web tier Excellent SQL/NoSQL support Luminus framework is released under the MIT License - Copyright ©"	"null"	"null"	"– It aims to provide a robust, scalable, and easy to use platform."	"true"
"Web Framework & Template"	"Mies"	"https://github.com/swannodette/mies"	"– A minimal ClojureScript project template."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"275"	"16"	"41"	"GitHub - swannodette/mies: Minimal ClojureScript project template Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 16 Star 275 Fork 41 swannodette/mies Code Issues 1 Pull requests 1 Pulse Graphs Minimal ClojureScript project template 111 commits 1 branch 1 release Fetching contributors Clojure 74.5% HTML 11.2% Shell 7.5% Batchfile 6.8% Clojure HTML Shell Batchfile Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show 0.6.0 Nothing to show New pull request Latest commit 8b9b165 Jun 27, 2016 mneise 0.6.13 … Update ClojureScript version to 1.9.89 Permalink Failed to load latest commit information. src/leiningen/new 0.6.13 Jun 27, 2016 .gitignore initial commit Oct 27, 2013 LICENSE initial commit Oct 28, 2013 README.md 0.6.12 May 16, 2016 project.clj 0.6.13 Jun 26, 2016 README.md mies A minimal ClojureScript template. Usage To create a new project: lein new mies hello-world cd hello-world  Most of the following scripts require rlwrap (on OS X installable via brew). To compile a developer build version: scripts/build  To continuously monitor source files and build when changed: scripts/watch  To compile a release version: scripts/release  License Copyright © 2013-2016 David Nolen Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/swannodette/mies"	"– A minimal ClojureScript project template."	"true"
"Web Framework & Template"	"re-frame"	"https://github.com/Day8/re-frame"	"– A Reagent Framework For Writing SPAs, in Clojurescript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"1661"	"126"	"116"	"GitHub - Day8/re-frame: A Reagent Framework For Writing SPAs, in Clojurescript. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 126 Star 1,661 Fork 116 Day8/re-frame Code Issues 10 Pull requests 2 Wiki Pulse Graphs A Reagent Framework For Writing SPAs, in Clojurescript. 549 commits 6 branches 11 releases 28 contributors Clojure 91.5% HTML 7.0% JavaScript 1.5% Clojure HTML JavaScript Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags dedupe-subs develop master singletons-for-sugar stus-undo-fix undo-fix Nothing to show v0.7.0 v0.7.0-alpha2 v0.5.0 v0.5.0-alpha3 v0.5.0-alpha1 v0.4.1 v0.4.0 v0.3.2 v0.3.0 v0.2.0 0.3.1 Nothing to show New pull request Latest commit 8c3acb0 Jul 15, 2016 mike-thompson-day8 Better README badges Permalink Failed to load latest commit information. examples Further towards fx Jul 14, 2016 src/re_frame Move `:forward-events` to be its own library. Jul 15, 2016 test Add cljs-test to test-runner via browser/html Jul 14, 2016 .gitignore Switch to using CircleCI and automated testing with Karma Dec 10, 2015 CHANGES.md Include the example effect handlers Jul 15, 2016 CONTRIBUTING.md Initial fx code now in. But it remains largely untested. Jul 14, 2016 README.md Better README badges Jul 15, 2016 circle.yml Add cljs-test to test-runner via browser/html Jul 14, 2016 karma.conf.js Add cljs-test to test-runner via browser/html Jul 14, 2016 license.txt Correctly name license file. Mar 14, 2015 project.clj Add cljs-test to test-runner via browser/html Jul 14, 2016 README.md Derived Values, Flowing This, milord, is my family's axe. We have owned it for almost nine hundred years, see. Of course, sometimes it needed a new blade. And sometimes it has required a new handle, new designs on the metalwork, a little refreshing of the ornamentation . . . but is this not the nine hundred-year-old axe of my family? And because it has changed gently over time, it is still a pretty good axe, y'know. Pretty good. -- Terry Pratchett, The Fifth Elephant Why Should You Care? Either: You want to develop an SPA in ClojureScript, and you are looking for a framework; or You believe that, by early 2015, ReactJS had won the JavaScript framework wars and you are curious about the bigger implications. Is the combination of reactive programming, functional programming and immutable data going to completely change everything? And, if so, what would that look like in a language that embraces those paradigms? re-frame re-frame is a pattern for writing SPAs in ClojureScript, using Reagent. This repo contains both a description of this pattern and a reference implementation. To quote McCoy: ""It's MVC, Jim, but not as we know it"". To build a re-frame app, you: design your app's data structure (data layer) write and register subscription functions (query layer) write Reagent component functions (view layer) write and register event handler functions (control layer and/or state transition layer) Features: The functions you write are pure, so the computational pieces of your app can be described, understood and tested independently. You won't need Dependency Injection to test. Think about that. These computational parts are composed via reactive data flows - a dynamic, unidirectional Signal graph. The resulting architecture involves ""derived data"" flowing in a two-stage, reactive loop. Without realising it, you will be explicitly modelling time. It is fast, straight out of the box. You won't have to go through this sort of pain. The surprising thing about re-frame is how simple it is. Beautifully simple! Our reference implementation is little more than 200 lines of (ClojureScript) code. Learn it in an afternoon. But it scales up nicely to more complex apps. Frameworks are just pesky overhead at small scale - measure them instead by how they help you tame the complexity of bigger apps. Re-frame is impressively buzzword compliant: it has FRP-nature, unidirectional data flow, pristinely pure functions, conveyor belts, statechart-friendliness (FSM) and claims an immaculate hammock conception. It also has a charming xkcd reference (soon) and a hilarious, insiders-joke T-shirt, ideal for conferences (in design). What could possibly go wrong? Warning: That was the summary. What follows is a long-ish tutorial/explanation. Tutorial Table of Contents What Problem Does It Solve? Guiding Philosophy FRP Clarifications Explaining re-frame On Data The Big Ratom The Benefits Of Data-In-The-One-Place Flow How Flow Happens In Reagent Components Truth Interlude Components Like Templates? React etc. Subscribe Just A Read-Only Cursor? The Signal Graph A More Efficient Signal Graph The 2nd Flow Event Flow What are events? Dispatching Events Event Handlers Routing Control Via FSM As A Reduce Derived Data, Everywhere, flowing Logging And Debugging Talking To A Server The CPU Hog Problem In Summary Where Do I Go Next Licence What Problem Does It Solve? First, we decided to build our SPA apps with ClojureScript, then we choose Reagent, then we had a problem. For all its considerable brilliance, Reagent (+ ReactJS) delivers only the 'V' part of a traditional MVC framework. But apps involve much more than V. Where does the control logic go? How is state stored & manipulated? etc. We read up on Flux, Pedestal App, Hoplon, OM, Elm, etc and re-frame is the architecture that emerged. re-frame does have M, V, and C parts but they aren't objects, they are pure functions (or pure data), and they are wired together via reactive data flows. It is sufficiently different in nature from (traditional, Smalltalk) MVC that calling it MVC would be confusing. I'd love an alternative. Perhaps it is a RACES framework - Reactive-Atom Component Event Subscription framework (I love the smell of acronym in the morning). Or, if we distill to pure essence, DDATWD - Derived Data All The Way Down. TODO: get acronym down to 3 chars! Get an image of stacked Turtles for DDATWD insider's joke, conference T-Shirt. Guiding Philosophy First, above all we believe in the one true Dan Holmsand, creator of Reagent, and his divine instrument the ratom. We genuflect towards Sweden once a day. Second, we believe in ClojureScript, immutable data and the process of building a system out of pure functions. Third, we believe that FRP is one honking great idea. You might be tempted to see Reagent as simply another of the React wrappers - a sibling to OM and quiescent. But you'll only really ""get"" Reagent when you view it as an FRP-ish library. To put that another way, I think that Reagent, at its best, is closer in nature to Hoplon or Elm than it is OM. Finally, we believe in one-way data flow. No two way data binding. We don't like read/write cursors which promote the two way flow of data. As programs get bigger, we've found that their use seems to encourage control logic into all the wrong places. FRP Clarifications We'll get to the meat in a second, I promise, but first one final, useful diversion ... Terminology in the FRP world seems to get people hot under the collar. Those who believe in continuous-time semantics might object to me describing re-frame as having FRP-nature. They'd claim that it does something different from pure FRP, which is true. But, these days, FRP seems to have become a ""big tent"" (a broad church?). Broad enough perhaps that re-frame can be in the far, top, left paddock of the tent, via a series of qualifications: re-frame has ""discrete, dynamic, asynchronous, push FRP-ish-nature"" without ""glitch free"" guarantees. (Surprisingly, ""glitch"" has specific meaning in FRP). If you are new to FRP, or reactive programming generally, browse these resources before going further (certainly read the first two): Creative Explanation Reactive Programming Backgrounder presentation (video) by Alan Dipert (co-author of Hoplon) serious pants Elm thesis And for the love of all that is good, please watch this terrific StrangeLoop presentation (40 mins). Watch what happens when you re-imagine a database as a stream!! Look at all the problems that are solved. Think about that: shared mutable state (the root of all evil), re-imagined as a stream!! Blew my socks off. re-frame tries to be Derived Data everywhere, flowing. Or perhaps, Derived Data All The Way Down (an infinite loop of Derived Data). More explanation on all these claims soon. Explaining re-frame To explain re-frame, I'll incrementally develop a diagram, describing each part as it is added. Initially, I'll be using Reagent at an intermediate to advanced level. But this is no introductory reagent tutorial and you will need to have done one of those before continuing here. Try The Introductory Tutorial or this one or Building Single Page Apps with Reagent. On Data Well-formed Data at rest is as close to perfection in programming as it gets. All the crap that had to happen to put it there however...— Fogus (@fogus) April 11, 2014 The Big Ratom Our re-frame diagram starts (very modestly) with Fogus' well-formed data at rest bit: app-db  re-frame says that you put your data into one place which we'll call app-db. Structure the data in that place, of course, and give it a schema. Now, this advice is not the slightest bit controversial for 'real' databases, right? You'd happily put all your well-formed data into PostgreSQL or MySQL. But within a running application (in memory), it is different. If you have a background in OO, this data-in-one-place business is a really, really hard one to swallow. You've spent your life breaking systems into pieces, organised around behaviour and trying to hide the data. I still wake up in a sweat some nights thinking about all that Clojure data lying around exposed and passive. But, as Fogus reminds us, data at rest is the easy bit. Believe. From here on in this document, we'll assume app-db is one of these: (def app-db  (reagent/atom {}))    ;; a Reagent atom, containing a map Although it is a Reagent atom (hereafter ratom), I'd encourage you to think of it as an in-memory database. It will contain structured data. You will need to query that data. You will perform CRUD and other transformations on it. You'll often want to transact on this database atomically, etc. So ""in-memory database"" seems a more useful paradigm than plain old map-in-atom. A clarification: app-db doesn't actually have to be a reagent/atom containing a map. It could, for example, be a datascript database. In fact, any database which is reactive (can tell you when it changes) would do. (We'd love! to be using datascript - so damn cool - but we had too much data in our apps. If you were to use it, you'd have to tweak the reference implementation a bit, perhaps using this inspiration). The reference implementation already creates and manages an internal app-db for you, you don't need to declare one yourself. The Benefits Of Data-In-The-One-Place I'm going to quote verbatim from Elm's website: There is a single source of truth. Traditional approaches force you to write a decent amount of custom and error prone code to synchronize state between many different stateful components. (The state of this widget needs to be synced with the application state, which needs to be synced with some other widget, etc.) By placing all of your state in one location, you eliminate an entire class of bugs in which two components get into inconsistent states. We also think you will end up writing much less code. That has been our observation in Elm so far. Save and Undo become quite easy. Many applications would benefit from the ability to save all application state and send it off to the server so it can be reloaded at some later date. This is extremely difficult when your application state is spread all over the place and potentially tied to objects that cannot be serialized. With a central store, this becomes very simple. Many applications would also benefit from the ability to easily undo user's actions. For example, a painting app is better with Undo. Since everything is immutable in Elm, this is also very easy. Saving past states is trivial, and you will automatically get pretty good sharing guarantees to keep the size of the snapshots down. To this list, I would briefly add two: the ability to genuinely model control via FSMs and the ability to do time travel debugging, even in a production setting. More on both soon. Hoplon takes the same approach via what they called stem cells, which is a root source of data. Flow Arguments from authority ... Everything flows, nothing stands still. (Panta rhei) No man ever steps in the same river twice for it's not the same river and he's not the same man. Heraclitus 500 BC. Who, being Greek, had never seen a frozen river. alt version. Think of an experience from your childhood. Something you remember clearly, something you can see, feel, maybe even smell, as if you were really there. After all you really were there at the time, weren’t you? How else could you remember it? But here is the bombshell: you weren’t there. Not a single atom that is in your body today was there when that event took place .... Matter flows from place to place and momentarily comes together to be you. Whatever you are, therefore, you are not the stuff of which you are made. If that does not make the hair stand up on the back of your neck, read it again until it does, because it is important. Steve Grand How Flow Happens In Reagent To implement FRP, Reagent provides a ratom and a reaction. re-frame uses both of these building blocks, so let's now make sure we understand them. ratoms behave just like normal ClojureScript atoms. You can swap! and reset! them, watch them, etc. From a ClojureScript perspective, the purpose of an atom is to hold mutable data. From a re-frame perspective, we'll tweak that paradigm slightly and view a ratom as having a value that changes over time. Seems like a subtle distinction, I know, but because of it, re-frame sees a ratom as a Signal. Pause and read this. The 2nd building block, reaction, acts a bit like a function. It's a macro which wraps some computation (a block of code) and returns a ratom holding the result of that computation. The magic thing about a reaction is that the computation it wraps will be automatically re-run whenever 'its inputs' change, producing a new output (return) value. Eh, how? Well, the computation is just a block of code, and if that code dereferences one or more ratoms, it will be automatically re-run (recomputing a new return value) whenever any of these dereferenced ratoms change. To put that yet another way, a reaction detects a computation's input Signals (aka input ratoms) and it will watch them, and when, later, it detects a change in one of them, it will re-run that computation, and it will reset! the new result of that computation into the ratom originally returned. So, the ratom returned by a reaction is itself a Signal. Its value will change over time when the computation is re-run. So, via the interplay between ratoms and reactions, values 'flow' into computations and out again, and then into further computations, etc. ""Values"" flow (propagate) through the Signal graph. But this Signal graph must be without cycles, because cycles cause mayhem! re-frame achieves a unidirectional flow. While the mechanics are different, reaction has the intent of map in Elm and defc= in Hoplon. Right, so that was a lot of words. Some code to clarify: (ns example1  (:require-macros [reagent.ratom :refer [reaction]])  ;; reaction is a macro  (:require        [reagent.core  :as    reagent]))  (def app-db  (reagent/atom {:a 1}))           ;; our root ratom  (signal)  (def ratom2  (reaction {:b (:a @app-db)}))    ;; reaction wraps a computation, returns a signal (def ratom3  (reaction (condp = (:b @ratom2)  ;; reaction wraps another computation                              0 ""World""                              1 ""Hello"")))  ;; Notice that both computations above involve de-referencing a ratom: ;;   - app-db in one case ;;   - ratom2 in the other ;; Notice that both reactions above return a ratom. ;; Those returned ratoms hold the (time varying) value of the computations.  (println @ratom2)    ;; ==>  {:b 1}       ;; a computed result, involving @app-db (println @ratom3)    ;; ==> ""Hello""       ;; a computed result, involving @ratom2  (reset!  app-db  {:a 0})       ;; this change to app-db, triggers re-computation                                ;; of ratom2                                ;; which, in turn, causes a re-computation of ratom3  (println @ratom2)    ;; ==>  {:b 0}    ;; ratom2 is result of {:b (:a @app-db)} (println @ratom3)    ;; ==> ""World""    ;; ratom3 is automatically updated too. So, in FRP-ish terms, a reaction will produce a ""stream"" of values over time (it is a Signal), accessible via the ratom it returns. Okay, that was all important background information for what is to follow. Back to the diagram ... Components Extending the diagram, we introduce components: app-db  -->  components  -->  Hiccup  When using Reagent, your primary job is to write one or more components. This is the view layer. Think about components as pure functions - data in, Hiccup out. Hiccup is ClojureScript data structures which represent DOM. Here's a trivial component: (defn greet   []   [:div ""Hello ratoms and reactions""]) And if we call it: (greet) ;; ==>  [:div ""Hello ratoms and reactions""] You'll notice that our component is a regular Clojure function, nothing special. In this case, it takes no parameters and it returns a ClojureScript vector (formatted as Hiccup). Here is a slightly more interesting (parameterised) component (function): (defn greet                    ;; greet has a parameter now   [name]                       ;; 'name' is a ratom  holding a string   [:div ""Hello ""  @name])      ;; dereference 'name' to extract the contained value  ;; create a ratom, containing a string (def n (reagent/atom ""re-frame""))  ;; call our `component` function, passing in a ratom (greet n) ;; ==>  [:div ""Hello "" ""re-frame""]    returns a vector So components are easy - at core they are a render function which turns data into Hiccup (which will later become DOM). Now, let's introduce reaction into this mix. On the one hand, I'm complicating things by doing this, because Reagent allows you to be ignorant of the mechanics I'm about to show you. (It invisibly wraps your components in a reaction allowing you to be blissfully ignorant of how the magic happens.) On the other hand, it is useful to understand exactly how the Reagent Signal graph is wired, because in a minute, when we get to subscriptions, we'll be directly using reaction, so we might as well bite the bullet here and now ... and, anyway, it is pretty easy... (defn greet                ;; a component - data in, Hiccup out.   [name]                   ;; name is a ratom   [:div ""Hello ""  @name])  ;; dereference name here, to extract the value within  (def n (reagent/atom ""re-frame""))  ;; The computation '(greet n)' returns Hiccup which is stored into 'hiccup-ratom' (def hiccup-ratom  (reaction (greet n)))    ;; <-- use of reaction !!!  ;; what is the result of the initial computation ? (println @hiccup-ratom) ;; ==>  [:div ""Hello "" ""re-frame""]    ;; returns hiccup  (a vector of stuff)  ;; now change 'n' ;; 'n' is an input Signal for the reaction above. ;; Warning: 'n' is not an input signal because it is a parameter. Rather, it is ;; because 'n' is dereferenced within the execution of the reaction's computation. ;; reaction notices what ratoms are dereferenced in its computation, and watches ;; them for changes. (reset! n ""blah"")            ;;    n changes  ;; The reaction above will notice the change to 'n' ... ;; ... and will re-run its computation ... ;; ... which will have a new ""return value""... ;; ... which will be ""reset!"" into ""hiccup-ratom"" (println @hiccup-ratom) ;; ==>   [:div ""Hello "" ""blah""]    ;; yep, there's the new value So, as n changes value over time (via a reset!), the output of the computation (greet n) changes, which in turn means that the value in hiccup-ratom changes. Both n and hiccup-ratom are FRP Signals. The Signal graph we created causes data to flow from n into hiccup-ratom. Derived Data, flowing. Truth Interlude I haven't been entirely straight with you: Reagent re-runs reactions (re-computations) via requestAnimationFrame. So a re-computation happens about 16ms after an input Signals change is detected, or after the current thread of processing finishes, whichever is the greater. So if you are in a bREPL and you run the lines of code above one after the other too quickly, you might not see the re-computation done immediately after n gets reset!, because the next animationFrame hasn't run (yet). But you could add a (reagent.core/flush) after the reset! to force re-computation to happen straight away. reaction doesn't actually return a ratom. But it returns something that has ratom-nature, so we'll happily continue believing it is a ratom and no harm will come to us. On with the rest of my lies and distortions... Components Like Templates? A component such as greet is like the templates you'd find in Django, Rails, Handlebars or Mustache -- it maps data to HTML -- except for two massive differences: you have the full power of ClojureScript available to you (generating a Clojure data structure). The downside is that these are not ""designer friendly"" HTML templates. these templates are reactive. When their input Signals change, they are automatically rerun, producing new DOM. Reagent adroitly shields you from the details, but the renderer of any component is wrapped by a reaction. If any of the the ""inputs"" to that render change, the render is rerun. React etc. Okay, so we have some unidirectional, dynamic, async, discrete FRP-ish data flow happening here. Question: To which ocean does this river of data flow? Answer: The DOM ocean. The full picture: app-db  -->  components  -->  Hiccup  -->  Reagent  -->  VDOM  -->  React  --> DOM  Best to imagine this process as a pipeline of 3 functions. Each function takes data from the previous step, and produces (derived!) data for the next step. In the next diagram, the three functions are marked (f1, f2, f3). The unmarked nodes are derived data, produced by one step, to be input to the following step. Hiccup, VDOM and DOM are all various forms of HTML markup (in our world that's data). app-db  -->  components  -->  Hiccup  -->  Reagent  -->  VDOM  -->  React  -->  DOM                f1                           f2                      f3  In abstract ClojureScript syntax terms, you could squint and imagine the process as: (-> app-db    components    ;; produces Hiccup    Reagent       ;; produces VDOM   (virtual DOM that React understands)    React         ;; produces HTML   (which magically and efficiently appears on the page).    Browser       ;; produces pixels    Monitor)      ;; produces photons? Via the interplay between ratom and reaction, changes to app-db stream into the pipeline, where it undergoes successive transformations, until pixels colour the monitor you to see. Derived Data, flowing. Every step is acting like a pure function and turning data into new data. All well and good, and nice to know, but we don't have to bother ourselves with most of the pipeline. We just write the components part and Reagent/React will look after the rest. So back we go to that part of the picture ... Subscribe components render the app's state as hiccup. app-db  -->  components  components (view layer) need to query aspects of app-db (data layer). But how? Let's pause to consider our dream solution for this part of the flow. components would: obtain data from app-db (their job is to turn this data into hiccup). obtain this data via a (possibly parameterised) query over app-db. Think database kind of query. automatically recompute their hiccup output, as the data returned by the query changes, over time use declarative queries. Components should know as little as possible about the structure of app-db. SQL? Datalog? re-frame's subscriptions are an attempt to live this dream. As you'll see, they fall short on the declarative query part, but they comfortably meet the other requirements. As a re-frame app developer, your job will be to write and register one or more ""subscription handlers"" - functions that do a named query. Your subscription functions must return a value that changes over time (a Signal). I.e. they'll be returning a reaction or, at least, the ratom produced by a reaction. Rules: components never source data directly from app-db, and instead, they use a subscription. subscriptions are only ever used by components (they are never used in, say, event handlers). Here's a component using a subscription: (defn greet         ;; outer, setup function, called once   []   (let [name-ratom  (subscribe [:name-query])]    ;; <---- subscribing happens here      (fn []        ;; the inner, render function, potentially called many times.          [:div ""Hello"" @name-ratom]))) First, note this is a Form-2 component (there are 3 forms). Previously in this document, we've used the simplest, Form-1 components (no setup was required, just render). With Form-2 components, there's a function returning a function: the returned function is the render function. Behind the scenes, Reagent will wrap this render function in a reaction to make it produce new Hiccup when its input Signals change. In our example above, that means it will rerun every time name-ratom changes. the outer function is a setup function, called once for each instance of the component. Notice the use of 'subscribe' with the parameter :name-query. That creates a Signal through which new values are supplied over time; each new value causing the returned function (the actual renderer) to be run. It is important to distinguish between a new instance of the component versus the same instance of a component reacting to a new value. Simplistically, a new component is returned for every unique value the setup function (i.e. the outer function) is called with. This allows subscriptions based on initialisation values to be created, for example:   (defn my-cmp [row-id]     (let [row-state (subscribe [row-id])]       (fn [row-id]         [:div (str ""Row: "" row-id "" is "" @row-state)]))) In this example, [my-cmp 1][my-cmp 2] will create two instances of my-cmp. Each instance will re-render when its internal row-state signal changes. subscribe is always called like this:    (subscribe  [query-id some optional query parameters]) There is only one (global) subscribe function and it takes one parameter, assumed to be a vector. The first element in the vector (shown as query-id above) identifies/names the query and the other elements are optional query parameters. With a traditional database a query might be: select * from customers where name=""blah""  In re-frame, that would be done as follows: (subscribe [:customer-query ""blah""]) which would return a ratom holding the customer state (a value which might change over time!). So let's now look at how to write and register the subscription handler for :customer-query (defn customer-query     ;; a query over 'app-db' which returns a customer    [db, [sid cid]]      ;; query fns are given 'app-db', plus vector given to subscribe    (assert (= sid :customer-query))   ;; subscription id was the first element in the vector    (reaction (get-in @db [:path :to :a :map cid])))    ;; re-runs each time db changes  ;; register our query handler (register-sub    :customer-query       ;; the id (the name of the query()    customer-query)       ;; the function which will perform the query Notice how the handler is registered to handle :customer-query subscriptions. Rules and Notes: you'll be writing one or more handlers, and you will need to register each one. handlers are functions which take two parameters: the db atom, and the vector given to subscribe. components tend to be organised into a hierarchy, often with data flowing from parent to child via parameters. So not every component needs a subscription. Very often the values passed in from a parent component are sufficient. subscriptions can only be used in Form-2 components and the subscription must be in the outer setup function and not in the inner render function. So the following is wrong (compare to the correct version above) (defn greet         ;; a Form-1 component - no inner render function   []   (let [name-ratom  (subscribe [:name-query])]    ;; Eek! subscription in renderer        [:div ""Hello"" @name-ratom])) Why is this wrong? Well, this component would be re-rendered every time app-db changed, even if the value in name-ratom (the result of the query) stayed the same. If you were to use a Form-2 component instead, and put the subscription in the outer functions, then there'll be no re-render unless the value queried (i.e. name-ratom) changed. Just A Read-Only Cursor? Subscriptions are different to read-only cursors. Yes, subscriptions abstract away (hide) the data source, like a Cursor, but they also allow for computation. To put that another way, they can create derived data from app-db (a Materialised View of app-db). Imagine that our app-db contained :items - a vector of maps. And imagine that we wanted to display these items sorted by one of their attributes. And that we only want to display the top 20 items. This is the sort of ""derived data"" which a subscription can deliver. (And as we'll see, more efficiently than a Cursor). The Signal Graph Let's sketch out the situation described above ... app-db would be a bit like this (items is a vector of maps): (def L  [{:name ""a"" :val 23 :flag ""y""}         {:name ""b"" :val 81 :flag ""n""}         {:name ""c"" :val 23 :flag ""y""}])  (def  app-db (reagent/atom  {:items L                             :sort-by :name}))     ;; sorted by the :name attribute The subscription-handler might be written: (register-sub  :sorted-items      ;; the query id  (the name of the query)  (fn [db [_]]       ;; the handler for the subscription    (reaction       (let [items      (get-in @db [:items])     ;; extract items from db             sort-attr  (get-in @db [:sort-by])]  ;; extract sort key from db           (sort-by sort-attr items)))))          ;; return them sorted Subscription handlers are given two parameters: app-db - that's a reagent/atom which holds ALL the app's state. This is the ""database"" on which we perform the ""query"". the vector originally supplied to subscribe. In our case, we ignore it. In the example above, notice that the reaction depends on the input Signal: db. If db changes, the query is re-run. In a component, we could use this query via subscribe: (defn items-list         ;; Form-2 component - outer, setup function, called once   []   (let [items   (subscribe [:sorted-items])   ;; <--   subscribe called with name         num     (reaction (count @items))     ;; Woh! a reaction based on the subscription         top-20  (reaction (take 20 @items))]  ;; Another dependent reaction      (fn []        [:div            (str ""there's "" @num "" of these suckers. Here's top 20"")     ;; rookie mistake to leave off the @            (into [:div ] (map item-render @top-20))])))   ;; item-render is another component, not shown There's a bit going on in that let, most of it tortuously contrived, just so I can show off chained reactions. Okay, okay, all I wanted really was an excuse to use the phrase ""chained reactions"". The calculation of num is done by a reaction which has items as an input Signal. And, as we saw, items is itself a reaction over two other signals (one of them the app-db). So this is a Signal Graph. Data is flowing through computation into renderer, which produce Hiccup, etc. A More Efficient Signal Graph But there is a small problem. The approach above might get inefficient, if :items gets long. Every time app-db changes, the :sorted-items query is going to be re-run and it's going to re-sort :items. But :items might not have changed. Some other part of app-db may have changed. We don't want to perform this computationally expensive re-sort each time something unrelated in app-db changes. Luckily, we can easily fix that up by tweaking our subscription function so that it chains reactions: (register-sub  :sorted-items             ;; the query id  (fn [db [_]]    (let [items      (reaction (get-in @db [:some :path :to :items]))]  ;; reaction #1          sort-attr  (reaction (get-in @db [:sort-by]))]                ;; reaction #2        (reaction (sort-by @sort-attr @items)))))                       ;; reaction #3 The original version had only one reaction which would be re-run completely each time app-db changed. This new version, has chained reactions. The 1st and 2nd reactions just extract from db. They will run each time app-db changes. But they are cheap. The 3rd one does the expensive computation using the result from the first two. That 3rd, expensive reaction will be re-run when either one of its two input Signals change, right? Not quite. reaction will only re-run the computation when one of the inputs has changed in value. reaction compares the old input Signal value with the new Signal value using identical?. Because we're using immutable data structures (thank you ClojureScript), reaction can perform near instant checks for change on even deeply nested and complex input Signals. And reaction will then stop unneeded propagation of identical? values through the Signal graph. In the example above, reaction #3 won't re-run until :items or :sort-by are different (do not test identical? to their previous value), even though app-db itself has changed (presumably somewhere else). Hideously contrived example, but I hope you get the idea. It is all screamingly efficient. Summary: you can chain reactions. a reaction will only be re-run when its input Signals test not identical? to previous value. As a result, unnecessary Signal propagation is eliminated using highly efficient checks, even for large, deep nested data structures. The 2nd Flow At the top, I said that re-frame had two data flows. The data flow from app-db to the DOM is the first half of the story. We now need to consider the 2nd part of the story: the flow in the opposite direction. While the first flow has FRP-nature, the 2nd flow does not. Well, not at first glance anyway. When I think about these two flows, I imagine one of those school diagrams showing the water cycle. Rivers taking water down to the oceans, and evaporation/clouds/wind taking water back over the mountains to fall again as rain or snow. Repeat. There is a cycle, but it is handled by two independent flows. With re-frame, it is not water that is flowing, it is data. Event Flow Events are what flow in the opposite direction. In response to user interaction, a DOM will generate events like ""clicked delete button on item 42"" or ""unticked the checkbox for 'send me spam'"". These events have to be ""handled"". The code doing this handling might mutate app state (in app-db), or request more data from the server, or POST somewhere and wait for a response, etc. In fact, all these actions ultimately result in changes to the app-db. An application has many handlers, and collectively they represent the control layer of the application. In re-frame, the backwards data flow of events happens via a conveyor belt: app-db  -->  components  -->  Hiccup  -->  Reagent  -->  VDOM  -->  React  -->  DOM  ^                                                                              |  |                                                                              v  handlers <-------------------  events  -----------------------------------------                           a ""conveyor belt"" takes events                           from the DOM to the handlers  Generally, when the user manipulates the GUI, the state of the application changes. In our case, that means the app-db will change. After all, it is the state. And the DOM presented to the user is a function of that state. So that tends to be the cycle: the user clicks something which causes an event to be dispatched a handler manages the event and causes app-db to change (mutation happens here!) which then causes a re-render the user sees something different goto #1 That's our water cycle. Because handlers are that part of the system which does app-db mutation, you could almost imagine them as a ""stored procedures"" on a database. Almost. Stretching it? We do like our in-memory database analogies. What are events? Events are data. You choose the format. In our reference implementation we choose a vector format. For example: [:delete-item 42] The first item in the vector identifies the event and the rest of the vector is the optional parameters -- in the example above, the id (42) of the item to delete. Here are some other example events:    [:yes-button-clicked]    [:set-spam-wanted false]    [[:complicated :multi :part :key] ""a parameter"" ""another one""  45.6] Rule: events are pure data. No dirty tricks like putting callback functions on the wire. You know who you are. Dispatching Events Events tend to start in the DOM in response to user actions. They are dispatched. For example, a button component might be like this:    (defn yes-button        []        [:div  {:class ""button-class""                :on-click  #(dispatch [:yes-button-clicked])}                ""Yes""]) Notice the on-click DOM handler:    #(dispatch [:yes-button-clicked]) With re-frame, we try to keep the DOM as passive as possible. We do not want our views containing any control logic. That ""on-click"" is as simple as we can make it. There's a single dispatch function in the entire framework, and it takes one parameter: the event (vector) to be dispatched (which is pure simple, lovely data, flowing). Let's update our diagram to show dispatch: app-db  -->  components  -->  Hiccup  -->  Reagent  -->  VDOM  -->  React  -->  DOM  ^                                                                              |  |                                                                              v  handlers <----------------------------------------  (dispatch [event-id  event params])  Rule: components are as passive and minimal as possible when it comes to handling events. They dispatch pure data and nothing more. Event Handlers Collectively, event handlers provide the control logic in a re-frame application. An event handler is a pure function of two parameters: current value in app-db. Note: that's the map in app-db, not the atom itself. an event (represented as a vector) It returns the new value which should be reset! into app-db. An example handler: (defn handle-delete    [app-state [_ item-id]]          ;; notice how event vector is destructured -- 2nd parameter    (dissoc-in app-state [:some :path item-id]))     ;; return a modified version of 'app-state' Handling an event invariably involves mutating the value in app-db (which is provided as the first parameter). An item is added here, or one is deleted there. So, often simple CRUD, but sometimes much more, and sometimes with async results. But the app-db mutation is ultimately handled by re-frame (it does the reset!). That leaves your event handlers pure. As a result, they tend to be easy to test and understand. Many are almost trivial. There's more to event handlers than can be covered here in this introductory tutorial. Read up on issues like Middleware in the Wiki. Routing When dispatch is passed an event vector, it just puts that event onto a conveyor belt. The consumer on the end of the conveyor is a router which will organise for that event to be processed by the right handler. app-db  -->  components  -->  Hiccup  -->  Reagent  -->  VDOM  -->  React  -->  DOM  ^                                                                              |  |                                                                              v  handlers <-----  router  <-----------------------  (dispatch [event-id  event params])  The router will: inspect the 1st element of the arriving vector look in its registry for the handler which is registered for this kind of event call that handler with two parameters: (1) the current value in app-db and (2) the event vector reset! the returned value back into app-db. As a re-frame app developer, your job is to write handlers for each kind of event, and then to register those handlers with the router. Here's how we would register our event handler: (reg-event-pure   :delete-item         ;; the event id (name)   handle-delete)       ;; the handler function for that event Any arriving event vector which has :delete-item as the first element will now be routed to our handler. Control Via FSM Above, I commented that event handlers collectively represent the ""control layer"" of the application. They contain logic which interprets arriving events and they ""step"" the application ""forward"" via mutations to app-db. Our delete-handler above is trivial, but as an application grows more features, the logic in many handlers will become more complicated, and they will have to query BOTH the current state of the app AND the arriving event vector to determine what action to take. If the app is in logical State A, and event X arrives, then the handler will move the app to logical state B (by changing values in app-db). Sound like anything you learned in those Theory Of Computation lectures? That's right - as an app becomes more complex, the handlers are likely to be collectively implementing a Finite State Machine: your app is in a certain logical state (defined by the current values in app-db) the arriving event vector represents a trigger. the event handler implements ""a transition"", subject to BOTH the current logical state and the arriving trigger. after the handler has run, the transition may have moved the app into a new logical state. Repeat. Not every app has lots of logical states, but many do, and if you are implementing one of them, then formally recognising it and using a technique like state charts will help greatly in getting a clean design and a nice datamodel. The beauty of re-frame from a FSM point of view is that all the data is in one place - unlike OO systems where the data is distributed (and synchronized) across many objects. So implementing your control logic as a FSM is both possible and natural in re-frame, whereas it is often difficult and contrived to do so in other kinds of architecture (in my experience). As A Reduce So here's another way of thinking about what's happening with this data flow - another useful mental model. First, imagine that all the events ever dispatched by a certain running app were stored in a collection. So, if when the app started, the user clicked on button X then the first item in this collection would be the event generated by that button, and then, if next the user moved a slider, the associated event would be the next item in the collection, and so on and so on. We'd end up with a collection of event vectors. Second, remind yourself that the combining function of a reduce takes two parameters: the current state of the reduction and the next collection member to fold in. Then notice that event handlers take two parameters too: the current state of app-db the next item to fold in. Which is the same as a combining function in a reduce!! So now we can introduce the new mental model: at any point in time, the value in app-db is the result of performing a reduce over the entire collection of events dispatched in the app up until that time. The combining function for this reduce is the set of handlers. It is almost like app-db is the temporary place where this imagined perpetual reduce stores its on-going reduction. Derived Data, Everywhere, flowing Have you watched that StrangeLoop presentation yet? I hope so. Database as a stream, right? If you have then, given the explanation above, you might twig to the idea that app-db is really a derived value (of the perpetual reduce). And yet, it acts as the authoritative source of state in the app. And yet, it isn't, it is simply a piece of derived state. And yet, it is the source. Hmm. This is an infinite loop of sorts. Derived data is flowing around the loop, reactively, through pure functions. There is a pause in the loop whenever we wait for a new event, but the moment we get it, it's another iteration of the ""derived data"" FRP loop. Derived values, all the way down, forever. Good news. If you've read this far, your insiders T-shirt will be arriving soon - it will feature turtles and xkcd. We're still working on the hilarious caption bit. Open a repo issue with a suggestion. Back to the more pragmatic world ... Logging And Debugging How did that exception happen, you wonder, shaking your head? What did the user do immediately prior to the exception? What state was the app in that this event was so disastrous? To debug it, you need to know this information: the state of the app immediately before the exception What final event then caused your app to fall in a screaming mess. Well, with re-frame you need to record (have available): A recent checkpoint of the app state in app-db (perhaps the initial state) all the events dispatched since the last checkpoint, up to the point where the exception occurred. Note: that's all just data. Pure, lovely loggable data. If you have that data, then you can reproduce the exception. re-frame allows you to time travel. Install the ""checkpoint"" state into app-db and then ""play forward"" through the collection dispatched events. The only way the app ""moves forwards"" is via events. ""Replaying events"" moves you step by step towards the exception causing problem. This is utterly, utterly perfect for debugging assuming, of course, you are in a position to capture a checkpoint, and the events since then. Talking To A Server Some events handlers will need to initiate an async server connection (e.g. GET or POST something). The initiating event handlers should organise that the on-success or on-fail handlers for these HTTP requests themselves simply dispatch a new event. They should never attempt to modify app-db themselves. That is always done in a handler. Notes: all events are handled via a call to dispatch. GUI events, async HTTP events, everything. dispatch will cause a handler function to be called. But the process is async. The call is queued. if you (further) dispatch in a handler, then that will be async too. The associated handler is queued for later processing. Why? Partially because handlers are given a snapshot of the app-db and can't be nested. if you kick off an HTTP request in a handler, then organise for the on-success or on-fail handlers to dispatch their outcome. All events are handled via dispatch. on-success should never ever change app-db. The wiki has more on the subject. The CPU Hog Problem Sometimes a handler has a lot of CPU intensive work to do, and getting through it will take a while. When a handler hogs the CPU, nothing else can happen. Browsers only give us one thread of execution and that CPU-hogging handler owns it, and it isn't giving it up. The UI will be frozen and there will be no processing of any other handlers (e.g. on-success of POSTs), etc., etc. Nothing. And a frozen UI is a problem. GUI repaints are not happening. And user interactions are not being processed. How are we to show progress updates like ""Hey, X% completed""? Or how can we handle the user clicking on that ""Cancel"" button trying to stop this long running process? We need a means by which long running handlers can hand control back for ""other"" processing every so often, while still continuing on with their computation. Luckily, re-frame has a solution. In Summary re-frame has two distinct flows, and I claim they are BOTH FRP in nature. The first is clearly FRP. The second one is conceptually FRP, but you do have to squint. All the parts are simple. The parts are easy to understand in isolation. The parts are composed so that derived data flows in a perpetual reactive loop, through pure functions. To build an app using re-frame, you'll have to: design your app's data structure. write and register subscription functions (query layer). write component functions (view layer). write and register event handler functions (control layer and/or state transition layer). Where Do I Go Next? Your next steps with re-frame should be: look at the examples: https://github.com/Day8/re-frame/tree/master/examples use the lein template: https://github.com/Day8/re-frame-template read more in the Wiki: https://github.com/Day8/re-frame/wiki You might also be interested in James MacAulay's excellent work (not re-frame!): https://github.com/jamesmacaulay/zelkova If you want reusable layout and widget components, consider this sister project: https://github.com/Day8/re-com Here are some open source re-frame apps you can look at for more inspiration: https://github.com/madvas/fractalify/ Licence Copyright © 2015 Michael Thompson Distributed under The MIT License (MIT) - See LICENSE.txt Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Day8/re-frame"	"– A Reagent Framework For Writing SPAs, in Clojurescript."	"true"
"Web Framework & Template"	"Tenzing"	"http://martinklepsch.github.io/tenzing/"	"– A ClojureScript template with no backend that uses Boot."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Tenzing, the awesome Clojurescript application template Tenzing, the awesome Clojurescript application template Tenzing Table of Contents Tenzing, the awesome Clojurescript application template. Rationale Why Boot? Why #noBackend? Usage Create a Project Running it Deployment License Tenzing, the awesome Clojurescript application template. Star Being inspired by the, also awesome, Chestnut template Tenzing offers the following features: Incremental Clojurescript compilation Live reloading of your Javascript, CSS, etc. Browser-REPL There are some significant differences though: Tenzing uses Boot instead of Leiningen (see below) Tenzing does not provide a backend layer (see below) Tenzing allows you to choose between Om, Reagent and others Tenzing is work in progress, please report issues as you encounter them! Rationale Why Boot? In contrast to Leiningen Boot offers a clear strategy when it comes to composing multi-step build processes such as compiling stylesheets and Javascript whenever a relevant file changes. Many Leinigen plugins come with an `auto` task that allows similar behavior. If you want to run multiple of those tasks it's usually done by starting multiple JVM instances which can lead to high memory usage. Boot allows this sort of behaviour to reside in one JVM process while making sure that build steps don't interfere with each other. You can learn more about Boot in a blog post by one of the authors, it's github project or a blog post I wrote about it. Why #noBackend? Tenzing is designed with prototyping in mind. Instead of writing your own backend you're encouraged to use services like Parse, Firebase, Usergrid and others. If you figure out that you need a Clojure based backend down the road it's simple to either add it yourself or create it as a standalone service that's being used by your clients. Please, also consider offline first as an approach for building early iterations of your application. If you're wondering how files are served during development: there is a boot task `serve` that allows you to serve static files. Usage Create a Project To create a new project we piggieback the existing lein new tooling: $ lein new tenzing your-app  There are a bunch of options that determine what your newly created project will contain: +om provides a basic Om application and adds relevant dependencies +reagent provides a basic Reagent application and adds relevant dependencies +divshot adds divshot.json for easy deployment to Divshot +garden sets up Garden and integrates into the build process +sass sets up Sass and integrates into the build process (requires libsass) +less sets up Less and integrates into the build process. If you want to add an option, pull-requests are welcome. Running it After you installed Boot you can run your Clojurescript application in ""development mode"" by executing the following: $ boot dev  After a moment of waiting you can head to localhost:3000 to see a small sample app. If you now go and edit one of the Clojurescript source files or a SASS file (if you've used the +sass option) this change will be picked up by Boot and the respective source file will get compiled. When a compiled file changes through that mechanism it will get pushed to the browser. Connecting to the browser REPL After you started your application with boot dev there will be a line printed like the following:  nREPL server started on port 63518 on host 0.0.0.0  This means there now is an nREPL server that you can connect to. You can do this with your favorite editor or just by running boot repl --client in the same directory. Once you are connected you can get into a Clojurescript REPL by running (start-repl). At this point I usually reload my browser one last time to make sure the REPL connection is properly setup. Now you can run things like (.log js/console ""test""), which should print ""test"" in the console of your browser. How it works If you look at the build and run tasks in the build.boot file of your newly created project you will see something like the following: (deftask build []   (comp (speak) 	(cljs) 	(sass :output-dir ""css"")))  (deftask run []   (comp (serve) 	(watch) 	(cljs-repl) 	(reload) 	(build)))  Basically this composes all kinds of build steps into a unified run task that will start our application. From top to bottom: The build task consists of three other tasks: speak gives us audible notifications about our build process cljs will compile Clojurescript source files to Javascript sass will compile Sass source files to CSS Now if we just run boot build instead of the aforementioned boot dev we will compile our Clojurescript and Sass exactly once and then the program will terminate. This is where the run task comes in: serve starts a webserver that will serve our compiled JS, CSS and anything else that is in resources/ watch will watch our filesystem for changes and trigger new builds when they occur cljs-repl sets up various things so we can connect to our application through a browser REPL reload will watch the compiled files for changes and push them to the browser build does the things already described above Please note that all tasks, except the one we defined ourselves have extensive documentation that you can view by running boot <taskname> -h (e.g. boot cljs-repl -h). Deployment The easiest way to deploy your app is using Divshot: $ divshot login add divshot.json (Only required if your project hasn't been created with the +divshot option.) {""name"": ""your-app"",  ""root"": ""target"",  ""clean_urls"": true,  ""error_page"": ""error.html""}  $ divshot push Since Tenzing comes without a backend you can also easily deploy your app to Amazon S3 or even host it in your Dropbox. To do that just copy the files in target/ to your desired location. PS. A nice tool to easily deploy to S3 from the command line is stout. License Copyright © 2014 Martin Klepsch Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version. Author: Martin Klepsch Created: 2015-04-11 Sat 19:56 Emacs 24.4.50.1 (Org mode 8.2.6) Validate"	"null"	"null"	"– A ClojureScript template with no backend that uses Boot."	"true"
"Web Framework & Template"	"WebFUI"	"https://github.com/drcode/webfui"	"– Client-Side Web Framework for ClojureScript."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"221"	"37"	"18"	"GitHub - drcode/webfui: Client-Side Web Framework for ClojureScript Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 37 Star 221 Fork 18 drcode/webfui Code Issues 2 Pull requests 2 Pulse Graphs Client-Side Web Framework for ClojureScript 22 commits 1 branch 0 releases Fetching contributors Clojure 97.0% JavaScript 3.0% Clojure JavaScript Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. lib src/webfui target/stale test/webfui/test webfui-examples .gitignore README.md info.txt pom.xml project.clj README.md WebFUI - Client Side Web Development Framework For ClojureScript Philosophy of WebFUI The goal of WebFUI is to let you do client-side Web programming in ClojureScript without having to ever deal with the DOM. Instead, all DOM is generated in realtime from a Clojure atom that contains just ""plain old data"" (called EDN in Clojure.) This ""DOM EDN"" is kept synchronized with a state atom that also contains EDN, where all the state for your program is kept. You, the programmer, is only responsible for providing the functions shown in red in the picture below: These functions in red can be written 100% in the functional style, which is one of the benefits of WebFUI. Also, having EDN as the arguments/results for all your app functions makes debugging/unit testing extremely easy. Finally, WebFUI code is extremely succinct- This fully-featured calculator app consists of only 92 lines of code, which includes all html generation! Note: WebFUI is still an alpha project and has limitations. Currently it only supports only Webkit based browsers (Chrome, Safari, including on Android/iOS). Tech Demo Showing Off WebFUI Here is an inverse kinematics demo written 100% in ClojureScript- Browse the source code in the webfui-examples directory. This example is pure HTML5, and using WebFUI means none of the application code directly manipulates the DOM. Click on the figure to drag it around the screen. For further demos, check out this calculator and this example of mouse interaction (drag numbers in the circle on top of each other to see what it does.) Performance Challenges One of the key design choices in WebFUI is that the DOM and the program state are strongly linked via a super simple mechanism: Any change to the state updates all the DOM. Similarly any changes to the DOM (Such as by the user entering text into a form field) updates all the state. This makes your code very simple, but can affect performance of your app. However, WebFUI mitigates the inefficiency of this two-way synchronization of state and the DOM in various ways. First of all, ClojureScript has highly-efficient persistent data structures that WebFUI can use to minimize these performance penalties. Also, WebFUI performs delta calculations during DOM changes to send as few DOM updates as possible to the web browser. Luckily, all the browser vendors are currently in a javascript performance arms race, making this less of a problem over time. Because of these optimizations, WebFUI has reasonable performance in most real-world applications (use the examples included with webfui as a guide to judge app responsiveness.) However, on some devices, such as older iPad/iPhones, Javascript is still relatively slow, and you'll notice some delays in a WebFUI-based HTML5 app. Installing WebFUI WebFUI is best installed by using leiningen. Include the following in the dependencies of your project.clj: :dependencies [[webfui ""0.2.1""]] Your application needs to be a ClojureScript application, and I recommend you use the lein-cljsbuild plugin for leiningen to build it. Compiling the Examples In the webfui-examples directory you'll see examples of webfui in action. Just run lein deps;lein cljsbuild once;lein run and fire up your Safari, Chrome, or iOS browser to ""localhost:8080"". A Simple WebFUI App Here is an entire concrete example program using WebFUI. It displays two edit fields and displays the sum of the numbers entered into those fields as a result (try it here) (ns webfui-examples.add-two-numbers.core   (:use [webfui.framework :only [launch-app]])   (:use-macros [webfui.framework.macros :only [add-dom-watch]]))  (defn render-all [state]❶   (let [{:keys [a b]} state]     [:div [:input#a {:watch :watch :value a}]❷           "" plus ""           [:input#b {:watch :watch :value b}]❸           [:p "" equals ""]           [:span (+ a b)]]))  (defn valid-integer [s]❹   (and (< (count s) 15) (re-matches #""^[0-9]+$"" s)))  (add-dom-watch :watch [state new-element]❺                (let [{:keys [value id]} (second new-element)]                  (when (valid-integer value)                    {id (js/parseInt value)})))❻  (launch-app (atom {:a 0 :b 0}) render-all)❼ How State Changes Make it to the DOM We initialize a WebFUI app by calling launch-app ❼ and supplying a state atom and the render-all ❶ function. In this example, the state consists only of the values in the edit fields named A and B. As you can see, the render-all function just transforms the state into HTML. (using the same syntax used by hiccup.) How DOM Changes Make it to the State This happens by attaching DOM watchers to the DOM. You can see right here ❷ and here ❸ that there is an attribute called watch attached to the generated html (WebFUI html can have special attributes that goes beyond standard html.) This will link the edit controls to a DOM watcher declared here ❺. The DOM watcher is responsible for updating the state to adjust to changes in the DOM: In this case, it means to update the A and B fields in the state (which it does by looking up the ID of the text field which is the same as the key in the state ❻) if the numbers entered in by the user into either text field changes. Note that the DOM watcher checks whether the fields contain valid integers with this function ❹. Because of the realtime nature of WebFUI you'll see that this automagically prevents a user from entering non-numeric values into the text fields. These DOM watchers are fundamentally different than javascript ""on__"" events in that they use a ""Show, don't tell"" design: You don't get an event object telling you what changed, but instead get a concrete look at the proposed changes to the HTML via new-element❺ (which can be compared to the state to see what was there before) that shows you what changed. Pinpoint Changes to the State As we've seen, in WebFUI the DOM is updated in a wholesale fashion from the program state, and the program state is updated wholesale from the DOM, as well. However, usually when we update our program state we want to do it in a pinpoint fashion. Because of this, the state returned from a DOM watcher is actually a delta applied to the program state: If a key is left unmentioned, it is left with its previous value, in a recursive fashion. To understand more about the model used for updating state using diffs, read the section on webfui.state-patch in this document. WebFUI Plugins WebFUI has a plugin mechanism for adding support for different types of user interaction. Plugins are used to add support for mouse actions, calculating scroll bar positions, and many more plugins are planned for the future. Read the following document to learn more about the design of WebFUI and the plugin architecture. Mouse Support/Further Documentation To learn how to handle mouse interactions in WebFUI, please check the section on mouse support in this document. License Distributed under the Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php), the same as Clojure. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/drcode/webfui"	"– Client-Side Web Framework for ClojureScript."	"true"
"Web Socket"	"Sente"	"https://github.com/ptaoussanis/sente"	"– Clojure(Script) + core.async + WebSockets/Ajax."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"1043"	"50"	"96"	"GitHub - ptaoussanis/sente: Realtime web comms for Clojure/Script Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 50 Star 1,043 Fork 96 ptaoussanis/sente Code Issues 5 Pull requests 2 Pulse Graphs Realtime web comms for Clojure/Script https://www.taoensso.com 393 commits 2 branches 32 releases 19 contributors Clojure 100.0% Clojure Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show v1.9.0 v1.9.0-beta3 v1.9.0-beta2 v1.9.0-beta1 v1.9.0-RC2 v1.9.0-RC1 v1.8.1 v1.8.0 v1.8.0-beta1 v1.7.0 v1.7.0-RC1 v1.6.0 v1.5.0 v1.4.1 v1.4.0 v1.3.0 v1.2.0 v1.1.0 v1.0.0 v0.15.1 v0.15.0 v0.14.1 v0.14.0 v0.13.0 v0.12.0 v0.11.0 v0.10.1 v0.10.0 v0.9.0 v0.8.2 v0.8.1 v0.8.0 Nothing to show New pull request Latest commit 6b8ae98 Jul 13, 2016 ptaoussanis v1.10.0-SNAPSHOT Permalink Failed to load latest commit information. example-project v1.10.0-SNAPSHOT Jul 14, 2016 src/taoensso Drop use of deprecated `async/map<` now that we're on Clojure 1.7+ Jul 14, 2016 test/taoensso/sente Update tests template Jan 26, 2016 .gitignore Update .gitignore Feb 27, 2014 CHANGELOG.md v1.9.0 Jul 6, 2016 LICENSE Initial skeleton commit Feb 24, 2014 README.md Update README version Jul 14, 2016 hero.jpg Update README template Jan 14, 2016 project.clj v1.10.0-SNAPSHOT Jul 14, 2016 README.md CHANGELOG | API | current Break Version: [com.taoensso/sente ""1.9.0""] ; BREAKING, see CHANGELOG for details Please consider helping to support my continued open-source Clojure/Script work? Even small contributions can add up + make a big difference to help sustain my time writing, maintaining, and supporting Sente and other Clojure/Script libraries. Thank you! - Peter Taoussanis Sente Realtime web comms for Clojure/Script Or: We don't need no Socket.IO Or: core.async + Ajax + WebSockets = The Shiznizzle Sente is a small client+server library that makes it easy to build reliable, high-performance realtime web applications with Clojure + ClojureScript. Sen-te (先手) is a Japanese Go term used to describe a play with such an overwhelming follow-up that it demands an immediate response, leaving its player with the initiative. (I'd also recommend checking out James Henderson's Chord and Kevin Lynagh's jetty7-websockets-async as possible alternatives!) Features Bidirectional a/sync comms over both WebSockets and Ajax (auto-fallback) It just works: auto keep-alives, buffering, protocol selection, reconnects Efficient design incl. transparent event batching for low-bandwidth use, even over Ajax Send arbitrary Clojure vals over edn or Transit (JSON, MessagePack, etc.) Tiny API: make-channel-socket! and you're good to go Automatic, sensible support for users connected with multiple clients and/or devices simultaneously Realtime info on which users are connected over which protocols (v0.10.0+) Flexible model: use it anywhere you'd use WebSockets/Ajax/Socket.IO, etc. Standard Ring security model: auth as you like, HTTPS when available, CSRF support, etc. Fully documented, with examples Small codebase: ~1.5k lines for the entire client+server implementation Supported servers: http-kit, Immutant v2+, nginx-clojure, node.js, Aleph Capabilities Protocol client>server client>server + ack/reply server>user push WebSockets ✓ (native) ✓ (emulated) ✓ (native) Ajax ✓ (emulated) ✓ (native) ✓ (emulated) So you can ignore the underlying protocol and deal directly with Sente's unified API. It's simple, and exposes the best of both WebSockets (bidirectionality + performance) and Ajax (optional evented ack/reply model). Getting started Note that there's also a variety of full example projects available Add the necessary dependency to your project: [com.taoensso/sente ""1.9.0""] On the server (Clojure) side First make sure that you're using one of the supported web servers (PRs for additional server adapters welcome!). Somewhere in your web app's code you'll already have a routing mechanism in place for handling Ring requests by request URL. If you're using Compojure for example, you'll have something that looks like this: (defroutes my-app   (GET  ""/""            req (my-landing-pg-handler  req))   (POST ""/submit-form"" req (my-form-submit-handler req))) For Sente, we're going to add 2 new URLs and setup their handlers: (ns my-server-side-routing-ns ; .clj   (:require     ;; <other stuff>     [taoensso.sente :as sente] ; <--- Add this      ;; Uncomment a web-server adapter --->     ;; [taoensso.sente.server-adapters.http-kit      :refer (get-sch-adapter)]     ;; [taoensso.sente.server-adapters.immutant      :refer (get-sch-adapter)]     ;; [taoensso.sente.server-adapters.nginx-clojure :refer (get-sch-adapter)]     ;; [taoensso.sente.server-adapters.aleph         :refer (get-sch-adapter)]   ))  ;;; Add this: ---> (let [{:keys [ch-recv send-fn connected-uids               ajax-post-fn ajax-get-or-ws-handshake-fn]}       (sente/make-channel-socket! (get-sch-adapter) {})]    (def ring-ajax-post                ajax-post-fn)   (def ring-ajax-get-or-ws-handshake ajax-get-or-ws-handshake-fn)   (def ch-chsk                       ch-recv) ; ChannelSocket's receive channel   (def chsk-send!                    send-fn) ; ChannelSocket's send API fn   (def connected-uids                connected-uids) ; Watchable, read-only atom   )  (defroutes my-app-routes   ;; <other stuff>    ;;; Add these 2 entries: --->   (GET  ""/chsk"" req (ring-ajax-get-or-ws-handshake req))   (POST ""/chsk"" req (ring-ajax-post                req))   )  (def my-app   (-> my-app-routes       ;; Add necessary Ring middleware:       ring.middleware.keyword-params/wrap-keyword-params       ring.middleware.params/wrap-params)) The ring-ajax-post and ring-ajax-get-or-ws-handshake fns will automatically handle Ring GET and POST requests to our channel socket URL (""/chsk""). Together these take care of the messy details of establishing + maintaining WebSocket or long-polling requests. On the client (ClojureScript) side You'll setup something similar on the client side: (ns my-client-side-ns ; .cljs   (:require-macros    [cljs.core.async.macros :as asyncm :refer (go go-loop)])   (:require    ;; <other stuff>    [cljs.core.async :as async :refer (<! >! put! chan)]    [taoensso.sente  :as sente :refer (cb-success?)] ; <--- Add this   ))  ;;; Add this: ---> (let [{:keys [chsk ch-recv send-fn state]}       (sente/make-channel-socket! ""/chsk"" ; Note the same path as before        {:type :auto ; e/o #{:auto :ajax :ws}        })]   (def chsk       chsk)   (def ch-chsk    ch-recv) ; ChannelSocket's receive channel   (def chsk-send! send-fn) ; ChannelSocket's send API fn   (def chsk-state state)   ; Watchable, read-only atom   ) Now what? The client will automatically initiate a WebSocket or repeating long-polling connection to your server. Client<->server events are now ready to transmit over the ch-chsk channel. Last step: you'll want to hook your own event handlers up to this channel. Please see one of the example projects for details. Client-side API ch-recv is a core.async channel that'll receive event-msgs chsk-send! is a (fn [event & [?timeout-ms ?cb-fn]]) for standard client>server req>resp calls Server-side API ch-recv is a core.async channel that'll receive event-msgs chsk-send! is a (fn [user-id event]) for async server>user PUSH calls Term Form event [<ev-id> <?ev-data>], e.g. [:my-app/some-req {:data ""data""}] server event-msg {:keys [event id ?data send-fn ?reply-fn uid ring-req client-id]} client event-msg {:keys [event id ?data send-fn]} <ev-id> A namespaced keyword like :my-app/some-req <?ev-data> An optional arbitrary edn value like {:data ""data""} :ring-req Ring map for Ajax request or WebSocket's initial handshake request :?reply-fn Present only when client requested a reply Summary So clients can use chsk-send! to send events to the server and optionally request a reply with timeout The server can likewise use chsk-send! to send events to all the clients (browser tabs, devices, etc.) of a particular connected user by his/her user-id The server can also use an event-msg's ?reply-fn to reply to a particular client event using an arbitrary edn value It's worth noting that the server>user push (chsk-send! <user-id> <event>) takes a mandatory user-id argument. See the FAQ later for more info. Ajax/Sente comparison: client>server (jayq/ajax ; Using the jayq wrapper around jQuery  {:type :post :url ""/some-url-on-server/""   :data {:name ""Rich Hickey""          :type ""Awesome""}   :timeout 8000   :success (fn [content text-status xhr]              (do-something! content))   :error   (fn [xhr text-status] (error-handler!))})  (chsk-send! ; Using Sente   [:some/request-id {:name ""Rich Hickey"" :type ""Awesome""}] ; Event   8000 ; Timeout   ;; Optional callback:   (fn [reply] ; Reply is arbitrary Clojure data     (if (sente/cb-success? reply) ; Checks for :chsk/closed, :chsk/timeout, :chsk/error       (do-something! reply)       (error-handler!)))) Some important differences to note: The Ajax request is slow to initialize, and bulky (HTTP overhead) The Sente request is pre-initialized (usu. WebSocket), and lean (edn/Transit protocol) Ajax/Sente comparison: server>user push Ajax would require clumsy long-polling setup, and wouldn't easily support users connected with multiple clients simultaneously Sente: (chsk-send! ""destination-user-id"" [:some/alert-id <arb-clj-data-payload>]) Example projects Link Description Official example Official Sente reference example, always up-to-date @danielsz/system-websockets Client-side UI, login and wiring of components @timothypratley/snakelake Multiplayer snake game with screencast walkthrough @theasp/sente-nodejs-example Ref. example adapted for Node.js servers (Express, Dog Fort) @ebellani/carpet Web+mobile interface for a remmitance application @danielsz/sente-system Ref example adapted for @danielsz/system @danielsz/sente-boot Ref example adapted for boot @seancorfield/om-sente ?? Your link here? PR's welcome! FAQ What is the user-id provided to the server>user push fn? There's now also a full user-id, client-id summary up here For the server to push events, we need a destination. Traditionally we might push to a client (e.g. browser tab). But with modern rich web applications and the increasing use of multiple simultaneous devices (tablets, mobiles, etc.) - the value of a client push is diminishing. You'll often see applications (even by Google) struggling to deal with these cases. Sente offers an out-the-box solution by pulling the concept of identity one level higher and dealing with unique users rather than clients. What constitutes a user is entirely at the discretion of each application: Each user-id may have zero or more connected clients at any given time Each user-id may survive across clients (browser tabs, devices), and sessions To give a user an identity, either set the user's :uid Ring session key OR supply a :user-id-fn (takes request, returns an identity string) to the make-channel-socket! constructor. If you want a simple per-session identity, generate a random uuid. If you want an identity that persists across sessions, try use something with semantic meaning that you may already have like a database-generated user-id, a login email address, a secure URL fragment, etc. Note that user-ids are used only for server>user push. client>server requests don't take a user-id. As of Sente v0.13.0+ it's also possible to send events to :sente/all-users-without-uid. How do I integrate Sente with my usual login/auth procedure? This is trivially easy as of Sente v0.13.0+. Please see one of the example projects for details. Will Sente work with Reactjs/Reagent/Om/Pedestel/etc.? Sure! Sente's just a client<->server comms mechanism so it'll work with any view/rendering approach you'd like. I have a strong preference for Reagent myself, so would recommend checking that out first if you're still evaluating options. What if I need to use JSON, XML, raw strings, etc.? As of v1, Sente uses an extensible client<->server serialization mechanism. It uses edn by default since this usu. gives good performance and doesn't require any external dependencies. The reference example project shows how you can plug in an alternative de/serializer. In particular, note that Sente ships with a Transit de/serializer that allows manual or smart (automatic) per-payload format selection. How do I add custom Transit read and write handlers? To add custom handlers to the TransitPacker, pass them in as writer-opts and reader-opts when creating a TransitPacker. These arguments are the same as the opts map you would pass directly to transit/writer. The code sample below shows how you would do this to add a write handler to convert Joda-Time DateTime objects to Transit time objects. (ns my-ns.app   (:require [cognitect.transit :as transit]             [taoensso.sente.packers.transit :as sente-transit])   (:import [org.joda.time DateTime ReadableInstant]))  ;; From http://increasinglyfunctional.com/2014/09/02/custom-transit-writers-clojure-joda-time/ (def joda-time-writer   (transit/write-handler     (constantly ""m"")     (fn [v] (-> ^ReadableInstant v .getMillis))     (fn [v] (-> ^ReadableInstant v .getMillis .toString))))  (def packer (sente-transit/->TransitPacker :json {:handlers {DateTime joda-time-writer}} {})) How do I route client/server events? However you like! If you don't have many events, a simple cond will probably do. Otherwise a multimethod dispatching against event ids works well (this is the approach taken in the reference example project). Security: is there HTTPS support? Yup, it's automatic for both Ajax and WebSockets. If the page serving your JavaScript (ClojureScript) is running HTTPS, your Sente channel sockets will run over HTTPS and/or the WebSocket equivalent (WSS). Security: CSRF protection? This is important. Sente has support, but you'll need to use middleware like ring-anti-forgery to generate and check CSRF codes. The ring-ajax-post handler should be covered (i.e. protected). Please see one of the example projects for a fully-baked example. Pageload: How do I know when Sente is ready client-side? You'll want to listen on the receive channel for a [:chsk/state {:first-open? true}] event. That's the signal that the socket's been established. How can server-side channel socket events modify a user's session? Update: @danielsz has kindly provided a detailed example here. Recall that server-side event-msgs are of the form {:ring-req _ :event _ :?reply-fn _}, so each server-side event is accompanied by the relevant[*] Ring request. For WebSocket events this is the initial Ring HTTP handshake request, for Ajax events it's just the Ring HTTP Ajax request. The Ring request's :session key is an immutable value, so how do you modify a session in response to an event? You won't be doing this often, but it can be handy (e.g. for login/logout forms). You've got two choices: Write any changes directly to your Ring SessionStore (i.e. the mutable state that's actually backing your sessions). You'll need the relevant user's session key, which you can find under your Ring request's :cookies key. This is flexible, but requires that you know how+where your session data is being stored. Just use regular HTTP Ajax requests for stuff that needs to modify sessions (like login/logout), since these will automatically go through the usual Ring session middleware and let you modify a session with a simple {:status 200 :session <new-session>} response. This is the strategy the reference example takes. Lifecycle management (component management/shutdown, etc.) Using something like @stuartsierra/component or @palletops/leaven? Most of Sente's state is held internally to each channel socket (the map returned from client/server calls to make-channel-socket!). The absence of global state makes things like testing, and running multiple concurrent connections easy. It also makes integration with your component management easy. The only thing you may[1] want to do on component shutdown is stop any router loops that you've created to dispatch events to handlers. The client/server side start-chsk-router! fns both return a (fn stop []) that you can call to do this. [1] The cost of not doing this is actually negligible (a single parked go thread). There's also a couple lifecycle libraries that include Sente components: @danielsz/system for use with @stuartsierra/component @palletops/bakery for use with @palletops/leaven Any other questions? If I've missed something here, feel free to open a GitHub issue or pop me an email! Contacting me / contributions Please use the project's GitHub issues page for all questions, ideas, etc. Pull requests welcome. See the project's GitHub contributors page for a list of contributors. Otherwise, you can reach me at Taoensso.com. Happy hacking! - Peter Taoussanis License Distributed under the EPL v1.0 (same as Clojure). Copyright © 2014-2016 Peter Taoussanis. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/ptaoussanis/sente"	"– Clojure(Script) + core.async + WebSockets/Ajax."	"true"
