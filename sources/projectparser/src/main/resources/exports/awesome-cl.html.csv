"category"	"name"	"url"	"description"	"star"	"stackOverflow"	"stackOverflowUrl"	"license"	"licenseUrl"	"site"	"userGuide"	"newStars"	"newWatchs"	"newForks"	"pageText"	"newStackOverflow"	"github"	"allText"	"isExist"
"README.md"	""	"https://camo.githubusercontent.com/55218fc2efd5a0aa7e7628fb0588fd13e02500f2/687474703a2f2f692e696d6775722e636f6d2f6a4c56586870632e706e67"	""	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	""	"false"
"Library Manager"	"Quicklisp"	"https://www.quicklisp.org/beta/"	"A library manager containing many libraries, with easy depencency management.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"null"	"null"	"null"	"quicklisp (Zach Beane) · GitHub Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub Zach Beane quicklisp Quicklisp Portland, Maine zach@quicklisp.org http://www.quicklisp.org/ Joined on Jul 7, 2010 404 Followers 16 Starred 6 Following Follow Overview Repositories Public activity Popular repositories quicklisp-projects 249 Metadata for projects tracked by Quicklisp. quicklisp-client 143 Quicklisp client. quicklisp-slime-helper 41 Helper library for easy Quicklisp SLIME setup quicklisp-bootstrap 25 Quicklisp bootstrap. quicklisp-controller 25 The software to build Quicklisp dists. 53 contributions in the last year Jul Aug Sep Oct Nov Dec Jan Feb Mar Apr May Jun S M T W T F S Summary of pull requests, issues opened, and commits. Learn how we count contributions. Less More Period: 1 week Filter activity 1 day 3 days 1 week 1 month Contribution activity quicklisp has no activity during this period. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/quicklisp/"	"A library manager containing many libraries, with easy depencency management.."	"true"
"Implementations"	"Standard compliance"	"http://www.sbcl.org/manual/index.html#ANSI-Conformance"	"A fork of CMUCL; compiles to machine code.. Public domain, with some parts under and."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"null"	"null"	"null"	"SBCL User Manual SBCL User Manual Table of Contents 1 Getting Support and Reporting Bugs 1.1 Volunteer Support 1.2 Commercial Support 1.3 Reporting Bugs 1.3.1 How to Report Bugs Effectively 1.3.2 Signal Related Bugs 2 Introduction 2.1 ANSI Conformance 2.2 Extensions 2.3 Idiosyncrasies 2.3.1 Declarations 2.3.2 FASL Format 2.3.3 Compiler-only Implementation 2.3.4 Defining Constants 2.3.5 Style Warnings 2.4 Development Tools 2.4.1 Editor Integration 2.4.2 Language Reference 2.4.3 Generating Executables 2.5 More SBCL Information 2.5.1 SBCL Homepage 2.5.2 Online Documentation 2.5.3 Additional Documentation Files 2.5.4 Internals Documentation 2.6 More Common Lisp Information 2.6.1 Internet Community 2.6.2 Third-party Libraries 2.6.3 Common Lisp Books 2.7 History and Implementation of SBCL 3 Starting and Stopping 3.1 Starting SBCL 3.1.1 From Shell to Lisp 3.1.2 Running from Emacs 3.1.3 Shebang Scripts 3.2 Stopping SBCL 3.2.1 Exit 3.2.2 End of File 3.2.3 Saving a Core Image 3.2.4 Exit on Errors 3.3 Command Line Options 3.3.1 Runtime Options 3.3.2 Toplevel Options 3.4 Initialization Files 3.5 Initialization and Exit Hooks 4 Compiler 4.1 Diagnostic Messages 4.1.1 Controlling Verbosity 4.1.2 Diagnostic Severity 4.1.3 Understanding Compile Diagnostics 4.1.3.1 The Parts of a Compiler Diagnostic 4.1.3.2 The Original and Actual Source 4.1.3.3 The Processing Path 4.2 Handling of Types 4.2.1 Declarations as Assertions 4.2.2 Precise Type Checking 4.2.3 Getting Existing Programs to Run 4.2.4 Implementation Limitations 4.3 Compiler Policy 4.4 Compiler Errors 4.4.1 Type Errors at Compile Time 4.4.2 Errors During Macroexpansion 4.4.3 Read Errors 4.5 Open Coding and Inline Expansion 4.6 Interpreter 5 Debugger 5.1 Debugger Entry 5.1.1 Debugger Banner 5.1.2 Debugger Invocation 5.2 Debugger Command Loop 5.3 Stack Frames 5.3.1 Stack Motion 5.3.2 How Arguments are Printed 5.3.3 Function Names 5.3.3.1 Entry Point Details 5.3.4 Debug Tail Recursion 5.3.5 Unknown Locations and Interrupts 5.4 Variable Access 5.4.1 Variable Value Availability 5.4.2 Note On Lexical Variable Access 5.5 Source Location Printing 5.5.1 How the Source is Found 5.5.2 Source Location Availability 5.6 Debugger Policy Control 5.7 Exiting Commands 5.8 Information Commands 5.9 Function Tracing 5.10 Single Stepping 5.11 Enabling and Disabling the Debugger 6 Efficiency 6.1 Slot access 6.1.1 Structure object slot access 6.1.2 Standard object slot access 6.2 Dynamic-extent allocation 6.3 Modular arithmetic 6.4 Global and Always-Bound variables 6.5 Miscellaneous Efficiency Issues 7 Beyond the ANSI Standard 7.1 Reader Extensions 7.2 Package-Local Nicknames 7.3 Package Variance 7.4 Garbage Collection 7.4.1 Finalization 7.4.2 Weak Pointers 7.4.3 Introspection and Tuning 7.5 Metaobject Protocol 7.5.1 AMOP Compatibility of Metaobject Protocol 7.5.2 Metaobject Protocol Extensions 7.6 Extensible Sequences 7.6.1 Iterator Protocol 7.6.2 Simple Iterator Protocol 7.7 Support For Unix 7.7.1 Command-line arguments 7.7.2 Querying the process environment 7.7.3 Running external programs 7.8 Unicode Support 7.8.1 Unicode property access 7.8.2 String operations 7.8.3 Breaking strings 7.9 Customization Hooks for Users 7.10 Tools To Help Developers 7.11 Resolution of Name Conflicts 7.12 Hash Table Extensions 7.13 Random Number Generation 7.14 Miscellaneous Extensions 7.15 Stale Extensions 7.16 Efficiency Hacks 8 Foreign Function Interface 8.1 Introduction to the Foreign Function Interface 8.2 Foreign Types 8.2.1 Defining Foreign Types 8.2.2 Foreign Types and Lisp Types 8.2.3 Foreign Type Specifiers 8.3 Operations On Foreign Values 8.3.1 Accessing Foreign Values 8.3.1.1 Untyped memory 8.3.2 Coercing Foreign Values 8.3.3 Foreign Dynamic Allocation 8.4 Foreign Variables 8.4.1 Local Foreign Variables 8.4.2 External Foreign Variables 8.5 Foreign Data Structure Examples 8.6 Loading Shared Object Files 8.7 Foreign Function Calls 8.7.1 The alien-funcall Primitive 8.7.2 The define-alien-routine Macro 8.7.3 define-alien-routine Example 8.7.4 Calling Lisp From C 8.8 Step-By-Step Example of the Foreign Function Interface 9 Pathnames 9.1 Lisp Pathnames 9.1.1 Home Directory Specifiers 9.1.2 The SYS Logical Pathname Host 9.2 Native Filenames 10 Streams 10.1 External Formats 10.2 Bivalent Streams 10.3 Gray Streams 10.3.1 Gray Streams classes 10.3.2 Methods common to all streams 10.3.3 Input stream methods 10.3.4 Character input stream methods 10.3.5 Output stream methods 10.3.6 Character output stream methods 10.3.7 Binary stream methods 10.3.8 Gray Streams examples 10.3.8.1 Character counting input stream 10.3.8.2 Output prefixing character stream 10.4 Simple Streams 11 Package Locks 11.1 Package Lock Concepts 11.1.1 Package Locking Overview 11.1.2 Implementation Packages 11.1.3 Package Lock Violations 11.1.3.1 Lexical Bindings and Declarations 11.1.3.2 Other Operations 11.1.4 Package Locks in Compiled Code 11.1.4.1 Interned Symbols 11.1.4.2 Other Limitations on Compiled Code 11.1.5 Operations Violating Package Locks 11.1.5.1 Operations on Packages 11.1.5.2 Operations on Symbols 11.2 Package Lock Dictionary 12 Threading 12.1 Threading basics 12.1.1 Thread Objects 12.1.2 Making, Returning From, Joining, and Yielding Threads 12.1.3 Asynchronous Operations 12.1.4 Miscellaneous Operations 12.1.5 Error Conditions 12.2 Special Variables 12.3 Atomic Operations CAS Protocol 12.4 Mutex Support 12.5 Semaphores 12.6 Waitqueue/condition variables 12.7 Barriers 12.8 Sessions/Debugging 12.9 Foreign threads 12.10 Implementation (Linux x86/x86-64) 13 Timers 13.1 Timer Dictionary 14 Networking 14.1 Sockets Overview 14.2 General Sockets 14.3 Socket Options 14.4 INET Domain Sockets 14.5 Local (Unix) Domain Sockets 14.6 Name Service 15 Profiling 15.1 Deterministic Profiler 15.2 Statistical Profiler 15.2.1 Example Usage 15.2.2 Output 15.2.3 Platform support 15.2.4 Macros 15.2.5 Functions 15.2.6 Variables 15.2.7 Credits 16 Contributed Modules 16.1 sb-aclrepl 16.1.1 Usage 16.1.2 Example Initialization 16.1.3 Credits 16.2 sb-concurrency 16.2.1 Queue 16.2.2 Mailbox (lock-free) 16.2.3 Gates 16.2.4 Frlocks, aka Fast Read Locks 16.3 sb-cover 16.3.1 Example Usage 16.3.2 Functions 16.4 sb-grovel 16.4.1 Using sb-grovel in your own ASDF system 16.4.2 Contents of a grovel-constants-file 16.4.3 Programming with sb-grovel’s structure types 16.4.3.1 Traps and Pitfalls 16.5 sb-md5 16.5.1 Credits 16.6 sb-posix 16.6.1 Lisp names for C names 16.6.2 Types 16.6.2.1 File-descriptors 16.6.2.2 Filenames 16.6.3 Function Parameters 16.6.4 Function Return Values 16.6.5 Lisp objects and C structures 16.6.6 Functions with idiosyncratic bindings 16.7 sb-queue 16.8 sb-rotate-byte 17 Deprecation 17.1 Why Deprecate? 17.2 The Deprecation Pipeline 17.3 Deprecation Conditions 17.4 Introspecting Deprecation Information 17.5 Deprecation Declaration 17.6 Deprecation Examples 17.7 Deprecated Interfaces in SBCL 17.7.1 List of Deprecated Interfaces 17.7.1.1 Early Deprecation 17.7.1.2 Late Deprecation 17.7.1.3 Final Deprecation 17.7.2 Historical Interfaces Appendix A Concept Index Appendix B Function Index Appendix C Variable Index Appendix D Type Index Colophon Next: Getting Support and Reporting Bugs, Up: (dir)   [Contents][Index] sbcl This manual is part of the SBCL software system. See the README file for more information. This manual is largely derived from the manual for the CMUCL system, which was produced at Carnegie Mellon University and later released into the public domain. This manual is in the public domain and is provided with absolutely no warranty. See the COPYING and CREDITS files for more information. • Getting Support and Reporting Bugs:    • Introduction:    • Starting and Stopping:    • Compiler:    • Debugger:    • Efficiency:    • Beyond the ANSI Standard:    • Foreign Function Interface:    • Pathnames:    • Streams:    • Package Locks:    • Threading:    • Timers:    • Networking:    • Profiling:    • Contributed Modules:    • Deprecation:    • Concept Index:    • Function Index:    • Variable Index:    • Type Index:    • Colophon:    Next: Introduction, Previous: Top, Up: Top   [Contents][Index] 1 Getting Support and Reporting Bugs • Volunteer Support:    • Commercial Support:    • Reporting Bugs:    Next: Commercial Support, Up: Getting Support and Reporting Bugs   [Contents][Index] 1.1 Volunteer Support Your primary source of SBCL support should probably be the mailing list sbcl-help: in addition to other users SBCL developers monitor this list and are available for advice. As an anti-spam measure subscription is required for posting:     https://lists.sourceforge.net/lists/listinfo/sbcl-help Remember that the people answering your question are volunteers, so you stand a much better chance of getting a good answer if you ask a good question. Before sending mail, check the list archives at either     http://sourceforge.net/mailarchive/forum.php?forum_name=sbcl-help or     http://news.gmane.org/gmane.lisp.steel-bank.general to see if your question has been answered already. Checking the bug database is also worth it See Reporting Bugs, to see if the issue is already known. For general advice on asking good questions, see     http://www.catb.org/~esr/faqs/smart-questions.html. Next: Reporting Bugs, Previous: Volunteer Support, Up: Getting Support and Reporting Bugs   [Contents][Index] 1.2 Commercial Support There is no formal organization developing SBCL, but if you need a paid support arrangement or custom SBCL development, we maintain the list of companies and consultants below. Use it to identify service providers with appropriate skills and interests, and contact them directly. The SBCL project cannot verify the accuracy of the information or the competence of the people listed, and they have provided their own blurbs below: you must make your own judgement of suitability from the available information - refer to the links they provide, the CREDITS file, mailing list archives, CVS commit messages, and so on. Please feel free to ask for advice on the sbcl-help list. (At present, no companies or consultants wish to advertise paid support or custom SBCL development in this manual). Previous: Commercial Support, Up: Getting Support and Reporting Bugs   [Contents][Index] 1.3 Reporting Bugs SBCL uses Launchpad to track bugs. The bug database is available at     https://bugs.launchpad.net/sbcl Reporting bugs there requires registering at Launchpad. However, bugs can also be reported on the mailing list sbcl-bugs, which is moderated but does not require subscribing. Simply send email to sbcl-bugs@lists.sourceforge.net and the bug will be checked and added to Launchpad by SBCL maintainers. 1.3.1 How to Report Bugs Effectively Please include enough information in a bug report that someone reading it can reproduce the problem, i.e. don’t write Subject: apparent bug in PRINT-OBJECT (or *PRINT-LENGTH*?) PRINT-OBJECT doesn't seem to work with *PRINT-LENGTH*. Is this a bug?  but instead Subject: apparent bug in PRINT-OBJECT (or *PRINT-LENGTH*?) In sbcl-1.2.3 running under OpenBSD 4.5 on my Alpha box, when I compile and load the file    (DEFSTRUCT (FOO (:PRINT-OBJECT (LAMBDA (X Y)                                     (LET ((*PRINT-LENGTH* 4))                                       (PRINT X Y)))))      X Y) then at the command line type    (MAKE-FOO) the program loops endlessly instead of printing the object.  A more in-depth discussion on reporting bugs effectively can be found at     http://www.chiark.greenend.org.uk/~sgtatham/bugs.html. 1.3.2 Signal Related Bugs If you run into a signal related bug, you are getting fatal errors such as signal N is [un]blocked or just hangs, and you want to send a useful bug report then: Compile SBCL with ldb support (feature :sb-ldb, see base-target-features.lisp-expr) and change #define QSHOW_SIGNAL 0 to #define QSHOW_SIGNAL 1 in src/runtime/runtime.h. Isolate a smallish test case, run it. If it just hangs kill it with sigabrt: kill -ABRT <pidof sbcl>. Print the backtrace from ldb by typing ba. Attach gdb: gdb -p <pidof sbcl> and get backtraces for all threads: thread apply all ba. If multiple threads are in play then still in gdb, try to get Lisp backtrace for all threads: thread apply all call backtrace_from_fp($ebp, 100). Substitute $ebp with $rbp on x86-64. The backtraces will appear in the stdout of the SBCL process. Send a report with the backtraces and the output (both stdout and stderr) produced by SBCL. Don’t forget to include OS and SBCL version. If available, include information on outcome of the same test with other versions of SBCL, OS, ... Next: Starting and Stopping, Previous: Getting Support and Reporting Bugs, Up: Top   [Contents][Index] 2 Introduction SBCL is a mostly-conforming implementation of the ANSI Common Lisp standard. This manual focuses on behavior which is specific to SBCL, not on behavior which is common to all implementations of ANSI Common Lisp. • ANSI Conformance:    • Extensions:    • Idiosyncrasies:    • Development Tools:    • More SBCL Information:    • More Common Lisp Information:    • History and Implementation of SBCL:    Next: Extensions, Up: Introduction   [Contents][Index] 2.1 ANSI Conformance Essentially every type of non-conformance is considered a bug. (The exceptions involve internal inconsistencies in the standard.) See Reporting Bugs. Next: Idiosyncrasies, Previous: ANSI Conformance, Up: Introduction   [Contents][Index] 2.2 Extensions SBCL comes with numerous extensions, some in core and some in modules loadable with require. Unfortunately, not all of these extensions have proper documentation yet. System Definition Tool asdf is a flexible and popular protocol-oriented system definition tool by Daniel Barlow. See (asdf)the asdf manual, for more information. Foreign Function Interface sb-alien package allows interfacing with C-code, loading shared object files, etc. See Foreign Function Interface. sb-grovel can be used to partially automate generation of foreign function interface definitions. See sb-grovel. Recursive Event Loop SBCL provides a recursive event loop (serve-event) for doing non-blocking IO on multiple streams without using threads. Metaobject Protocol sb-mop package provides a metaobject protocol for the Common Lisp Object System as described in Art of Metaobject Protocol. Extensible Sequences SBCL allows users to define subclasses of the sequence class. See Extensible Sequences. Native Threads SBCL has native threads on x86/Linux, capable of taking advantage of SMP on multiprocessor machines. See Threading. Network Interface sb-bsd-sockets is a low-level networking interface, providing both TCP and UDP sockets. See Networking. Introspective Facilities sb-introspect module offers numerous introspective extensions, including access to function lambda-lists and a cross referencing facility. Operating System Interface sb-ext contains a number of functions for running external processes, accessing environment variables, etc. sb-posix module provides a lispy interface to standard POSIX facilities. Extensible Streams sb-gray is an implementation of Gray Streams. See Gray Streams. sb-simple-streams is an implementation of the simple streams API proposed by Franz Inc. See Simple Streams. Profiling sb-profile is a exact per-function profiler. See Deterministic Profiler. sb-sprof is a statistical profiler, capable of call-graph generation and instruction level profiling, which also supports allocation profiling. See Statistical Profiler. Customization Hooks SBCL contains a number of extra-standard customization hooks that can be used to tweak the behaviour of the system. See Customization Hooks for Users. sb-aclrepl provides an Allegro CL -style toplevel for SBCL, as an alternative to the classic CMUCL-style one. See sb-aclrepl. CLTL2 Compatibility Layer sb-cltl2 module provides compiler-let and environment access functionality described in Common Lisp The Language, 2nd Edition which were removed from the language during the ANSI standardization process. Executable Delivery The :executable argument to Function sb-ext:save-lisp-and-die can produce a ‘standalone’ executable containing both an image of the current Lisp session and an SBCL runtime. Bitwise Rotation sb-rotate-byte provides an efficient primitive for bitwise rotation of integers, an operation required by e.g. numerous cryptographic algorithms, but not available as a primitive in ANSI Common Lisp. See sb-rotate-byte. Test Harness sb-rt module is a simple yet attractive regression and unit-test framework. MD5 Sums sb-md5 is an implementation of the MD5 message digest algorithm for Common Lisp, using the modular arithmetic optimizations provided by SBCL. See sb-md5. Next: Development Tools, Previous: Extensions, Up: Introduction   [Contents][Index] 2.3 Idiosyncrasies The information in this section describes some of the ways that SBCL deals with choices that the ANSI standard leaves to the implementation. • Declarations:    • FASL Format:    • Compiler-only Implementation:    • Defining Constants:    • Style Warnings:    Next: FASL Format, Up: Idiosyncrasies   [Contents][Index] 2.3.1 Declarations Declarations are generally treated as assertions. This general principle, and its implications, and the bugs which still keep the compiler from quite satisfying this principle, are discussed in Declarations as Assertions. Next: Compiler-only Implementation, Previous: Declarations, Up: Idiosyncrasies   [Contents][Index] 2.3.2 FASL Format SBCL fasl-format is binary compatible only with the exact SBCL version it was generated with. While this is obviously suboptimal, it has proven more robust than trying to maintain fasl compatibility across versions: accidentally breaking things is far too easy, and can lead to hard to diagnose bugs. The following snippet handles fasl recompilation automatically for ASDF-based systems, and makes a good candidate for inclusion in the user or system initialization file (see Initialization Files.) (require :asdf)  ;;; If a fasl was stale, try to recompile and load (once). (defmethod asdf:perform :around ((o asdf:load-op)                                  (c asdf:cl-source-file))    (handler-case (call-next-method o c)       ;; If a fasl was stale, try to recompile and load (once).       (sb-ext:invalid-fasl ()          (asdf:perform (make-instance 'asdf:compile-op) c)          (call-next-method))))  Next: Defining Constants, Previous: FASL Format, Up: Idiosyncrasies   [Contents][Index] 2.3.3 Compiler-only Implementation SBCL is essentially a compiler-only implementation of Common Lisp. That is, for all but a few special cases, eval creates a lambda expression, calls compile on the lambda expression to create a compiled function, and then calls funcall on the resulting function object. A more traditional interpreter is also available on default builds; it is usually only called internally. This is explicitly allowed by the ANSI standard, but leads to some oddities; e.g. at default settings, functionp and compiled-function-p are equivalent, and they collapse into the same function when SBCL is built without the interpreter. Next: Style Warnings, Previous: Compiler-only Implementation, Up: Idiosyncrasies   [Contents][Index] 2.3.4 Defining Constants SBCL is quite strict about ANSI’s definition of defconstant. ANSI says that doing defconstant of the same symbol more than once is undefined unless the new value is eql to the old value. Conforming to this specification is a nuisance when the “constant” value is only constant under some weaker test like string= or equal. It’s especially annoying because, in SBCL, defconstant takes effect not only at load time but also at compile time, so that just compiling and loading reasonable code like (defconstant +foobyte+ '(1 4))  runs into this undefined behavior. Many implementations of Common Lisp try to help the programmer around this annoyance by silently accepting the undefined code and trying to do what the programmer probably meant. SBCL instead treats the undefined behavior as an error. Often such code can be rewritten in portable ANSI Common Lisp which has the desired behavior. E.g., the code above can be given an exactly defined meaning by replacing defconstant either with defparameter or with a customized macro which does the right thing, e.g. (defmacro define-constant (name value &optional doc)   `(defconstant ,name (if (boundp ',name) (symbol-value ',name) ,value)                       ,@(when doc (list doc))))  or possibly along the lines of the defconstant-eqx macro used internally in the implementation of SBCL itself. In circumstances where this is not appropriate, the programmer can handle the condition type sb-ext:defconstant-uneql, and choose either the continue or abort restart as appropriate. Previous: Defining Constants, Up: Idiosyncrasies   [Contents][Index] 2.3.5 Style Warnings SBCL gives style warnings about various kinds of perfectly legal code, e.g. defmethod without a preceding defgeneric; multiple defuns of the same symbol in different units; special variables not named in the conventional *foo* style, and lexical variables unconventionally named in the *foo* style This causes friction with people who point out that other ways of organizing code (especially avoiding the use of defgeneric) are just as aesthetically stylish. However, these warnings should be read not as “warning, bad aesthetics detected, you have no style” but “warning, this style keeps the compiler from understanding the code as well as you might like.” That is, unless the compiler warns about such conditions, there’s no way for the compiler to warn about some programming errors which would otherwise be easy to overlook. (Related bug: The warning about multiple defuns is pointlessly annoying when you compile and then load a function containing defun wrapped in eval-when, and ideally should be suppressed in that case, but still isn’t as of SBCL 0.7.6.) Next: More SBCL Information, Previous: Idiosyncrasies, Up: Introduction   [Contents][Index] 2.4 Development Tools • Editor Integration:    • Language Reference:    • Generating Executables:    Next: Language Reference, Up: Development Tools   [Contents][Index] 2.4.1 Editor Integration Though SBCL can be used running “bare”, the recommended mode of development is with an editor connected to SBCL, supporting not only basic lisp editing (paren-matching, etc), but providing among other features an integrated debugger, interactive compilation, and automated documentation lookup. Currently SLIME1 (Superior Lisp Interaction Mode for Emacs) together with Emacs is recommended for use with SBCL, though other options exist as well. SLIME can be downloaded from http://www.common-lisp.net/project/slime/. Next: Generating Executables, Previous: Editor Integration, Up: Development Tools   [Contents][Index] 2.4.2 Language Reference CLHS (Common Lisp Hyperspec) is a hypertext version of the ANSI standard, made freely available by LispWorks – an invaluable reference. See: http://www.lispworks.com/reference/HyperSpec/index.html Previous: Language Reference, Up: Development Tools   [Contents][Index] 2.4.3 Generating Executables SBCL can generate stand-alone executables. The generated executables include the SBCL runtime itself, so no restrictions are placed on program functionality. For example, a deployed program can call compile and load, which requires the compiler to be present in the executable. For further information, See Function sb-ext:save-lisp-and-die. Next: More Common Lisp Information, Previous: Development Tools, Up: Introduction   [Contents][Index] 2.5 More SBCL Information • SBCL Homepage:    • Online Documentation:    • Additional Documentation Files:    • Internals Documentation:    Next: Online Documentation, Up: More SBCL Information   [Contents][Index] 2.5.1 SBCL Homepage The SBCL website at http://www.sbcl.org/ has some general information, plus links to mailing lists devoted to SBCL, and to archives of these mailing lists. Subscribing to the mailing lists sbcl-help and sbcl-announce is recommended: both are fairly low-volume, and help you keep abreast with SBCL development. Next: Additional Documentation Files, Previous: SBCL Homepage, Up: More SBCL Information   [Contents][Index] 2.5.2 Online Documentation Documentation for non-ANSI extensions for various commands is available online from the SBCL executable itself. The extensions for functions which have their own command prompts (e.g. the debugger, and inspect) are documented in text available by typing help at their command prompts. The extensions for functions which don’t have their own command prompt (such as trace) are described in their documentation strings, unless your SBCL was compiled with an option not to include documentation strings, in which case the documentation strings are only readable in the source code. Next: Internals Documentation, Previous: Online Documentation, Up: More SBCL Information   [Contents][Index] 2.5.3 Additional Documentation Files Besides this user manual both SBCL source and binary distributions include some other SBCL-specific documentation files, which should be installed along with this manual on your system, e.g. in /usr/local/share/doc/sbcl/. COPYING Licence and copyright summary. CREDITS Authorship information on various parts of SBCL. INSTALL Covers installing SBCL from both source and binary distributions on your system, and also has some installation related troubleshooting information. NEWS Summarizes changes between various SBCL versions. Previous: Additional Documentation Files, Up: More SBCL Information   [Contents][Index] 2.5.4 Internals Documentation If you’re interested in the development of the SBCL system itself, then subscribing to sbcl-devel is a good idea. SBCL internals documentation – besides comments in the source – is currently maintained as a wiki-like website: http://sbcl-internals.cliki.net/. Some low-level information describing the programming details of the conversion from CMUCL to SBCL is available in the doc/FOR-CMUCL-DEVELOPERS file in the SBCL distribution, though it is not installed by default. Next: History and Implementation of SBCL, Previous: More SBCL Information, Up: Introduction   [Contents][Index] 2.6 More Common Lisp Information • Internet Community:    • Third-party Libraries:    • Common Lisp Books:    Next: Third-party Libraries, Up: More Common Lisp Information   [Contents][Index] 2.6.1 Internet Community The Common Lisp internet community is fairly diverse: news://comp.lang.lisp is fairly high volume newsgroup, but has a rather poor signal/noise ratio. Various special interest mailing lists and IRC tend to provide more content and less flames. http://www.lisp.org and http://www.cliki.net contain numerous pointers places in the net where lispers talks shop. Next: Common Lisp Books, Previous: Internet Community, Up: More Common Lisp Information   [Contents][Index] 2.6.2 Third-party Libraries For a wealth of information about free Common Lisp libraries and tools we recommend checking out CLiki: http://www.cliki.net/. Previous: Third-party Libraries, Up: More Common Lisp Information   [Contents][Index] 2.6.3 Common Lisp Books If you’re not a programmer and you’re trying to learn, many introductory Lisp books are available. However, we don’t have any standout favorites. If you can’t decide, try checking the Usenet news://comp.lang.lisp FAQ for recent recommendations. If you are an experienced programmer in other languages but need to learn about Common Lisp, some books stand out: Practical Common Lisp, by Peter Seibel An excellent introduction to the language, covering both the basics and “advanced topics” like macros, CLOS, and packages. Available both in print format and on the web: http://www.gigamonkeys.com/book/. Paradigms Of Artificial Intelligence Programming, by Peter Norvig Good information on general Common Lisp programming, and many nontrivial examples. Whether or not your work is AI, it’s a very good book to look at. On Lisp, by Paul Graham An in-depth treatment of macros, but not recommended as a first Common Lisp book, since it is slightly pre-ANSI so you need to be on your guard against non-standard usages, and since it doesn’t really even try to cover the language as a whole, focusing solely on macros. Downloadable from http://www.paulgraham.com/onlisp.html. Object-Oriented Programming In Common Lisp, by Sonya Keene With the exception of Practical Common Lisp most introductory books don’t emphasize CLOS. This one does. Even if you’re very knowledgeable about object oriented programming in the abstract, it’s worth looking at this book if you want to do any OO in Common Lisp. Some abstractions in CLOS (especially multiple dispatch) go beyond anything you’ll see in most OO systems, and there are a number of lesser differences as well. This book tends to help with the culture shock. Art Of Metaobject Programming, by Gregor Kiczales et al. Currently the prime source of information on the Common Lisp Metaobject Protocol, which is supported by SBCL. Section 2 (Chapters 5 and 6) are freely available at http://www.lisp.org/mop/. Previous: More Common Lisp Information, Up: Introduction   [Contents][Index] 2.7 History and Implementation of SBCL You can work productively with SBCL without knowing or understanding anything about where it came from, how it is implemented, or how it extends the ANSI Common Lisp standard. However, a little knowledge can be helpful in order to understand error messages, to troubleshoot problems, to understand why some parts of the system are better debugged than others, and to anticipate which known bugs, known performance problems, and missing extensions are likely to be fixed, tuned, or added. SBCL is descended from CMUCL, which is itself descended from Spice Lisp, including early implementations for the Mach operating system on the IBM RT, back in the 1980s. Some design decisions from that time are still reflected in the current implementation: The system expects to be loaded into a fixed-at-compile-time location in virtual memory, and also expects the location of all of its heap storage to be specified at compile time. The system overcommits memory, allocating large amounts of address space from the system (often more than the amount of virtual memory available) and then failing if ends up using too much of the allocated storage. The system is implemented as a C program which is responsible for supplying low-level services and loading a Lisp .core file. SBCL also inherited some newer architectural features from CMUCL. The most important is that on some architectures it has a generational garbage collector (“GC”), which has various implications (mostly good) for performance. These are discussed in another chapter, Efficiency. SBCL has diverged from CMUCL in that SBCL is now essentially a “compiler-only implementation” of Common Lisp. This is a change in implementation strategy, taking advantage of the freedom “any of these facilities might share the same execution strategy” guaranteed in the ANSI specification section 3.1 (“Evaluation”). It does not mean SBCL can’t be used interactively, and in fact the change is largely invisible to the casual user, since SBCL still can and does execute code interactively by compiling it on the fly. (It is visible if you know how to look, like using compiled-function-p; and it is visible in the way that SBCL doesn’t have many bugs which behave differently in interpreted code than in compiled code.) What it means is that in SBCL, the eval function only truly “interprets” a few easy kinds of forms, such as symbols which are boundp. More complicated forms are evaluated by calling compile and then calling funcall on the returned result. The direct ancestor of SBCL is the x86 port of CMUCL. This port was in some ways the most cobbled-together of all the CMUCL ports, since a number of strange changes had to be made to support the register-poor x86 architecture. Some things (like tracing and debugging) do not work particularly well there. SBCL should be able to improve in these areas (and has already improved in some other areas), but it takes a while. On the x86 SBCL – like the x86 port of CMUCL – uses a conservative GC. This means that it doesn’t maintain a strict separation between tagged and untagged data, instead treating some untagged data (e.g. raw floating point numbers) as possibly-tagged data and so not collecting any Lisp objects that they point to. This has some negative consequences for average time efficiency (though possibly no worse than the negative consequences of trying to implement an exact GC on a processor architecture as register-poor as the X86) and also has potentially unlimited consequences for worst-case memory efficiency. In practice, conservative garbage collectors work reasonably well, not getting anywhere near the worst case. But they can occasionally cause odd patterns of memory usage. The fork from CMUCL was based on a major rewrite of the system bootstrap process. CMUCL has for many years tolerated a very unusual “build” procedure which doesn’t actually build the complete system from scratch, but instead progressively overwrites parts of a running system with new versions. This quasi-build procedure can cause various bizarre bootstrapping hangups, especially when a major change is made to the system. It also makes the connection between the current source code and the current executable more tenuous than in other software systems – it’s easy to accidentally “build” a CMUCL system containing characteristics not reflected in the current version of the source code. Other major changes since the fork from CMUCL include SBCL has removed many CMUCL extensions, (e.g. IP networking, remote procedure call, Unix system interface, and X11 interface) from the core system. Most of these are available as contributed modules (distributed with SBCL) or third-party modules instead. SBCL has deleted or deprecated some nonstandard features and code complexity which helped efficiency at the price of maintainability. For example, the SBCL compiler no longer implements memory pooling internally (and so is simpler and more maintainable, but generates more garbage and runs more slowly), and various block-compilation efficiency-increasing extensions to the language have been deleted or are no longer used in the implementation of SBCL itself. Next: Compiler, Previous: Introduction, Up: Top   [Contents][Index] 3 Starting and Stopping • Starting SBCL:    • Stopping SBCL:    • Command Line Options:    • Initialization Files:    • Initialization and Exit Hooks:    Next: Stopping SBCL, Up: Starting and Stopping   [Contents][Index] 3.1 Starting SBCL • Running from Shell:    • Running from Emacs:    • Shebang Scripts:    Next: Running from Emacs, Up: Starting SBCL   [Contents][Index] 3.1.1 From Shell to Lisp To run SBCL type sbcl at the command line. You should end up in the toplevel REPL (read, eval, print -loop), where you can interact with SBCL by typing expressions. $ sbcl This is SBCL 0.8.13.60, an implementation of ANSI Common Lisp. More information about SBCL is available at <http://www.sbcl.org/>.  SBCL is free software, provided as is, with absolutely no warranty. It is mostly in the public domain; some portions are provided under BSD-style licenses.  See the CREDITS and COPYING files in the distribution for more information. * (+ 2 2)  4 * (exit) $  See also Command Line Options and Stopping SBCL. Next: Shebang Scripts, Previous: Running from Shell, Up: Starting SBCL   [Contents][Index] 3.1.2 Running from Emacs To run SBCL as an inferior-lisp from Emacs in your .emacs do something like: ;;; The SBCL binary and command-line arguments (setq inferior-lisp-program ""/usr/local/bin/sbcl --noinform"")  For more information on using SBCL with Emacs, see Editor Integration. Previous: Running from Emacs, Up: Starting SBCL   [Contents][Index] 3.1.3 Shebang Scripts Standard Unix tools that are interpreters follow a common command line protocol that is necessary to work with “shebang scripts”. SBCL supports this via the --script command line option. Example file (hello.lisp): #!/usr/local/bin/sbcl --script (write-line ""Hello, World!"")  Usage examples: $ ./hello.lisp Hello, World!  $ sbcl --script hello.lisp Hello, World!  Next: Command Line Options, Previous: Starting SBCL, Up: Starting and Stopping   [Contents][Index] 3.2 Stopping SBCL • Exit:    • End of File:    • Saving a Core Image:    • Exit on Errors:    Next: End of File, Up: Stopping SBCL   [Contents][Index] 3.2.1 Exit SBCL can be stopped at any time by calling sb-ext:exit, optionally returning a specified numeric value to the calling process. See Threading for information about terminating individual threads. Function: exit [sb-ext] &key code abort timeout Terminates the process, causing sbcl to exit with code. code defaults to 0 when abort is false, and 1 when it is true. When abort is false (the default), current thread is first unwound, *exit-hooks* are run, other threads are terminated, and standard output streams are flushed before sbcl calls exit(3) -- at which point atexit(3) functions will run. If multiple threads call exit with abort being false, the first one to call it will complete the protocol. When abort is true, sbcl exits immediately by calling _exit(2) without unwinding stack, or calling exit hooks. Note that _exit(2) does not call atexit(3) functions unlike exit(3). Recursive calls to exit cause exit to behave as it abort was true. timeout controls waiting for other threads to terminate when abort is nil. Once current thread has been unwound and *exit-hooks* have been run, spawning new threads is prevented and all other threads are terminated by calling terminate-thread on them. The system then waits for them to finish using join-thread, waiting at most a total timeout seconds for all threads to join. Those threads that do not finish in time are simply ignored while the exit protocol continues. timeout defaults to *exit-timeout*, which in turn defaults to 60. timeout nil means to wait indefinitely. Note that timeout applies only to join-thread, not *exit-hooks*. Since terminate-thread is asynchronous, getting multithreaded application termination with complex cleanups right using it can be tricky. To perform an orderly synchronous shutdown use an exit hook instead of relying on implicit thread termination. Consequences are unspecified if serious conditions occur during exit excepting errors from *exit-hooks*, which cause warnings and stop execution of the hook that signaled, but otherwise allow the exit process to continue normally. Next: Saving a Core Image, Previous: Exit, Up: Stopping SBCL   [Contents][Index] 3.2.2 End of File By default SBCL also exits on end of input, caused either by user pressing Control-D on an attached terminal, or end of input when using SBCL as part of a shell pipeline. Next: Exit on Errors, Previous: End of File, Up: Stopping SBCL   [Contents][Index] 3.2.3 Saving a Core Image SBCL has the ability to save its state as a file for later execution. This functionality is important for its bootstrapping process, and is also provided as an extension to the user. Function: save-lisp-and-die [sb-ext] core-file-name &key toplevel executable save-runtime-options purify root-structures environment-name compression Save a ""core image"", i.e. enough information to restart a Lisp process later in the same state, in the file of the specified name. Only global state is preserved: the stack is unwound in the process. The following &key arguments are defined: :toplevel The function to run when the created core file is resumed. The default function handles command line toplevel option processing and runs the top level read-eval-print loop. This function returning is equivalent to (sb-ext:exit :code 0) being called. toplevel functions should always provide an abort restart: otherwise code they call will run without one. :executable If true, arrange to combine the sbcl runtime and the core image to create a standalone executable. If false (the default), the core image will not be executable on its own. Executable images always behave as if they were passed the –noinform runtime option. :save-runtime-options If true, values of runtime options –dynamic-space-size and –control-stack-size that were used to start sbcl are stored in the standalone executable, and restored when the executable is run. This also inhibits normal runtime option processing, causing all command line arguments to be passed to the toplevel. Meaningless if :executable is nil. :purify If true (the default on cheneygc), do a purifying gc which moves all dynamically allocated objects into static space. This takes somewhat longer than the normal gc which is otherwise done, but it’s only done once, and subsequent GC’s will be done less often and will take less time in the resulting core file. See the purify function. This parameter has no effect on platforms using the generational garbage collector. :root-structures This should be a list of the main entry points in any newly loaded systems. This need not be supplied, but locality and/or gc performance may be better if they are. Meaningless if :purify is nil. See the purify function. :environment-name This is also passed to the purify function when :purify is t. (rarely used) :compression This is only meaningful if the runtime was built with the :sb-core-compression feature enabled. If nil (the default), saves to uncompressed core files. If :sb-core-compression was enabled at build-time, the argument may also be an integer from -1 to 9, corresponding to zlib compression levels, or t (which is equivalent to the default compression level, -1). :application-type Present only on Windows and is meaningful only with :executable t. Specifies the subsystem of the executable, :console or :gui. The notable difference is that :gui doesn’t automatically create a console window. The default is :console. The save/load process changes the values of some global variables: *standard-output*, *debug-io*, etc. Everything related to open streams is necessarily changed, since the os won’t let us preserve a stream across save and load. *default-pathname-defaults* This is reinitialized to reflect the working directory where the saved core is loaded. save-lisp-and-die interacts with sb-alien:load-shared-object: see its documentation for details. On threaded platforms only a single thread may remain running after sb-ext:*save-hooks* have run. Applications using multiple threads can be save-lisp-and-die friendly by registering a save-hook that quits any additional threads, and an init-hook that restarts them. This implementation is not as polished and painless as you might like: It corrupts the current Lisp image enough that the current process needs to be killed afterwards. This can be worked around by forking another process that saves the core. There is absolutely no binary compatibility of core images between different runtime support programs. Even runtimes built from the same sources at different times are treated as incompatible for this purpose. This isn’t because we like it this way, but just because there don’t seem to be good quick fixes for either limitation and no one has been sufficiently motivated to do lengthy fixes. Variable: *save-hooks* [sb-ext] This is a list of functions which are called in an unspecified order before creating a saved core image. Unused by sbcl itself: reserved for user and applications. In cases where the standard initialization files have already been loaded into the saved core, and alternative ones should be used (or none at all), SBCL allows customizing the initfile pathname computation. Variable: *sysinit-pathname-function* [sb-ext] Designator for a function of zero arguments called to obtain a pathname designator for the default sysinit file, or nil. If the function returns nil, no sysinit file is used unless one has been specified on the command-line. Variable: *userinit-pathname-function* [sb-ext] Designator for a function of zero arguments called to obtain a pathname designator or a stream for the default userinit file, or nil. If the function returns nil, no userinit file is used unless one has been specified on the command-line. To facilitate distribution of SBCL applications using external resources, the filesystem location of the SBCL core file being used is available from Lisp. Variable: *core-pathname* [sb-ext] The absolute pathname of the running sbcl core. Previous: Saving a Core Image, Up: Stopping SBCL   [Contents][Index] 3.2.4 Exit on Errors SBCL can also be configured to exit if an unhandled error occurs, which is mainly useful for acting as part of a shell pipeline; doing so under most other circumstances would mean giving up large parts of the flexibility and robustness of Common Lisp. See Debugger Entry. Next: Initialization Files, Previous: Stopping SBCL, Up: Starting and Stopping   [Contents][Index] 3.3 Command Line Options Command line options can be considered an advanced topic; for ordinary interactive use, no command line arguments should be necessary. In order to understand the command line argument syntax for SBCL, it is helpful to understand that the SBCL system is implemented as two components, a low-level runtime environment written in C and a higher-level system written in Common Lisp itself. Some command line arguments are processed during the initialization of the low-level runtime environment, some command line arguments are processed during the initialization of the Common Lisp system, and any remaining command line arguments are passed on to user code. The full, unambiguous syntax for invoking SBCL at the command line is: sbcl runtime-option* --end-runtime-options toplevel-option* --end-toplevel-options user-options* For convenience, the --end-runtime-options and --end-toplevel-options elements can be omitted. Omitting these elements can be convenient when you are running the program interactively, and you can see that no ambiguities are possible with the option values you are using. Omitting these elements is probably a bad idea for any batch file where any of the options are under user control, since it makes it impossible for SBCL to detect erroneous command line input, so that erroneous command line arguments will be passed on to the user program even if they was intended for the runtime system or the Lisp system. • Runtime Options:    • Toplevel Options:    Next: Toplevel Options, Up: Command Line Options   [Contents][Index] 3.3.1 Runtime Options --core corefilename Run the specified Lisp core file instead of the default. Note that if the Lisp core file is a user-created core file, it may run a nonstandard toplevel which does not recognize the standard toplevel options. --dynamic-space-size megabytes Size of the dynamic space reserved on startup in megabytes. Default value is platform dependent. --control-stack-size megabytes Size of control stack reserved for each thread in megabytes. Default value is 2. --noinform Suppress the printing of any banner or other informational message at startup. This makes it easier to write Lisp programs which work cleanly in Unix pipelines. See also the --noprint and --disable-debugger options. --disable-ldb Disable the low-level debugger. Only effective if SBCL is compiled with LDB. --lose-on-corruption There are some dangerous low level errors (for instance, control stack exhausted, memory fault) that (or whose handlers) can corrupt the image. By default SBCL prints a warning, then tries to continue and handle the error in Lisp, but this will not always work and SBCL may malfunction or even hang. With this option, upon encountering such an error SBCL will invoke ldb (if present and enabled) or else exit. --script filename As a runtime option this is equivalent to --noinform --disable-ldb --lose-on-corruption --end-runtime-options --script filename. See the description of --script as a toplevel option below. If there are no other command line arguments following --script, the filename argument can be omitted. --merge-core-pages When platform support is present, provide hints to the operating system that identical pages may be shared between processes until they are written to. This can be useful to reduce the memory usage on systems with multiple SBCL processes started from similar but differently-named core files, or from compressed cores. Without platform support, do nothing. --no-merge-core-pages Ensures that no sharing hint is provided to the operating system. --default-merge-core-pages Reverts the sharing hint policy to the default: only compressed cores trigger hinting. Uncompressed cores are mapped directly from the core file, which is usually enough to ensure sharing. --help Print some basic information about SBCL, then exit. --version Print SBCL’s version information, then exit. In the future, runtime options may be added to control behaviour such as lazy allocation of memory. Runtime options, including any –end-runtime-options option, are stripped out of the command line before the Lisp toplevel logic gets a chance to see it. Previous: Runtime Options, Up: Command Line Options   [Contents][Index] 3.3.2 Toplevel Options --sysinit filename Load filename instead of the default system initialization file (see Initialization Files.) --no-sysinit Don’t load a system-wide initialization file. If this option is given, the --sysinit option is ignored. --userinit filename Load filename instead of the default user initialization file (see Initialization Files.) --no-userinit Don’t load a user initialization file. If this option is given, the --userinit option is ignored. --eval command After executing any initialization file, but before starting the read-eval-print loop on standard input, read and evaluate the command given. More than one --eval option can be used, and all will be read and executed, in the order they appear on the command line. --load filename This is equivalent to --eval '(load ""filename"")'. The special syntax is intended to reduce quoting headaches when invoking SBCL from shell scripts. --noprint When ordinarily the toplevel ""read-eval-print loop"" would be executed, execute a ""read-eval loop"" instead, i.e. don’t print a prompt and don’t echo results. Combined with the --noinform runtime option, this makes it easier to write Lisp ""scripts"" which work cleanly in Unix pipelines. --disable-debugger By default when SBCL encounters an error, it enters the builtin debugger, allowing interactive diagnosis and possible intercession. This option disables the debugger, causing errors to print a backtrace and exit with status 1 instead. When given, this option takes effect before loading of initialization files or processing --eval and --load options. See sb-ext:disable-debugger for details. See Debugger Entry. --script filename Implies --no-userinit --no-sysinit --disable-debugger --end-toplevel-options. Causes the system to load the specified file instead of entering the read-eval-print-loop, and exit afterwards. If the file begins with a shebang line, it is ignored. If there are no other command line arguments following, the filename can be omitted: this causes the script to be loaded from standard input instead. Shebang lines in standard input script are currently not ignored. In either case, if there is an unhandled error (e.g. end of file, or a broken pipe) on either standard input, standard output, or standard error, the script silently exits with code 0. This allows e.g. safely piping output from SBCL to head -n1 or similar. Next: Initialization and Exit Hooks, Previous: Command Line Options, Up: Starting and Stopping   [Contents][Index] 3.4 Initialization Files SBCL processes initialization files with read and eval, not load; hence initialization files can be used to set startup *package* and *readtable*, and for proclaiming a global optimization policy. System Initialization File Defaults to $SBCL_HOME/sbclrc, or if that doesn’t exist to /etc/sbclrc. Can be overridden with the command line option --sysinit or --no-sysinit. The system initialization file is intended for system administrators and software packagers to configure locations of installed third party modules, etc. User Initialization File Defaults to $HOME/.sbclrc. Can be overridden with the command line option --userinit or --no-userinit. The user initialization file is intended for personal customizations, such as loading certain modules at startup, defining convenience functions to use in the REPL, handling automatic recompilation of FASLs (see FASL Format), etc. Neither initialization file is required. Previous: Initialization Files, Up: Starting and Stopping   [Contents][Index] 3.5 Initialization and Exit Hooks SBCL provides hooks into the system initialization and exit. Variable: *init-hooks* [sb-ext] This is a list of functions which are called in an unspecified order when a saved core image starts up, after the system itself has been initialized. Unused by sbcl itself: reserved for user and applications. Variable: *exit-hooks* [sb-ext] This is a list of functions which are called in an unspecified order when sbcl process exits. Unused by sbcl itself: reserved for user and applications. Using (sb-ext:exit :abort t), or calling exit(3) directly will circumvent these hooks. Next: Debugger, Previous: Starting and Stopping, Up: Top   [Contents][Index] 4 Compiler This chapter will discuss most compiler issues other than efficiency, including compiler error messages, the SBCL compiler’s unusual approach to type safety in the presence of type declarations, the effects of various compiler optimization policies, and the way that inlining and open coding may cause optimized code to differ from a naive translation. Efficiency issues are sufficiently varied and separate that they have their own chapter, Efficiency. • Diagnostic Messages:    • Handling of Types:    • Compiler Policy:    • Compiler Errors:    • Open Coding and Inline Expansion:    • Interpreter:    Next: Handling of Types, Up: Compiler   [Contents][Index] 4.1 Diagnostic Messages • Controlling Verbosity:    • Diagnostic Severity:    • Understanding Compiler Diagnostics:    Next: Diagnostic Severity, Up: Diagnostic Messages   [Contents][Index] 4.1.1 Controlling Verbosity The compiler can be quite verbose in its diagnostic reporting, rather more then some users would prefer – the amount of noise emitted can be controlled, however. To control emission of compiler diagnostics (of any severity other than error: see Diagnostic Severity) use the sb-ext:muffle-conditions and sb-ext:unmuffle-conditions declarations, specifying the type of condition that is to be muffled (the muffling is done using an associated muffle-warning restart). Global control: ;;; Muffle compiler-notes globally (declaim (sb-ext:muffle-conditions sb-ext:compiler-note))  Local control: ;;; Muffle compiler-notes based on lexical scope (defun foo (x)   (declare (optimize speed) (fixnum x)            (sb-ext:muffle-conditions sb-ext:compiler-note))   (values (* x 5) ; no compiler note from this     (locally       (declare (sb-ext:unmuffle-conditions sb-ext:compiler-note))       ;; this one gives a compiler note       (* x -5))))  Declaration: muffle-conditions [sb-ext] Syntax: type* Muffles the diagnostic messages that would be caused by compile-time signals of given types. Declaration: unmuffle-conditions [sb-ext] Syntax: type* Cancels the effect of a previous sb-ext:muffle-conditions declaration. Various details of how the compiler messages are printed can be controlled via the alist sb-ext:*compiler-print-variable-alist*. Variable: *compiler-print-variable-alist* [sb-ext] an association list describing new bindings for special variables to be used by the compiler for error-reporting, etc. Eg.  ((*PRINT-LENGTH* . 10) (*PRINT-LEVEL* . 6) (*PRINT-PRETTY* . NIL))  The variables in the car positions are bound to the values in the cdr during the execution of some debug commands. When evaluating arbitrary expressions in the debugger, the normal values of the printer control variables are in effect. Initially empty, *compiler-print-variable-alist* is Typically used to specify bindings for printer control variables. For information about muffling warnings signaled outside of the compiler, see Customization Hooks for Users. Next: Understanding Compiler Diagnostics, Previous: Controlling Verbosity, Up: Diagnostic Messages   [Contents][Index] 4.1.2 Diagnostic Severity There are four levels of compiler diagnostic severity: error warning style warning note The first three levels correspond to condition classes which are defined in the ANSI standard for Common Lisp and which have special significance to the compile and compile-file functions. These levels of compiler error severity occur when the compiler handles conditions of these classes. The fourth level of compiler error severity, note, corresponds to the sb-ext:compiler-note, and is used for problems which are too mild for the standard condition classes, typically hints about how efficiency might be improved. The sb-ext:code-deletion-note, a subtype of compiler-note, is signalled when the compiler deletes user-supplied code after proving that the code in question is unreachable. Future work for SBCL includes expanding this hierarchy of types to allow more fine-grained control over emission of diagnostic messages. Condition: compiler-note [sb-ext] Class precedence list: compiler-note, condition, t Root of the hierarchy of conditions representing information discovered by the compiler that the user might wish to know, but which does not merit a style-warning (or any more serious condition). Condition: code-deletion-note [sb-ext] Class precedence list: code-deletion-note, compiler-note, condition, t A condition type signalled when the compiler deletes code that the user has written, having proved that it is unreachable. Previous: Diagnostic Severity, Up: Diagnostic Messages   [Contents][Index] 4.1.3 Understanding Compile Diagnostics The messages emitted by the compiler contain a lot of detail in a terse format, so they may be confusing at first. The messages will be illustrated using this example program: (defmacro zoq (x)   `(roq (ploq (+ ,x 3))))  (defun foo (y)   (declare (symbol y))   (zoq y))  The main problem with this program is that it is trying to add 3 to a symbol. Note also that the functions roq and ploq aren’t defined anywhere. • The Parts of a Compiler Diagnostic:    • The Original and Actual Source:    • The Processing Path:    Next: The Original and Actual Source, Up: Understanding Compiler Diagnostics   [Contents][Index] 4.1.3.1 The Parts of a Compiler Diagnostic When processing this program, the compiler will produce this warning: ; file: /tmp/foo.lisp ; in: DEFUN FOO ;     (ZOQ Y) ; --> ROQ PLOQ ; ==> ;   (+ Y 3) ; ; caught WARNING: ;   Asserted type NUMBER conflicts with derived type (VALUES SYMBOL &OPTIONAL).  In this example we see each of the six possible parts of a compiler diagnostic: ‘file: /tmp/foo.lisp’ This is the name of the file that the compiler read the relevant code from. The file name is displayed because it may not be immediately obvious when there is an error during compilation of a large system, especially when with-compilation-unit is used to delay undefined warnings. ‘in: DEFUN FOO’ This is the definition top level form responsible for the diagnostic. It is obtained by taking the first two elements of the enclosing form whose first element is a symbol beginning with “‘def’”. If there is no such enclosing “‘def’” form, then the outermost form is used. If there are multiple ‘def’ forms, then they are all printed from the outside in, separated by ‘=>’’s. In this example, the problem was in the defun for foo. ‘(ZOQ Y)’ This is the original source form responsible for the diagnostic. Original source means that the form directly appeared in the original input to the compiler, i.e. in the lambda passed to compile or in the top level form read from the source file. In this example, the expansion of the zoq macro was responsible for the message. ‘--> ROQ PLOQ’ This is the processing path that the compiler used to produce the code that caused the message to be emitted. The processing path is a representation of the evaluated forms enclosing the actual source that the compiler encountered when processing the original source. The path is the first element of each form, or the form itself if the form is not a list. These forms result from the expansion of macros or source-to-source transformation done by the compiler. In this example, the enclosing evaluated forms are the calls to roq and ploq. These calls resulted from the expansion of the zoq macro. ‘==> (+ Y 3)’ This is the actual source responsible for the diagnostic. If the actual source appears in the explanation, then we print the next enclosing evaluated form, instead of printing the actual source twice. (This is the form that would otherwise have been the last form of the processing path.) In this example, the problem is with the evaluation of the reference to the variable y. ‘caught WARNING: Asserted type NUMBER conflicts with derived type (VALUES SYMBOL &OPTIONAL).’ This is the explanation of the problem. In this example, the problem is that, while the call to + requires that its arguments are all of type number, the compiler has derived that y will evaluate to a symbol. Note that ‘(VALUES SYMBOL &OPTIONAL)’ expresses that y evaluates to precisely one value. Note that each part of the message is distinctively marked: ‘file:’ and ‘in:’ mark the file and definition, respectively. The original source is an indented form with no prefix. Each line of the processing path is prefixed with ‘-->’ The actual source form is indented like the original source, but is marked by a preceding ‘==>’ line. The explanation is prefixed with the diagnostic severity, which can be ‘caught ERROR:’, ‘caught WARNING:’, ‘caught STYLE-WARNING:’, or ‘note:’. Each part of the message is more specific than the preceding one. If consecutive messages are for nearby locations, then the front part of the messages would be the same. In this case, the compiler omits as much of the second message as in common with the first. For example: ; file: /tmp/foo.lisp ; in: DEFUN FOO ;     (ZOQ Y) ; --> ROQ ; ==> ;   (PLOQ (+ Y 3)) ; ; caught STYLE-WARNING: ;   undefined function: PLOQ  ; ==> ;   (ROQ (PLOQ (+ Y 3))) ; ; caught STYLE-WARNING: ;   undefined function: ROQ  In this example, the file, definition and original source are identical for the two messages, so the compiler omits them in the second message. If consecutive messages are entirely identical, then the compiler prints only the first message, followed by: ‘[Last message occurs repeats times]’ where repeats is the number of times the message was given. If the source was not from a file, then no file line is printed. If the actual source is the same as the original source, then the processing path and actual source will be omitted. If no forms intervene between the original source and the actual source, then the processing path will also be omitted. Next: The Processing Path, Previous: The Parts of a Compiler Diagnostic, Up: Understanding Compiler Diagnostics   [Contents][Index] 4.1.3.2 The Original and Actual Source The original source displayed will almost always be a list. If the actual source for an message is a symbol, the original source will be the immediately enclosing evaluated list form. So even if the offending symbol does appear in the original source, the compiler will print the enclosing list and then print the symbol as the actual source (as though the symbol were introduced by a macro.) When the actual source is displayed (and is not a symbol), it will always be code that resulted from the expansion of a macro or a source-to-source compiler optimization. This is code that did not appear in the original source program; it was introduced by the compiler. Keep in mind that when the compiler displays a source form in an diagnostic message, it always displays the most specific (innermost) responsible form. For example, compiling this function (defun bar (x)   (let (a)     (declare (fixnum a))     (setq a (foo x))     a))  gives this error message ; file: /tmp/foo.lisp ; in: DEFUN BAR ;     (LET (A) ;     (DECLARE (FIXNUM A)) ;     (SETQ A (FOO X)) ;     A) ; ; caught WARNING: ;   Asserted type FIXNUM conflicts with derived type (VALUES NULL &OPTIONAL).  This message is not saying “there is a problem somewhere in this let” – it is saying that there is a problem with the let itself. In this example, the problem is that a’s nil initial value is not a fixnum. Previous: The Original and Actual Source, Up: Understanding Compiler Diagnostics   [Contents][Index] 4.1.3.3 The Processing Path The processing path is mainly useful for debugging macros, so if you don’t write macros, you can probably ignore it. Consider this example: (defun foo (n)   (dotimes (i n *undefined*)))  Compiling results in this error message: ; in: DEFUN FOO ;     (DOTIMES (I N *UNDEFINED*)) ; --> DO BLOCK LET TAGBODY RETURN-FROM ; ==> ;   (PROGN *UNDEFINED*) ; ; caught WARNING: ;   undefined variable: *UNDEFINED*  Note that do appears in the processing path. This is because dotimes expands into: (do ((i 0 (1+ i)) (#:g1 n))     ((>= i #:g1) *undefined*)   (declare (type unsigned-byte i)))  The rest of the processing path results from the expansion of do: (block nil   (let ((i 0) (#:g1 n))     (declare (type unsigned-byte i))     (tagbody (go #:g3)       #:g2    (psetq i (1+ i))       #:g3    (unless (>= i #:g1) (go #:g2))       (return-from nil (progn *undefined*)))))  In this example, the compiler descended into the block, let, tagbody and return-from to reach the progn printed as the actual source. This is a place where the “actual source appears in explanation” rule was applied. The innermost actual source form was the symbol *undefined* itself, but that also appeared in the explanation, so the compiler backed out one level. Next: Compiler Policy, Previous: Diagnostic Messages, Up: Compiler   [Contents][Index] 4.2 Handling of Types One of the most important features of the SBCL compiler (similar to the original CMUCL compiler, also known as Python) is its fairly sophisticated understanding of the Common Lisp type system and its conservative approach to the implementation of type declarations. These two features reward the use of type declarations throughout development, even when high performance is not a concern. Also, as discussed in the chapter on performance (see Efficiency), the use of appropriate type declarations can be very important for performance as well. The SBCL compiler also has a greater knowledge of the Common Lisp type system than other compilers. Support is incomplete only for types involving the satisfies type specifier. • Declarations as Assertions:    • Precise Type Checking:    • Getting Existing Programs to Run:    • Implementation Limitations:    Next: Precise Type Checking, Up: Handling of Types   [Contents][Index] 4.2.1 Declarations as Assertions The SBCL compiler treats type declarations differently from most other Lisp compilers. Under default compilation policy the compiler doesn’t blindly believe type declarations, but considers them assertions about the program that should be checked: all type declarations that have not been proven to always hold are asserted at runtime. Remaining bugs in the compiler’s handling of types unfortunately provide some exceptions to this rule, see Implementation Limitations. CLOS slot types form a notable exception. Types declared using the :type slot option in defclass are asserted if and only if the class was defined in safe code and the slot access location is in safe code as well. This laxness does not pose any internal consistency issues, as the CLOS slot types are not available for the type inferencer, nor do CLOS slot types provide any efficiency benefits. There are three type checking policies available in SBCL, selectable via optimize declarations. Full Type Checks All declarations are considered assertions to be checked at runtime, and all type checks are precise. The default compilation policy provides full type checks. Used when (or (>= safety 2) (>= safety speed 1)). Weak Type Checks Declared types may be simplified into faster to check supertypes: for example, (or (integer -17 -7) (integer 7 17)) is simplified into (integer -17 17). Note: it is relatively easy to corrupt the heap when weak type checks are used if the program contains type-errors. Used when (and (< safety 2) (< safety speed)) No Type Checks All declarations are believed without assertions. Also disables argument count and array bounds checking. Note: any type errors in code where type checks are not performed are liable to corrupt the heap. Used when (= safety 0). Next: Getting Existing Programs to Run, Previous: Declarations as Assertions, Up: Handling of Types   [Contents][Index] 4.2.2 Precise Type Checking Precise checking means that the check is done as though typep had been called with the exact type specifier that appeared in the declaration. If a variable is declared to be (integer 3 17) then its value must always be an integer between 3 and 17. If multiple type declarations apply to a single variable, then all the declarations must be correct; it is as though all the types were intersected producing a single and type specifier. To gain maximum benefit from the compiler’s type checking, you should always declare the types of function arguments and structure slots as precisely as possible. This often involves the use of or, member, and other list-style type specifiers. Next: Implementation Limitations, Previous: Precise Type Checking, Up: Handling of Types   [Contents][Index] 4.2.3 Getting Existing Programs to Run Since SBCL’s compiler does much more comprehensive type checking than most Lisp compilers, SBCL may detect type errors in programs that have been debugged using other compilers. These errors are mostly incorrect declarations, although compile-time type errors can find actual bugs if parts of the program have never been tested. Some incorrect declarations can only be detected by run-time type checking. It is very important to initially compile a program with full type checks (high safety optimization) and then test this safe version. After the checking version has been tested, then you can consider weakening or eliminating type checks. This applies even to previously debugged programs, because the SBCL compiler does much more type inference than other Common Lisp compilers, so an incorrect declaration can do more damage. The most common problem is with variables whose constant initial value doesn’t match the type declaration. Incorrect constant initial values will always be flagged by a compile-time type error, and they are simple to fix once located. Consider this code fragment: (prog (foo)   (declare (fixnum foo))   (setq foo ...)   ...)  Here foo is given an initial value of nil, but is declared to be a fixnum. Even if it is never read, the initial value of a variable must match the declared type. There are two ways to fix this problem. Change the declaration (prog (foo)   (declare (type (or fixnum null) foo))   (setq foo ...)   ...)  or change the initial value (prog ((foo 0))   (declare (fixnum foo))   (setq foo ...)   ...)  It is generally preferable to change to a legal initial value rather than to weaken the declaration, but sometimes it is simpler to weaken the declaration than to try to make an initial value of the appropriate type. Another declaration problem occasionally encountered is incorrect declarations on defmacro arguments. This can happen when a function is converted into a macro. Consider this macro: (defmacro my-1+ (x)   (declare (fixnum x))   `(the fixnum (1+ ,x)))  Although legal and well-defined Common Lisp code, this meaning of this definition is almost certainly not what the writer intended. For example, this call is illegal: (my-1+ (+ 4 5))  This call is illegal because the argument to the macro is (+ 4 5), which is a list, not a fixnum. Because of macro semantics, it is hardly ever useful to declare the types of macro arguments. If you really want to assert something about the type of the result of evaluating a macro argument, then put a the in the expansion: (defmacro my-1+ (x)   `(the fixnum (1+ (the fixnum ,x))))  In this case, it would be stylistically preferable to change this macro back to a function and declare it inline. Some more subtle problems are caused by incorrect declarations that can’t be detected at compile time. Consider this code: (do ((pos 0 (position #\a string :start (1+ pos))))   ((null pos))   (declare (fixnum pos))   ...)  Although pos is almost always a fixnum, it is nil at the end of the loop. If this example is compiled with full type checks (the default), then running it will signal a type error at the end of the loop. If compiled without type checks, the program will go into an infinite loop (or perhaps position will complain because (1+ nil) isn’t a sensible start.) Why? Because if you compile without type checks, the compiler just quietly believes the type declaration. Since the compiler believes that pos is always a fixnum, it believes that pos is never nil, so (null pos) is never true, and the loop exit test is optimized away. Such errors are sometimes flagged by unreachable code notes, but it is still important to initially compile and test any system with full type checks, even if the system works fine when compiled using other compilers. In this case, the fix is to weaken the type declaration to (or fixnum null) 2. Note that there is usually little performance penalty for weakening a declaration in this way. Any numeric operations in the body can still assume that the variable is a fixnum, since nil is not a legal numeric argument. Another possible fix would be to say: (do ((pos 0 (position #\a string :start (1+ pos))))     ((null pos))   (let ((pos pos))     (declare (fixnum pos))     ...))  This would be preferable in some circumstances, since it would allow a non-standard representation to be used for the local pos variable in the loop body. Previous: Getting Existing Programs to Run, Up: Handling of Types   [Contents][Index] 4.2.4 Implementation Limitations Ideally, the compiler would consider all type declarations to be assertions, so that adding type declarations to a program, no matter how incorrect they might be, would never cause undefined behavior. However, the compiler is known to fall short of this goal in two areas: Proclaimed constraints on argument and result types of a function are supposed to be checked by the function. If the function type is proclaimed before function definition, type checks are inserted by the compiler, but the standard allows the reversed order, in which case the compiler will trust the declaration. The compiler cannot check types of an unknown number of values; if the number of generated values is unknown, but the number of consumed is known, only consumed values are checked. For example, (defun foo (x)   (the integer (bar x)))  causes the following compiler diagnostic to be emitted: ; note: type assertion too complex to check: ;  (VALUES INTEGER &REST T).  A partial workaround is instead write: (defun foo (x)   (the (values integer &optional) (bar x)))  These are important issues, but are not necessarily easy to fix, so they may, alas, remain in the system for a while. Next: Compiler Errors, Previous: Handling of Types, Up: Compiler   [Contents][Index] 4.3 Compiler Policy Compiler policy is controlled by the optimize declaration, supporting all ANSI optimization qualities (debug, safety, space, and speed).3 For effects of various optimization qualities on type-safety and debuggability see Declarations as Assertions and Debugger Policy Control. Ordinarily, when the speed quality is high, the compiler emits notes to notify the programmer about its inability to apply various optimizations. For selective muffling of these notes See Controlling Verbosity. The value of space mostly influences the compiler’s decision whether to inline operations, which tend to increase the size of programs. Use the value 0 with caution, since it can cause the compiler to inline operations so indiscriminately that the net effect is to slow the program by causing cache misses or even swapping. Function: describe-compiler-policy [sb-ext] &optional spec Print all global optimization settings, augmented by spec. Function: restrict-compiler-policy [sb-ext] &optional quality min Assign a minimum value to an optimization quality. quality is the name of the optimization quality to restrict, and min (defaulting to zero) is the minimum allowed value. Returns the alist describing the current policy restrictions. If quality is nil or not given, nothing is done. Otherwise, if min is zero or not given, any existing restrictions of quality are removed. If min is between one and three inclusive, it becomes the new minimum value for the optimization quality: any future proclamations or declarations of the quality with a value less then min behave as if the value was min instead. This is intended to be used interactively, to facilitate recompiling large bodies of code with eg. a known minimum safety. See also :policy option in with-compilation-unit. experimental interface: Subject to change. Macro: with-compilation-unit [cl] options &body body Affects compilations that take place within its dynamic extent. It is intended to be eg. wrapped around the compilation of all files in the same system. Following options are defined: :override Boolean-Form One of the effects of this form is to delay undefined warnings until the end of the form, instead of giving them at the end of each compilation. If override is nil (the default), then the outermost with-compilation-unit form grabs the undefined warnings. Specifying override true causes that form to grab any enclosed warnings, even if it is enclosed by another with-compilation-unit. :policy Optimize-Declaration-Form Provides dynamic scoping for global compiler optimization qualities and restrictions, limiting effects of subsequent optimize proclamations and calls to sb-ext:restrict-compiler-policy to the dynamic scope of body. If override is false, specified policy is merged with current global policy. If override is true, current global policy, including any restrictions, is discarded in favor of the specified policy. Supplying policy nil is equivalent to the option not being supplied at all, ie. dynamic scoping of policy does not take place. This option is an SBCL-specific experimental extension: Interface subject to change. :source-namestring Namestring-Form Attaches the value returned by the Namestring-Form to the internal debug-source information as the namestring of the source file. Normally the namestring of the input-file for compile-file is used: this option can be used to provide source-file information for functions compiled using compile, or to override the input-file of compile-file. If both an outer and an inner with-compilation-unit provide a source-namestring, the inner one takes precedence. Unaffected by :override. This is an SBCL-specific extension. :source-plist Plist-Form Attaches the value returned by the Plist-Form to internal debug-source information of functions compiled in within the dynamic extent of body. Primarily for use by development environments, in order to eg. associate function definitions with editor-buffers. Can be accessed using sb-introspect:definition-source-plist. If an outer with-compilation-unit form also provide a source-plist, it is appended to the end of the provided source-plist. Unaffected by :override. This is an SBCL-specific extension. Examples:   ;; Prevent proclamations from the file leaking, and restrict   ;; SAFETY to 3 -- otherwise uses the current global policy.   (with-compilation-unit (:policy '(optimize))     (restrict-compiler-policy 'safety 3)     (load ""foo.lisp""))    ;; Using default policy instead of the current global one,   ;; except for DEBUG 3.   (with-compilation-unit (:policy '(optimize debug)                           :override t)     (load ""foo.lisp""))    ;; Same as if :POLICY had not been specified at all: SAFETY 3   ;; proclamation leaks out from WITH-COMPILATION-UNIT.   (with-compilation-unit (:policy nil)     (declaim (optimize safety))     (load ""foo.lisp""))  Next: Open Coding and Inline Expansion, Previous: Compiler Policy, Up: Compiler   [Contents][Index] 4.4 Compiler Errors • Type Errors at Compile Time:    • Errors During Macroexpansion:    • Read Errors:    Next: Errors During Macroexpansion, Up: Compiler Errors   [Contents][Index] 4.4.1 Type Errors at Compile Time If the compiler can prove at compile time that some portion of the program cannot be executed without a type error, then it will give a warning at compile time. It is possible that the offending code would never actually be executed at run-time due to some higher level consistency constraint unknown to the compiler, so a type warning doesn’t always indicate an incorrect program. For example, consider this code fragment: (defun raz (foo)   (let ((x (case foo               (:this 13)               (:that 9)               (:the-other 42))))     (declare (fixnum x))     (foo x)))  Compilation produces this warning: ; in: DEFUN RAZ ;     (CASE FOO (:THIS 13) (:THAT 9) (:THE-OTHER 42)) ; --> LET COND IF COND IF COND IF ; ==> ;   (COND) ; ; caught WARNING: ;   This is not a FIXNUM: ;   NIL  In this case, the warning means that if foo isn’t any of :this, :that or :the-other, then x will be initialized to nil, which the fixnum declaration makes illegal. The warning will go away if ecase is used instead of case, or if :the-other is changed to t. This sort of spurious type warning happens moderately often in the expansion of complex macros and in inline functions. In such cases, there may be dead code that is impossible to correctly execute. The compiler can’t always prove this code is dead (could never be executed), so it compiles the erroneous code (which will always signal an error if it is executed) and gives a warning. Next: Read Errors, Previous: Type Errors at Compile Time, Up: Compiler Errors   [Contents][Index] 4.4.2 Errors During Macroexpansion The compiler handles errors that happen during macroexpansion, turning them into compiler errors. If you want to debug the error (to debug a macro), you can set *break-on-signals* to error. For example, this definition: (defun foo (e l)   (do ((current l (cdr current))        ((atom current) nil))       (when (eq (car current) e) (return current))))  gives this error: ; in: DEFUN FOO ;     (DO ((CURRENT L (CDR CURRENT)) ;        ((ATOM CURRENT) NIL)) ;       (WHEN (EQ (CAR CURRENT) E) (RETURN CURRENT))) ; ; caught ERROR: ;   (in macroexpansion of (DO # #)) ;   (hint: For more precise location, try *BREAK-ON-SIGNALS*.) ;   DO step variable is not a symbol: (ATOM CURRENT)  Previous: Errors During Macroexpansion, Up: Compiler Errors   [Contents][Index] 4.4.3 Read Errors SBCL’s compiler does not attempt to recover from read errors when reading a source file, but instead just reports the offending character position and gives up on the entire source file. Next: Interpreter, Previous: Compiler Errors, Up: Compiler   [Contents][Index] 4.5 Open Coding and Inline Expansion Since Common Lisp forbids the redefinition of standard functions, the compiler can have special knowledge of these standard functions embedded in it. This special knowledge is used in various ways (open coding, inline expansion, source transformation), but the implications to the user are basically the same: Attempts to redefine standard functions may be frustrated, since the function may never be called. Although it is technically illegal to redefine standard functions, users sometimes want to implicitly redefine these functions when they are debugging using the trace macro. Special-casing of standard functions can be inhibited using the notinline declaration, but even then some phases of analysis such as type inferencing are applied by the compiler. The compiler can have multiple alternate implementations of standard functions that implement different trade-offs of speed, space and safety. This selection is based on the compiler policy, Compiler Policy. When a function call is open coded, inline code whose effect is equivalent to the function call is substituted for that function call. When a function call is closed coded, it is usually left as is, although it might be turned into a call to a different function with different arguments. As an example, if nthcdr were to be open coded, then (nthcdr 4 foobar)  might turn into (cdr (cdr (cdr (cdr foobar))))  or even (do ((i 0 (1+ i))   (list foobar (cdr foobar)))   ((= i 4) list))  If nth is closed coded, then (nth x l)  might stay the same, or turn into something like (car (nthcdr x l))  In general, open coding sacrifices space for speed, but some functions (such as car) are so simple that they are always open-coded. Even when not open-coded, a call to a standard function may be transformed into a different function call (as in the last example) or compiled as static call. Static function call uses a more efficient calling convention that forbids redefinition. Previous: Open Coding and Inline Expansion, Up: Compiler   [Contents][Index] 4.6 Interpreter By default SBCL implements eval by calling the native code compiler. SBCL also includes an interpreter for use in special cases where using the compiler is undesirable, for example due to compilation overhead. Unlike in some other Lisp implementations, in SBCL interpreted code is not safer or more debuggable than compiled code. Variable: *evaluator-mode* [sb-ext] Toggle between different evaluator implementations. If set to :compile, an implementation of eval that calls the compiler will be used. If set to :interpret, an interpreter will be used. Next: Efficiency, Previous: Compiler, Up: Top   [Contents][Index] 5 Debugger This chapter documents the debugging facilities of SBCL, including the debugger, single-stepper and trace, and the effect of (optimize debug) declarations. • Debugger Entry:    • Debugger Command Loop:    • Stack Frames:    • Variable Access:    • Source Location Printing:    • Debugger Policy Control:    • Exiting Commands:    • Information Commands:    • Function Tracing:    • Single Stepping:    • Enabling and Disabling the Debugger:    Next: Debugger Command Loop, Up: Debugger   [Contents][Index] 5.1 Debugger Entry • Debugger Banner:    • Debugger Invocation:    Next: Debugger Invocation, Up: Debugger Entry   [Contents][Index] 5.1.1 Debugger Banner When you enter the debugger, it looks something like this: debugger invoked on a TYPE-ERROR in thread 11184:   The value 3 is not of type LIST.  You can type HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.  restarts (invokable by number or by possibly-abbreviated name):   0: [ABORT   ] Reduce debugger level (leaving debugger, returning to toplevel).   1: [TOPLEVEL] Restart at toplevel READ/EVAL/PRINT loop. (CAR 1 3) 0]  The first group of lines describe what the error was that put us in the debugger. In this case car was called on 3, causing a type-error. This is followed by the “beginner help line”, which appears only if sb-ext:*debug-beginner-help-p* is true (default). Next comes a listing of the active restart names, along with their descriptions – the ways we can restart execution after this error. In this case, both options return to top-level. Restarts can be selected by entering the corresponding number or name. The current frame appears right underneath the restarts, immediately followed by the debugger prompt. Previous: Debugger Banner, Up: Debugger Entry   [Contents][Index] 5.1.2 Debugger Invocation The debugger is invoked when: error is called, and the condition it signals is not handled. break is called, or signal is called with a condition that matches the current *break-on-signals*. the debugger is explicitly entered with the invoke-debugger function. When the debugger is invoked by a condition, ANSI mandates that the value of *debugger-hook*, if any, be called with two arguments: the condition that caused the debugger to be invoked and the previous value of *debugger-hook*. When this happens, *debugger-hook* is bound to NIL to prevent recursive errors. However, ANSI also mandates that *debugger-hook* not be invoked when the debugger is to be entered by the break function. For users who wish to provide an alternate debugger interface (and thus catch break entries into the debugger), SBCL provides sb-ext:*invoke-debugger-hook*, which is invoked during any entry into the debugger. Variable: *invoke-debugger-hook* [sb-ext] This is either nil or a designator for a function of two arguments, to be run when the debugger is about to be entered. The function is run with *invoke-debugger-hook* bound to nil to minimize recursive errors, and receives as arguments the condition that triggered debugger entry and the previous value of *invoke-debugger-hook* This mechanism is an sbcl extension similar to the standard *debugger-hook*. In contrast to *debugger-hook*, it is observed by invoke-debugger even when called by break. Next: Stack Frames, Previous: Debugger Entry, Up: Debugger   [Contents][Index] 5.2 Debugger Command Loop The debugger is an interactive read-eval-print loop much like the normal top level, but some symbols are interpreted as debugger commands instead of being evaluated. A debugger command starts with the symbol name of the command, possibly followed by some arguments on the same line. Some commands prompt for additional input. Debugger commands can be abbreviated by any unambiguous prefix: help can be typed as ‘h’, ‘he’, etc. The package is not significant in debugger commands; any symbol with the name of a debugger command will work. If you want to show the value of a variable that happens also to be the name of a debugger command you can wrap the variable in a progn to hide it from the command loop. The debugger prompt is “frame]”, where frame is the number of the current frame. Frames are numbered starting from zero at the top (most recent call), increasing down to the bottom. The current frame is the frame that commands refer to. It is possible to override the normal printing behaviour in the debugger by using the sb-ext:*debug-print-variable-alist*. Variable: *debug-print-variable-alist* [sb-ext] an association list describing new bindings for special variables to be used within the debugger. Eg.  ((*PRINT-LENGTH* . 10) (*PRINT-LEVEL* . 6) (*PRINT-PRETTY* . NIL))  The variables in the car positions are bound to the values in the cdr during the execution of some debug commands. When evaluating arbitrary expressions in the debugger, the normal values of the printer control variables are in effect. Initially empty, *debug-print-variable-alist* is typically used to provide bindings for printer control variables. Next: Variable Access, Previous: Debugger Command Loop, Up: Debugger   [Contents][Index] 5.3 Stack Frames A stack frame is the run-time representation of a call to a function; the frame stores the state that a function needs to remember what it is doing. Frames have: variables (see Variable Access), which are the values being operated on. arguments to the call (which are really just particularly interesting variables). a current source location (see Source Location Printing), which is the place in the program where the function was running when it stopped to call another function, or because of an interrupt or error. • Stack Motion:    • How Arguments are Printed:    • Function Names:    • Debug Tail Recursion:    • Unknown Locations and Interrupts:    Next: How Arguments are Printed, Up: Stack Frames   [Contents][Index] 5.3.1 Stack Motion These commands move to a new stack frame and print the name of the function and the values of its arguments in the style of a Lisp function call: Debugger Command: up Move up to the next higher frame. More recent function calls are considered to be higher on the stack. Debugger Command: down Move down to the next lower frame. Debugger Command: top Move to the highest frame, that is, the frame where the debugger was entered. Debugger Command: bottom Move to the lowest frame. Debugger Command: frame [n] Move to the frame with the specified number. Prompts for the number if not supplied. The frame with number 0 is the frame where the debugger was entered. Next: Function Names, Previous: Stack Motion, Up: Stack Frames   [Contents][Index] 5.3.2 How Arguments are Printed A frame is printed to look like a function call, but with the actual argument values in the argument positions. So the frame for this call in the source: (myfun (+ 3 4) 'a)  would look like this: (MYFUN 7 A)  All keyword and optional arguments are displayed with their actual values; if the corresponding argument was not supplied, the value will be the default. So this call: (subseq ""foo"" 1)  would look like this: (SUBSEQ ""foo"" 1 3)  And this call: (string-upcase ""test case"")  would look like this: (STRING-UPCASE ""test case"" :START 0 :END NIL)  The arguments to a function call are displayed by accessing the argument variables. Although those variables are initialized to the actual argument values, they can be set inside the function; in this case the new value will be displayed. &rest arguments are handled somewhat differently. The value of the rest argument variable is displayed as the spread-out arguments to the call, so: (format t ""~A is a ~A."" ""This"" 'test)  would look like this: (FORMAT T ""~A is a ~A."" ""This"" 'TEST)  Rest arguments cause an exception to the normal display of keyword arguments in functions that have both &rest and &key arguments. In this case, the keyword argument variables are not displayed at all; the rest arg is displayed instead. So for these functions, only the keywords actually supplied will be shown, and the values displayed will be the argument values, not values of the (possibly modified) variables. If the variable for an argument is never referenced by the function, it will be deleted. The variable value is then unavailable, so the debugger prints ‘#<unused-arg>’ instead of the value. Similarly, if for any of a number of reasons the value of the variable is unavailable or not known to be available (see Variable Access), then ‘#<unavailable-arg>’ will be printed instead of the argument value. Note that inline expansion and open-coding affect what frames are present in the debugger, see Debugger Policy Control. Next: Debug Tail Recursion, Previous: How Arguments are Printed, Up: Stack Frames   [Contents][Index] 5.3.3 Function Names If a function is defined by defun it will appear in backtrace by that name. Functions defined by labels and flet will appear as (FLET name) and (LABELS name) respectively. Anonymous lambdas will appear as (LAMDBA lambda-list). • Entry Point Details:    Up: Function Names   [Contents][Index] 5.3.3.1 Entry Point Details Sometimes the compiler introduces new functions that are used to implement a user function, but are not directly specified in the source. This is mostly done for argument type and count checking. With recursive functions, an additional external frame may appear before the frame representing the first call to the recursive function. This is a consequence of the way the compiler works: there is nothing odd with your program. You may also see cleanup frames during the execution of unwind-protect cleanup code, and optional for variable argument entry points. Next: Unknown Locations and Interrupts, Previous: Function Names, Up: Stack Frames   [Contents][Index] 5.3.4 Debug Tail Recursion The compiler is “properly tail recursive.” If a function call is in a tail-recursive position, the stack frame will be deallocated at the time of the call, rather than after the call returns. Consider this backtrace: (BAR ...) (FOO ...)  Because of tail recursion, it is not necessarily the case that FOO directly called BAR. It may be that FOO called some other function FOO2 which then called BAR tail-recursively, as in this example: (defun foo ()   ...   (foo2 ...)   ...)  (defun foo2 (...)   ...   (bar ...))  (defun bar (...)   ...)  Usually the elimination of tail-recursive frames makes debugging more pleasant, since these frames are mostly uninformative. If there is any doubt about how one function called another, it can usually be eliminated by finding the source location in the calling frame. See Source Location Printing. The elimination of tail-recursive frames can be prevented by disabling tail-recursion optimization, which happens when the debug optimization quality is greater than 2. See Debugger Policy Control. Previous: Debug Tail Recursion, Up: Stack Frames   [Contents][Index] 5.3.5 Unknown Locations and Interrupts The debugger operates using special debugging information attached to the compiled code. This debug information tells the debugger what it needs to know about the locations in the code where the debugger can be invoked. If the debugger somehow encounters a location not described in the debug information, then it is said to be unknown. If the code location for a frame is unknown, then some variables may be inaccessible, and the source location cannot be precisely displayed. There are three reasons why a code location could be unknown: There is inadequate debug information due to the value of the debug optimization quality. See Debugger Policy Control. The debugger was entered because of an interrupt such as C-c. A hardware error such as “‘bus error’” occurred in code that was compiled unsafely due to the value of the safety optimization quality. In the last two cases, the values of argument variables are accessible, but may be incorrect. For more details on when variable values are accessible, Variable Value Availability. It is possible for an interrupt to happen when a function call or return is in progress. The debugger may then flame out with some obscure error or insist that the bottom of the stack has been reached, when the real problem is that the current stack frame can’t be located. If this happens, return from the interrupt and try again. Next: Source Location Printing, Previous: Stack Frames, Up: Debugger   [Contents][Index] 5.4 Variable Access There are two ways to access the current frame’s local variables in the debugger: list-locals and sb-debug:var. The debugger doesn’t really understand lexical scoping; it has just one namespace for all the variables in the current stack frame. If a symbol is the name of multiple variables in the same function, then the reference appears ambiguous, even though lexical scoping specifies which value is visible at any given source location. If the scopes of the two variables are not nested, then the debugger can resolve the ambiguity by observing that only one variable is accessible. When there are ambiguous variables, the evaluator assigns each one a small integer identifier. The sb-debug:var function uses this identifier to distinguish between ambiguous variables. The list-locals command prints the identifier. In the following example, there are two variables named X. The first one has identifier 0 (which is not printed), the second one has identifier 1. X  =  1 X#1  =  2  Debugger Command: list-locals [prefix] This command prints the name and value of all variables in the current frame whose name has the specified prefix. prefix may be a string or a symbol. If no prefix is given, then all available variables are printed. If a variable has a potentially ambiguous name, then the name is printed with a “#identifier” suffix, where identifier is the small integer used to make the name unique. Function: var [sb-debug] name &optional identifier This function returns the value of the variable in the current frame with the specified name. If supplied, identifier determines which value to return when there are ambiguous variables. When name is a symbol, it is interpreted as the symbol name of the variable, i.e. the package is significant. If name is an uninterned symbol (gensym), then return the value of the uninterned variable with the same name. If name is a string, sb-debug:var interprets it as the prefix of a variable name that must unambiguously complete to the name of a valid variable. identifier is used to disambiguate the variable name; use list-locals to find out the identifiers. • Variable Value Availability:    • Note On Lexical Variable Access:    Next: Note On Lexical Variable Access, Up: Variable Access   [Contents][Index] 5.4.1 Variable Value Availability The value of a variable may be unavailable to the debugger in portions of the program where Lisp says that the variable is defined. If a variable value is not available, the debugger will not let you read or write that variable. With one exception, the debugger will never display an incorrect value for a variable. Rather than displaying incorrect values, the debugger tells you the value is unavailable. The one exception is this: if you interrupt (e.g., with C-c) or if there is an unexpected hardware error such as “‘bus error’” (which should only happen in unsafe code), then the values displayed for arguments to the interrupted frame might be incorrect.4 This exception applies only to the interrupted frame: any frame farther down the stack will be fine. The value of a variable may be unavailable for these reasons: The value of the debug optimization quality may have omitted debug information needed to determine whether the variable is available. Unless a variable is an argument, its value will only be available when debug is at least 2. The compiler did lifetime analysis and determined that the value was no longer needed, even though its scope had not been exited. Lifetime analysis is inhibited when the debug optimization quality is 3. The variable’s name is an uninterned symbol (gensym). To save space, the compiler only dumps debug information about uninterned variables when the debug optimization quality is 3. The frame’s location is unknown (see Unknown Locations and Interrupts) because the debugger was entered due to an interrupt or unexpected hardware error. Under these conditions the values of arguments will be available, but might be incorrect. This is the exception mentioned above. The variable (or the code referencing it) was optimized out of existence. Variables with no reads are always optimized away. The degree to which the compiler deletes variables will depend on the value of the compilation-speed optimization quality, but most source-level optimizations are done under all compilation policies. The variable is never set and its definition looks like (LET ((var1 var2))    ...)  In this case, var1 is substituted with var2. The variable is never set and is referenced exactly once. In this case, the reference is substituted with the variable initial value. Since it is especially useful to be able to get the arguments to a function, argument variables are treated specially when the speed optimization quality is less than 3 and the debug quality is at least 1. With this compilation policy, the values of argument variables are almost always available everywhere in the function, even at unknown locations. For non-argument variables, debug must be at least 2 for values to be available, and even then, values are only available at known locations. Previous: Variable Value Availability, Up: Variable Access   [Contents][Index] 5.4.2 Note On Lexical Variable Access When the debugger command loop establishes variable bindings for available variables, these variable bindings have lexical scope and dynamic extent.5 You can close over them, but such closures can’t be used as upward function arguments. You can also set local variables using setq, but if the variable was closed over in the original source and never set, then setting the variable in the debugger may not change the value in all the functions the variable is defined in. Another risk of setting variables is that you may assign a value of a type that the compiler proved the variable could never take on. This may result in bad things happening. Next: Debugger Policy Control, Previous: Variable Access, Up: Debugger   [Contents][Index] 5.5 Source Location Printing One of the debugger’s capabilities is source level debugging of compiled code. These commands display the source location for the current frame: Debugger Command: source [context] This command displays the file that the current frame’s function was defined from (if it was defined from a file), and then the source form responsible for generating the code that the current frame was executing. If context is specified, then it is an integer specifying the number of enclosing levels of list structure to print. The source form for a location in the code is the innermost list present in the original source that encloses the form responsible for generating that code. If the actual source form is not a list, then some enclosing list will be printed. For example, if the source form was a reference to the variable *some-random-special*, then the innermost enclosing evaluated form will be printed. Here are some possible enclosing forms: (let ((a *some-random-special*))   ...)  (+ *some-random-special* ...)  If the code at a location was generated from the expansion of a macro or a source-level compiler optimization, then the form in the original source that expanded into that code will be printed. Suppose the file /usr/me/mystuff.lisp looked like this: (defmacro mymac ()   '(myfun))  (defun foo ()   (mymac)   ...)  If foo has called myfun, and is waiting for it to return, then the source command would print: ; File: /usr/me/mystuff.lisp  (MYMAC)  Note that the macro use was printed, not the actual function call form, (myfun). If enclosing source is printed by giving an argument to source or vsource, then the actual source form is marked by wrapping it in a list whose first element is ‘#:***HERE***’. In the previous example, source 1 would print: ; File: /usr/me/mystuff.lisp  (DEFUN FOO ()   (#:***HERE***    (MYMAC))   ...)  • How the Source is Found:    • Source Location Availability:    Next: Source Location Availability, Up: Source Location Printing   [Contents][Index] 5.5.1 How the Source is Found If the code was defined from Lisp by compile or eval, then the source can always be reliably located. If the code was defined from a fasl file created by compile-file, then the debugger gets the source forms it prints by reading them from the original source file. This is a potential problem, since the source file might have moved or changed since the time it was compiled. The source file is opened using the truename of the source file pathname originally given to the compiler. This is an absolute pathname with all logical names and symbolic links expanded. If the file can’t be located using this name, then the debugger gives up and signals an error. If the source file can be found, but has been modified since the time it was compiled, the debugger prints this warning: ; File has been modified since compilation: ;   filename ; Using form offset instead of character position.  where filename is the name of the source file. It then proceeds using a robust but not foolproof heuristic for locating the source. This heuristic works if: No top-level forms before the top-level form containing the source have been added or deleted, and The top-level form containing the source has not been modified much. (More precisely, none of the list forms beginning before the source form have been added or deleted.) If the heuristic doesn’t work, the displayed source will be wrong, but will probably be near the actual source. If the “shape” of the top-level form in the source file is too different from the original form, then an error will be signaled. When the heuristic is used, the source location commands are noticeably slowed. Source location printing can also be confused if (after the source was compiled) a read-macro you used in the code was redefined to expand into something different, or if a read-macro ever returns the same eq list twice. If you don’t define read macros and don’t use ## in perverted ways, you don’t need to worry about this. Previous: How the Source is Found, Up: Source Location Printing   [Contents][Index] 5.5.2 Source Location Availability Source location information is only available when the debug optimization quality is at least 2. If source location information is unavailable, the source commands will give an error message. If source location information is available, but the source location is unknown because of an interrupt or unexpected hardware error (see Unknown Locations and Interrupts), then the command will print: Unknown location: using block start.  and then proceed to print the source location for the start of the basic block enclosing the code location. It’s a bit complicated to explain exactly what a basic block is, but here are some properties of the block start location: The block start location may be the same as the true location. The block start location will never be later in the program’s flow of control than the true location. No conditional control structures (such as if, cond, or) will intervene between the block start and the true location (but note that some conditionals present in the original source could be optimized away.) Function calls do not end basic blocks. The head of a loop will be the start of a block. The programming language concept of “block structure” and the Lisp block special form are totally unrelated to the compiler’s basic block. In other words, the true location lies between the printed location and the next conditional (but watch out because the compiler may have changed the program on you.) Next: Exiting Commands, Previous: Source Location Printing, Up: Debugger   [Contents][Index] 5.6 Debugger Policy Control The compilation policy specified by optimize declarations affects the behavior seen in the debugger. The debug quality directly affects the debugger by controlling the amount of debugger information dumped. Other optimization qualities have indirect but observable effects due to changes in the way compilation is done. Unlike the other optimization qualities (which are compared in relative value to evaluate tradeoffs), the debug optimization quality is directly translated to a level of debug information. This absolute interpretation allows the user to count on a particular amount of debug information being available even when the values of the other qualities are changed during compilation. These are the levels of debug information that correspond to the values of the debug quality: 0 Only the function name and enough information to allow the stack to be parsed. > 0 Any level greater than 0 gives level 0 plus all argument variables. Values will only be accessible if the argument variable is never set and speed is not 3. SBCL allows any real value for optimization qualities. It may be useful to specify 0.5 to get backtrace argument display without argument documentation. 1 Level 1 provides argument documentation (printed argument lists) and derived argument/result type information. This makes describe more informative, and allows the compiler to do compile-time argument count and type checking for any calls compiled at run-time. This is the default. 2 Level 1 plus all interned local variables, source location information, and lifetime information that tells the debugger when arguments are available (even when speed is 3 or the argument is set). > 2 Any level greater than 2 gives level 2 and in addition disables tail-call optimization, so that the backtrace will contain frames for all invoked functions, even those in tail positions. 3 Level 2 plus all uninterned variables. In addition, lifetime analysis is disabled (even when speed is 3), ensuring that all variable values are available at any known location within the scope of the binding. This has a speed penalty in addition to the obvious space penalty. > (max speed space) If debug is greater than both speed and space, the command return can be used to continue execution by returning a value from the current stack frame. > (max speed space compilation-speed) If debug is greater than all of speed, space and compilation-speed the code will be steppable (see Single Stepping). As you can see, if the speed quality is 3, debugger performance is degraded. This effect comes from the elimination of argument variable special-casing (see Variable Value Availability). Some degree of speed/debuggability tradeoff is unavoidable, but the effect is not too drastic when debug is at least 2. In addition to inline and notinline declarations, the relative values of the speed and space qualities also change whether functions are inline expanded. If a function is inline expanded, then there will be no frame to represent the call, and the arguments will be treated like any other local variable. Functions may also be “semi-inline”, in which case there is a frame to represent the call, but the call is to an optimized local version of the function, not to the original function. Next: Information Commands, Previous: Debugger Policy Control, Up: Debugger   [Contents][Index] 5.7 Exiting Commands These commands get you out of the debugger. Debugger Command: toplevel Throw to top level. Debugger Command: restart [n] Invokes the nth restart case as displayed by the error command. If n is not specified, the available restart cases are reported. Debugger Command: continue Calls continue on the condition given to debug. If there is no restart case named continue, then an error is signaled. Debugger Command: abort Calls abort on the condition given to debug. This is useful for popping debug command loop levels or aborting to top level, as the case may be. Debugger Command: return value Returns value from the current stack frame. This command is available when the debug optimization quality is greater than both speed and space. Care must be taken that the value is of the same type as SBCL expects the stack frame to return. Debugger Command: restart-frame Restarts execution of the current stack frame. This command is available when the debug optimization quality is greater than both speed and space and when the frame is for is a global function. If the function is redefined in the debugger before the frame is restarted, the new function will be used. Next: Function Tracing, Previous: Exiting Commands, Up: Debugger   [Contents][Index] 5.8 Information Commands Most of these commands print information about the current frame or function, but a few show general information. Debugger Command: help Debugger Command: ? Displays a synopsis of debugger commands. Debugger Command: describe Calls describe on the current function and displays the number of local variables. Debugger Command: print Displays the current function call as it would be displayed by moving to this frame. Debugger Command: error Prints the condition given to invoke-debugger and the active proceed cases. Debugger Command: backtrace [n] Displays all the frames from the current to the bottom. Only shows n frames if specified. The printing is controlled by *debug-print-variable-alist*. Next: Single Stepping, Previous: Information Commands, Up: Debugger   [Contents][Index] 5.9 Function Tracing The tracer causes selected functions to print their arguments and their results whenever they are called. Options allow conditional printing of the trace information and conditional breakpoints on function entry or exit. Macro: trace [cl] &rest specs trace {Option Global-Value}* {Name {Option Value}*}* trace is a debugging tool that provides information when specified functions are called. In its simplest form:        (TRACE NAME-1 NAME-2 ...)  The NAMEs are not evaluated. Each may be a symbol, denoting an individual function, or a string, denoting all functions fbound to symbols whose home package is the package with the given name. Options allow modification of the default behavior. Each option is a pair of an option keyword and a value form. Global options are specified before the first name, and affect all functions traced by a given use of trace. Options may also be interspersed with function names, in which case they act as local options, only affecting tracing of the immediately preceding function name. Local options override global options. By default, trace causes a printout on *trace-output* each time that one of the named functions is entered or returns. (This is the basic, ansi Common Lisp behavior of trace.) As an sbcl extension, the :report sb-ext:profile option can be used to instead cause information to be silently recorded to be inspected later using the sb-ext:profile function. The following options are defined: :report Report-Type If Report-Type is trace (the default) then information is reported by printing immediately. If Report-Type is sb-ext:profile, information is recorded for later summary by calls to sb-ext:profile. If Report-Type is nil, then the only effect of the trace is to execute other options (e.g. print or BREAK). :condition Form :condition-after Form :condition-all Form If :condition is specified, then trace does nothing unless Form evaluates to true at the time of the call. :condition-after is similar, but suppresses the initial printout, and is tested when the function returns. :condition-all tries both before and after. This option is not supported with :report profile. :break Form :break-after Form :break-all Form If specified, and Form evaluates to true, then the debugger is invoked at the start of the function, at the end of the function, or both, according to the respective option. :print Form :print-after Form :print-all Form In addition to the usual printout, the result of evaluating Form is printed at the start of the function, at the end of the function, or both, according to the respective option. Multiple print options cause multiple values to be printed. :wherein Names If specified, Names is a function name or list of names. trace does nothing unless a call to one of those functions encloses the call to this function (i.e. it would appear in a backtrace.) Anonymous functions have string names like ""DEFUN FOO"". This option is not supported with :report profile. :encapsulate {:DEFAULT | t | NIL} If t, the tracing is done via encapsulation (redefining the function name) rather than by modifying the function. :default is the default, and means to use encapsulation for interpreted functions and funcallable instances, breakpoints otherwise. When encapsulation is used, forms are *not* evaluated in the function’s lexical environment, but sb-debug:arg can still be used. :methods {T | NIL} If t, any function argument naming a generic function will have its methods traced in addition to the generic function itself. :function Function-Form This is a not really an option, but rather another way of specifying what function to trace. The Function-Form is evaluated immediately, and the resulting function is instrumented, i.e. traced or profiled as specified in report. :condition, :break and :print forms are evaluated in a context which mocks up the lexical environment of the called function, so that sb-debug:var and sb-debug:arg can be used. The -after and -all forms can use sb-debug:arg. Macro: untrace [cl] &rest specs Remove tracing from the specified functions. Untraces all functions when called with no arguments. Variable: *trace-indentation-step* [sb-debug] the increase in trace indentation at each call level Variable: *max-trace-indentation* [sb-debug] If the trace indentation exceeds this value, then indentation restarts at 0. Variable: *trace-encapsulate-default* [sb-debug] the default value for the :encapsulate option to trace Next: Enabling and Disabling the Debugger, Previous: Function Tracing, Up: Debugger   [Contents][Index] 5.10 Single Stepping SBCL includes an instrumentation based single-stepper for compiled code, that can be invoked via the step macro, or from within the debugger. See Debugger Policy Control, for details on enabling stepping for compiled code. The following debugger commands are used for controlling single stepping. Debugger Command: start Selects the continue restart if one exists and starts single stepping. None of the other single stepping commands can be used before stepping has been started either by using start or by using the standard step macro. Debugger Command: step Steps into the current form. Stepping will be resumed when the next form that has been compiled with stepper instrumentation is evaluated. Debugger Command: next Steps over the current form. Stepping will be disabled until evaluation of the form is complete. Debugger Command: out Steps out of the current frame. Stepping will be disabled until the topmost stack frame that had been stepped into returns. Debugger Command: stop Stops the single stepper and resumes normal execution. Macro: step [cl] form The form is evaluated with single stepping enabled. Function calls outside the lexical scope of the form can be stepped into only if the functions in question have been compiled with sufficient debug policy to be at least partially steppable. Previous: Single Stepping, Up: Debugger   [Contents][Index] 5.11 Enabling and Disabling the Debugger In certain contexts (e.g., non-interactive applications), it may be desirable to turn off the SBCL debugger (and possibly re-enable it). The functions here control the debugger. Function: disable-debugger [sb-ext] When invoked, this function will turn off both the sbcl debugger and ldb (the low-level debugger). See also enable-debugger. Function: enable-debugger [sb-ext] Restore the debugger if it has been turned off by disable-debugger. Next: Beyond the ANSI Standard, Previous: Debugger, Up: Top   [Contents][Index] 6 Efficiency • Slot access:    • Dynamic-extent allocation:    • Modular arithmetic:    • Global and Always-Bound variables:    • Miscellaneous Efficiency Issues:    Next: Dynamic-extent allocation, Up: Efficiency   [Contents][Index] 6.1 Slot access 6.1.1 Structure object slot access Structure slot accessors are efficient only if the compiler is able to open code them: compiling a call to a structure slot accessor before the structure is defined, declaring one notinline, or passing it as a functional argument to another function causes severe performance degradation. 6.1.2 Standard object slot access The most efficient way to access a slot of a standard-object is by using slot-value with a constant slot name argument inside a defmethod body, where the variable holding the instance is a specializer parameter of the method and is never assigned to. The cost is roughly 1.6 times that of an open coded structure slot accessor. Second most efficient way is to use a CLOS slot accessor, or slot-value with a constant slot name argument, but in circumstances other than specified above. This may be up to 3 times as slow as the method described above. Example: (defclass foo () ((bar)))  ;; Fast: specializer and never assigned to (defmethod quux ((foo foo) new)   (let ((old (slot-value foo 'bar)))     (setf (slot-value foo 'bar) new)     old))  ;; Slow: not a specializer (defmethod quux ((foo foo) new)   (let* ((temp foo)          (old (slot-value temp 'bar)))     (setf (slot-value temp 'bar) new)     old))  ;; Slow: assignment to FOO (defmethod quux ((foo foo) new)   (let ((old (slot-value foo 'bar)))     (setf (slot-value foo 'bar) new)     (setf foo new)     old))  Note that when profiling code such as this, the first few calls to the generic function are not representative, as the dispatch mechanism is lazily set up during those calls. Next: Modular arithmetic, Previous: Slot access, Up: Efficiency   [Contents][Index] 6.2 Dynamic-extent allocation SBCL has fairly extensive support for performing allocation on the stack when a variable is declared dynamic-extent. The dynamic-extent declarations are not verified, but are simply trusted as long as sb-ext:*stack-allocate-dynamic-extent* is true. Variable: *stack-allocate-dynamic-extent* [sb-ext] If true (the default), the compiler respects dynamic-extent declarations and stack allocates otherwise inaccessible parts of the object whenever possible. Potentially long (over one page in size) vectors are, however, not stack allocated except in zero safety code, as such a vector could overflow the stack without triggering overflow protection. If dynamic extent constraints specified in the Common Lisp standard are violated, the best that can happen is for the program to have garbage in variables and return values; more commonly, the system will crash. In particular, it is important to realize that dynamic extend is contagious: (let* ((a (list 1 2 3))        (b (cons a a)))    (declare (dynamic-extent b))    ;; Unless A is accessed elsewhere as well, SBCL will consider    ;; it to be otherwise inaccessible -- it can only be accessed    ;; through B, after all -- and stack allocate it as well.    ;;    ;; Hence returning (CAR B) here is unsafe.    ...)  This allows stack allocation of complex structures. As a notable exception to this, SBCL does not as of 1.0.48.21 propagate dynamic-extentness through &rest arguments – but another conforming implementation might, so portable code should not rely on this. (declaim (inline foo)) (defun foo (fun &rest arguments)   (declare (dynamic-extent arguments))   (apply fun arguments))  (defun bar (a)   ;; SBCL will heap allocate the result of (LIST A), and stack allocate   ;; only the spine of the &rest list -- so this is safe, but unportable.   ;;   ;; Another implementation, including earlier versions of SBCL might consider   ;; (LIST A) to be otherwise inaccessible and stack-allocate it as well!   (foo #'car (list a)))  There are many cases when dynamic-extent declarations could be useful. At present, SBCL implements stack allocation for &rest lists, when these are declared dynamic-extent. cons, list, list*, and vector when the result is bound to a variable declared dynamic-extent. simple forms of make-array, whose result is bound to a variable declared dynamic-extent: stack allocation is possible only if the resulting array is known to be both simple and one-dimensional, and has a constant :element-type. Note: stack space is limited, so allocation of a large vector may cause stack overflow. For this reason potentially large vectors, which might circumvent stack overflow detection, are stack allocated only in zero safety policies. closures defined with flet or labels, with a bound dynamic-extent declaration. Blocks and tags are also allocated on the heap, unless all non-local control transfers to them are compiled with zero safety. user-defined structures when the structure constructor defined using defstruct has been declared inline and the result of the call to the constructor is bound to a variable declared dynamic-extent. Note: structures with “raw” slots can currently be stack-allocated only on x86 and x86-64. all of the above when they appear as initial parts of another stack-allocated object. Examples: ;;; Declaiming a structure constructor inline before definition makes ;;; stack allocation possible. (declaim (inline make-thing)) (defstruct thing obj next)  ;;; Stack allocation of various objects bound to DYNAMIC-EXTENT ;;; variables. (let* ((list (list 1 2 3))        (nested (cons (list 1 2) (list* 3 4 (list 5))))        (vector (make-array 3 :element-type 'single-float))        (thing (make-thing :obj list                           :next (make-thing :obj (make-array 3)))))   (declare (dynamic-extent list nested vector thing))   ...)  ;;; Stack allocation of arguments to a local function is equivalent ;;; to stack allocation of local variable values. (flet ((f (x)          (declare (dynamic-extent x))          ...))   ...   (f (list 1 2 3))   (f (cons (cons 1 2) (cons 3 4)))   ...)  ;;; Stack allocation of &REST lists (defun foo (&rest args)   (declare (dynamic-extent args))   ...)  Future plans include Automatic detection of the common idiom of calling quantifiers with a closure, even when the closure is not declared dynamic-extent. Next: Global and Always-Bound variables, Previous: Dynamic-extent allocation, Up: Efficiency   [Contents][Index] 6.3 Modular arithmetic Some numeric functions have a property: N lower bits of the result depend only on N lower bits of (all or some) arguments. If the compiler sees an expression of form (logand exp mask), where exp is a tree of such “good” functions and mask is known to be of type (unsigned-byte w), where w is a “good” width, all intermediate results will be cut to w bits (but it is not done for variables and constants!). This often results in an ability to use simple machine instructions for the functions. Consider an example. (defun i (x y)   (declare (type (unsigned-byte 32) x y))   (ldb (byte 32 0) (logxor x (lognot y))))  The result of (lognot y) will be negative and of type (signed-byte 33), so a naive implementation on a 32-bit platform is unable to use 32-bit arithmetic here. But modular arithmetic optimizer is able to do it: because the result is cut down to 32 bits, the compiler will replace logxor and lognot with versions cutting results to 32 bits, and because terminals (here—expressions x and y) are also of type (unsigned-byte 32), 32-bit machine arithmetic can be used. As of SBCL 0.8.5 “good” functions are +, -; logand, logior, logxor, lognot and their combinations; and ash with the positive second argument. “Good” widths are 32 on HPPA, MIPS, PPC, Sparc and x86 and 64 on Alpha. While it is possible to support smaller widths as well, currently this is not implemented. Next: Miscellaneous Efficiency Issues, Previous: Modular arithmetic, Up: Efficiency   [Contents][Index] 6.4 Global and Always-Bound variables Macro: defglobal [sb-ext] name value &optional doc Defines name as a global variable that is always bound. value is evaluated and assigned to name both at compile- and load-time, but only if name is not already bound. Global variables share their values between all threads, and cannot be locally bound, declared special, defined as constants, and neither bound nor defined as symbol macros. See also the declarations sb-ext:global and sb-ext:always-bound. Declaration: global [sb-ext] Syntax: (sb-ext:global symbol*) Only valid as a global proclamation. Specifies that the named symbols cannot be proclaimed or locally declared special. Proclaiming an already special or constant variable name as global signal an error. Allows more efficient value lookup in threaded environments in addition to expressing programmer intention. Declaration: always-bound [sb-ext] Syntax: (sb-ext:always-bound symbol*) Only valid as a global proclamation. Specifies that the named symbols are always bound. Inhibits makunbound of the named symbols. Proclaiming an unbound symbol as always-bound signals an error. Allows the compiler to elide boundness checks from value lookups. Previous: Global and Always-Bound variables, Up: Efficiency   [Contents][Index] 6.5 Miscellaneous Efficiency Issues FIXME: The material in the CMUCL manual about getting good performance from the compiler should be reviewed, reformatted in Texinfo, lightly edited for SBCL, and substituted into this manual. In the meantime, the original CMUCL manual is still 95+% correct for the SBCL version of the Python compiler. See the sections Advanced Compiler Use and Efficiency Hints Advanced Compiler Introduction More About Types in Python Type Inference Source Optimization Tail Recursion Local Call Block Compilation Inline Expansion Object Representation Numbers General Efficiency Hints Efficiency Notes Besides this information from the CMUCL manual, there are a few other points to keep in mind. The CMUCL manual doesn’t seem to state it explicitly, but Python has a mental block about type inference when assignment is involved. Python is very aggressive and clever about inferring the types of values bound with let, let*, inline function call, and so forth. However, it’s much more passive and dumb about inferring the types of values assigned with setq, setf, and friends. It would be nice to fix this, but in the meantime don’t expect that just because it’s very smart about types in most respects it will be smart about types involved in assignments. (This doesn’t affect its ability to benefit from explicit type declarations involving the assigned variables, only its ability to get by without explicit type declarations.) Since the time the CMUCL manual was written, CMUCL (and thus SBCL) has gotten a generational garbage collector. This means that there are some efficiency implications of various patterns of memory usage which aren’t discussed in the CMUCL manual. (Some new material should be written about this.) SBCL has some important known efficiency problems. Perhaps the most important are - The garbage collector is not particularly efficient, at least on platforms without the generational collector (as of SBCL 0.8.9, all except x86). - Various aspects of the PCL implementation of CLOS are more inefficient than necessary. Finally, note that Common Lisp defines many constructs which, in the infamous phrase, “could be compiled efficiently by a sufficiently smart compiler”. The phrase is infamous because making a compiler which actually is sufficiently smart to find all these optimizations systematically is well beyond the state of the art of current compiler technology. Instead, they’re optimized on a case-by-case basis by hand-written code, or not optimized at all if the appropriate case hasn’t been hand-coded. Some cases where no such hand-coding has been done as of SBCL version 0.6.3 include (reduce #'f x) where the type of x is known at compile time various bit vector operations, e.g. (position 0 some-bit-vector) specialized sequence idioms, e.g. (remove item list :count 1) cases where local compilation policy does not require excessive type checking, e.g. (locally (declare (safety 1)) (assoc item list)) (which currently performs safe endp checking internal to assoc). If your system’s performance is suffering because of some construct which could in principle be compiled efficiently, but which the SBCL compiler can’t in practice compile efficiently, consider writing a patch to the compiler and submitting it for inclusion in the main sources. Such code is often reasonably straightforward to write; search the sources for the string “deftransform” to find many examples (some straightforward, some less so). Next: Foreign Function Interface, Previous: Efficiency, Up: Top   [Contents][Index] 7 Beyond the ANSI Standard SBCL is derived from CMUCL, which implements many extensions to the ANSI standard. SBCL doesn’t support as many extensions as CMUCL, but it still has quite a few. See Contributed Modules. • Reader Extensions:    • Package-Local Nicknames:    • Package Variance:    • Garbage Collection:    • Metaobject Protocol:    • Extensible Sequences:    • Support For Unix:    • Unicode Support:    • Customization Hooks for Users:    • Tools To Help Developers:    • Resolution of Name Conflicts:    • Hash Table Extensions:    • Random Number Generation:    • Miscellaneous Extensions:    • Stale Extensions:    • Efficiency Hacks:    Next: Package-Local Nicknames, Up: Beyond the ANSI Standard   [Contents][Index] 7.1 Reader Extensions SBCL supports extended package prefix syntax, which allows specifying an alternate package instead of *package* for the reader to use as the default package for interning symbols: package-name::form-with-interning-into-package  Example:   'foo::(bar quux zot) == '(foo::bar foo::quux foo::zot)  Doesn’t alter *package*: if foo::bar would cause a read-time package lock violation, so does foo::(bar). SBCL also extends the reader to normalize all symbols to Normalization Form KC in builds with Unicode enabled. Whether symbols are normalized is controlled by Function: readtable-normalization [sb-ext] readtable Returns t if readtable normalizes strings to nfkc, and nil otherwise. The readtable-normalization of the standard readtable is t. Symbols created by intern and similar functions are not affected by this setting. If sb-ext:readtable-normalization is t, symbols that are not normalized are escaped during printing. Next: Package Variance, Previous: Reader Extensions, Up: Beyond the ANSI Standard   [Contents][Index] 7.2 Package-Local Nicknames SBCL allows giving packages local nicknames: they allow short and easy-to-use names to be used without fear of name conflict associated with normal nicknames. A local nickname is valid only when inside the package for which it has been specified. Different packages can use same local nickname for different global names, or different local nickname for same global name. Symbol :package-local-nicknames in *features* denotes the support for this feature. Macro: defpackage [cl] name [[option]]* ⇒ package Options are extended to include :local-nicknames (local-nickname actual-package-name)* The package has the specified local nicknames for the corresponding actual packages. Example: (defpackage :bar (:intern ""X"")) (defpackage :foo (:intern ""X"")) (defpackage :quux (:use :cl) (:local-nicknames (:bar :foo) (:foo :bar))) (find-symbol ""X"" :foo) ; => FOO::X (find-symbol ""X"" :bar) ; => BAR::X (let ((*package* (find-package :quux)))   (find-symbol ""X"" :foo))               ; => BAR::X (let ((*package* (find-package :quux)))   (find-symbol ""X"" :bar))               ; => FOO::X  Function: package-local-nicknames [sb-ext] package-designator Returns an alist of (local-nickname . actual-package) describing the nicknames local to the designated package. When in the designated package, calls to find-package with the any of the local-nicknames will return the corresponding actual-package instead. This also affects all implied calls to find-package, including those performed by the reader. When printing a package prefix for a symbol with a package local nickname, the local nickname is used instead of the real name in order to preserve print-read consistency. See also: add-package-local-nickname, package-locally-nicknamed-by-list, remove-package-local-nickname, and the defpackage option :local-nicknames. Experimental: interface subject to change. Function: package-locally-nicknamed-by-list [sb-ext] package-designator Returns a list of packages which have a local nickname for the designated package. See also: add-package-local-nickname, package-local-nicknames, remove-package-local-nickname, and the defpackage option :local-nicknames. Experimental: interface subject to change. Function: add-package-local-nickname [sb-ext] local-nickname actual-package &optional package-designator Adds local-nickname for actual-package in the designated package, defaulting to current package. local-nickname must be a string designator, and actual-package must be a package designator. Returns the designated package. Signals a continuable error if local-nickname is already a package local nickname for a different package, or if local-nickname is one of ""CL"", ""COMMON-LISP"", or, ""KEYWORD"", or if local-nickname is a global name or nickname for the package to which the nickname would be added. When in the designated package, calls to find-package with the local-nickname will return the package the designated actual-package instead. This also affects all implied calls to find-package, including those performed by the reader. When printing a package prefix for a symbol with a package local nickname, local nickname is used instead of the real name in order to preserve print-read consistency. See also: package-local-nicknames, package-locally-nicknamed-by-list, remove-package-local-nickname, and the defpackage option :local-nicknames. Experimental: interface subject to change. Function: remove-package-local-nickname [sb-ext] old-nickname &optional package-designator If the designated package had old-nickname as a local nickname for another package, it is removed. Returns true if the nickname existed and was removed, and nil otherwise. See also: add-package-local-nickname, package-local-nicknames, package-locally-nicknamed-by-list, and the defpackage option :local-nicknames. Experimental: interface subject to change. Next: Garbage Collection, Previous: Package-Local Nicknames, Up: Beyond the ANSI Standard   [Contents][Index] 7.3 Package Variance Common Lisp standard specifies that “If the new definition is at variance with the current state of that package, the consequences are undefined;” SBCL by default signals a full warning and retains as much of the package state as possible. This can be adjusted using sb-ext:*on-package-variance*: Variable: *on-package-variance* [sb-ext] Specifies behavior when redefining a package using defpackage and the definition is in variance with the current state of the package. The value should be of the form:   (:WARN [T | packages-names] :ERROR [T | package-names])  specifying which packages get which behaviour -- with t signifying the default unless otherwise specified. If default is not specified, :warn is used. :warn keeps as much state as possible and causes sbcl to signal a full warning. :error causes sbcl to signal an error when the variant defpackage form is executed, with restarts provided for user to specify what action should be taken. Example:   (setf *on-package-variance* '(:warn (:swank :swank-backend) :error t))  specifies to signal a warning if swank package is in variance, and an error otherwise. Next: Metaobject Protocol, Previous: Package Variance, Up: Beyond the ANSI Standard   [Contents][Index] 7.4 Garbage Collection SBCL provides additional garbage collection functionality not specified by ANSI. Variable: *after-gc-hooks* [sb-ext] Called after each garbage collection, except for garbage collections triggered during thread exits. In a multithreaded environment these hooks may run in any thread. Function: gc [sb-ext] &key full gen &allow-other-keys Initiate a garbage collection. The default is to initiate a nursery collection, which may in turn trigger a collection of one or more older generations as well. If full is true, all generations are collected. If gen is provided, it can be used to specify the oldest generation guaranteed to be collected. On CheneyGC platforms arguments full and gen take no effect: a full collection is always performed. 7.4.1 Finalization Finalization allows code to be executed after an object has been garbage collected. This is useful for example for releasing foreign memory associated with a Lisp object. Function: finalize [sb-ext] object function &key dont-save Arrange for the designated function to be called when there are no more references to object, including references in function itself. If dont-save is true, the finalizer will be cancelled when save-lisp-and-die is called: this is useful for finalizers deallocating system memory, which might otherwise be called with addresses from the old image. In a multithreaded environment function may be called in any thread. In both single and multithreaded environments function may be called in any dynamic scope: consequences are unspecified if function is not fully re-entrant. Errors from function are handled and cause a warning to be signalled in whichever thread the function was called in. Examples:   ;;; GOOD, assuming RELEASE-HANDLE is re-entrant.   (let* ((handle (get-handle))          (object (make-object handle)))    (finalize object (lambda () (release-handle handle)))    object)    ;;; BAD, finalizer refers to object being finalized, causing   ;;; it to be retained indefinitely!   (let* ((handle (get-handle))          (object (make-object handle)))     (finalize object               (lambda ()                 (release-handle (object-handle object)))))    ;;; BAD, not re-entrant!   (defvar *rec* nil)    (defun oops ()    (when *rec*      (error ""recursive OOPS""))    (let ((*rec* t))      (gc))) ; or just cons enough to cause one    (progn     (finalize ""oops"" #'oops)     (oops)) ; GC causes re-entry to #'oops due to the finalizer             ; -> ERROR, caught, WARNING signalled  Function: cancel-finalization [sb-ext] object Cancel any finalization for object. 7.4.2 Weak Pointers Weak pointers allow references to objects to be maintained without keeping them from being garbage collected: useful for building caches among other things. Hash tables can also have weak keys and values: see Hash Table Extensions. Function: make-weak-pointer [sb-ext] object Allocate and return a weak pointer which points to object. Function: weak-pointer-value [sb-ext] weak-pointer If weak-pointer is valid, return the value of weak-pointer and t. If the referent of weak-pointer has been garbage collected, returns the values nil and nil. 7.4.3 Introspection and Tuning Variable: *gc-run-time* [sb-ext] Total cpu time spent doing garbage collection (as reported by get-internal-run-time.) Initialized to zero on startup. It is safe to bind this to zero in order to measure gc time inside a certain section of code, but doing so may interfere with results reported by eg. time. Function: bytes-consed-between-gcs [sb-ext] The amount of memory that will be allocated before the next garbage collection is initiated. This can be set with setf. On gencgc platforms this is the nursery size, and defaults to 5% of dynamic space size. Note: currently changes to this value are lost when saving core. Function: dynamic-space-size [sb-ext] Size of the dynamic space in bytes. Function: get-bytes-consed [sb-ext] Return the number of bytes consed since the program began. Typically this result will be a consed bignum, so if you have an application (e.g. profiling) which can’t tolerate the overhead of consing bignums, you’ll probably want either to hack in at a lower level (as the code in the sb-profile package does), or to design a more microefficient interface and submit it as a patch. Function: gc-logfile [sb-ext] Return the pathname used to log garbage collections. Can be setf. Default is nil, meaning collections are not logged. If non-null, the designated file is opened before and after each collection, and generation statistics are appended to it. Function: generation-average-age [sb-ext] generation Average age of memory allocated to generation: average number of times objects allocated to the generation have seen younger objects promoted to it. Available on gencgc platforms only. Experimental: interface subject to change. Function: generation-bytes-allocated [sb-ext] generation Number of bytes allocated to generation currently. Available on gencgc platforms only. Experimental: interface subject to change. Function: generation-bytes-consed-between-gcs [sb-ext] generation Number of bytes that can be allocated to generation before that generation is considered for garbage collection. This value is meaningless for generation 0 (the nursery): see bytes-consed-between-gcs instead. Default is 5% of the dynamic space size divided by the number of non-nursery generations. Can be assigned to using setf. Available on gencgc platforms only. Experimental: interface subject to change. Function: generation-minimum-age-before-gc [sb-ext] generation Minimum average age of objects allocated to generation before that generation is may be garbage collected. Default is 0.75. See also generation-average-age. Can be assigned to using setf. Available on gencgc platforms only. Experimental: interface subject to change. Function: generation-number-of-gcs-before-promotion [sb-ext] generation Number of times garbage collection is done on generation before automatic promotion to the next generation is triggered. Default is 1. Can be assigned to using setf. Available on gencgc platforms only. Experimental: interface subject to change. Function: generation-number-of-gcs [sb-ext] generation Number of times garbage collection has been done on generation without promotion. Available on gencgc platforms only. Experimental: interface subject to change. Next: Extensible Sequences, Previous: Garbage Collection, Up: Beyond the ANSI Standard   [Contents][Index] 7.5 Metaobject Protocol 7.5.1 AMOP Compatibility of Metaobject Protocol SBCL supports a metaobject protocol which is intended to be compatible with AMOP; present exceptions to this (as distinct from current bugs) are: compute-effective-method only returns one value, not two. There is no record of what the second return value was meant to indicate, and apparently no clients for it. The direct superclasses of funcallable-standard-object are (function standard-object), not (standard-object function). This is to ensure that the standard-object class is the last of the standardized classes before t appearing in the class precedence list of generic-function and standard-generic-function, as required by section 1.4.4.5 of the ANSI specification. the arguments :declare and :declarations to ensure-generic-function are both accepted, with the leftmost argument defining the declarations to be stored and returned by generic-function-declarations. Where AMOP specifies :declarations as the keyword argument to ensure-generic-function, the Common Lisp standard specifies :declare. Portable code should use :declare. although SBCL obeys the requirement in AMOP that validate-superclass should treat standard-class and funcallable-standard-class as compatible metaclasses, we impose an additional requirement at class finalization time: a class of metaclass funcallable-standard-class must have function in its superclasses, and a class of metaclass standard-class must not. After a class has been finalized, it is associated with a class prototype which is accessible by a standard mop function class-prototype. The user can then ask whether this object is a function or not in several different ways: whether it is a function according to typep; whether its class-of is subtypep function, or whether function appears in the superclasses of the class. The additional consistency requirement comes from the desire to make all of these answers the same. The following class definitions are bad, and will lead to errors either immediately or if an instance is created: (defclass bad-object (funcallable-standard-object)   ()   (:metaclass standard-class))  (defclass bad-funcallable-object (standard-object)   ()   (:metaclass funcallable-standard-class))  The following definition is acceptable: (defclass mixin ()   ((slot :initarg slot))) (defclass funcallable-object (funcallable-standard-object mixin)   ()   (:metaclass funcallable-standard-class))  and leads to a class whose instances are funcallable and have one slot. Note that this requirement also applies to the class funcallable-standard-object, which has metaclass funcallable-standard-class rather than standard-class as AMOP specifies. the requirement that “No portable class C_p may inherit, by virtue of being a direct or indirect subclass of a specified class, any slot for which the name is a symbol accessible in the common-lisp-user package or exported by any package defined in the ANSI Common Lisp standard.” is interpreted to mean that the standardized classes themselves should not have slots named by external symbols of public packages. The rationale behind the restriction is likely to be similar to the ANSI Common Lisp restriction on defining functions, variables and types named by symbols in the Common Lisp package: preventing two independent pieces of software from colliding with each other. specializations of the new-value argument to (setf slot-value-using-class) are not allowed: all user-defined methods must have a specializer of the class t. This prohibition is motivated by a separation of layers: the slot-value-using-class family of functions is intended for use in implementing different and new slot allocation strategies, rather than in performing application-level dispatching. Additionally, with this requirement, there is a one-to-one mapping between metaclass, class and slot-definition-class tuples and effective methods of (setf slot-value-using-class), which permits optimization of (setf slot-value-using-class)’s discriminating function in the same manner as for slot-value-using-class and slot-boundp-using-class. Note that application code may specialize on the new-value argument of slot accessors. the class named by the name argument to ensure-class, if any, is only redefined if it is the proper name of that class; otherwise, a new class is created. This is consistent with the description of ensure-class in AMOP as the functional version of defclass, which has this behaviour; however, it is not consistent with the weaker requirement in AMOP, which states that any class found by find-class, no matter what its class-name, is redefined. an error is not signaled in the case of the :name initialization argument for slot-definition objects being a constant, when the slot definition is of type structure-slot-definition (i.e. it is associated with a class of type structure-class). This allows code which uses constant names for structure slots to continue working as specified in ANSI, while enforcing the constraint for all other types of slot. the class named t is not an instance of the built-in-class metaclass. AMOP specifies, in the “Inheritance Structure of Metaobject Classes” section, that the class named t should be an instance of built-in-class. However, it also specifies that validate-superclass should return true (indicating that a direct superclass relationship is permissible) if the second argument is the class named t. Also, ANSI specifies that classes with metaclass built-in-class may not be subclassed using defclass, and also that the class named t is the universal superclass, inconsistent with it being a built-in-class. 7.5.2 Metaobject Protocol Extensions In addition, SBCL supports extensions to the Metaobject protocol from AMOP; at present, they are: compile-time support for generating specializer metaobjects from specializer names in defmethod forms is provided by the make-method-specializers-form function, which returns a form which, when evaluated in the lexical environment of the defmethod, returns a list of specializer metaobjects. This operator suffers from similar restrictions to those affecting make-method-lambda, namely that the generic function must be defined when the defmethod form is expanded, so that the correct method of make-method-specializers-form is invoked. The system-provided method on make-method-specializers-form generates a call to find-class for each symbol specializer name, and a call to intern-eql-specializer for each (eql x) specializer name. run-time support for converting between specializer names and specializer metaobjects, mostly for the purposes of find-method, is provided by parse-specializer-using-class and unparse-specializer-using-class, which dispatch on their first argument, the generic function associated with a method with the given specializer. The system-provided methods on those methods convert between classes and proper names and between lists of the form (eql x) and interned eql specializer objects. distinguishing unbound instance allocated slots from bound ones when using standard-instance-access and funcallable-standard-instance-access is possible by comparison to the constant +slot-unbound+. Next: Support For Unix, Previous: Metaobject Protocol, Up: Beyond the ANSI Standard   [Contents][Index] 7.6 Extensible Sequences • Iterator Protocol:    • Simple Iterator Protocol:    ANSI Common Lisp has a class sequence with subclasses list and vector on which the “sequence functions” like find, subseq, etc. operate. As an extension to the ANSI specification, SBCL allows additional subclasses of sequence to be defined 6. Users of this extension just make instances of sequence subclasses and transparently operate on them using sequence functions: (coerce (subseq (make-instance 'my-sequence) 5 10) 'list)  From this perspective, no distinction between builtin and user-defined sequence subclasses should be necessary. Providers of the extension, that is of user-defined sequence subclasses, have to adhere to a “sequence protocol” which consists of a set of generic functions in the sequence package. A minimal sequence subclass has to specify standard-object and sequence as its superclasses and has to be the specializer of the sequence parameter of methods on at least the following generic functions: Generic Function: length [sb-sequence] sequence Returns the length of sequence or signals a protocol-unimplemented error if the sequence protocol is not implemented for the class of sequence. Generic Function: elt [sb-sequence] sequence index Returns the element at position index of sequence or signals a protocol-unimplemented error if the sequence protocol is not implemented for the class of sequence. Generic Function: (setf elt [sb-sequence]) Replaces the element at position index of sequence with new-value and returns new-value or signals a protocol-unimplemented error if the sequence protocol is not implemented for the class of sequence. Generic Function: adjust-sequence [sb-sequence] sequence length &key initial-element initial-contents Return destructively modified sequence or a freshly allocated sequence of the same class as sequence of length length. Elements of the returned sequence are initialized to initial-element, if supplied, initialized to initial-contents if supplied, or identical to the elements of sequence if neither is supplied. Signals a protocol-unimplemented error if the sequence protocol is not implemented for the class of sequence. Generic Function: make-sequence-like [sb-sequence] sequence length &key initial-element initial-contents Returns a freshly allocated sequence of length length and of the same class as sequence. Elements of the new sequence are initialized to initial-element, if supplied, initialized to initial-contents if supplied, or identical to the elements of sequence if neither is supplied. Signals a protocol-unimplemented error if the sequence protocol is not implemented for the class of sequence. make-sequence-like is needed for functions returning freshly-allocated sequences such as subseq or copy-seq. adjust-sequence is needed for functions which destructively modify their arguments such as delete. In fact, all other sequence functions can be implemented in terms of the above functions and actually are, if no additional methods are defined. However, relying on these generic implementations, in particular not implementing the iterator protocol can incur a high performance penalty See Iterator Protocol. When the sequence protocol is only partially implemented for a given sequence subclass, an attempt to apply one of the missing operations to instances of that class signals the following condition: Condition: protocol-unimplemented [sb-sequence] Class precedence list: protocol-unimplemented, type-error, error, serious-condition, condition, t This error is signaled if a sequence operation is applied to an instance of a sequence class that does not support the operation. In addition to the mandatory functions above, methods on the sequence functions listed below can be defined. There are two noteworthy irregularities: The function sb-sequence:emptyp does not have a counterpart in the cl package. It is intended to be used instead of length when working with lazy or infinite sequences. The functions map, concatenate and merge receive a type designator specifying the type of the constructed sequence as their first argument. However, the corresponding generic functions sb-sequence:map, sb-sequence:concatenate and sb-sequence:merge receive a prototype instance of the requested sequence subclass instead. Generic Function: emptyp [sb-sequence] sequence Returns t if sequence is an empty sequence and nil otherwise. Signals an error if sequence is not a sequence. sb-sequence:count, sb-sequence:count-if, sb-sequence:count-if-not sb-sequence:find, sb-sequence:find-if, sb-sequence:find-if-not sb-sequence:position, sb-sequence:position-if, sb-sequence:position-if-not sb-sequence:subseq sb-sequence:copy-seq sb-sequence:fill Generic Function: map [sb-sequence] result-prototype function sequence &rest sequences Implements cl:map for extended sequences. result-prototype corresponds to the result-type of cl:map but receives a prototype instance of an extended sequence class instead of a type specifier. By dispatching on result-prototype, methods on this generic function specify how extended sequence classes act when they are specified as the result type in a cl:map call. result-prototype may not be fully initialized and thus should only be used for dispatch and to determine its class. Another difference to cl:map is that function is a function, not a function designator. sb-sequence:nsubstitute, sb-sequence:nsubstitute-if, sb-sequence:nsubstitute-if-not, sb-sequence:substitute, sb-sequence:substitute-if, sb-sequence:substitute-if-not sb-sequence:replace sb-sequence:nreverse, sb-sequence:reverse Generic Function: concatenate [sb-sequence] result-prototype &rest sequences Implements cl:concatenate for extended sequences. result-prototype corresponds to the result-type of cl:concatenate but receives a prototype instance of an extended sequence class instead of a type specifier. By dispatching on result-prototype, methods on this generic function specify how extended sequence classes act when they are specified as the result type in a cl:concatenate call. result-prototype may not be fully initialized and thus should only be used for dispatch and to determine its class. sb-sequence:reduce sb-sequence:mismatch sb-sequence:search sb-sequence:delete, sb-sequence:delete-if, sb-sequence:delete-if-not, sb-sequence:remove, sb-sequence:remove-if, sb-sequence:remove-if-not, sb-sequence:delete-duplicates, sb-sequence:remove-duplicates sb-sequence:sort, sb-sequence:stable-sort Generic Function: merge [sb-sequence] result-prototype sequence1 sequence2 predicate &key key Implements cl:merge for extended sequences. result-prototype corresponds to the result-type of cl:merge but receives a prototype instance of an extended sequence class instead of a type specifier. By dispatching on result-prototype, methods on this generic function specify how extended sequence classes act when they are specified as the result type in a cl:merge call. result-prototype may not be fully initialized and thus should only be used for dispatch and to determine its class. Another difference to cl:merge is that predicate is a function, not a function designator. In the spirit of dolist, generic sequences can be traversed using the macro Macro: dosequence [sb-sequence] (element sequence &optional return) &body body Executes body with element subsequently bound to each element of sequence, then returns return. Next: Simple Iterator Protocol, Up: Extensible Sequences   [Contents][Index] 7.6.1 Iterator Protocol The iterator protocol allows subsequently accessing some or all elements of a sequence in forward or reverse direction. Users first call make-sequence-iterator to create an iteration state and receive functions to query and mutate it. These functions allow, among other things, moving to, retrieving or modifying elements of the sequence. An iteration state consists of a state object, a limit object, a from-end indicator and the following six functions to query or mutate this state: Function: step function sequence iterator from-end Moves the iterator one position forward or backward in the associated sequence depending on the iteration direction. Function: endp function sequence iterator limit from-end Returns non-nil when the iterator has reached the end of the associated sequence with respect to the iteration direction. Function: element function sequence iterator Returns the sequence element associated to the current position of the iteration. Function: setf element function new-value sequence iterator Destructively modifies the associates sequence by replacing the sequence element associated to the current iteration position with a new value. Function: index function sequence iterator Returns the position of the iteration in the associated sequence. Function: copy function sequence iterator Returns a copy of the iteration state which can be mutated independently of the copied iteration state. An iterator is created by calling: Generic Function: make-sequence-iterator [sb-sequence] sequence &key from-end start end Returns a sequence iterator for sequence or, if start and/or end are supplied, the subsequence bounded by start and end as nine values: 1. iterator state 2. limit 3. from-end 4. step function 5. endp function 6. element function 7. setf element function 8. index function 9. copy state function If from-end is nil, the constructed iterator visits the specified elements in the order in which they appear in sequence. Otherwise, the elements are visited in the opposite order. Note that make-sequence-iterator calls make-simple-sequence-iterator when there is no specialized method for a particular sequence subclass. See Simple Iterator Protocol. The following convenience macros simplify traversing sequences using iterators: Macro: with-sequence-iterator [sb-sequence] (&rest vars) (sequence &rest args &key from-end start end) &body body Executes body with the elements of vars bound to the iteration state returned by make-sequence-iterator for sequence and args. Elements of vars may be nil in which case the corresponding value returned by make-sequence-iterator is ignored. Macro: with-sequence-iterator-functions [sb-sequence] (step endp elt setf index copy) (sequence &rest args &key from-end start end) &body body Executes body with the names step, endp, elt, setf, index and copy bound to local functions which execute the iteration state query and mutation functions returned by make-sequence-iterator for sequence and args. step, endp, elt, setf, index and copy have dynamic extent. Previous: Iterator Protocol, Up: Extensible Sequences   [Contents][Index] 7.6.2 Simple Iterator Protocol For cases in which the full flexibility and performance of the general sequence iterator protocol is not required, there is a simplified sequence iterator protocol consisting of a few generic functions which can be specialized for iterator classes: Generic Function: iterator-step [sb-sequence] sequence iterator from-end Moves iterator one position forward or backward in sequence depending on the iteration direction encoded in from-end. Generic Function: iterator-endp [sb-sequence] sequence iterator limit from-end Returns non-NIL when iterator has reached limit (which may correspond to the end of SEQUENCE) with respect to the iteration direction encoded in from-end. Generic Function: iterator-element [sb-sequence] sequence iterator Returns the element of sequence associated to the position of iterator. Generic Function: (setf iterator-element [sb-sequence]) Destructively modifies sequence by replacing the sequence element associated to position of iterator with new-value. Generic Function: iterator-index [sb-sequence] sequence iterator Returns the position of iterator in sequence. Generic Function: iterator-copy [sb-sequence] sequence iterator Returns a copy of iterator which also traverses sequence but can be mutated independently of iterator. Iterator objects implementing the above simple iteration protocol are created by calling the following generic function: Generic Function: make-simple-sequence-iterator [sb-sequence] sequence &key from-end start end Returns a sequence iterator for sequence, start, end and from-end as three values: 1. iterator state 2. limit 3. from-end The returned iterator can be used with the generic iterator functions iterator-step, iterator-endp, iterator-element, (SETF ITERATOR-ELEMENT), iterator-index and iterator-copy. Next: Unicode Support, Previous: Extensible Sequences, Up: Beyond the ANSI Standard   [Contents][Index] 7.7 Support For Unix • Command-line arguments:    • Querying the process environment:    • Running external programs:    Next: Querying the process environment, Up: Support For Unix   [Contents][Index] 7.7.1 Command-line arguments The UNIX command line can be read from the variable sb-ext:*posix-argv*. Next: Running external programs, Previous: Command-line arguments, Up: Support For Unix   [Contents][Index] 7.7.2 Querying the process environment The UNIX environment can be queried with the sb-ext:posix-getenv function. Function: posix-getenv [sb-ext] name Return the ""value"" part of the environment string ""name=value"" which corresponds to name, or nil if there is none. Previous: Querying the process environment, Up: Support For Unix   [Contents][Index] 7.7.3 Running external programs External programs can be run with sb-ext:run-program. 7 Function: run-program [sb-ext] program args &key env environment wait search pty input if-input-does-not-exist output if-output-exists error if-error-exists status-hook external-format directory run-program creates a new process specified by the program argument. args are the standard arguments that can be passed to a program. For no arguments, use nil (which means that just the name of the program is passed as arg 0). The program arguments and the environment are encoded using the default external format for streams. run-program will return a process structure. See the cmu Common Lisp Users Manual for details about the process structure. Notes about Unix environments (as in the :environment and :env args): The sbcl implementation of run-program, like Perl and many other programs, but unlike the original cmu cl implementation, copies the Unix environment by default. Running Unix programs from a setuid process, or in any other situation where the Unix environment is under the control of someone else, is a mother lode of security problems. If you are contemplating doing this, read about it first. (The Perl community has a lot of good documentation about this and other security issues in script-like programs.) The &key arguments have the following meanings: :environment a list of STRINGs describing the new Unix environment (as in ""man environ""). The default is to copy the environment of the current process. :env an alternative lossy representation of the new Unix environment, for compatibility with cmu cl :search Look for program in each of the directories in the child’s $PATH environment variable. Otherwise an absolute pathname is required. :wait If non-NIL (default), wait until the created process finishes. If nil, continue running Lisp until the program finishes. :pty Either t, nil, or a stream. Unless nil, the subprocess is established under a pty. If :pty is a stream, all output to this pty is sent to this stream, otherwise the process-pty slot is filled in with a stream connected to pty that can read output and write input. :input Either t, nil, a pathname, a stream, or :stream. If t, the standard input for the current process is inherited. If nil, /dev/null is used. If a pathname, the file so specified is used. If a stream, all the input is read from that stream and sent to the subprocess. If :stream, the process-input slot is filled in with a stream that sends its output to the process. Defaults to nil. :if-input-does-not-exist (when :input is the name of a file) can be one of: :error to generate an error :create to create an empty file nil (the default) to return nil from run-program :output Either t, nil, a pathname, a stream, or :stream. If t, the standard output for the current process is inherited. If nil, /dev/null is used. If a pathname, the file so specified is used. If a stream, all the output from the process is written to this stream. If :stream, the process-output slot is filled in with a stream that can be read to get the output. Defaults to nil. :if-output-exists (when :output is the name of a file) can be one of: :error (the default) to generate an error :supersede to supersede the file with output from the program :append to append output from the program to the file nil to return nil from run-program, without doing anything :error and :if-error-exists Same as :output and :if-output-exists, except that :error can also be specified as :output in which case all error output is routed to the same place as normal output. :status-hook This is a function the system calls whenever the status of the process changes. The function takes the process as an argument. :external-format The external-format to use for :input, :output, and :error :STREAMs. :directory Specifies the directory in which the program should be run. nil (the default) means the directory is unchanged. When sb-ext:run-program is called with wait equal to NIL, an instance of class sb-ext:process is returned. The following functions are available for use with processes: Function: process-p [sb-ext] object t if object is a process, nil otherwise. Function: process-input [sb-ext] instance The input stream of the process or nil. Function: process-output [sb-ext] instance The output stream of the process or nil. Function: process-error [sb-ext] instance The error stream of the process or nil. Function: process-alive-p [sb-ext] process Return t if process is still alive, nil otherwise. Function: process-status [sb-ext] process Return the current status of process. The result is one of :running, :stopped, :exited, or :signaled. Function: process-wait [sb-ext] process &optional check-for-stopped Wait for process to quit running for some reason. When check-for-stopped is t, also returns when process is stopped. Returns process. Function: process-exit-code [sb-ext] process The exit code or the signal of a stopped process. Function: process-core-dumped [sb-ext] instance t if a core image was dumped by the process. Function: process-close [sb-ext] process Close all streams connected to process and stop maintaining the status slot. Function: process-kill [sb-ext] process signal &optional whom Hand signal to process. If whom is :pid, use the kill Unix system call. If whom is :process-group, use the killpg Unix system call. If whom is :pty-process-group deliver the signal to whichever process group is currently in the foreground. Next: Customization Hooks for Users, Previous: Support For Unix, Up: Beyond the ANSI Standard   [Contents][Index] 7.8 Unicode Support SBCL provides support for working with Unicode text and querying the standard Unicode database for information about individual codepoints. Unicode-related functions are located in the sb-unicode package. SBCL also extends ANSI character literal syntax to support Unicode codepoints. You can either specify a character by its Unicode name, with spaces replaced by underscores, if a unique name exists 8 or by giving its hexadecimal codepoint preceded by a “U”, an optional “+”, and an arbitrary number of leading zeros. You may also input the character directly into your source code if it can be encoded in your file. If a character had an assigned name in Unicode 1.0 that was distinct from its current name, you may also use that name (with spaces replaced by underscores) to specify the character, unless the name is already associated with a codepoint in the latest Unicode standard (such as “BELL”). For example, you can specify the codepoint U+00E1 (“Latin Small Letter A With Acute”) as #\LATIN_SMALL_LETTER_A_WITH_ACUTE #\LATIN_SMALL_LETTER_A_ACUTE #\á assuming a Unicode source file #\U00E1 #\UE1 #\U+00E1 7.8.1 Unicode property access The following functions can be used to find information about a Unicode codepoint. Function: general-category [sb-unicode] character Returns the general category of character as it appears in UnicodeData.txt Function: bidi-class [sb-unicode] character Returns the bidirectional class of character Function: combining-class [sb-unicode] character Returns the canonical combining class (CCC) of character Function: decimal-value [sb-unicode] character Returns the decimal digit value associated with character or nil if there is no such value. The only characters in Unicode with a decimal digit value are those that are part of a range of characters that encode the digits 0-9. Because of this, ‘(decimal-digit c) <=> (digit-char-p c 10)‘ in #+sb-unicode builds Function: digit-value [sb-unicode] character Returns the Unicode digit value of character or nil if it doesn’t exist. Digit values are guaranteed to be integers between 0 and 9 inclusive. All characters with decimal digit values have the same digit value, but there are characters (such as digits of number systems without a 0 value) that have a digit value but no decimal digit value Function: numeric-value [sb-unicode] character Returns the numeric value of character or nil if there is no such value. Numeric value is the most general of the Unicode numeric properties. The only constraint on the numeric value is that it be a rational number. Function: mirrored-p [sb-unicode] character Returns t if character needs to be mirrored in bidirectional text. Otherwise, returns nil. Function: bidi-mirroring-glyph [sb-unicode] character Returns the mirror image of character if it exists. Otherwise, returns nil. Function: age [sb-unicode] character Returns the version of Unicode in which character was assigned as a pair of values, both integers, representing the major and minor version respectively. If character is not assigned in Unicode, returns nil for both values. Function: hangul-syllable-type [sb-unicode] character Returns the Hangul syllable type of character. The syllable type can be one of :l, :v, :t, :lv, or :lvt. If the character is not a Hangul syllable or Jamo, returns nil Function: east-asian-width [sb-unicode] character Returns the East Asian Width property of character as one of the keywords :n (Narrow), :a (Ambiguous), :h (Halfwidth), :w (Wide), :f (Fullwidth), or :na (Not applicable) Function: script [sb-unicode] character Returns the Script property of character as a keyword. If character does not have a known script, returns :unknown Function: char-block [sb-unicode] character Returns the Unicode block in which character resides as a keyword. If character does not have a known block, returns :no-block Function: unicode-1-name [sb-unicode] character Returns the name assigned to character in Unicode 1.0 if it is distinct from the name currently assigned to character. Otherwise, returns nil. This property has been officially obsoleted by the Unicode standard, and is only included for backwards compatibility. Function: proplist-p [sb-unicode] character property Returns t if character has the specified property. property is a keyword representing one of the properties from PropList.txt, with underscores replaced by dashes. Function: uppercase-p [sb-unicode] character Returns t if character has the Unicode property Uppercase and nil otherwise Function: lowercase-p [sb-unicode] character Returns t if character has the Unicode property Lowercase and nil otherwise Function: cased-p [sb-unicode] character Returns t if character has a (Unicode) case, and nil otherwise Function: case-ignorable-p [sb-unicode] character Returns t if character is Case Ignorable as defined in Unicode 6.3, Chapter 3 Function: alphabetic-p [sb-unicode] character Returns t if character is Alphabetic according to the Unicode standard and nil otherwise Function: ideographic-p [sb-unicode] character Returns t if character has the Unicode property Ideographic, which loosely corresponds to the set of ""Chinese characters"" Function: math-p [sb-unicode] character Returns t if character is a mathematical symbol according to Unicode and nil otherwise Function: whitespace-p [sb-unicode] character Returns t if character is whitespace according to Unicode and nil otherwise Function: soft-dotted-p [sb-unicode] character Returns t if character has a soft dot (such as the dots on i and j) which disappears when accents are placed on top of it. and nil otherwise Function: hex-digit-p [sb-unicode] character &key ascii Returns t if character is a hexadecimal digit and nil otherwise. If :ascii is non-NIL, fullwidth equivalents of the Latin letters A through f are excluded. Function: default-ignorable-p [sb-unicode] character Returns t if character is a Default_Ignorable_Code_Point Function: grapheme-break-class [sb-unicode] char Returns the grapheme breaking class of character, as specified in uax #29. Function: word-break-class [sb-unicode] char Returns the word breaking class of character, as specified in uax #29. Function: sentence-break-class [sb-unicode] char Returns the sentence breaking class of character, as specified in uax #29. Function: line-break-class [sb-unicode] character &key resolve Returns the line breaking class of character, as specified in uax #14. If :resolve is nil, returns the character class found in the property file. If :resolve is non-NIL, centain line-breaking classes will be mapped to othec classes as specified in the applicable standards. Addinionally, if :resolve is :east-asian, Ambigious (class :AI) characters will be mapped to the Ideographic (:ID) class instead of Alphabetic (:AL). 7.8.2 String operations SBCL can normalize strings using: Function: normalize-string [sb-unicode] string &optional form filter Normalize string to the Unicode normalization form form. Acceptable values for form are :nfd, :nfc, :nfkd, and :nfkc. If filter is a function it is called on each decomposed character and only characters for which it returns t are collected. Function: normalized-p [sb-unicode] string &optional form Tests if string is normalized to form SBCL implements the full range of Unicode case operations with the functions Function: uppercase [sb-unicode] string &key locale Returns the full uppercase of string according to the Unicode standard. The result is not guaranteed to have the same length as the input. If :locale is nil, no language-specific case transformations are applied. If :locale is a keyword representing a two-letter iso country code, the case transforms of that locale are used. If :locale is t, the user’s current locale is used (Unix and Win32 only). Function: lowercase [sb-unicode] string &key locale Returns the full lowercase of string according to the Unicode standard. The result is not guaranteed to have the same length as the input. :locale has the same semantics as the :locale argument to uppercase. Function: titlecase [sb-unicode] string &key locale Returns the titlecase of string. The resulting string can be longer than the input. :locale has the same semantics as the :locale argument to uppercase. Function: casefold [sb-unicode] string Returns the full casefolding of string according to the Unicode standard. Casefolding removes case information in a way that allows the results to be used for case-insensitive comparisons. The result is not guaranteed to have the same length as the input. It also extends standard Common Lisp case functions such as string-upcase and string-downcase to support a subset of Unicode’s casing behavior. Specifically, a character is both-case-p if its case mapping in Unicode is one-to-one and invertable. The sb-unicode package also provides functions for collating/sorting strings according to the Unicode Collation Algorithm. Function: unicode< [sb-unicode] string1 string2 &key start1 end1 start2 end2 Determines whether STRING1 sorts before STRING2 using the Unicode Collation Algorithm, The function uses an untailored Default Unicode Collation Element Table to produce the sort keys. The function uses the Shifted method for dealing with variable-weight characters, as described in uts #10 Function: unicode= [sb-unicode] string1 string2 &key start1 end1 start2 end2 strict Determines whether STRING1 and STRING2 are canonically equivalent according to Unicode. The start and end arguments behave like the arguments to STRING=. If :strict is nil, UNICODE= tests compatibility equavalence instead. Function: unicode-equal [sb-unicode] string1 string2 &key start1 end1 start2 end2 strict Determines whether STRING1 and STRING2 are canonically equivalent after casefoldin8 (that is, ignoring case differences) according to Unicode. The start and end arguments behave like the arguments to STRING=. If :strict is nil, UNICODE= tests compatibility equavalence instead. Function: unicode<= [sb-unicode] string1 string2 &key start1 end1 start2 end2 Tests if STRING1 and STRING2 are either UNICODE< or UNICODE= Function: unicode> [sb-unicode] string1 string2 &key start1 end1 start2 end2 Tests if STRING2 is UNICODE< STRING1. Function: unicode>= [sb-unicode] string1 string2 &key start1 end1 start2 end2 Tests if STRING1 and STRING2 are either UNICODE= or UNICODE> The following functions are provided for detecting visually confusable strings: Function: confusable-p [sb-unicode] string1 string2 &key start1 end1 start2 end2 Determines whether STRING1 and STRING2 could be visually confusable according to the idna confusableSummary.txt table 7.8.3 Breaking strings The sb-unicode package includes several functions for breaking a Unicode string into useful parts. Function: graphemes [sb-unicode] string Breaks string into graphemes acording to the default grapheme breaking rules specified in uax #29, returning a list of strings. Function: words [sb-unicode] string Breaks string into words acording to the default word breaking rules specified in uax #29. Returns a list of strings Function: sentences [sb-unicode] string Breaks string into sentences acording to the default sentence breaking rules specified in uax #29 Function: lines [sb-unicode] string &key margin Breaks string into lines that are no wider than :margin according to the line breaking rules outlined in uax #14. Combining marks will always be kept together with their base characters, and spaces (but not other types of whitespace) will be removed from the end of lines. If :margin is unspecified, it defaults to 80 characters Next: Tools To Help Developers, Previous: Unicode Support, Up: Beyond the ANSI Standard   [Contents][Index] 7.9 Customization Hooks for Users The toplevel repl prompt may be customized, and the function that reads user input may be replaced completely. The behaviour of require when called with only one argument is implementation-defined. In SBCL, require behaves in the following way: Function: require [cl] module-name &optional pathnames Loads a module, unless it already has been loaded. pathnames, if supplied, is a designator for a list of pathnames to be loaded if the module needs to be. If pathnames is not supplied, functions from the list *module-provider-functions* are called in order with module-name as an argument, until one of them returns non-NIL. User code is responsible for calling provide to indicate a successful load of the module. Variable: *module-provider-functions* [sb-ext] See function documentation for require. Although SBCL does not provide a resident editor, the ed function can be customized to hook into user-provided editing mechanisms as follows: Function: ed [cl] &optional x Starts the editor (on a file or a function if named). Functions from the list *ed-functions* are called in order with x as an argument until one of them returns non-NIL; these functions are responsible for signalling a file-error to indicate failure to perform an operation on the file system. Variable: *ed-functions* [sb-ext] See function documentation for ed. Conditions of type warning and style-warning are sometimes signaled at runtime, especially during execution of Common Lisp defining forms such as defun, defmethod, etc. To muffle these warnings at runtime, SBCL provides a variable sb-ext:*muffled-warnings*: Variable: *muffled-warnings* [sb-ext] A type that ought to specify a subtype of warning. Whenever a warning is signaled, if the warning if of this type and is not handled by any other handler, it will be muffled. Next: Resolution of Name Conflicts, Previous: Customization Hooks for Users, Up: Beyond the ANSI Standard   [Contents][Index] 7.10 Tools To Help Developers SBCL provides a profiler and other extensions to the ANSI trace facility. For more information, see Macro common-lisp:trace. The debugger supports a number of options. Its documentation is accessed by typing help at the debugger prompt. See Debugger. Documentation for inspect is accessed by typing help at the inspect prompt. Next: Hash Table Extensions, Previous: Tools To Help Developers, Up: Beyond the ANSI Standard   [Contents][Index] 7.11 Resolution of Name Conflicts The ANSI standard (section 11.1.1.2.5) requires that name conflicts in packages be resolvable in favour of any of the conflicting symbols. In the interactive debugger, this is achieved by prompting for the symbol in whose favour the conflict should be resolved; for programmatic use, the sb-ext:resolve-conflict restart should be invoked with one argument, which should be a member of the list returned by the condition accessor sb-ext:name-conflict-symbols. Next: Random Number Generation, Previous: Resolution of Name Conflicts, Up: Beyond the ANSI Standard   [Contents][Index] 7.12 Hash Table Extensions Hash table extensions supported by SBCL are all controlled by keyword arguments to make-hash-table. Function: make-hash-table [cl] &key test size rehash-size rehash-threshold hash-function weakness synchronized Create and return a new hash table. The keywords are as follows: :test Determines how keys are compared. Must a designator for one of the standard hash table tests, or a hash table test defined using sb-ext:define-hash-table-test. Additionally, when an explicit hash-function is provided (see below), any two argument equivalence predicate can be used as the test. :size A hint as to how many elements will be put in this hash table. :rehash-size Indicates how to expand the table when it fills up. If an integer, add space for that many elements. If a floating point number (which must be greater than 1.0), multiply the size by that amount. :rehash-threshold Indicates how dense the table can become before forcing a rehash. Can be any positive number <=1, with density approaching zero as the threshold approaches 0. Density 1 means an average of one entry per bucket. :hash-function If nil (the default), a hash function based on the test argument is used, which then must be one of the standardized hash table test functions, or one for which a default hash function has been defined using sb-ext:define-hash-table-test. If hash-function is specified, the test argument can be any two argument predicate consistent with it. The hash-function is expected to return a non-negative fixnum hash code. :weakness When :weakness is not nil, garbage collection may remove entries from the hash table. The value of :weakness specifies how the presence of a key or value in the hash table preserves their entries from garbage collection. Valid values are: :key means that the key of an entry must be live to guarantee that the entry is preserved. :value means that the value of an entry must be live to guarantee that the entry is preserved. :key-and-value means that both the key and the value must be live to guarantee that the entry is preserved. :key-or-value means that either the key or the value must be live to guarantee that the entry is preserved. nil (the default) means that entries are always preserved. :synchronized If nil (the default), the hash-table may have multiple concurrent readers, but results are undefined if a thread writes to the hash-table concurrently with another reader or writer. If t, all concurrent accesses are safe, but note that clhs 3.6 (Traversal Rules and Side Effects) remains in force. See also: sb-ext:with-locked-hash-table. This keyword argument is experimental, and may change incompatibly or be removed in the future. Macro: define-hash-table-test [sb-ext] name hash-function Defines name as a new kind of hash table test for use with the :test argument to make-hash-table, and associates a default hash-function with it. name must be a symbol naming a global two argument equivalence predicate. Afterwards both 'name and #'name can be used with :test argument. In both cases hash-table-test will return the symbol name. hash-function must be a symbol naming a global hash function consistent with the predicate, or be a lambda form implementing one in the current lexical environment. The hash function must compute the same hash code for any two objects for which name returns true, and subsequent calls with already hashed objects must always return the same hash code. Note: The :hash-function keyword argument to make-hash-table can be used to override the specified default hash-function. Attempting to define name in a locked package as hash-table test causes a package lock violation. Examples:   ;;; 1.    ;; We want to use objects of type FOO as keys (by their   ;; names.) EQUALP would work, but would make the names   ;; case-insensitive -- which we don't want.   (defstruct foo (name nil :type (or null string)))    ;; Define an equivalence test function and a hash function.   (defun foo-name= (f1 f2) (equal (foo-name f1) (foo-name f2)))   (defun sxhash-foo-name (f) (sxhash (foo-name f)))    (define-hash-table-test foo-name= sxhash-foo-name)    ;; #'foo-name would work too.   (defun make-foo-table () (make-hash-table :test 'foo-name=))    ;;; 2.    (defun == (x y) (= x y))    (define-hash-table-test ==     (lambda (x)       ;; Hash codes must be consistent with test, so       ;; not (SXHASH X), since       ;;   (= 1 1.0)                   => T       ;;   (= (SXHASH 1) (SXHASH 1.0)) => NIL       ;; Note: this doesn't deal with complex numbers or       ;; bignums too large to represent as double floats.       (sxhash (coerce x 'double-float))))    ;; #'== would work too   (defun make-number-table () (make-hash-table :test '==))  Macro: with-locked-hash-table [sb-ext] (hash-table) &body body Limits concurrent accesses to hash-table for the duration of body. If hash-table is synchronized, body will execute with exclusive ownership of the table. If hash-table is not synchronized, body will execute with other with-locked-hash-table bodies excluded -- exclusion of hash-table accesses not surrounded by with-locked-hash-table is unspecified. Function: hash-table-synchronized-p [sb-ext] instance Returns t if hash-table is synchronized. Function: hash-table-weakness [sb-ext] instance Return the weakness of hash-table which is one of nil, :key, :value, :key-and-value, :key-or-value. Next: Miscellaneous Extensions, Previous: Hash Table Extensions, Up: Beyond the ANSI Standard   [Contents][Index] 7.13 Random Number Generation The initial value of *random-state* is the same each time SBCL is started. This makes it possible for user code to obtain repeatable pseudo random numbers using only standard-provided functionality. See seed-random-state below for an SBCL extension that allows to seed the random number generator from given data for an additional possibility to achieve this. Non-repeatable random numbers can always be obtained using (make-random-state t). The sequence of numbers produced by repeated calls to random starting with the same random state and using the same sequence of limit arguments is guaranteed to be reproducible only in the same version of SBCL on the same platform, using the same code under the same evaluator mode and compiler optimization qualities. Just two examples of differences that may occur otherwise: calls to random can be compiled differently depending on how much is known about the limit argument at compile time, yielding different results even if called with the same argument at run time, and the results can differ depending on the machine’s word size, for example for limits that are fixnums under 64-bit word size but bignums under 32-bit word size. Function: seed-random-state [sb-ext] &optional state Make a random state object. The optional state argument specifies a seed for deterministic pseudo-random number generation. As per the Common Lisp standard for make-random-state, If state is nil or not supplied, return a copy of the default *random-state*. If state is a random state, return a copy of it. If state is t, return a randomly initialized state (using operating-system provided randomness where available, otherwise a poor substitute based on internal time and pid). As a supported sbcl extension, we also support receiving as a seed an object of the following types: (simple-array (unsigned-byte 8) (*)) unsigned-byte While we support arguments of any size and will mix the provided bits into the random state, it is probably overkill to provide more than 256 bits worth of actual information. This particular sbcl version also accepts an argument of the following type: (simple-array (unsigned-byte 32) (*)) This particular sbcl version uses the popular MT19937 prng algorithm, and its internal state only effectively contains about 19937 bits of information. http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html Some notes on random floats: The standard doesn’t prescribe a specific method of generating random floats. The following paragraph describes SBCL’s current implementation and should be taken purely informational, that is, user code should not depend on any of its specific properties. The method used has been chosen because it is common, conceptually simple and fast. To generate random floats, SBCL evaluates code that has an equivalent effect as (* limit    (float (/ (random (expt 2 23)) (expt 2 23)) 1.0f0))  (for single-floats) and correspondingly (with 52 and 1.0d0 instead of 23 and 1.0f0) for double-floats. Note especially that this means that zero is a possible return value occurring with probability (expt 2 -23) respectively (expt 2 -52). Also note that there exist twice as many equidistant floats between 0 and 1 as are generated. For example, the largest number that (random 1.0f0) ever returns is (float (/ (1- (expt 2 23)) (expt 2 23)) 1.0f0) while (float (/ (1- (expt 2 24)) (expt 2 24)) 1.0f0) is the largest single-float less than 1. This is a side effect of the fact that the implementation uses the fastest possible conversion from bits to floats. SBCL currently uses the Mersenne Twister as its random number generator, specifically the 32-bit version under both 32- and 64-bit word size. The seeding algorithm has been improved several times by the authors of the Mersenne Twister; SBCL uses the third version (from 2002) which is still the most recent as of June 2012. The implementation has been tested to provide output identical to the recommended C implementation. While the Mersenne Twister generates random numbers of much better statistical quality than other widely used generators, it uses only linear operations modulo 2 and thus fails some statistical tests9. For example, the distribution of ranks of (sufficiently large) random binary matrices is much distorted compared to the theoretically expected one when the matrices are generated by the Mersenne Twister. Thus, applications that are sensitive to this aspect should use a different type of generator. Next: Stale Extensions, Previous: Random Number Generation, Up: Beyond the ANSI Standard   [Contents][Index] 7.14 Miscellaneous Extensions Function: array-storage-vector [sb-ext] array Returns the underlying storage vector of array, which must be a non-displaced array. In sbcl, if array is a of type (simple-array * (*)), it is its own storage vector. Multidimensional arrays, arrays with fill pointers, and adjustable arrays have an underlying storage vector with the same array-element-type as array, which this function returns. Important note: the underlying vector is an implementation detail. Even though this function exposes it, changes in the implementation may cause this function to be removed without further warning. Function: delete-directory [sb-ext] pathspec &key recursive Deletes the directory designated by pathspec (a pathname designator). Returns the truename of the directory deleted. If recursive is false (the default), signals an error unless the directory is empty. If recursive is true, first deletes all files and subdirectories. If recursive is true and the directory contains symbolic links, the links are deleted, not the files and directories they point to. Signals an error if pathspec designates a file or a symbolic link instead of a directory, or if the directory could not be deleted for any reason. Both    (DELETE-DIRECTORY ""/tmp/foo"")    (DELETE-DIRECTORY ""/tmp/foo/"")  delete the ""foo"" subdirectory of ""/tmp"", or signal an error if it does not exist or if is a file or a symbolic link. Function: get-time-of-day [sb-ext] Return the number of seconds and microseconds since the beginning of the unix epoch (January 1st 1970.) Macro: wait-for [sb-ext] test-form &key timeout Wait until test-form evaluates to true, then return its primary value. If timeout is provided, waits at most approximately timeout seconds before returning nil. If with-deadline has been used to provide a global deadline, signals a deadline-timeout if test-form doesn’t evaluate to true before the deadline. Experimental: subject to change without prior notice. Function: assert-version->= [sb-ext] &rest subversions Asserts that the current sbcl is of version equal to or greater than the version specified in the arguments. A continuable error is signaled otherwise. The arguments specify a sequence of subversion numbers in big endian order. They are compared lexicographically with the runtime version, and versions are treated as though trailed by an unbounded number of 0s. For example, (assert-version->= 1 1 4) asserts that the current sbcl is version 1.1.4[.0.0...] or greater, and (assert-version->= 1) that it is version 1[.0.0...] or greater. Next: Efficiency Hacks, Previous: Miscellaneous Extensions, Up: Beyond the ANSI Standard   [Contents][Index] 7.15 Stale Extensions SBCL has inherited from CMUCL various hooks to allow the user to tweak and monitor the garbage collection process. These are somewhat stale code, and their interface might need to be cleaned up. If you have urgent need of them, look at the code in src/code/gc.lisp and bring it up on the developers’ mailing list. SBCL has various hooks inherited from CMUCL, like sb-ext:float-denormalized-p, to allow a program to take advantage of IEEE floating point arithmetic properties which aren’t conveniently or efficiently expressible using the ANSI standard. These look good, and their interface looks good, but IEEE support is slightly broken due to a stupid decision to remove some support for infinities (because it wasn’t in the ANSI spec and it didn’t occur to me that it was in the IEEE spec). If you need this stuff, take a look at the code and bring it up on the developers’ mailing list. Previous: Stale Extensions, Up: Beyond the ANSI Standard   [Contents][Index] 7.16 Efficiency Hacks The sb-ext:purify function causes SBCL first to collect all garbage, then to mark all uncollected objects as permanent, never again attempting to collect them as garbage. This can cause a large increase in efficiency when using a primitive garbage collector, or a more moderate increase in efficiency when using a more sophisticated garbage collector which is well suited to the program’s memory usage pattern. It also allows permanent code to be frozen at fixed addresses, a precondition for using copy-on-write to share code between multiple Lisp processes. This is less important with modern generational garbage collectors, but not all SBCL platforms use such a garbage collector. Function: purify [sb-ext] &key root-structures environment-name This function optimizes garbage collection by moving all currently live objects into non-collected storage. root-structures is an optional list of objects which should be copied first to maximize locality. defstruct structures defined with the (:pure t) option are moved into read-only storage, further reducing gc cost. List and vector slots of pure structures are also moved into read-only storage. environment-name is unused. This function is a no-op on platforms using the generational garbage collector (x86, x86-64, ppc, arm, arm64). The sb-ext:truly-the special form declares the type of the result of the operations, producing its argument; the declaration is not checked. In short: don’t use it. Special Operator: truly-the [sb-ext] value-type form Specifies that the values returned by form conform to the value-type, and causes the compiler to trust this information unconditionally. Consequences are undefined if any result is not of the declared type -- typical symptoms including memory corruptions. Use with great care. The sb-ext:freeze-type declaration declares that a type will never change, which can make type testing (typep, etc.) more efficient for structure types. Next: Pathnames, Previous: Beyond the ANSI Standard, Up: Top   [Contents][Index] 8 Foreign Function Interface This chapter describes SBCL’s interface to C programs and libraries (and, since C interfaces are a sort of lingua franca of the Unix world, to other programs and libraries in general.) Note: In the modern Lisp world, the usual term for this functionality is Foreign Function Interface, or FFI, where despite the mention of “function” in this term, FFI also refers to direct manipulation of C data structures as well as functions. The traditional CMUCL terminology is Alien Interface, and while that older terminology is no longer used much in the system documentation, it still reflected in names in the implementation, notably in the name of the SB-ALIEN package. • Introduction to the Foreign Function Interface:    • Foreign Types:    • Operations On Foreign Values:    • Foreign Variables:    • Foreign Data Structure Examples:    • Loading Shared Object Files:    • Foreign Function Calls:    • Step-By-Step Example of the Foreign Function Interface:    Next: Foreign Types, Up: Foreign Function Interface   [Contents][Index] 8.1 Introduction to the Foreign Function Interface Because of Lisp’s emphasis on dynamic memory allocation and garbage collection, Lisp implementations use non-C-like memory representations for objects. This representation mismatch creates friction when a Lisp program must share objects with programs which expect C data. There are three common approaches to establishing communication: The burden can be placed on the foreign program (and programmer) by requiring the knowledge and use of the representations used internally by the Lisp implementation. This can require a considerable amount of “glue” code on the C side, and that code tends to be sensitively dependent on the internal implementation details of the Lisp system. The Lisp system can automatically convert objects back and forth between the Lisp and foreign representations. This is convenient, but translation becomes prohibitively slow when large or complex data structures must be shared. This approach is supported by the SBCL FFI, and used automatically when passing integers and strings. The Lisp program can directly manipulate foreign objects through the use of extensions to the Lisp language. SBCL, like CMUCL before it, relies primarily on the automatic conversion and direct manipulation approaches. The SB-ALIEN package provides a facility wherein foreign values of simple scalar types are automatically converted and complex types are directly manipulated in their foreign representation. Additionally the lower-level System Area Pointers (or SAPs) can be used where necessary to provide untyped access to foreign memory. Any foreign objects that can’t automatically be converted into Lisp values are represented by objects of type alien-value. Since Lisp is a dynamically typed language, even foreign objects must have a run-time type; this type information is provided by encapsulating the raw pointer to the foreign data within an alien-value object. The type language and operations on foreign types are intentionally similar to those of the C language. Next: Operations On Foreign Values, Previous: Introduction to the Foreign Function Interface, Up: Foreign Function Interface   [Contents][Index] 8.2 Foreign Types Alien types have a description language based on nested list structure. For example the C type struct foo {     int a;     struct foo *b[100]; };  has the corresponding SBCL FFI type (struct foo   (a int)   (b (array (* (struct foo)) 100)))  • Defining Foreign Types:    • Foreign Types and Lisp Types:    • Foreign Type Specifiers:    Next: Foreign Types and Lisp Types, Up: Foreign Types   [Contents][Index] 8.2.1 Defining Foreign Types Types may be either named or anonymous. With structure and union types, the name is part of the type specifier, allowing recursively defined types such as: (struct foo (a (* (struct foo))))  An anonymous structure or union type is specified by using the name nil. The with-alien macro defines a local scope which “captures” any named type definitions. Other types are not inherently named, but can be given named abbreviations using the define-alien-type macro. Next: Foreign Type Specifiers, Previous: Defining Foreign Types, Up: Foreign Types   [Contents][Index] 8.2.2 Foreign Types and Lisp Types The foreign types form a subsystem of the SBCL type system. An alien type specifier provides a way to use any foreign type as a Lisp type specifier. For example, (typep foo '(alien (* int)))  can be used to determine whether foo is a pointer to a foreign int. alien type specifiers can be used in the same ways as ordinary Lisp type specifiers (like string.) Alien type declarations are subject to the same precise type checking as any other declaration. See Precise Type Checking. Note that the type identifiers used in the foreign type system overlap with native Lisp type specifiers in some cases. For example, the type specifier (alien single-float) is identical to single-float, since foreign floats are automatically converted to Lisp floats. When type-of is called on an alien value that is not automatically converted to a Lisp value, then it will return an alien type specifier. Previous: Foreign Types and Lisp Types, Up: Foreign Types   [Contents][Index] 8.2.3 Foreign Type Specifiers Note: All foreign type names are exported from the sb-alien package. Some foreign type names are also symbols in the common-lisp package, in which case they are reexported from the sb-alien package, so that e.g. it is legal to refer to sb-alien:single-float. These are the basic foreign type specifiers: The foreign type specifier (* foo) describes a pointer to an object of type foo. A pointed-to type foo of t indicates a pointer to anything, similar to void * in ANSI C. A null alien pointer can be detected with the sb-alien:null-alien function. The foreign type specifier (array foo &rest dimensions) describes array of the specified dimensions, holding elements of type foo. Note that (unlike in C) (* foo) and (array foo) are considered to be different types when type checking is done. If equivalence of pointer and array types is desired, it may be explicitly coerced using sb-alien:cast. Arrays are accessed using sb-alien:deref, passing the indices as additional arguments. Elements are stored in column-major order (as in C), so the first dimension determines only the size of the memory block, and not the layout of the higher dimensions. An array whose first dimension is variable may be specified by using nil as the first dimension. Fixed-size arrays can be allocated as array elements, structure slots or sb-alien:with-alien variables. Dynamic arrays can only be allocated using sb-alien:make-alien. The foreign type specifier (sb-alien:struct name &rest fields) describes a structure type with the specified name and fields. Fields are allocated at the same offsets used by the implementation’s C compiler, as guessed by the SBCL internals. An optional :alignment keyword argument can be specified for each field to explicitly control the alignment of a field. If name is nil then the structure is anonymous. If a named foreign struct specifier is passed to define-alien-type or with-alien, then this defines, respectively, a new global or local foreign structure type. If no fields are specified, then the fields are taken from the current (local or global) alien structure type definition of name. The foreign type specifier (sb-alien:union name &rest fields) is similar to sb-alien:struct, but describes a union type. All fields are allocated at the same offset, and the size of the union is the size of the largest field. The programmer must determine which field is active from context. The foreign type specifier (sb-alien:enum name &rest specs) describes an enumeration type that maps between integer values and symbols. If name is nil, then the type is anonymous. Each element of the specs list is either a Lisp symbol, or a list (symbol value). value is an integer. If value is not supplied, then it defaults to one greater than the value for the preceding spec (or to zero if it is the first spec). The foreign type specifier (sb-alien:signed &optional bits) specifies a signed integer with the specified number of bits precision. The upper limit on integer precision is determined by the machine’s word size. If bits is not specified, the maximum size will be used. The foreign type specifier (integer &optional bits) is equivalent to the corresponding type specifier using sb-alien:signed instead of integer. The foreign type specifier (sb-alien:unsigned &optional bits) is like corresponding type specifier using sb-alien:signed except that the variable is treated as an unsigned integer. The foreign type specifier (boolean &optional bits) is similar to an enumeration type, but maps from Lisp nil and t to C 0 and 1 respectively. bits determines the amount of storage allocated to hold the truth value. The foreign type specifier single-float describes a floating-point number in IEEE single-precision format. The foreign type specifier double-float describes a floating-point number in IEEE double-precision format. The foreign type specifier (function result-type &rest arg-types) describes a foreign function that takes arguments of the specified arg-types and returns a result of type result-type. Note that the only context where a foreign function type is directly specified is in the argument to sb-alien:alien-funcall. In all other contexts, foreign functions are represented by foreign function pointer types: (* (function …)). The foreign type specifier sb-alien:system-area-pointer describes a pointer which is represented in Lisp as a system-area-pointer object. SBCL exports this type from sb-alien because CMUCL did, but tentatively (as of the first draft of this section of the manual, SBCL 0.7.6) it is deprecated, since it doesn’t seem to be required by user code. The foreign type specifier sb-alien:void is used in function types to declare that no useful value is returned. Using alien-funcall to call a void foreign function will return zero values. The foreign type specifier (sb-alien:c-string &key external-format element-type not-null) is similar to (* char), but is interpreted as a null-terminated string, and is automatically converted into a Lisp string when accessed; or if the pointer is C NULL or 0, then accessing it gives Lisp nil unless not-null is true, in which case a type-error is signalled. External format conversion is automatically done when Lisp strings are passed to foreign code, or when foreign strings are passed to Lisp code. If the type specifier has an explicit external-format, that external format will be used. Otherwise a default external format that has been determined at SBCL startup time based on the current locale settings will be used. For example, when the following alien routine is called, the Lisp string given as argument is converted to an ebcdic octet representation. (define-alien-routine test int (str (c-string :external-format :ebcdic-us)))  Lisp strings of type base-string are stored with a trailing NUL termination, so no copying (either by the user or the implementation) is necessary when passing them to foreign code, assuming that the external-format and element-type of the c-string type are compatible with the internal representation of the string. For an SBCL built with Unicode support that means an external-format of :ascii and an element-type of base-char. Without Unicode support the external-format can also be :iso-8859-1, and the element-type can also be character. If the external-format or element-type is not compatible, or the string is a (simple-array character (*)), this data is copied by the implementation as required. Assigning a Lisp string to a c-string structure field or variable stores the contents of the string to the memory already pointed to by that variable. When a foreign object of type (* char) is assigned to a c-string, then the c-string pointer is assigned to. This allows c-string pointers to be initialized. For example: (cl:in-package ""CL-USER"") ; which USEs package ""SB-ALIEN""  (define-alien-type nil (struct foo (str c-string)))  (defun make-foo (str)   (let ((my-foo (make-alien (struct foo))))     (setf (slot my-foo 'str) (make-alien char (length str))           (slot my-foo 'str) str)     my-foo))  Storing Lisp NIL in a c-string writes C NULL to the variable. sb-alien also exports translations of these C type specifiers as foreign type specifiers: char, short, int, long, unsigned-char, unsigned-short, unsigned-int, unsigned-long, float, double, size-t, and off-t. Next: Foreign Variables, Previous: Foreign Types, Up: Foreign Function Interface   [Contents][Index] 8.3 Operations On Foreign Values This section describes how to read foreign values as Lisp values, how to coerce foreign values to different kinds of foreign values, and how to dynamically allocate and free foreign variables. • Accessing Foreign Values:    • Coercing Foreign Values:    • Foreign Dynamic Allocation:    Next: Coercing Foreign Values, Up: Operations On Foreign Values   [Contents][Index] 8.3.1 Accessing Foreign Values Function: deref [sb-alien] pointer-or-array &rest indices The sb-alien:deref function returns the value pointed to by a foreign pointer, or the value of a foreign array element. When dereferencing a pointer, an optional single index can be specified to give the equivalent of C pointer arithmetic; this index is scaled by the size of the type pointed to. When dereferencing an array, the number of indices must be the same as the number of dimensions in the array type. deref can be set with setf to assign a new value. Function: slot [sb-alien] struct-or-union slot-name The sb-alien:slot function extracts the value of the slot named slot-name from a foreign struct or union. If struct-or-union is a pointer to a structure or union, then it is automatically dereferenced. sb-alien:slot can be set with setf to assign a new value. Note that slot-name is evaluated, and need not be a compile-time constant (but only constant slot accesses are efficiently compiled). 8.3.1.1 Untyped memory As noted at the beginning of the chapter, the System Area Pointer facilities allow untyped access to foreign memory. SAPs can be converted to and from the usual typed foreign values using sap-alien and alien-sap (described elsewhere), and also to and from integers - raw machine addresses. They should thus be used with caution; corrupting the Lisp heap or other memory with SAPs is trivial. Function: int-sap [sb-sys] machine-address Creates a SAP pointing at the virtual address machine-address. Function: sap-ref-32 [sb-sys] sap offset Access the value of the memory location at offset bytes from sap. This form may also be used with setf to alter the memory at that location. Function: sap= [sb-sys] sap1 sap2 Compare sap1 and sap2 for equality. Similarly named functions exist for accessing other sizes of word, other comparisons, and other conversions. The reader is invited to use apropos and describe for more details (apropos ""sap"" :sb-sys)  Next: Foreign Dynamic Allocation, Previous: Accessing Foreign Values, Up: Operations On Foreign Values   [Contents][Index] 8.3.2 Coercing Foreign Values Macro: addr [sb-alien] alien-expr The sb-alien:addr macro returns a pointer to the location specified by alien-expr, which must be either a foreign variable, a use of sb-alien:deref, a use of sb-alien:slot, or a use of sb-alien:extern-alien. Macro: cast [sb-alien] foreign-value new-type The sb-alien:cast macro converts foreign-value to a new foreign value with the specified new-type. Both types, old and new, must be foreign pointer, array or function types. Note that the resulting Lisp foreign variable object is not eq to the argument, but it does refer to the same foreign data bits. Macro: sap-alien [sb-alien] sap type The sb-alien:sap-alien macro converts sap (a system area pointer) to a foreign value with the specified type. type is not evaluated. The type must be some foreign pointer, array, or record type. Function: alien-sap [sb-alien] foreign-value The sb-alien:alien-sap function returns the SAP which points to alien-value’s data. The foreign-value must be of some foreign pointer, array, or record type. Previous: Coercing Foreign Values, Up: Operations On Foreign Values   [Contents][Index] 8.3.3 Foreign Dynamic Allocation Lisp code can call the C standard library functions malloc and free to dynamically allocate and deallocate foreign variables. The Lisp code shares the same allocator with foreign C code, so it’s OK for foreign code to call free on the result of Lisp sb-alien:make-alien, or for Lisp code to call sb-alien:free-alien on foreign objects allocated by C code. Macro: make-alien [sb-alien] type &optional size Allocate an alien of type type in foreign heap, and return an alien pointer to it. The allocated memory is not initialized, and may contain garbage. The memory is allocated using malloc(3), so it can be passed to foreign functions which use free(3), or released using free-alien. For alien stack allocation, see macro with-alien. The type argument is not evaluated. If size is supplied, how it is interpreted depends on type: When type is a foreign array type, an array of that type is allocated, and a pointer to it is returned. Note that you must use deref to first access the array through the pointer. If supplied, size is used as the first dimension for the array. When type is any other foreign type, then an object for that type is allocated, and a pointer to it is returned. So (make-alien int) returns a (* int). If size is specified, then a block of that many objects is allocated, with the result pointing to the first one. Examples:   (defvar *foo* (make-alien (array char 10)))   (type-of *foo*)                 ; => (alien (* (array (signed 8) 10)))   (setf (deref (deref foo) 0) 10) ; => 10    (make-alien char 12)            ; => (alien (* (signed 8)))  Function: make-alien-string [sb-alien] string &rest rest &key start end external-format null-terminate Copy part of string delimited by start and end into freshly allocated foreign memory, freeable using free(3) or free-alien. Returns the allocated string as a (* char) alien, and the number of bytes allocated as secondary value. The string is encoded using external-format. If null-terminate is true (the default), the alien string is terminated by an additional null byte. Function: free-alien [sb-alien] alien Dispose of the storage pointed to by alien. The alien must have been allocated by make-alien, make-alien-string or malloc(3). Next: Foreign Data Structure Examples, Previous: Operations On Foreign Values, Up: Foreign Function Interface   [Contents][Index] 8.4 Foreign Variables Both local (stack allocated) and external (C global) foreign variables are supported. • Local Foreign Variables:    • External Foreign Variables:    Next: External Foreign Variables, Up: Foreign Variables   [Contents][Index] 8.4.1 Local Foreign Variables Macro: with-alien [sb-alien] var-definitions &body body The with-alien macro establishes local foreign variables with the specified alien types and names. This form is analogous to defining a local variable in C: additional storage is allocated, and the initial value is copied. This form is less analogous to LET-allocated Lisp variables, since the variables can’t be captured in closures: they live only for the dynamic extent of the body, and referring to them outside is a gruesome error. The var-definitions argument is a list of variable definitions, each of the form (name type &optional initial-value)  The names of the variables are established as symbol-macros; the bindings have lexical scope, and may be assigned with setq or setf. The with-alien macro also establishes a new scope for named structures and unions. Any type specified for a variable may contain named structure or union types with the slots specified. Within the lexical scope of the binding specifiers and body, a locally defined foreign structure type foo can be referenced by its name using (struct foo). Previous: Local Foreign Variables, Up: Foreign Variables   [Contents][Index] 8.4.2 External Foreign Variables External foreign names are strings, and Lisp names are symbols. When an external foreign value is represented using a Lisp variable, there must be a way to convert from one name syntax into the other. The macros extern-alien, define-alien-variable and define-alien-routine use this conversion heuristic: Alien names are converted to Lisp names by uppercasing and replacing underscores with hyphens. Conversely, Lisp names are converted to alien names by lowercasing and replacing hyphens with underscores. Both the Lisp symbol and alien string names may be separately specified by using a list of the form (alien-string lisp-symbol)  Macro: define-alien-variable [sb-alien] name type The define-alien-variable macro defines name as an external foreign variable of the specified foreign type. name and type are not evaluated. The Lisp name of the variable (see above) becomes a global alien variable. Global alien variables are effectively “global symbol macros”; a reference to the variable fetches the contents of the external variable. Similarly, setting the variable stores new contents – the new contents must be of the declared type. Someday, they may well be implemented using the ANSI define-symbol-macro mechanism, but as of SBCL 0.7.5, they are still implemented using an older more-or-less parallel mechanism inherited from CMUCL. For example, to access a C-level counter foo, one could write (define-alien-variable ""foo"" int) ;; Now it is possible to get the value of the C variable foo simply by ;; referencing that Lisp variable: (print foo) (setf foo 14) (incf foo)  Function: get-errno [sb-alien] Since in modern C libraries, the errno “variable” is typically no longer a variable, but some bizarre artificial construct which behaves superficially like a variable within a given thread, it can no longer reliably be accessed through the ordinary define-alien-variable mechanism. Instead, SBCL provides the operator sb-alien:get-errno to allow Lisp code to read it. Macro: extern-alien [sb-alien] name type The extern-alien macro returns an alien with the specified type which points to an externally defined value. name is not evaluated, and may be either a string or a symbol. type is an unevaluated alien type specifier. Next: Loading Shared Object Files, Previous: Foreign Variables, Up: Foreign Function Interface   [Contents][Index] 8.5 Foreign Data Structure Examples Now that we have alien types, operations and variables, we can manipulate foreign data structures. This C declaration struct foo {     int a;     struct foo *b[100]; };  can be translated into the following alien type: (define-alien-type nil   (struct foo     (a int)     (b (array (* (struct foo)) 100))))  Once the foo alien type has been defined as above, the C expression struct foo f; f.b[7].a;  can be translated in this way: (with-alien ((f (struct foo)))   (slot (deref (slot f 'b) 7) 'a)   ;;   ;; Do something with f...   )  Or consider this example of an external C variable and some accesses: struct c_struct {         short x, y;         char a, b;         int z;         c_struct *n; }; extern struct c_struct *my_struct; my_struct->x++; my_struct->a = 5; my_struct = my_struct->n;  which can be manipulated in Lisp like this: (define-alien-type nil   (struct c-struct           (x short)           (y short)           (a char)           (b char)           (z int)           (n (* c-struct)))) (define-alien-variable ""my_struct"" (* c-struct)) (incf (slot my-struct 'x)) (setf (slot my-struct 'a) 5) (setq my-struct (slot my-struct 'n))  Next: Foreign Function Calls, Previous: Foreign Data Structure Examples, Up: Foreign Function Interface   [Contents][Index] 8.6 Loading Shared Object Files Foreign object files can be loaded into the running Lisp process by calling load-shared-object. Function: load-shared-object [sb-alien] pathname &key dont-save Load a shared library / dynamic shared object file / similar foreign container specified by designated pathname, such as a .so on an elf platform. Locating the shared object follows standard rules of the platform, consult the manual page for dlopen(3) for details. Typically paths specified by environment variables such as LD_LIBRARY_PATH are searched if the pathname has no directory, but on some systems (eg. Mac os X) search may happen even if pathname is absolute. (On Windows LoadLibrary is used instead of dlopen(3).) On non-Windows platforms calling load-shared-object again with a pathname equal to the designated pathname of a previous call will replace the old definitions; if a symbol was previously referenced through the object and is not present in the reloaded version an error will be signalled. Reloading may not work as expected if user or library-code has called dlopen(3) on the same shared object. load-shared-object interacts with sb-ext:save-lisp-and-die: 1. If dont-save is true (default is NIL), the shared object will be dropped when save-lisp-and-die is called -- otherwise shared objects are reloaded automatically when a saved core starts up. Specifying dont-save can be useful when the location of the shared object on startup is uncertain. 2. On most platforms references in compiled code to foreign symbols in shared objects (such as those generated by DEFINE-ALIEN-ROUTINE) remain valid across save-lisp-and-die. On those platforms where this is not supported, a warning will be signalled when the core is saved -- this is orthogonal from dont-save. Function: unload-shared-object [sb-alien] pathname Unloads the shared object loaded earlier using the designated pathname with load-shared-object, to the degree supported on the platform. Experimental. Next: Step-By-Step Example of the Foreign Function Interface, Previous: Loading Shared Object Files, Up: Foreign Function Interface   [Contents][Index] 8.7 Foreign Function Calls The foreign function call interface allows a Lisp program to call many functions written in languages that use the C calling convention. Lisp sets up various signal handling routines and other environment information when it first starts up, and expects these to be in place at all times. The C functions called by Lisp should not change the environment, especially the signal handlers: the signal handlers installed by Lisp typically have interesting flags set (e.g to request machine context information, or for signal delivery on an alternate stack) which the Lisp runtime relies on for correct operation. Precise details of how this works may change without notice between versions; the source, or the brain of a friendly SBCL developer, is the only documentation. Users of a Lisp built with the :sb-thread feature should also read the section about threads, Threading. • The alien-funcall Primitive:    • The define-alien-routine Macro:    • define-alien-routine Example:    • Calling Lisp From C:    Next: The define-alien-routine Macro, Up: Foreign Function Calls   [Contents][Index] 8.7.1 The alien-funcall Primitive Function: alien-funcall [sb-alien] alien-function &rest arguments The alien-funcall function is the foreign function call primitive: alien-function is called with the supplied arguments and its C return value is returned as a Lisp value. The alien-function is an arbitrary run-time expression; to refer to a constant function, use extern-alien or a value defined by define-alien-routine. The type of alien-function must be (alien (function ...)) or (alien (* (function ...))). The function type is used to determine how to call the function (as though it was declared with a prototype.) The type need not be known at compile time, but only known-type calls are efficiently compiled. Limitations: Structure type return values are not implemented. Passing of structures by value is not implemented. Here is an example which allocates a (struct foo), calls a foreign function to initialize it, then returns a Lisp vector of all the (* (struct foo)) objects filled in by the foreign call: ;; Allocate a foo on the stack. (with-alien ((f (struct foo)))   ;; Call some C function to fill in foo fields.   (alien-funcall (extern-alien ""mangle_foo"" (function void (* foo)))                  (addr f))   ;; Find how many foos to use by getting the A field.   (let* ((num (slot f 'a))          (result (make-array num)))     ;; Get a pointer to the array so that we don't have to keep extracting it:     (with-alien ((a (* (array (* (struct foo)) 100)) (addr (slot f 'b))))       ;; Loop over the first N elements and stash them in the result vector.       (dotimes (i num)         (setf (svref result i) (deref (deref a) i)))       ;; Voila.       result)))  Next: define-alien-routine Example, Previous: The alien-funcall Primitive, Up: Foreign Function Calls   [Contents][Index] 8.7.2 The define-alien-routine Macro Macro: define-alien-routine [sb-alien] name result-type &rest arg-specifiers The define-alien-routine macro is a convenience for automatically generating Lisp interfaces to simple foreign functions. The primary feature is the parameter style specification, which translates the C pass-by-reference idiom into additional return values. name is usually a string external symbol, but may also be a symbol Lisp name or a list of the foreign name and the Lisp name. If only one name is specified, the other is automatically derived as for extern-alien. result-type is the alien type of the return value. Each element of the arg-specifiers list specifies an argument to the foreign function, and is of the form (aname atype &amp;optional style)  aname is the symbol name of the argument to the constructed function (for documentation). atype is the alien type of corresponding foreign argument. The semantics of the actual call are the same as for alien-funcall. style specifies how this argument should be handled at call and return time, and should be one of the following: :in specifies that the argument is passed by value. This is the default. :in arguments have no corresponding return value from the Lisp function. :copy is similar to :in, but the argument is copied to a pre-allocated object and a pointer to this object is passed to the foreign routine. :out specifies a pass-by-reference output value. The type of the argument must be a pointer to a fixed-sized object (such as an integer or pointer). :out and :in-out style cannot be used with pointers to arrays, records or functions. An object of the correct size is allocated on the stack, and its address is passed to the foreign function. When the function returns, the contents of this location are returned as one of the values of the Lisp function (and the location is automatically deallocated). :in-out is a combination of :copy and :out. The argument is copied to a pre-allocated object and a pointer to this object is passed to the foreign routine. On return, the contents of this location is returned as an additional value. Note: Any efficiency-critical foreign interface function should be inline expanded, which can be done by preceding the define-alien-routine call with: (declaim (inline lisp-name))  In addition to avoiding the Lisp call overhead, this allows pointers, word-integers and floats to be passed using non-descriptor representations, avoiding consing.) Next: Calling Lisp From C, Previous: The define-alien-routine Macro, Up: Foreign Function Calls   [Contents][Index] 8.7.3 define-alien-routine Example Consider the C function cfoo with the following calling convention: void cfoo (str, a, i)     char *str;     char *a; /* update */     int *i; /* out */ {   /* body of cfoo(...) */ }  This can be described by the following call to define-alien-routine: (define-alien-routine ""cfoo"" void   (str c-string)   (a char :in-out)   (i int :out))  The Lisp function cfoo will have two arguments (str and a) and two return values (a and i). Previous: define-alien-routine Example, Up: Foreign Function Calls   [Contents][Index] 8.7.4 Calling Lisp From C Calling Lisp functions from C is sometimes possible, but is extremely hackish and poorly supported as of SBCL 0.7.5. See funcall0 … funcall3 in the runtime system. The arguments must be valid SBCL object descriptors (so that e.g. fixnums must be left-shifted by 2.) As of SBCL 0.7.5, the format of object descriptors is documented only by the source code and, in parts, by the old CMUCL INTERNALS documentation. Note that the garbage collector moves objects, and won’t be able to fix up any references in C variables. There are three mechanisms for coping with this: The sb-ext:purify moves all live Lisp data into static or read-only areas such that it will never be moved (or freed) again in the life of the Lisp session sb-sys:with-pinned-objects is a macro which arranges for some set of objects to be pinned in memory for the dynamic extent of its body forms. On ports which use the generational garbage collector (as of SBCL 0.8.3, only the x86) this has a page granularity - i.e. the entire 4k page or pages containing the objects will be locked down. On other ports it is implemented by turning off GC for the duration (so could be said to have a whole-world granularity). Disable GC, using the without-gcing macro. Previous: Foreign Function Calls, Up: Foreign Function Interface   [Contents][Index] 8.8 Step-By-Step Example of the Foreign Function Interface This section presents a complete example of an interface to a somewhat complicated C function. Suppose you have the following C function which you want to be able to call from Lisp in the file test.c struct c_struct {   int x;   char *s; };  struct c_struct *c_function (i, s, r, a)     int i;     char *s;     struct c_struct *r;     int a[10]; {   int j;   struct c_struct *r2;    printf(""i = %d\n"", i);   printf(""s = %s\n"", s);   printf(""r->x = %d\n"", r->x);   printf(""r->s = %s\n"", r->s);   for (j = 0; j < 10; j++) printf(""a[%d] = %d.\n"", j, a[j]);   r2 = (struct c_struct *) malloc (sizeof(struct c_struct));   r2->x = i + 5;   r2->s = ""a C string"";   return(r2); };  It is possible to call this C function from Lisp using the file test.lisp containing (cl:defpackage ""TEST-C-CALL"" (:use ""CL"" ""SB-ALIEN"" ""SB-C-CALL"")) (cl:in-package ""TEST-C-CALL"")  ;;; Define the record C-STRUCT in Lisp. (define-alien-type nil     (struct c-struct             (x int)             (s c-string)))  ;;; Define the Lisp function interface to the C routine.  It returns a ;;; pointer to a record of type C-STRUCT.  It accepts four parameters: ;;; I, an int; S, a pointer to a string; R, a pointer to a C-STRUCT ;;; record; and A, a pointer to the array of 10 ints. ;;; ;;; The INLINE declaration eliminates some efficiency notes about heap ;;; allocation of alien values. (declaim (inline c-function)) (define-alien-routine c-function     (* (struct c-struct))   (i int)   (s c-string)   (r (* (struct c-struct)))   (a (array int 10)))  ;;; a function which sets up the parameters to the C function and ;;; actually calls it (defun call-cfun ()   (with-alien ((ar (array int 10))                (c-struct (struct c-struct)))     (dotimes (i 10)                     ; Fill array.       (setf (deref ar i) i))     (setf (slot c-struct 'x) 20)     (setf (slot c-struct 's) ""a Lisp string"")      (with-alien ((res (* (struct c-struct))                       (c-function 5 ""another Lisp string"" (addr c-struct) ar)))       (format t ""~&amp;back from C function~%"")       (multiple-value-prog1           (values (slot res 'x)                   (slot res 's))          ;; Deallocate result. (after we are done referring to it:         ;; ""Pillage, *then* burn."")         (free-alien res)))))  To execute the above example, it is necessary to compile the C routine, e.g.: ‘cc -c test.c && ld -shared -o test.so test.o’ (In order to enable incremental loading with some linkers, you may need to say ‘cc -G 0 -c test.c’) Once the C code has been compiled, you can start up Lisp and load it in: ‘sbcl’. Lisp should start up with its normal prompt. Within Lisp, compile the Lisp file. (This step can be done separately. You don’t have to recompile every time.) ‘(compile-file ""test.lisp"")’ Within Lisp, load the foreign object file to define the necessary symbols: ‘(load-shared-object ""test.so"")’. Now you can load the compiled Lisp (“fasl”) file into Lisp: ‘(load ""test.fasl"")’ And once the Lisp file is loaded, you can call the Lisp routine that sets up the parameters and calls the C function: ‘(test-c-call::call-cfun)’ The C routine should print the following information to standard output: i = 5 s = another Lisp string r->x = 20 r->s = a Lisp string a[0] = 0. a[1] = 1. a[2] = 2. a[3] = 3. a[4] = 4. a[5] = 5. a[6] = 6. a[7] = 7. a[8] = 8. a[9] = 9.  After return from the C function, the Lisp wrapper function should print the following output: back from C function  And upon return from the Lisp wrapper function, before the next prompt is printed, the Lisp read-eval-print loop should print the following return values: 10 ""a C string""  Next: Streams, Previous: Foreign Function Interface, Up: Top   [Contents][Index] 9 Pathnames • Lisp Pathnames:    • Native Filenames:    Next: Native Filenames, Up: Pathnames   [Contents][Index] 9.1 Lisp Pathnames There are many aspects of ANSI Common Lisp’s pathname support which are implementation-defined and so need documentation. 9.1.1 Home Directory Specifiers SBCL accepts the keyword :home and a list of the form (:home ""username"") as a directory component immediately following :absolute. :home is represented in namestrings by ~/ and (:home ""username"" by ~username/ at the start of the namestring. Tilde-characters elsewhere in namestrings represent themselves. Home directory specifiers are resolved to home directory of the current or specified user by native-namestring, which is used by the implementation to translate pathnames before passing them on to operating system specific routines. Using (:home ""user"") form on Windows signals an error. 9.1.2 The SYS Logical Pathname Host The logical pathname host named by ""SYS"" exists in SBCL. Its logical-pathname-translations may be set by the site or the user applicable to point to the locations of the system’s sources; in particular, the core system’s source files match the logical pathname ""SYS:SRC;**;*.*.*"", and the contributed modules’ source files match ""SYS:CONTRIB;**;*.*.*"". Function: set-sbcl-source-location [sb-ext] pathname Initialize the sys logical host based on pathname, which should be the top-level directory of the sbcl sources. This will replace any existing translations for ""SYS:SRC;"", ""SYS:CONTRIB;"", and ""SYS:OUTPUT;"". Other ""SYS:"" translations are preserved. Previous: Lisp Pathnames, Up: Pathnames   [Contents][Index] 9.2 Native Filenames In some circumstances, what is wanted is a Lisp pathname object which corresponds to a string produced by the Operating System. In this case, some of the default parsing rules are inappropriate: most filesystems do not have a native understanding of wild pathnames; such functionality is often provided by shells above the OS, often in mutually-incompatible ways. To allow the user to deal with this, the following functions are provided: parse-native-namestring and native-pathname return the closest equivalent Lisp pathname to a given string (appropriate for the Operating System), while native-namestring converts a non-wild pathname designator to the equivalent native namestring, if possible. Some Lisp pathname concepts (such as the :back directory component) have no direct equivalents in most Operating Systems; the behaviour of native-namestring is unspecified if an inappropriate pathname designator is passed to it. Additionally, note that conversion from pathname to native filename and back to pathname should not be expected to preserve equivalence under equal. Function: parse-native-namestring [sb-ext] thing &optional host defaults &key start end junk-allowed as-directory Convert thing into a pathname, using the native conventions appropriate for the pathname host host, or if not specified the host of defaults. If thing is a string, the parse is bounded by start and end, and error behaviour is controlled by junk-allowed, as with parse-namestring. For file systems whose native conventions allow directories to be indicated as files, if as-directory is true, return a pathname denoting thing as a directory. Function: native-pathname [sb-ext] pathspec Convert pathspec (a pathname designator) into a pathname, assuming the operating system native pathname conventions. Function: native-namestring [sb-ext] pathname &key as-file Construct the full native (name)string form of pathname. For file systems whose native conventions allow directories to be indicated as files, if as-file is true and the name, type, and version components of pathname are all nil or :unspecific, construct a string that names the directory according to the file system’s syntax for files. Because some file systems permit the names of directories to be expressed in multiple ways, it is occasionally necessary to parse a native file name “as a directory name” or to produce a native file name that names a directory “as a file”. For these cases, parse-native-namestring accepts the keyword argument as-directory to force a filename to parse as a directory, and native-namestring accepts the keyword argument as-file to force a pathname to unparse as a file. For example, ; On Unix, the directory ""/tmp/"" can be denoted by ""/tmp/"" or ""/tmp"". ; Under the default rules for native filenames, these parse and ; unparse differently. (defvar *p*) (setf *p* (parse-native-namestring ""/tmp/"")) ⇒ #P""/tmp/"" (pathname-name *p*) ⇒ NIL (pathname-directory *p*) ⇒ (:ABSOLUTE ""tmp"") (native-namestring *p*) ⇒ ""/tmp/""  (setf *p* (parse-native-namestring ""/tmp"")) ⇒ #P""/tmp"" (pathname-name *p*) ⇒ ""tmp"" (pathname-directory *p*) ⇒ (:ABSOLUTE) (native-namestring *p*) ⇒ ""/tmp""  ; A non-NIL AS-DIRECTORY argument to PARSE-NATIVE-NAMESTRING forces ; both the second string to parse the way the first does. (setf *p* (parse-native-namestring ""/tmp""                                    nil *default-pathname-defaults*                                    :as-directory t)) ⇒ #P""/tmp/"" (pathname-name *p*) ⇒ NIL (pathname-directory *p*) ⇒ (:ABSOLUTE ""tmp"")  ; A non-NIL AS-FILE argument to NATIVE-NAMESTRING forces the pathname ; parsed from the first string to unparse as the second string. (setf *p* (parse-native-namestring ""/tmp/"")) ⇒ #P""/tmp/"" (native-namestring *p* :as-file t) ⇒ ""/tmp""  Next: Package Locks, Previous: Pathnames, Up: Top   [Contents][Index] 10 Streams Streams which read or write Lisp character data from or to the outside world – files, sockets or other external entities – require the specification of a conversion between the external, binary data and the Lisp characters. In ANSI Common Lisp, this is done by specifying the :external-format argument when the stream is created. The major information required is an encoding, specified by a keyword naming that encoding; however, it is also possible to specify refinements to that encoding as additional options to the external format designator. In addition, SBCL supports various extensions of ANSI Common Lisp streams: Bivalent Streams A type of stream that can read and write both character and (unsigned-byte 8) values. Gray Streams User-overloadable CLOS classes whose instances can be used as Lisp streams (e.g. passed as the first argument to format). Simple Streams The bundled contrib module sb-simple-streams implements a subset of the Franz Allegro simple-streams proposal. • External Formats:    • Bivalent Streams:    • Gray Streams:    • Simple Streams:    Next: Bivalent Streams, Up: Streams   [Contents][Index] 10.1 External Formats The encodings supported by SBCL as external formats are named by keyword. Each encoding has a canonical name, which will be encoding returned by stream-external-format, and a number of aliases for convenience, as shown in the table below: :ASCII :US-ASCII, :ANSI_X3.4-1968, :ISO-646, :ISO-646-US, :|646| :CP1250 :|cp1250|, :WINDOWS-1250, :|windows-1250| :CP1251 :|cp1251|, :WINDOWS-1251, :|windows-1251| :CP1252 :|cp1252|, :WINDOWS-1252, :|windows-1252| :CP1253 :|cp1253|, :WINDOWS-1253, :|windows-1253| :CP1254 :|cp1254| :CP1255 :|cp1255|, :WINDOWS-1255, :|windows-1255| :CP1256 :|cp1256|, :WINDOWS-1256, :|windows-1256| :CP1257 :|cp1257|, :WINDOWS-1257, :|windows-1257| :CP1258 :|cp1258|, :WINDOWS-1258, :|windows-1258| :CP437 :|cp437| :CP850 :|cp850| :CP852 :|cp852| :CP855 :|cp855| :CP857 :|cp857| :CP860 :|cp860| :CP861 :|cp861| :CP862 :|cp862| :CP863 :|cp863| :CP864 :|cp864| :CP865 :|cp865| :CP866 :|cp866| :CP869 :|cp869| :CP874 :|cp874| :EBCDIC-US :CP037, :|cp037|, :IBM-037, :IBM037 :EUC-JP :EUCJP, :|eucJP| :GBK :CP936 :ISO-8859-10 :|iso-8859-10|, :LATIN-6, :|latin-6| :ISO-8859-11 :|iso-8859-11| :ISO-8859-13 :|iso-8859-13|, :LATIN-7, :|latin-7| :ISO-8859-14 :|iso-8859-14|, :LATIN-8, :|latin-8| :ISO-8859-2 :|iso-8859-2|, :LATIN-2, :|latin-2| :ISO-8859-3 :|iso-8859-3|, :LATIN-3, :|latin-3| :ISO-8859-4 :|iso-8859-4|, :LATIN-4, :|latin-4| :ISO-8859-5 :|iso-8859-5| :ISO-8859-6 :|iso-8859-6| :ISO-8859-7 :|iso-8859-7| :ISO-8859-8 :|iso-8859-8| :ISO-8859-9 :|iso-8859-9|, :LATIN-5, :|latin-5| :KOI8-R :|koi8-r| :KOI8-U :|koi8-u| :LATIN-1 :LATIN1, :ISO-8859-1, :ISO8859-1 :LATIN-9 :LATIN9, :ISO-8859-15, :ISO8859-15 :MAC-ROMAN :|mac-roman|, :|MacRoman|, :MAC, :|mac|, :MACINTOSH, :|macintosh| :SHIFT_JIS :SJIS, :|Shift_JIS|, :CP932 :UCS-2BE :UCS2BE :UCS-2LE :UCS2LE :UCS-4BE :UCS4BE :UCS-4LE :UCS4LE :UTF-16BE :UTF16BE :UTF-16LE :UTF16LE :UTF-32BE :UTF32BE :UTF-32LE :UTF32LE :UTF-8 :UTF8 :X-MAC-CYRILLIC :|x-mac-cyrillic| In situations where an external file format designator is required, such as the :external-format argument in calls to open or with-open-file, users may supply the name of an encoding to denote the external format which is applying that encoding to Lisp characters. In addition to the basic encoding for an external format, options controlling various special cases may be passed, by using a list (whose first element must be an encoding name and whose rest is a plist) as an external file format designator. At present, the only supported key in the plist is :replacement, where the corresponding value is a string designator which is used as a replacement when an encoding or decoding error happens, handling those errors without user intervention; for example: (with-open-file (i pathname :external-format '(:utf-8 :replacement #\?))   (read-line i))  will read the first line of pathname, replacing any invalid utf-8 sequences with question marks. Next: Gray Streams, Previous: External Formats, Up: Streams   [Contents][Index] 10.2 Bivalent Streams A bivalent stream can be used to read and write both character and (unsigned-byte 8) values. A bivalent stream is created by calling open with the argument :element-type :default. On such a stream, both binary and character data can be read and written with the usual input and output functions. Streams are not created bivalent by default for performance reasons. Bivalent streams are incompatible with fast-read-char, an internal optimization in SBCL’s stream machinery that bulk-converts octets to characters and implements a fast path through read-char. Next: Simple Streams, Previous: Bivalent Streams, Up: Streams   [Contents][Index] 10.3 Gray Streams The Gray Streams interface is a widely supported extension that provides for definition of CLOS-extensible stream classes. Gray stream classes are implemented by adding methods to generic functions analogous to Common Lisp’s standard I/O functions. Instances of Gray stream classes may be used with any I/O operation where a non-Gray stream can, provided that all required methods have been implemented suitably. • Gray Streams classes:    • Methods common to all streams:    • Input stream methods:    • Character input stream methods:    • Output stream methods:    • Character output stream methods:    • Binary stream methods:    • Gray Streams examples:    Next: Methods common to all streams, Up: Gray Streams   [Contents][Index] 10.3.1 Gray Streams classes The defined Gray Stream classes are these: Class: fundamental-stream [sb-gray] Class precedence list: fundamental-stream, standard-object, stream, t Base class for all Gray streams. Class: fundamental-input-stream [sb-gray] Class precedence list: fundamental-input-stream, fundamental-stream, standard-object, stream, t Superclass of all Gray input streams. The function input-stream-p will return true of any generalized instance of fundamental-input-stream. Class: fundamental-output-stream [sb-gray] Class precedence list: fundamental-output-stream, fundamental-stream, standard-object, stream, t Superclass of all Gray output streams. The function output-stream-p will return true of any generalized instance of fundamental-output-stream. Class: fundamental-binary-stream [sb-gray] Class precedence list: fundamental-binary-stream, fundamental-stream, standard-object, stream, t Superclass of all Gray streams whose element-type is a subtype of unsigned-byte or signed-byte. Note that instantiable subclasses of fundamental-binary-stream should provide (or inherit) an applicable method for the generic function stream-element-type. Class: fundamental-character-stream [sb-gray] Class precedence list: fundamental-character-stream, fundamental-stream, standard-object, stream, t Superclass of all Gray streams whose element-type is a subtype of character. Class: fundamental-binary-input-stream [sb-gray] Class precedence list: fundamental-binary-input-stream, fundamental-input-stream, fundamental-binary-stream, fundamental-stream, standard-object, stream, t Superclass of all Gray input streams whose element-type is a subtype of unsigned-byte or signed-byte. Class: fundamental-binary-output-stream [sb-gray] Class precedence list: fundamental-binary-output-stream, fundamental-output-stream, fundamental-binary-stream, fundamental-stream, standard-object, stream, t Superclass of all Gray output streams whose element-type is a subtype of unsigned-byte or signed-byte. Class: fundamental-character-input-stream [sb-gray] Class precedence list: fundamental-character-input-stream, fundamental-input-stream, fundamental-character-stream, fundamental-stream, standard-object, stream, t Superclass of all Gray input streams whose element-type is a subtype of character. Class: fundamental-character-output-stream [sb-gray] Class precedence list: fundamental-character-output-stream, fundamental-output-stream, fundamental-character-stream, fundamental-stream, standard-object, stream, t Superclass of all Gray output streams whose element-type is a subtype of character. Next: Input stream methods, Previous: Gray Streams classes, Up: Gray Streams   [Contents][Index] 10.3.2 Methods common to all streams These generic functions can be specialized on any generalized instance of fundamental-stream. Generic Function: stream-element-type [cl] stream Return a type specifier for the kind of object returned by the stream. The class fundamental-character-stream provides a default method which returns character. Generic Function: close [cl] stream &key abort Close the given stream. No more I/O may be performed, but inquiries may still be made. If :abort is true, an attempt is made to clean up the side effects of having created the stream. Generic Function: stream-file-position [sb-gray] stream &optional position-spec Used by file-position. Returns or changes the current position within stream. Next: Character input stream methods, Previous: Methods common to all streams, Up: Gray Streams   [Contents][Index] 10.3.3 Input stream methods These generic functions may be specialized on any generalized instance of fundamental-input-stream. Generic Function: stream-clear-input [sb-gray] stream This is like cl:clear-input, but for Gray streams, returning nil. The default method does nothing. Generic Function: stream-read-sequence [sb-gray] stream seq &optional start end This is like cl:read-sequence, but for Gray streams. Next: Output stream methods, Previous: Input stream methods, Up: Gray Streams   [Contents][Index] 10.3.4 Character input stream methods These generic functions are used to implement subclasses of fundamental-input-stream: Generic Function: stream-peek-char [sb-gray] stream This is used to implement peek-char; this corresponds to peek-type of nil. It returns either a character or :eof. The default method calls stream-read-char and stream-unread-char. Generic Function: stream-read-char-no-hang [sb-gray] stream This is used to implement read-char-no-hang. It returns either a character, or nil if no input is currently available, or :eof if end-of-file is reached. The default method provided by fundamental-character-input-stream simply calls stream-read-char; this is sufficient for file streams, but interactive streams should define their own method. Generic Function: stream-read-char [sb-gray] stream Read one character from the stream. Return either a character object, or the symbol :eof if the stream is at end-of-file. Every subclass of fundamental-character-input-stream must define a method for this function. Generic Function: stream-read-line [sb-gray] stream This is used by read-line. A string is returned as the first value. The second value is true if the string was terminated by end-of-file instead of the end of a line. The default method uses repeated calls to stream-read-char. Generic Function: stream-listen [sb-gray] stream This is used by listen. It returns true or false. The default method uses stream-read-char-no-hang and stream-unread-char. Most streams should define their own method since it will usually be trivial and will always be more efficient than the default method. Generic Function: stream-unread-char [sb-gray] stream character Undo the last call to stream-read-char, as in unread-char. Return nil. Every subclass of fundamental-character-input-stream must define a method for this function. Next: Character output stream methods, Previous: Character input stream methods, Up: Gray Streams   [Contents][Index] 10.3.5 Output stream methods These generic functions are used to implement subclasses of fundamental-output-stream: Generic Function: stream-clear-output [sb-gray] stream This is like cl:clear-output, but for Gray streams: clear the given output stream. The default method does nothing. Generic Function: stream-finish-output [sb-gray] stream Attempts to ensure that all output sent to the Stream has reached its destination, and only then returns false. Implements finish-output. The default method does nothing. Generic Function: stream-force-output [sb-gray] stream Attempts to force any buffered output to be sent. Implements force-output. The default method does nothing. Generic Function: stream-write-sequence [sb-gray] stream seq &optional start end This is like cl:write-sequence, but for Gray streams. Next: Binary stream methods, Previous: Output stream methods, Up: Gray Streams   [Contents][Index] 10.3.6 Character output stream methods These generic functions are used to implement subclasses of fundamental-character-output-stream: Generic Function: stream-advance-to-column [sb-gray] stream column Write enough blank space so that the next character will be written at the specified column. Returns true if the operation is successful, or nil if it is not supported for this stream. This is intended for use by by pprint and format ~T. The default method uses stream-line-column and repeated calls to stream-write-char with a #space character; it returns nil if stream-line-column returns nil. Generic Function: stream-fresh-line [sb-gray] stream Outputs a new line to the Stream if it is not positioned at the beginning of a line. Returns t if it output a new line, nil otherwise. Used by fresh-line. The default method uses stream-start-line-p and stream-terpri. Generic Function: stream-line-column [sb-gray] stream Return the column number where the next character will be written, or nil if that is not meaningful for this stream. The first column on a line is numbered 0. This function is used in the implementation of pprint and the format ~T directive. For every character output stream class that is defined, a method must be defined for this function, although it is permissible for it to always return nil. Generic Function: stream-line-length [sb-gray] stream Return the stream line length or nil. Generic Function: stream-start-line-p [sb-gray] stream Is stream known to be positioned at the beginning of a line? It is permissible for an implementation to always return nil. This is used in the implementation of fresh-line. Note that while a value of 0 from stream-line-column also indicates the beginning of a line, there are cases where stream-start-line-p can be meaningfully implemented although stream-line-column can’t be. For example, for a window using variable-width characters, the column number isn’t very meaningful, but the beginning of the line does have a clear meaning. The default method for stream-start-line-p on class fundamental-character-output-stream uses stream-line-column, so if that is defined to return nil, then a method should be provided for either stream-start-line-p or stream-fresh-line. Generic Function: stream-terpri [sb-gray] stream Writes an end of line, as for terpri. Returns nil. The default method does (stream-write-char stream #NEWLINE). Generic Function: stream-write-char [sb-gray] stream character Write character to stream and return character. Every subclass of fundamental-character-output-stream must have a method defined for this function. Generic Function: stream-write-string [sb-gray] stream string &optional start end This is used by write-string. It writes the string to the stream, optionally delimited by start and end, which default to 0 and nil. The string argument is returned. The default method provided by fundamental-character-output-stream uses repeated calls to stream-write-char. Next: Gray Streams examples, Previous: Character output stream methods, Up: Gray Streams   [Contents][Index] 10.3.7 Binary stream methods The following generic functions are available for subclasses of fundamental-binary-stream: Generic Function: stream-read-byte [sb-gray] stream Used by read-byte; returns either an integer, or the symbol :eof if the stream is at end-of-file. Generic Function: stream-write-byte [sb-gray] stream integer Implements write-byte; writes the integer to the stream and returns the integer as the result. Previous: Binary stream methods, Up: Gray Streams   [Contents][Index] 10.3.8 Gray Streams examples Below are two classes of stream that can be conveniently defined as wrappers for Common Lisp streams. These are meant to serve as examples of minimal implementations of the protocols that must be followed when defining Gray streams. Realistic uses of the Gray Streams API would implement the various methods that can do I/O in batches, such as stream-read-line, stream-write-string, stream-read-sequence, and stream-write-sequence. • Character counting input stream:    • Output prefixing character stream:    Next: Output prefixing character stream, Up: Gray Streams examples   [Contents][Index] 10.3.8.1 Character counting input stream It is occasionally handy for programs that process input files to count the number of characters and lines seen so far, and the number of characters seen on the current line, so that useful messages may be reported in case of parsing errors, etc. Here is a character input stream class that keeps track of these counts. Note that all character input streams must implement stream-read-char and stream-unread-char. (defclass wrapped-stream (fundamental-stream)   ((stream :initarg :stream :reader stream-of)))     (defmethod stream-element-type ((stream wrapped-stream))   (stream-element-type (stream-of stream)))     (defmethod close ((stream wrapped-stream) &key abort)   (close (stream-of stream) :abort abort))     (defclass wrapped-character-input-stream     (wrapped-stream fundamental-character-input-stream)   ())     (defmethod stream-read-char ((stream wrapped-character-input-stream))   (read-char (stream-of stream) nil :eof))     (defmethod stream-unread-char ((stream wrapped-character-input-stream)                                char)   (unread-char char (stream-of stream)))     (defclass counting-character-input-stream     (wrapped-character-input-stream)   ((char-count :initform 1 :accessor char-count-of)    (line-count :initform 1 :accessor line-count-of)    (col-count :initform 1 :accessor col-count-of)    (prev-col-count :initform 1 :accessor prev-col-count-of)))     (defmethod stream-read-char ((stream counting-character-input-stream))   (with-accessors ((inner-stream stream-of) (chars char-count-of)                    (lines line-count-of) (cols col-count-of)                    (prev prev-col-count-of)) stream       (let ((char (call-next-method)))         (cond ((eql char :eof)                :eof)               ((char= char #\Newline)                (incf lines)                (incf chars)                (setf prev cols)                (setf cols 1)                char)               (t                (incf chars)                (incf cols)                char)))))     (defmethod stream-unread-char ((stream counting-character-input-stream)                                char)   (with-accessors ((inner-stream stream-of) (chars char-count-of)                    (lines line-count-of) (cols col-count-of)                    (prev prev-col-count-of)) stream       (cond ((char= char #\Newline)              (decf lines)              (decf chars)              (setf cols prev))             (t              (decf chars)              (decf cols)              char))       (call-next-method)))  The default methods for stream-read-char-no-hang, stream-peek-char, stream-listen, stream-clear-input, stream-read-line, and stream-read-sequence should be sufficient (though the last two will probably be slower than methods that forwarded directly). Here’s a sample use of this class: (with-input-from-string (input ""1 2  3 :foo  "")   (let ((counted-stream (make-instance 'counting-character-input-stream                          :stream input)))     (loop for thing = (read counted-stream) while thing        unless (numberp thing) do          (error ""Non-number ~S (line ~D, column ~D)"" thing                 (line-count-of counted-stream)                 (- (col-count-of counted-stream)                    (length (format nil ""~S"" thing))))        end        do (print thing))))  1 2 3 Non-number :FOO (line 2, column 5)   [Condition of type SIMPLE-ERROR]  Previous: Character counting input stream, Up: Gray Streams examples   [Contents][Index] 10.3.8.2 Output prefixing character stream One use for a wrapped output stream might be to prefix each line of text with a timestamp, e.g., for a logging stream. Here’s a simple stream that does this, though without any fancy line-wrapping. Note that all character output stream classes must implement stream-write-char and stream-line-column. (defclass wrapped-stream (fundamental-stream)   ((stream :initarg :stream :reader stream-of)))     (defmethod stream-element-type ((stream wrapped-stream))   (stream-element-type (stream-of stream)))     (defmethod close ((stream wrapped-stream) &key abort)   (close (stream-of stream) :abort abort))     (defclass wrapped-character-output-stream     (wrapped-stream fundamental-character-output-stream)   ((col-index :initform 0 :accessor col-index-of)))     (defmethod stream-line-column ((stream wrapped-character-output-stream))   (col-index-of stream))     (defmethod stream-write-char ((stream wrapped-character-output-stream)                               char)   (with-accessors ((inner-stream stream-of) (cols col-index-of)) stream     (write-char char inner-stream)     (if (char= char #\Newline)         (setf cols 0)         (incf cols))))     (defclass prefixed-character-output-stream     (wrapped-character-output-stream)   ((prefix :initarg :prefix :reader prefix-of)))     (defgeneric write-prefix (prefix stream)   (:method ((prefix string) stream) (write-string prefix stream))   (:method ((prefix function) stream) (funcall prefix stream)))     (defmethod stream-write-char ((stream prefixed-character-output-stream)                               char)   (with-accessors ((inner-stream stream-of) (cols col-index-of)                    (prefix prefix-of)) stream     (when (zerop cols)       (write-prefix prefix inner-stream))     (call-next-method)))  As with the example input stream, this implements only the minimal protocol. A production implementation should also provide methods for at least stream-write-line, stream-write-sequence. And here’s a sample use of this class: (flet ((format-timestamp (stream)          (apply #'format stream ""[~2@*~2,' D:~1@*~2,'0D:~0@*~2,'0D] ""                 (multiple-value-list (get-decoded-time)))))   (let ((output (make-instance 'prefixed-character-output-stream                                :stream *standard-output*                                :prefix #'format-timestamp)))     (loop for string in '(""abc"" ""def"" ""ghi"") do          (write-line string output)          (sleep 1))))  [ 0:30:05] abc [ 0:30:06] def [ 0:30:07] ghi NIL  Previous: Gray Streams, Up: Streams   [Contents][Index] 10.4 Simple Streams Simple streams are an extensible streams protocol that avoids some problems with Gray streams. Documentation about simple streams is available at: http://www.franz.com/support/documentation/6.2/doc/streams.htm The implementation should be considered Alpha-quality; the basic framework is there, but many classes are just stubs at the moment. See SYS:CONTRIB;SB-SIMPLE-STREAMS;SIMPLE-STREAM-TEST.LISP for things that should work. Known differences to the ACL behaviour: open not return a simple-stream by default. This can be adjusted; see default-open-class in the file cl.lisp write-vector is unimplemented. Next: Threading, Previous: Streams, Up: Top   [Contents][Index] 11 Package Locks None of the following sections apply to SBCL built without package locking support. warning: The interface described here is experimental: incompatible changes in future SBCL releases are possible, even expected: the concept of “implementation packages” and the associated operators may be renamed; more operations (such as naming restarts or catch tags) may be added to the list of operations violating package locks. • Package Lock Concepts:    • Package Lock Dictionary:    Next: Package Lock Dictionary, Up: Package Locks   [Contents][Index] 11.1 Package Lock Concepts • Package Lock Overview:    • Implementation Packages:    • Package Lock Violations:    • Package Locks in Compiled Code:    • Operations Violating Package Locks:    Next: Implementation Packages, Up: Package Lock Concepts   [Contents][Index] 11.1.1 Package Locking Overview Package locks protect against unintentional modifications of a package: they provide similar protection to user packages as is mandated to common-lisp package by the ANSI specification. They are not, and should not be used as, a security measure. Newly created packages are by default unlocked (see the :lock option to defpackage). The package common-lisp and SBCL internal implementation packages are locked by default, including sb-ext. It may be beneficial to lock common-lisp-user as well, to ensure that various libraries don’t pollute it without asking, but this is not currently done by default. Next: Package Lock Violations, Previous: Package Lock Overview, Up: Package Lock Concepts   [Contents][Index] 11.1.2 Implementation Packages Each package has a list of associated implementation packages. A locked package, and the symbols whose home package it is, can be modified without violating package locks only when *package* is bound to one of the implementation packages of the locked package. Unless explicitly altered by defpackage, sb-ext:add-implementation-package, or sb-ext:remove-implementation-package each package is its own (only) implementation package. Next: Package Locks in Compiled Code, Previous: Implementation Packages, Up: Package Lock Concepts   [Contents][Index] 11.1.3 Package Lock Violations 11.1.3.1 Lexical Bindings and Declarations Lexical bindings or declarations that violate package locks cause a compile-time warning, and a runtime program-error when the form that violates package locks would be executed. A complete listing of operators affect by this is: let, let*, flet, labels, macrolet, and symbol-macrolet, declare. Package locks affecting both lexical bindings and declarations can be disabled locally with sb-ext:disable-package-locks declaration, and re-enabled with sb-ext:enable-package-locks declaration. Example: (in-package :locked)  (defun foo () ...)  (defmacro with-foo (&body body)   `(locally (declare (disable-package-locks locked:foo))      (flet ((foo () ...))        (declare (enable-package-locks locked:foo)) ; re-enable for body        ,@body)))  11.1.3.2 Other Operations If an non-lexical operation violates a package lock, a continuable error that is of a subtype of sb-ext:package-lock-violation (subtype of package-error) is signalled when the operation is attempted. Additional restarts may be established for continuable package lock violations for interactive use. The actual type of the error depends on circumstances that caused the violation: operations on packages signal errors of type sb-ext:package-locked-error, and operations on symbols signal errors of type sb-ext:symbol-package-locked-error. Next: Operations Violating Package Locks, Previous: Package Lock Violations, Up: Package Lock Concepts   [Contents][Index] 11.1.4 Package Locks in Compiled Code 11.1.4.1 Interned Symbols If file-compiled code contains interned symbols, then loading that code into an image without the said symbols will not cause a package lock violation, even if the packages in question are locked. 11.1.4.2 Other Limitations on Compiled Code With the exception of interned symbols, behaviour is unspecified if package locks affecting compiled code are not the same during loading of the code or execution. Specifically, code compiled with packages unlocked may or may not fail to signal package-lock-violations even if the packages are locked at runtime, and code compiled with packages locked may or may not signal spurious package-lock-violations at runtime even if the packages are unlocked. In practice all this means that package-locks have a negligible performance penalty in compiled code as long as they are not violated. Previous: Package Locks in Compiled Code, Up: Package Lock Concepts   [Contents][Index] 11.1.5 Operations Violating Package Locks 11.1.5.1 Operations on Packages The following actions cause a package lock violation if the package operated on is locked, and *package* is not an implementation package of that package, and the action would cause a change in the state of the package (so e.g. exporting already external symbols is never a violation). Package lock violations caused by these operations signal errors of type sb-ext:package-locked-error. Shadowing a symbol in a package. Importing a symbol to a package. Uninterning a symbol from a package. Exporting a symbol from a package. Unexporting a symbol from a package. Changing the packages used by a package. Renaming a package. Deleting a package. Adding a new package local nickname to a package. Removing an existing package local nickname to a package. 11.1.5.2 Operations on Symbols Following actions cause a package lock violation if the home package of the symbol operated on is locked, and *package* is not an implementation package of that package. Package lock violations caused by these action signal errors of type sb-ext:symbol-package-locked-error. These actions cause only one package lock violation per lexically apparent violated package. Example: ;;; Packages FOO and BAR are locked. ;;; ;;; Two lexically apparent violated packages: exactly two ;;; package-locked-errors will be signalled.  (defclass foo:point ()   ((x :accessor bar:x)    (y :accessor bar:y)))  Binding or altering its value lexically or dynamically, or establishing it as a symbol-macro. Exceptions: - If the symbol is not defined as a constant, global symbol-macro or a global dynamic variable, it may be lexically bound or established as a local symbol macro. - If the symbol is defined as a global dynamic variable, it may be assigned or bound. Defining, undefining, or binding it, or its setf name as a function. Exceptions: - If the symbol is not defined as a function, macro, or special operator it and its setf name may be lexically bound as a function. Defining, undefining, or binding it as a macro or compiler macro. Exceptions: - If the symbol is not defined as a function, macro, or special operator it may be lexically bound as a macro. Defining it as a type specifier or structure. Defining it as a declaration with a declaration proclamation. Declaring or proclaiming it special. Declaring or proclaiming its type or ftype. Exceptions: - If the symbol may be lexically bound, the type of that binding may be declared. - If the symbol may be lexically bound as a function, the ftype of that binding may be declared. Defining a setf expander for it. Defining it as a method combination type. Using it as the class-name argument to setf of find-class. Defining it as a hash table test using sb-ext:define-hash-table-test. Previous: Package Lock Concepts, Up: Package Locks   [Contents][Index] 11.2 Package Lock Dictionary Declaration: disable-package-locks [sb-ext] Syntax: (sb-ext:disable-package-locks symbol*) Disables package locks affecting the named symbols during compilation in the lexical scope of the declaration. Disabling locks on symbols whose home package is unlocked, or disabling an already disabled lock, has no effect. Declaration: enable-package-locks [sb-ext] Syntax: (sb-ext:enable-package-locks symbol*) Re-enables package locks affecting the named symbols during compilation in the lexical scope of the declaration. Enabling locks that were not first disabled with sb-ext:disable-package-locks declaration, or enabling locks that are already enabled has no effect. Condition: package-lock-violation [sb-ext] Class precedence list: package-lock-violation, package-error, error, serious-condition, condition, t Subtype of cl:package-error. A subtype of this error is signalled when a package-lock is violated. Condition: package-locked-error [sb-ext] Class precedence list: package-locked-error, package-lock-violation, package-error, error, serious-condition, condition, t Subtype of sb-ext:package-lock-violation. An error of this type is signalled when an operation on a package violates a package lock. Condition: symbol-package-locked-error [sb-ext] Class precedence list: symbol-package-locked-error, package-lock-violation, package-error, error, serious-condition, condition, t Subtype of sb-ext:package-lock-violation. An error of this type is signalled when an operation on a symbol violates a package lock. The symbol that caused the violation is accessed by the function sb-ext:package-locked-error-symbol. Function: package-locked-error-symbol [sb-ext] symbol-package-locked-error Returns the symbol that caused the symbol-package-locked-error condition. Function: package-locked-p [sb-ext] package Returns t when package is locked, nil otherwise. Signals an error if package doesn’t designate a valid package. Function: lock-package [sb-ext] package Locks package and returns t. Has no effect if package was already locked. Signals an error if package is not a valid package designator Function: unlock-package [sb-ext] package Unlocks package and returns t. Has no effect if package was already unlocked. Signals an error if package is not a valid package designator. Function: package-implemented-by-list [sb-ext] package Returns a list containing the implementation packages of package. Signals an error if package is not a valid package designator. Function: package-implements-list [sb-ext] package Returns the packages that package is an implementation package of. Signals an error if package is not a valid package designator. Function: add-implementation-package [sb-ext] packages-to-add &optional package Adds packages-to-add as implementation packages of package. Signals an error if package or any of the packages-to-add is not a valid package designator. Function: remove-implementation-package [sb-ext] packages-to-remove &optional package Removes packages-to-remove from the implementation packages of package. Signals an error if package or any of the packages-to-remove is not a valid package designator. Macro: without-package-locks [sb-ext] &body body Ignores all runtime package lock violations during the execution of body. Body can begin with declarations. Macro: with-unlocked-packages [sb-ext] (&rest packages) &body forms Unlocks packages for the dynamic scope of the body. Signals an error if any of packages is not a valid package designator. Macro: defpackage [cl] name [[option]]* ⇒ package Options are extended to include the following: :lock boolean If the argument to :lock is t, the package is initially locked. If :lock is not provided it defaults to nil. :implement package-designator* The package is added as an implementation package to the packages named. If :implement is not provided, it defaults to the package itself. Example: (defpackage ""FOO"" (:export ""BAR"") (:lock t) (:implement)) (defpackage ""FOO-INT"" (:use ""FOO"") (:implement ""FOO"" ""FOO-INT""))  ;;; is equivalent to  (defpackage ""FOO"") (:export ""BAR"")) (lock-package ""FOO"") (remove-implementation-package ""FOO"" ""FOO"") (defpackage ""FOO-INT"" (:use ""BAR"")) (add-implementation-package ""FOO-INT"" ""FOO"")  Next: Timers, Previous: Package Locks, Up: Top   [Contents][Index] 12 Threading SBCL supports a fairly low-level threading interface that maps onto the host operating system’s concept of threads or lightweight processes. This means that threads may take advantage of hardware multiprocessing on machines that have more than one CPU, but it does not allow Lisp control of the scheduler. This is found in the SB-THREAD package. Threads are part of the default build on x86[-64]/ARM64 Linux and Windows. They are also supported on: x86[-64] Darwin (Mac OS X), x86[-64] FreeBSD, x86 SunOS (Solaris), PPC Linux, ARM64 Linux. On these platforms threads must be explicitly enabled at build-time, see INSTALL for directions. • Threading basics:    • Special Variables:    • Atomic Operations:    • Mutex Support:    • Semaphores:    • Waitqueue/condition variables:    • Barriers:    • Sessions/Debugging:    • Foreign threads:    • Implementation (Linux x86/x86-64):    Next: Special Variables, Up: Threading   [Contents][Index] 12.1 Threading basics (make-thread (lambda () (write-line ""Hello, world"")))  12.1.1 Thread Objects Structure: thread [sb-thread] Class precedence list: thread, structure-object, t Thread type. Do not rely on threads being structs as it may change in future versions. Variable: *current-thread* [sb-thread] Bound in each thread to the thread itself. Function: list-all-threads [sb-thread] Return a list of the live threads. Note that the return value is potentially stale even before the function returns, as new threads may be created and old ones may exit at any time. Function: thread-alive-p [sb-thread] thread Return t if thread is still alive. Note that the return value is potentially stale even before the function returns, as the thread may exit at any time. Function: thread-name [sb-thread] instance Name of the thread. Can be assigned to using setf. Thread names can be arbitrary printable objects, and need not be unique. Function: main-thread-p [sb-thread] &optional thread True if thread, defaulting to current thread, is the main thread of the process. Function: main-thread [sb-thread] Returns the main thread of the process. 12.1.2 Making, Returning From, Joining, and Yielding Threads Function: make-thread [sb-thread] function &key name arguments ephemeral Create a new thread of name that runs function with the argument list designator provided (defaults to no argument). Thread exits when the function returns. The return values of function are kept around and can be retrieved by join-thread. Invoking the initial abort restart established by make-thread terminates the thread. See also: return-from-thread, abort-thread. Macro: return-from-thread [sb-thread] values-form &key allow-exit Unwinds from and terminates the current thread, with values from values-form as the results visible to join-thread. If current thread is the main thread of the process (see MAIN-THREAD-P), signals an error unless allow-exit is true, as terminating the main thread would terminate the entire process. If allow-exit is true, returning from the main thread is equivalent to calling sb-ext:exit with :code 0 and :abort nil. See also: abort-thread and sb-ext:exit. Function: abort-thread [sb-thread] &key allow-exit Unwinds from and terminates the current thread abnormally, causing join-thread on current thread to signal an error unless a default-value is provided. If current thread is the main thread of the process (see MAIN-THREAD-P), signals an error unless allow-exit is true, as terminating the main thread would terminate the entire process. If allow-exit is true, aborting the main thread is equivalent to calling sb-ext:exit code 1 and :abort nil. Invoking the initial abort restart established by make-thread is equivalent to calling abort-thread in other than main threads. However, whereas abort restart may be rebound, abort-thread always unwinds the entire thread. (Behaviour of the initial abort restart for main thread depends on the :toplevel argument to sb-ext:save-lisp-and-die.) See also: return-from-thread and sb-ext:exit. Function: join-thread [sb-thread] thread &key default timeout Suspend current thread until thread exits. Return the result values of the thread function. If thread does not exit within timeout seconds and default is supplied, return two values: 1) default 2) :timeout. If default is not supplied, signal a join-thread-error with join-thread-problem equal to :timeout. If thread does not exit normally (i.e. aborted) and default is supplied, return two values: 1) default 2) :abort. If default is not supplied, signal a join-thread-error with join-thread-problem equal to :abort. If thread is the current thread, signal a join-thread-error with join-thread-problem equal to :self-join. Trying to join the main thread causes join-thread to block until timeout occurs or the process exits: when the main thread exits, the entire process exits. note: Return convention in case of a timeout is experimental and subject to change. Function: thread-yield [sb-thread] Yield the processor to other threads. 12.1.3 Asynchronous Operations Function: interrupt-thread [sb-thread] thread function Interrupt thread and make it run function. The interrupt is asynchronous, and can occur anywhere with the exception of sections protected using sb-sys:without-interrupts. function is called with interrupts disabled, under sb-sys:allow-with-interrupts. Since functions such as grab-mutex may try to enable interrupts internally, in most cases function should either enter sb-sys:with-interrupts to allow nested interrupts, or sb-sys:without-interrupts to prevent them completely. When a thread receives multiple interrupts, they are executed in the order they were sent -- first in, first out. This means that a great degree of care is required to use interrupt-thread safely and sanely in a production environment. The general recommendation is to limit uses of interrupt-thread for interactive debugging, banning it entirely from production environments -- it is simply exceedingly hard to use correctly. With those caveats in mind, what you need to know when using it: If calling function causes a non-local transfer of control (ie. an unwind), all normal cleanup forms will be executed. However, if the interrupt occurs during cleanup forms of an unwind-protect, it is just as if that had happened due to a regular go, throw, or return-from: the interrupted cleanup form and those following it in the same unwind-protect do not get executed. sbcl tries to keep its own internals asynch-unwind-safe, but this is frankly an unreasonable expectation for third party libraries, especially given that asynch-unwind-safety does not compose: a function calling only asynch-unwind-safe function isn’t automatically asynch-unwind-safe. This means that in order for an asynch unwind to be safe, the entire callstack at the point of interruption needs to be asynch-unwind-safe. In addition to asynch-unwind-safety you must consider the issue of reentrancy. interrupt-thread can cause function that are never normally called recursively to be re-entered during their dynamic contour, which may cause them to misbehave. (Consider binding of special variables, values of global variables, etc.) Take together, these two restrict the ""safe"" things to do using interrupt-thread to a fairly minimal set. One useful one -- exclusively for interactive development use is using it to force entry to debugger to inspect the state of a thread:   (interrupt-thread thread #'break)  Short version: be careful out there. Function: terminate-thread [sb-thread] thread Terminate the thread identified by thread, by interrupting it and causing it to call sb-ext:abort-thread with :allow-exit t. The unwind caused by terminate-thread is asynchronous, meaning that eg. thread executing   (let (foo)      (unwind-protect          (progn             (setf foo (get-foo))             (work-on-foo foo))        (when foo          ;; An interrupt occurring inside the cleanup clause          ;; will cause cleanups from the current UNWIND-PROTECT          ;; to be dropped.          (release-foo foo))))  might miss calling release-foo despite get-foo having returned true if the interrupt occurs inside the cleanup clause, eg. during execution of release-foo. Thus, in order to write an asynch unwind safe unwind-protect you need to use without-interrupts:   (let (foo)     (sb-sys:without-interrupts       (unwind-protect           (progn             (setf foo (sb-sys:allow-with-interrupts                         (get-foo)))             (sb-sys:with-local-interrupts               (work-on-foo foo)))        (when foo          (release-foo foo)))))  Since most libraries using unwind-protect do not do this, you should never assume that unknown code can safely be terminated using terminate-thread. 12.1.4 Miscellaneous Operations Function: symbol-value-in-thread [sb-thread] symbol thread &optional errorp Return the local value of symbol in thread, and a secondary value of t on success. If the value cannot be retrieved (because the thread has exited or because it has no local binding for NAME) and errorp is true signals an error of type symbol-value-in-thread-error; if errorp is false returns a primary value of nil, and a secondary value of nil. Can also be used with setf to change the thread-local value of symbol. symbol-value-in-thread is primarily intended as a debugging tool, and not as a mechanism for inter-thread communication. 12.1.5 Error Conditions Condition: thread-error [sb-thread] Class precedence list: thread-error, error, serious-condition, condition, t Conditions of type thread-error are signalled when thread operations fail. The offending thread is initialized by the :thread initialization argument and read by the function thread-error-thread. Function: thread-error-thread [sb-thread] condition Return the offending thread that the thread-error pertains to. Condition: interrupt-thread-error [sb-thread] Class precedence list: interrupt-thread-error, thread-error, error, serious-condition, condition, t Signalled when interrupting a thread fails because the thread has already exited. The offending thread can be accessed using thread-error-thread. Condition: join-thread-error [sb-thread] Class precedence list: join-thread-error, thread-error, error, serious-condition, condition, t Signalled when joining a thread fails due to abnormal exit of the thread to be joined. The offending thread can be accessed using thread-error-thread. Next: Atomic Operations, Previous: Threading basics, Up: Threading   [Contents][Index] 12.2 Special Variables The interaction of special variables with multiple threads is mostly as one would expect, with behaviour very similar to other implementations. global special values are visible across all threads; bindings (e.g. using LET) are local to the thread; threads do not inherit dynamic bindings from the parent thread The last point means that (defparameter *x* 0) (let ((*x* 1))   (sb-thread:make-thread (lambda () (print *x*))))  prints 0 and not 1 as of 0.9.6. Next: Mutex Support, Previous: Special Variables, Up: Threading   [Contents][Index] 12.3 Atomic Operations Following atomic operations are particularly useful for implementing lockless algorithms. Macro: atomic-decf [sb-ext] place &optional diff Atomically decrements place by diff, and returns the value of place before the decrement. place must access one of the following: a defstruct slot with declared type (unsigned-byte 64) or aref of a (simple-array (unsigned-byte 64) (*)) The type sb-ext:word can be used for these purposes. car or cdr (respectively first or REST) of a cons. a variable defined using defglobal with a proclaimed type of fixnum. Macroexpansion is performed on place before expanding atomic-decf. Decrementing is done using modular arithmetic, which is well-defined over two different domains: For structures and arrays, the operation accepts and produces an (unsigned-byte 64), and diff must be of type (signed-byte 64). atomic-decf of #x0 by one results in #xFFFFFFFFFFFFFFFF being stored in place. For other places, the domain is fixnum, and diff must be a fixnum. atomic-decf of #x-4000000000000000 by one results in #x3FFFFFFFFFFFFFFF being stored in place. diff defaults to 1. experimental: Interface subject to change. Macro: atomic-incf [sb-ext] place &optional diff Atomically increments place by diff, and returns the value of place before the increment. place must access one of the following: a defstruct slot with declared type (unsigned-byte 64) or aref of a (simple-array (unsigned-byte 64) (*)) The type sb-ext:word can be used for these purposes. car or cdr (respectively first or REST) of a cons. a variable defined using defglobal with a proclaimed type of fixnum. Macroexpansion is performed on place before expanding atomic-incf. Incrementing is done using modular arithmetic, which is well-defined over two different domains: For structures and arrays, the operation accepts and produces an (unsigned-byte 64), and diff must be of type (signed-byte 64). atomic-incf of #xFFFFFFFFFFFFFFFF by one results in #x0 being stored in place. For other places, the domain is fixnum, and diff must be a fixnum. atomic-incf of #x3FFFFFFFFFFFFFFF by one results in #x-4000000000000000 being stored in place. diff defaults to 1. experimental: Interface subject to change. Macro: atomic-pop [sb-ext] place Like pop, but atomic. place may be read multiple times before the operation completes -- the write does not occur until such time that no other thread modified place between the read and the write. Works on all CASable places. Macro: atomic-push [sb-ext] obj place Like push, but atomic. place may be read multiple times before the operation completes -- the write does not occur until such time that no other thread modified place between the read and the write. Works on all CASable places. Macro: atomic-update [sb-ext] place update-fn &rest arguments Updates place atomically to the value returned by calling function designated by update-fn with arguments and the previous value of place. place may be read and update-fn evaluated and called multiple times before the update succeeds: atomicity in this context means that the value of place did not change between the time it was read, and the time it was replaced with the computed value. place can be any place supported by sb-ext:compare-and-swap. Examples:   ;;; Conses T to the head of FOO-LIST.   (defstruct foo list)   (defvar *foo* (make-foo))   (atomic-update (foo-list *foo*) #'cons t)    (let ((x (cons :count 0)))      (mapc #'sb-thread:join-thread            (loop repeat 1000                  collect (sb-thread:make-thread                           (lambda ()                             (loop repeat 1000                                   do (atomic-update (cdr x) #'1+)                                      (sleep 0.00001))))))      ;; Guaranteed to be (:COUNT . 1000000) -- if you replace      ;; atomic update with (INCF (CDR X)) above, the result becomes      ;; unpredictable.      x)  Macro: compare-and-swap [sb-ext] place old new Atomically stores new in place if old matches the current value of place. Two values are considered to match if they are eq. Returns the previous value of place: if the returned value is eq to old, the swap was carried out. place must be an CAS-able place. Built-in CAS-able places are accessor forms whose car is one of the following: car, cdr, first, rest, svref, symbol-plist, symbol-value, svref, slot-value sb-mop:standard-instance-access, sb-mop:funcallable-standard-instance-access, or the name of a defstruct created accessor for a slot whose declared type is either fixnum or t. Results are unspecified if the slot has a declared type other than fixnum or t. In case of slot-value, if the slot is unbound, slot-unbound is called unless old is eq to sb-pcl:+slot-unbound+ in which case sb-pcl:+slot-unbound+ is returned and new is assigned to the slot. Additionally, the results are unspecified if there is an applicable method on either sb-mop:slot-value-using-class, (setf sb-mop:slot-value-using-class), or sb-mop:slot-boundp-using-class. Additionally, the place can be a anything for which a CAS-expansion has been specified using defcas, define-cas-expander, or for which a CAS-function has been defined. (See sb-ext:cas for more information.) CAS Protocol Our compare-and-swap is user-extensible using a protocol similar to setf, allowing users to add CAS support to new places via e.g. defcas. At the same time, new atomic operations can be built on top of CAS using get-cas-expansion. See atomic-update, atomic-push, and atomic-pop for examples of how to do this. Macro: cas [sb-ext] place old new Synonym for compare-and-swap. Additionally defun, defgeneric, defmethod, flet, and labels can be also used to define CAS-functions analogously to SETF-functions:   (defvar *foo* nil)    (defun (cas foo) (old new)     (cas (symbol-value '*foo*) old new))  First argument of a cas function is the expected old value, and the second argument of is the new value. Note that the system provides no automatic atomicity for cas functions, nor can it verify that they are atomic: it is up to the implementor of a cas function to ensure its atomicity. experimental: Interface subject to change. Macro: define-cas-expander [sb-ext] accessor lambda-list &body body Analogous to define-setf-expander. Defines a CAS-expansion for accessor. body must return six values as specified in get-cas-expansion. Note that the system provides no automatic atomicity for cas expansion, nor can it verify that they are atomic: it is up to the implementor of a cas expansion to ensure its atomicity. experimental: Interface subject to change. Macro: defcas [sb-ext] accessor lambda-list function &optional docstring Analogous to short-form defsetf. Defines function as responsible for compare-and-swap on places accessed using accessor. lambda-list must correspond to the lambda-list of the accessor. Note that the system provides no automatic atomicity for cas expansions resulting from defcas, nor can it verify that they are atomic: it is up to the user of defcas to ensure that the function specified is atomic. experimental: Interface subject to change. Function: get-cas-expansion [sb-ext] place &optional environment Analogous to get-setf-expansion. Returns the following six values: list of temporary variables list of value-forms whose results those variable must be bound temporary variable for the old value of place temporary variable for the new value of place form using the aforementioned temporaries which performs the compare-and-swap operation on place form using the aforementioned temporaries with which to perform a volatile read of place Example:   (get-cas-expansion '(car x))   ; => (#:CONS871), (X), #:OLD872, #:NEW873,   ;    (SB-KERNEL:%COMPARE-AND-SWAP-CAR #:CONS871 #:OLD872 :NEW873).   ;    (CAR #:CONS871)    (defmacro my-atomic-incf (place &optional (delta 1) &environment env)     (multiple-value-bind (vars vals old new cas-form read-form)         (get-cas-expansion place env)      (let ((delta-value (gensym ""DELTA"")))        `(let* (,@(mapcar 'list vars vals)                (,old ,read-form)                (,delta-value ,delta)                (,new (+ ,old ,delta-value)))           (loop until (eq ,old (setf ,old ,cas-form))                 do (setf ,new (+ ,old ,delta-value)))           ,new))))  experimental: Interface subject to change. Next: Semaphores, Previous: Atomic Operations, Up: Threading   [Contents][Index] 12.4 Mutex Support Mutexes are used for controlling access to a shared resource. One thread is allowed to hold the mutex, others which attempt to take it will be made to wait until it’s free. Threads are woken in the order that they go to sleep. (defpackage :demo (:use ""CL"" ""SB-THREAD"" ""SB-EXT""))  (in-package :demo)  (defvar *a-mutex* (make-mutex :name ""my lock""))  (defun thread-fn ()   (format t ""Thread ~A running ~%"" *current-thread*)   (with-mutex (*a-mutex*)     (format t ""Thread ~A got the lock~%"" *current-thread*)     (sleep (random 5)))   (format t ""Thread ~A dropped lock, dying now~%"" *current-thread*))  (make-thread #'thread-fn) (make-thread #'thread-fn)  Structure: mutex [sb-thread] Class precedence list: mutex, structure-object, t Mutex type. Macro: with-mutex [sb-thread] (mutex &key wait-p timeout value) &body body Acquire mutex for the dynamic scope of body. If wait-p is true (the default), and the mutex is not immediately available, sleep until it is available. If timeout is given, it specifies a relative timeout, in seconds, on how long the system should try to acquire the lock in the contested case. If the mutex isn’t acquired successfully due to either wait-p or timeout, the body is not executed, and with-mutex returns nil. Otherwise body is executed with the mutex held by current thread, and with-mutex returns the values of body. Historically with-mutex also accepted a value argument, which when provided was used as the new owner of the mutex instead of the current thread. This is no longer supported: if value is provided, it must be either nil or the current thread. Macro: with-recursive-lock [sb-thread] (mutex &key wait-p timeout) &body body Acquire mutex for the dynamic scope of body. If wait-p is true (the default), and the mutex is not immediately available or held by the current thread, sleep until it is available. If timeout is given, it specifies a relative timeout, in seconds, on how long the system should try to acquire the lock in the contested case. If the mutex isn’t acquired successfully due to either wait-p or timeout, the body is not executed, and with-recursive-lock returns nil. Otherwise body is executed with the mutex held by current thread, and with-recursive-lock returns the values of body. Unlike with-mutex, which signals an error on attempt to re-acquire an already held mutex, with-recursive-lock allows recursive lock attempts to succeed. Function: make-mutex [sb-thread] &key name Create a mutex. Function: mutex-name [sb-thread] instance The name of the mutex. Setfable. Function: mutex-owner [sb-thread] mutex Current owner of the mutex, nil if the mutex is free. Naturally, this is racy by design (another thread may acquire the mutex after this function returns), it is intended for informative purposes. For testing whether the current thread is holding a mutex see holding-mutex-p. Function: mutex-value [sb-thread] mutex Current owner of the mutex, nil if the mutex is free. May return a stale value, use mutex-owner instead. Function: grab-mutex [sb-thread] mutex &key waitp timeout Acquire mutex for the current thread. If waitp is true (the default) and the mutex is not immediately available, sleep until it is available. If timeout is given, it specifies a relative timeout, in seconds, on how long grab-mutex should try to acquire the lock in the contested case. If grab-mutex returns t, the lock acquisition was successful. In case of waitp being nil, or an expired timeout, grab-mutex may also return nil which denotes that grab-mutex did -not- acquire the lock. Notes: grab-mutex is not interrupt safe. The correct way to call it is: (WITHOUT-INTERRUPTS ... (allow-with-interrupts (grab-mutex ...)) ...) without-interrupts is necessary to avoid an interrupt unwinding the call while the mutex is in an inconsistent state while allow-with-interrupts allows the call to be interrupted from sleep. (grab-mutex <mutex> :timeout 0.0) differs from (grab-mutex <mutex> :waitp nil) in that the former may signal a deadline-timeout if the global deadline was due already on entering grab-mutex. The exact interplay of grab-mutex and deadlines are reserved to change in future versions. It is recommended that you use with-mutex instead of calling grab-mutex directly. Function: release-mutex [sb-thread] mutex &key if-not-owner Release mutex by setting it to nil. Wake up threads waiting for this mutex. release-mutex is not interrupt safe: interrupts should be disabled around calls to it. If the current thread is not the owner of the mutex then it silently returns without doing anything (if if-not-owner is :PUNT), signals a warning (if if-not-owner is :WARN), or releases the mutex anyway (if if-not-owner is :FORCE). Next: Waitqueue/condition variables, Previous: Mutex Support, Up: Threading   [Contents][Index] 12.5 Semaphores Semaphores are among other things useful for keeping track of a countable resource, e.g. messages in a queue, and sleep when the resource is exhausted. Structure: semaphore [sb-thread] Class precedence list: semaphore, structure-object, t Semaphore type. The fact that a semaphore is a structure-object should be considered an implementation detail, and may change in the future. Function: make-semaphore [sb-thread] &key name count Create a semaphore with the supplied count and name. Function: signal-semaphore [sb-thread] semaphore &optional n Increment the count of semaphore by n. If there are threads waiting on this semaphore, then n of them is woken up. Function: wait-on-semaphore [sb-thread] semaphore &key n timeout notification Decrement the count of semaphore by n if the count would not be negative. Else blocks until the semaphore can be decremented. Returns the new count of semaphore on success. If timeout is given, it is the maximum number of seconds to wait. If the count cannot be decremented in that time, returns nil without decrementing the count. If notification is given, it must be a semaphore-notification object whose semaphore-notification-status is nil. If wait-on-semaphore succeeds and decrements the count, the status is set to t. Function: try-semaphore [sb-thread] semaphore &optional n notification Try to decrement the count of semaphore by n. If the count were to become negative, punt and return nil, otherwise return the new count of semaphore. If notification is given it must be a semaphore notification object with semaphore-notification-status of nil. If the count is decremented, the status is set to t. Function: semaphore-count [sb-thread] instance Returns the current count of the semaphore instance. Function: semaphore-name [sb-thread] instance The name of the semaphore instance. Setfable. Structure: semaphore-notification [sb-thread] Class precedence list: semaphore-notification, structure-object, t Semaphore notification object. Can be passed to wait-on-semaphore and try-semaphore as the :notification argument. Consequences are undefined if multiple threads are using the same notification object in parallel. Function: make-semaphore-notification [sb-thread] Constructor for semaphore-notification objects. semaphore-notification-status is initially nil. Function: semaphore-notification-status [sb-thread] semaphore-notification Returns t if a wait-on-semaphore or try-semaphore using semaphore-notification has succeeded since the notification object was created or cleared. Function: clear-semaphore-notification [sb-thread] semaphore-notification Resets the semaphore-notification object for use with another call to wait-on-semaphore or try-semaphore. Next: Barriers, Previous: Semaphores, Up: Threading   [Contents][Index] 12.6 Waitqueue/condition variables These are based on the POSIX condition variable design, hence the annoyingly CL-conflicting name. For use when you want to check a condition and sleep until it’s true. For example: you have a shared queue, a writer process checking “queue is empty” and one or more readers that need to know when “queue is not empty”. It sounds simple, but is astonishingly easy to deadlock if another process runs when you weren’t expecting it to. There are three components: the condition itself (not represented in code) the condition variable (a.k.a. waitqueue) which proxies for it a lock to hold while testing the condition Important stuff to be aware of: when calling condition-wait, you must hold the mutex. condition-wait will drop the mutex while it waits, and obtain it again before returning for whatever reason; likewise, you must be holding the mutex around calls to condition-notify; a process may return from condition-wait in several circumstances: it is not guaranteed that the underlying condition has become true. You must check that the resource is ready for whatever you want to do to it. (defvar *buffer-queue* (make-waitqueue)) (defvar *buffer-lock* (make-mutex :name ""buffer lock""))  (defvar *buffer* (list nil))  (defun reader ()   (with-mutex (*buffer-lock*)     (loop      (condition-wait *buffer-queue* *buffer-lock*)      (loop       (unless *buffer* (return))       (let ((head (car *buffer*)))         (setf *buffer* (cdr *buffer*))         (format t ""reader ~A woke, read ~A~%""                 *current-thread* head))))))  (defun writer ()   (loop    (sleep (random 5))    (with-mutex (*buffer-lock*)      (let ((el (intern                 (string (code-char                          (+ (char-code #\A) (random 26)))))))        (setf *buffer* (cons el *buffer*)))      (condition-notify *buffer-queue*))))  (make-thread #'writer) (make-thread #'reader) (make-thread #'reader)  Structure: waitqueue [sb-thread] Class precedence list: waitqueue, structure-object, t Waitqueue type. Function: make-waitqueue [sb-thread] &key name Create a waitqueue. Function: waitqueue-name [sb-thread] instance The name of the waitqueue. Setfable. Function: condition-wait [sb-thread] queue mutex &key timeout Atomically release mutex and start waiting on queue for till another thread wakes us up using either condition-notify or condition-broadcast on that queue, at which point we re-acquire mutex and return t. Spurious wakeups are possible. If timeout is given, it is the maximum number of seconds to wait, including both waiting for the wakeup and the time to re-acquire mutex. Unless both wakeup and re-acquisition do not occur within the given time, returns nil without re-acquiring the mutex. If condition-wait unwinds, it may do so with or without the mutex being held. Important: Since condition-wait may return without condition-notify having occurred the correct way to write code that uses condition-wait is to loop around the call, checking the the associated data:   (defvar *data* nil)   (defvar *queue* (make-waitqueue))   (defvar *lock* (make-mutex))    ;; Consumer   (defun pop-data (&optional timeout)     (with-mutex (*lock*)       (loop until *data*             do (or (condition-wait *queue* *lock* :timeout timeout)                    ;; Lock not held, must unwind without touching *data*.                    (return-from pop-data nil)))       (pop *data*)))    ;; Producer   (defun push-data (data)     (with-mutex (*lock*)       (push data *data*)       (condition-notify *queue*)))  Function: condition-notify [sb-thread] queue &optional n Notify n threads waiting on queue. important: The same mutex that is used in the corresponding condition-wait must be held by this thread during this call. Function: condition-broadcast [sb-thread] queue Notify all threads waiting on queue. important: The same mutex that is used in the corresponding condition-wait must be held by this thread during this call. Next: Sessions/Debugging, Previous: Waitqueue/condition variables, Up: Threading   [Contents][Index] 12.7 Barriers These are based on the Linux kernel barrier design, which is in turn based on the Alpha CPU memory model. They are presently implemented for x86, x86-64, PPC, and ARM64 systems, and behave as compiler barriers on all other CPUs. In addition to explicit use of the sb-thread:barrier macro, the following functions and macros also serve as :memory barriers: sb-ext:atomic-decf, sb-ext:atomic-incf, sb-ext:atomic-push, and sb-ext:atomic-pop. sb-ext:compare-and-swap. sb-thread:grab-mutex, sb-thread:release-mutex, sb-thread:with-mutex and sb-thread:with-recursive-lock. sb-thread:signal-semaphore, sb-thread:try-semaphore and sb-thread:wait-on-semaphore. sb-thread:condition-wait, sb-thread:condition-notify and sb-thread:condition-broadcast. Macro: barrier [sb-thread] (kind) &body forms Insert a barrier in the code stream, preventing some sort of reordering. kind should be one of: :compiler Prevent the compiler from reordering memory access across the barrier. :memory Prevent the cpu from reordering any memory access across the barrier. :read Prevent the cpu from reordering any read access across the barrier. :write Prevent the cpu from reordering any write access across the barrier. :data-dependency Prevent the cpu from reordering dependent memory reads across the barrier (requiring reads before the barrier to complete before any reads after the barrier that depend on them). This is a weaker form of the :read barrier. forms is an implicit progn, evaluated before the barrier. barrier returns the values of the last form in forms. The file ""memory-barriers.txt"" in the Linux kernel documentation is highly recommended reading for anyone programming at this level. Next: Foreign threads, Previous: Barriers, Up: Threading   [Contents][Index] 12.8 Sessions/Debugging If the user has multiple views onto the same Lisp image (for example, using multiple terminals, or a windowing system, or network access) they are typically set up as multiple sessions such that each view has its own collection of foreground/background/stopped threads. A thread which wishes to create a new session can use sb-thread:with-new-session to remove itself from the current session (which it shares with its parent and siblings) and create a fresh one. # See also sb-thread:make-listener-thread. Within a single session, threads arbitrate between themselves for the user’s attention. A thread may be in one of three notional states: foreground, background, or stopped. When a background process attempts to print a repl prompt or to enter the debugger, it will stop and print a message saying that it has stopped. The user at his leisure may switch to that thread to find out what it needs. If a background thread enters the debugger, selecting any restart will put it back into the background before it resumes. Arbitration for the input stream is managed by calls to sb-thread:get-foreground (which may block) and sb-thread:release-foreground. Next: Implementation (Linux x86/x86-64), Previous: Sessions/Debugging, Up: Threading   [Contents][Index] 12.9 Foreign threads Direct calls to pthread_create (instead of MAKE-THREAD) create threads that SBCL is not aware of, these are called foreign threads. Currently, it is not possible to run Lisp code in such threads. This means that the Lisp side signal handlers cannot work. The best solution is to start foreign threads with signals blocked, but since third party libraries may create threads, it is not always feasible to do so. As a workaround, upon receiving a signal in a foreign thread, SBCL changes the thread’s sigmask to block all signals that it wants to handle and resends the signal to the current process which should land in a thread that does not block it, that is, a Lisp thread. The resignalling trick cannot work for synchronously triggered signals (SIGSEGV and co), take care not to trigger any. Resignalling for synchronously triggered signals in foreign threads is subject to --lose-on-corruption, see Runtime Options. Previous: Foreign threads, Up: Threading   [Contents][Index] 12.10 Implementation (Linux x86/x86-64) Threading is implemented using pthreads and some Linux specific bits like futexes. On x86 the per-thread local bindings for special variables is achieved using the %fs segment register to point to a per-thread storage area. This may cause interesting results if you link to foreign code that expects threading or creates new threads, and the thread library in question uses %fs in an incompatible way. On x86-64 the r12 register has a similar role. Queues require the sys_futex() system call to be available: this is the reason for the NPTL requirement. We test at runtime that this system call exists. Garbage collection is done with the existing Conservative Generational GC. Allocation is done in small (typically 8k) regions: each thread has its own region so this involves no stopping. However, when a region fills, a lock must be obtained while another is allocated, and when a collection is required, all processes are stopped. This is achieved by sending them signals, which may make for interesting behaviour if they are interrupted in system calls. The streams interface is believed to handle the required system call restarting correctly, but this may be a consideration when making other blocking calls e.g. from foreign library code. Large amounts of the SBCL library have not been inspected for thread-safety. Some of the obviously unsafe areas have large locks around them, so compilation and fasl loading, for example, cannot be parallelized. Work is ongoing in this area. A new thread by default is created in the same POSIX process group and session as the thread it was created by. This has an impact on keyboard interrupt handling: pressing your terminal’s intr key (typically Control-C) will interrupt all processes in the foreground process group, including Lisp threads that SBCL considers to be notionally ‘background’. This is undesirable, so background threads are set to ignore the SIGINT signal. sb-thread:make-listener-thread in addition to creating a new Lisp session makes a new POSIX session, so that pressing Control-C in one window will not interrupt another listener - this has been found to be embarrassing. Next: Networking, Previous: Threading, Up: Top   [Contents][Index] 13 Timers SBCL supports a system-wide event scheduler implemented on top of setitimer that also works with threads but does not require a separate scheduler thread. The following example schedules a timer that writes “Hello, word” after two seconds. (schedule-timer (make-timer (lambda ()                               (write-line ""Hello, world"")                               (force-output)))                 2)  It should be noted that writing timer functions requires special care, as the dynamic environment in which they run is unpredictable: dynamic variable bindings, locks held, etc, all depend on whatever code was running when the timer fired. The following example should serve as a cautionary tale: (defvar *foo* nil)  (defun show-foo ()   (format t ""~&foo=~S~%"" *foo*)   (force-output t))  (defun demo ()   (schedule-timer (make-timer #'show-foo) 0.5)   (schedule-timer (make-timer #'show-foo) 1.5)   (let ((*foo* t))     (sleep 1.0))   (let ((*foo* :surprise!))     (sleep 2.0)))  13.1 Timer Dictionary Structure: timer [sb-ext] Class precedence list: timer, structure-object, t Timer type. Do not rely on timers being structs as it may change in future versions. Function: make-timer [sb-ext] function &key name thread Create a timer that runs function when triggered. If a thread is supplied, function is run in that thread. If thread is t, a new thread is created for function each time the timer is triggered. If thread is nil, function is run in an unspecified thread. When thread is not t, interrupt-thread is used to run function and the ordering guarantees of interrupt-thread apply. In that case, function runs with interrupts disabled but with-interrupts is allowed. Function: timer-name [sb-ext] timer Return the name of timer. Function: timer-scheduled-p [sb-ext] timer &key delta See if timer will still need to be triggered after delta seconds from now. For timers with a repeat interval it returns true. Function: schedule-timer [sb-ext] timer time &key repeat-interval absolute-p catch-up Schedule timer to be triggered at time. If absolute-p then time is universal time, but non-integral values are also allowed, else time is measured as the number of seconds from the current time. If repeat-interval is given, timer is automatically rescheduled upon expiry. If repeat-interval is non-NIL, the Boolean catch-up controls whether timer will ""catch up"" by repeatedly calling its function without delay in case calls are missed because of a clock discontinuity such as a suspend and resume cycle of the computer. The default is nil, i.e. do not catch up. Function: unschedule-timer [sb-ext] timer Cancel timer. Once this function returns it is guaranteed that timer shall not be triggered again and there are no unfinished triggers. Function: list-all-timers [sb-ext] Return a list of all timers in the system. Next: Profiling, Previous: Timers, Up: Top   [Contents][Index] 14 Networking The sb-bsd-sockets module provides a thinly disguised BSD socket API for SBCL. Ideas have been stolen from the BSD socket API for C and Graham Barr’s IO::Socket classes for Perl. Sockets are represented as CLOS objects, and the API naming conventions attempt to balance between the BSD names and good lisp style. • Sockets Overview:    • General Sockets:    Methods applicable to all sockets • Socket Options:    • INET Domain Sockets:    • Local (Unix) Domain Sockets:    • Name Service:    Next: General Sockets, Up: Networking   [Contents][Index] 14.1 Sockets Overview Most of the functions are modelled on the BSD socket API. BSD sockets are widely supported, portably (“portable” by Unix standards, at least) available on a variety of systems, and documented. There are some differences in approach where we have taken advantage of some of the more useful features of Common Lisp - briefly: Where the C API would typically return -1 and set errno, sb-bsd-sockets signals an error. All the errors are subclasses of sb-bsd-sockets:socket-condition and generally correspond one for one with possible errno values. We use multiple return values in many places where the C API would use pass-by-reference values. We can often avoid supplying an explicit length argument to functions because we already know how long the argument is. IP addresses and ports are represented in slightly friendlier fashion than ""network-endian integers"". Next: Socket Options, Previous: Sockets Overview, Up: Networking   [Contents][Index] 14.2 General Sockets Class: socket [sb-bsd-sockets] Class precedence list: socket, standard-object, t Slots: protocol — initarg: :protocol; reader: sb-bsd-sockets:socket-protocol Protocol used by the socket. If a keyword, the symbol-name of the keyword will be passed to get-protocol-by-name downcased, and the returned value used as protocol. Other values are used as-is. type — initarg: :type; reader: sb-bsd-sockets:socket-type Type of the socket: :stream or :datagram. Common superclass of all sockets, not meant to be directly instantiated. Generic Function: socket-bind [sb-bsd-sockets] socket &rest address Bind socket to address, which may vary according to socket family. For the inet family, pass address and port as two arguments; for file address family sockets, pass the filename string. See also bind(2) Generic Function: socket-accept [sb-bsd-sockets] socket Perform the accept(2) call, returning a newly-created connected socket and the peer address as multiple values Generic Function: socket-connect [sb-bsd-sockets] socket &rest address Perform the connect(2) call to connect socket to a remote peer. No useful return value. Generic Function: socket-peername [sb-bsd-sockets] socket Return SOCKET’s peer; depending on the address family this may return multiple values Generic Function: socket-name [sb-bsd-sockets] socket Return the address (as vector of bytes) and port that socket is bound to, as multiple values. Generic Function: socket-receive [sb-bsd-sockets] socket buffer length &key oob peek waitall dontwait element-type Read length octets from socket into buffer (or a freshly-consed buffer if NIL), using recvfrom(2). If length is nil, the length of buffer is used, so at least one of these two arguments must be non-NIL. If buffer is supplied, it had better be of an element type one octet wide. Returns the buffer, its length, and the address of the peer that sent it, as multiple values. On datagram sockets, sets MSG_TRUNC so that the actual packet length is returned even if the buffer was too small. Generic Function: socket-send [sb-bsd-sockets] socket buffer length &key address external-format oob eor dontroute dontwait nosignal confirm more Send length octets from buffer into socket, using sendto(2). If buffer is a string, it will converted to octets according to external-format. If length is nil, the length of the octet buffer is used. The format of address depends on the socket type (for example for inet domain sockets it would be a list of an ip address and a port). If no socket address is provided, send(2) will be called instead. Returns the number of octets written. Generic Function: socket-listen [sb-bsd-sockets] socket backlog Mark socket as willing to accept incoming connections. The integer backlog defines the maximum length that the queue of pending connections may grow to before new connection attempts are refused. See also listen(2) Generic Function: socket-open-p [sb-bsd-sockets] socket Return true if socket is open; otherwise, return false. Generic Function: socket-close [sb-bsd-sockets] socket &key abort Close socket, unless it was already closed. If socket-make-stream has been called, calls close using abort on that stream. Otherwise closes the socket file descriptor using close(2). Generic Function: socket-shutdown [sb-bsd-sockets] socket &key direction Indicate that no communication in direction will be performed on socket. direction has to be one of :input, :output or :io. After a shutdown, no input and/or output of the indicated direction can be performed on socket. Generic Function: socket-make-stream [sb-bsd-sockets] socket &key input output element-type external-format buffering timeout auto-close serve-events Find or create a stream that can be used for io on socket (which must be connected). Specify whether the stream is for input, output, or both (it is an error to specify neither). element-type and external-format are as per open. timeout specifies a read timeout for the stream. Method: socket-make-stream [sb-bsd-sockets] (socket socket) &key input output (element-type (quote character)) (buffering full) (external-format default) timeout auto-close serve-events Default method for socket objects. element-type defaults to character, to construct a bivalent stream, capable of both binary and character io use :default. Acceptable values for buffering are :full, :line and :none, default is :full, ie. output is buffered till it is explicitly flushed using close or finish-output. (force-output forces some output to be flushed: to ensure all buffered output is flused use finish-output.) Streams have no timeout by default. If one is provided, it is the number of seconds the system will at most wait for input to appear on the socket stream when trying to read from it. If auto-close is true, the underlying os socket is automatically closed after the stream and the socket have been garbage collected. Default is false. If serve-events is true, blocking io on the socket will dispatch to the recursive event loop. Default is false. The stream for socket will be cached, and a second invocation of this method will return the same stream. This may lead to oddities if this function is invoked with inconsistent arguments (e.g., one might request an input stream and get an output stream in response). Function: socket-error [sb-bsd-sockets] where &optional errno Generic Function: non-blocking-mode [sb-bsd-sockets] socket Is socket in non-blocking mode? Next: INET Domain Sockets, Previous: General Sockets, Up: Networking   [Contents][Index] 14.3 Socket Options A subset of socket options are supported, using a fairly general framework which should make it simple to add more as required - see SYS:CONTRIB;SB-BSD-SOCKETS:SOCKOPT.LISP for details. The name mapping from C is fairly straightforward: SO_RCVLOWAT becomes sockopt-receive-low-water and (setf sockopt-receive-low-water). Function: sockopt-reuse-address [sb-bsd-sockets] socket Return the value of the so-reuseaddr socket option for socket. This can also be updated with setf. Function: sockopt-keep-alive [sb-bsd-sockets] socket Return the value of the so-keepalive socket option for socket. This can also be updated with setf. Function: sockopt-oob-inline [sb-bsd-sockets] socket Return the value of the so-oobinline socket option for socket. This can also be updated with setf. Function: sockopt-bsd-compatible [sb-bsd-sockets] socket Return the value of the so-bsdcompat socket option for socket. This can also be updated with setf. Available only on Linux. Function: sockopt-pass-credentials [sb-bsd-sockets] socket Return the value of the so-passcred socket option for socket. This can also be updated with setf. Available only on Linux. Function: sockopt-debug [sb-bsd-sockets] socket Return the value of the so-debug socket option for socket. This can also be updated with setf. Function: sockopt-dont-route [sb-bsd-sockets] socket Return the value of the so-dontroute socket option for socket. This can also be updated with setf. Function: sockopt-broadcast [sb-bsd-sockets] socket Return the value of the so-broadcast socket option for socket. This can also be updated with setf. Function: sockopt-tcp-nodelay [sb-bsd-sockets] socket Return the value of the tcp-nodelay socket option for socket. This can also be updated with setf. Next: Local (Unix) Domain Sockets, Previous: Socket Options, Up: Networking   [Contents][Index] 14.4 INET Domain Sockets The TCP and UDP sockets that you know and love. Some representation issues: IPv4 Internet addresses are represented by vectors of (unsigned-byte 8) - viz. #(127 0 0 1). Ports are just integers: 6010. No conversion between network- and host-order data is needed from the user of this package. IPv6 Internet addresses are represented by vectors of 16 (unsigned-byte 8) - viz. #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1). Ports are just integers. As for IPv4 addresses, no conversion between network- and host-order data is needed from the user of this package. Socket addresses are represented by the two values for address and port, so for example, (socket-connect socket #(192 168 1 1) 80) for IPv4 and (socket-connect socket #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1) 80) for IPv6. Class: inet-socket [sb-bsd-sockets] Class precedence list: inet-socket, socket, standard-object, t Class representing tcp and udp over IPv4 sockets. Examples:  (make-instance 'sb-bsd-sockets:inet-socket :type :stream :protocol :tcp)   (make-instance 'sb-bsd-sockets:inet-socket :type :datagram :protocol :udp)  Class: inet6-socket [sb-bsd-sockets] Class precedence list: inet6-socket, socket, standard-object, t Class representing tcp and udp over IPv6 sockets. Examples:  (make-instance 'sb-bsd-sockets:inet6-socket :type :stream :protocol :tcp)   (make-instance 'sb-bsd-sockets:inet6-socket :type :datagram :protocol :udp)  Function: make-inet-address [sb-bsd-sockets] dotted-quads Return a vector of octets given a string dotted-quads in the format ""127.0.0.1"". Signals an error if the string is malformed. Function: make-inet6-address [sb-bsd-sockets] colon-separated-integers Return a vector of octets given a string representation of an IPv6 address colon-separated-integers. Signal an error if the string is malformed. Function: get-protocol-by-name [sb-bsd-sockets] name Given a protocol name, return the protocol number, the protocol name, and a list of protocol aliases Next: Name Service, Previous: INET Domain Sockets, Up: Networking   [Contents][Index] 14.5 Local (Unix) Domain Sockets Local domain (AF_LOCAL) sockets are also known as Unix-domain sockets, but were renamed by POSIX presumably on the basis that they may be available on other systems too. A local socket address is a string, which is used to create a node in the local filesystem. This means of course that they cannot be used across a network. Class: local-socket [sb-bsd-sockets] Class precedence list: local-socket, socket, standard-object, t Class representing local domain (AF_LOCAL) sockets, also known as unix-domain sockets. Previous: Local (Unix) Domain Sockets, Up: Networking   [Contents][Index] 14.6 Name Service Presently name service is implemented by calling out to the getaddrinfo(3) and gethostinfo(3), or to gethostbyname(3) gethostbyaddr(3) on platforms where the preferred functions are not available. The exact details of the name resolving process (for example the choice of whether DNS or a hosts file is used for lookup) are platform dependent. Class: host-ent [sb-bsd-sockets] Class precedence list: host-ent, standard-object, t Slots: name — initarg: :name; reader: sb-bsd-sockets:host-ent-name The name of the host addresses — initarg: :addresses; reader: sb-bsd-sockets:host-ent-addresses A list of addresses for this host. This class represents the results of an address lookup. Function: get-host-by-name [sb-bsd-sockets] node Returns a host-ent instance for node or signals a name-service-error. Another host-ent instance containing zero, one or more IPv6 addresses may be returned as a second return value. node may also be an ip address in dotted quad notation or some other weird stuff - see getaddrinfo(3) for the details. Function: get-host-by-address [sb-bsd-sockets] address Returns a host-ent instance for address, which should be a vector of (integer 0 255) with 4 elements in case of an IPv4 address and 16 elements in case of an IPv6 address, or signals a name-service-error. See gethostbyaddr(3) for details. Generic Function: host-ent-address [sb-bsd-sockets] host-ent Return some valid address for host-ent. Next: Contributed Modules, Previous: Networking, Up: Top   [Contents][Index] 15 Profiling SBCL includes both a deterministic profiler, that can collect statistics on individual functions, and a more “modern” statistical profiler. Inlined functions do not appear in the results reported by either. • Deterministic Profiler:    • Statistical Profiler:    Next: Statistical Profiler, Up: Profiling   [Contents][Index] 15.1 Deterministic Profiler The package sb-profile provides a classic, per-function-call profiler. note: When profiling code executed by multiple threads in parallel, the consing attributed to each function is inaccurate. Macro: profile [sb-profile] &rest names profile Name* If no names are supplied, return the list of profiled functions. If names are supplied, wrap profiling code around the named functions. As in trace, the names are not evaluated. A symbol names a function. A string names all the functions named by symbols in the named package. If a function is already profiled, then unprofile and reprofile (useful to notice function redefinition.) If a name is undefined, then we give a warning and ignore it. See also unprofile, report and reset. Macro: unprofile [sb-profile] &rest names Unwrap any profiling code around the named functions, or if no names are given, unprofile all profiled functions. A symbol names a function. A string names all the functions named by symbols in the named package. names defaults to the list of names of all currently profiled functions. Function: report [sb-profile] &key limit print-no-call-list Report results from profiling. The results are approximately adjusted for profiling overhead. The compensation may be rather inaccurate when bignums are involved in runtime calculation, as in a very-long-running Lisp process. If limit is set to an integer, only the top limit results are reported. If print-no-call-list is t (the default) then a list of uncalled profiled functions are listed. Function: reset [sb-profile] Reset the counters for all profiled functions. Previous: Deterministic Profiler, Up: Profiling   [Contents][Index] 15.2 Statistical Profiler The sb-sprof module, loadable by (require :sb-sprof)  provides an alternate profiler which works by taking samples of the program execution at regular intervals, instead of instrumenting functions like sb-profile:profile does. You might find sb-sprof more useful than the deterministic profiler when profiling functions in the common-lisp-package, SBCL internals, or code where the instrumenting overhead is excessive. Additionally sb-sprof includes a limited deterministic profiler which can be used for reporting the amounts of calls to some functions during 15.2.1 Example Usage (in-package :cl-user)  (require :sb-sprof)  (declaim (optimize speed))  (defun cpu-test-inner (a i)   (logxor a           (* i 5)           (+ a i)))  (defun cpu-test (n)   (let ((a 0))     (dotimes (i (expt 2 n) a)       (setf a (cpu-test-inner a i)))))  ;;;; CPU profiling  ;;; Take up to 1000 samples of running (CPU-TEST 26), and give a flat ;;; table report at the end. Profiling will end one the body has been ;;; evaluated once, whether or not 1000 samples have been taken. (sb-sprof:with-profiling (:max-samples 1000                           :report :flat                           :loop nil)   (cpu-test 26))  ;;; Record call counts for functions defined on symbols in the CL-USER ;;; package. (sb-sprof:profile-call-counts ""CL-USER"")  ;;; Take 1000 samples of running (CPU-TEST 24), and give a flat ;;; table report at the end. The body will be re-evaluated in a loop ;;; until 1000 samples have been taken. A sample count will be printed ;;; after each iteration. (sb-sprof:with-profiling (:max-samples 1000                           :report :flat                           :loop t                           :show-progress t)   (cpu-test 24))  ;;;; Allocation profiling  (defun foo (&rest args)   (mapcar (lambda (x) (float x 1d0)) args))  (defun bar (n)   (declare (fixnum n))   (apply #'foo (loop repeat n collect n)))  (sb-sprof:with-profiling (:max-samples 10000                           :mode :alloc                           :report :flat)   (bar 1000))  15.2.2 Output The flat report format will show a table of all functions that the profiler encountered on the call stack during sampling, ordered by the number of samples taken while executing that function.            Self        Total        Cumul   Nr  Count     %  Count     %  Count     %    Calls  Function ------------------------------------------------------------------------    1     69  24.4     97  34.3     69  24.4 67108864  CPU-TEST-INNER    2     64  22.6     64  22.6    133  47.0        -  SB-VM::GENERIC-+    3     39  13.8    256  90.5    172  60.8        1  CPU-TEST    4     31  11.0     31  11.0    203  71.7        -  SB-KERNEL:TWO-ARG-XOR  For each function, the table will show three absolute and relative sample counts. The Self column shows samples taken while directly executing that function. The Total column shows samples taken while executing that function or functions called from it (sampled to a platform-specific depth). The Cumul column shows the sum of all Self columns up to and including that line in the table. Additionally the Calls column will record the amount of calls that were made to the function during the profiling run. This value will only be reported for functions that have been explicitly marked for call counting with profile-call-counts. The profiler also hooks into the disassembler such that instructions which have been sampled are annotated with their relative frequency of sampling. This information is not stored across different sampling runs. ;      6CF:       702E             JO L4              ; 6/242 samples ;      6D1:       D1E3             SHL EBX, 1 ;      6D3:       702A             JO L4 ;      6D5: L2:   F6C303           TEST BL, 3         ; 2/242 samples ;      6D8:       756D             JNE L8 ;      6DA:       8BC3             MOV EAX, EBX       ; 5/242 samples ;      6DC: L3:   83F900           CMP ECX, 0         ; 4/242 samples  15.2.3 Platform support This module is known not to work consistently on the Alpha platform, for technical reasons related to the implementation of a machine language idiom for marking sections of code to be treated as atomic by the garbage collector; However, it should work on other platforms, and the deficiency on the Alpha will eventually be rectified. Allocation profiling is only supported on SBCL builds that use the generational garbage collector. Tracking of call stacks at a depth of more than two levels is only supported on x86 and x86-64. 15.2.4 Macros Macro: with-profiling [sb-sprof] (&key sample-interval alloc-interval max-samples reset mode loop max-depth show-progress threads report) &body body Evaluate body with statistical profiling turned on. If loop is true, loop around the body until a sufficient number of samples has been collected. Returns the values from the last evaluation of body. In multithreaded operation, only the thread in which with-profiling was evaluated will be profiled by default. If you want to profile multiple threads, invoke the profiler with start-profiling. The following keyword args are recognized: :sample-interval <n> Take a sample every <n> seconds. Default is *sample-interval*. :alloc-interval <n> Take a sample every time <n> allocation regions (approximately 8kB) have been allocated since the last sample. Default is *alloc-interval*. :mode <mode> If :cpu, run the profiler in cpu profiling mode. If :alloc, run the profiler in allocation profiling mode. If :time, run the profiler in wallclock profiling mode. :max-samples <max> Repeat evaluating body until <max> samples are taken. Default is *max-samples*. :max-depth <max> Maximum call stack depth that the profiler should consider. Only has an effect on x86 and x86-64. :report <type> If specified, call report with :type <type> at the end. :reset <bool> It true, call reset at the beginning. :threads <list-form> Form that evaluates to the list threads to profile, or :all to indicate that all threads should be profiled. Defaults to the current thread. (Note: start-profiling defaults to all threads.) :threads has no effect on call-counting at the moment. On some platforms (eg. Darwin) the signals used by the profiler are not properly delivered to threads in proportion to their cpu usage when doing :cpu profiling. If you see empty call graphs, or are obviously missing several samples from certain threads, you may be falling afoul of this. In this case using :mode :time is likely to work better. :loop <bool> If false (the default), evaluate body only once. If true repeatedly evaluate body. Macro: with-sampling [sb-sprof] (&optional on) &body body Evaluate body with statistical sampling turned on or off. 15.2.5 Functions Function: report [sb-sprof] &key type max min-percent call-graph sort-by sort-order stream show-progress Report statistical profiling results. The following keyword args are recognized: :type <type> Specifies the type of report to generate. If :flat, show flat report, if :graph show a call graph and a flat report. If nil, don’t print out a report. :stream <stream> Specify a stream to print the report on. Default is *standard-output*. :max <max> Don’t show more than <max> entries in the flat report. :min-percent <min-percent> Don’t show functions taking less than <min-percent> of the total time in the flat report. :sort-by <column> If :samples, sort flat report by number of samples taken. If :cumulative-samples, sort flat report by cumulative number of samples taken (shows how much time each function spent on stack.) Default is *report-sort-by*. :sort-order <order> If :descending, sort flat report in descending order. If :ascending, sort flat report in ascending order. Default is *report-sort-order*. :show-progress <bool> If true, print progress messages while generating the call graph. :call-graph <graph> Print a report from <graph> instead of the latest profiling results. Value of this function is a call-graph object representing the resulting call-graph, or nil if there are no samples (eg. right after calling reset.) Profiling is stopped before the call graph is generated. Function: reset [sb-sprof] Reset the profiler. Function: start-profiling [sb-sprof] &key max-samples mode sample-interval alloc-interval max-depth threads sampling Start profiling statistically in the current thread if not already profiling. The following keyword args are recognized: :sample-interval <n> Take a sample every <n> seconds. Default is *sample-interval*. :alloc-interval <n> Take a sample every time <n> allocation regions (approximately 8kB) have been allocated since the last sample. Default is *alloc-interval*. :mode <mode> If :cpu, run the profiler in cpu profiling mode. If :alloc, run the profiler in allocation profiling mode. If :time, run the profiler in wallclock profiling mode. :max-samples <max> Maximum number of samples. Default is *max-samples*. :max-depth <max> Maximum call stack depth that the profiler should consider. Only has an effect on x86 and x86-64. :threads <list> List threads to profile, or :all to indicate that all threads should be profiled. Defaults to :all. (Note: with-profiling defaults to the current thread.) :threads has no effect on call-counting at the moment. On some platforms (eg. Darwin) the signals used by the profiler are not properly delivered to threads in proportion to their cpu usage when doing :cpu profiling. If you see empty call graphs, or are obviously missing several samples from certain threads, you may be falling afoul of this. :sampling <bool> If true, the default, start sampling right away. If false, start-sampling can be used to turn sampling on. Function: stop-profiling [sb-sprof] Stop profiling if profiling. Function: profile-call-counts [sb-sprof] &rest names Mark the functions named by names as being subject to call counting during statistical profiling. If a string is used as a name, it will be interpreted as a package name. In this case call counting will be done for all functions with names like x or (setf x), where x is a symbol with the package as its home package. Function: unprofile-call-counts [sb-sprof] Clear all call counting information. Call counting will be done for no functions during statistical profiling. 15.2.6 Variables Variable: *max-samples* [sb-sprof] Default number of traces taken. This variable is somewhat misnamed: each trace may actually consist of an arbitrary number of samples, depending on the depth of the call stack. Variable: *sample-interval* [sb-sprof] Default number of seconds between samples. 15.2.7 Credits sb-sprof is an SBCL port, with enhancements, of Gerd Moellmann’s statistical profiler for CMUCL. Next: Deprecation, Previous: Profiling, Up: Top   [Contents][Index] 16 Contributed Modules SBCL comes with a number of modules that are not part of the core system. These are loaded via (require :modulename) (see Customization Hooks for Users). This section contains documentation (or pointers to documentation) for some of the contributed modules. • sb-aclrepl:    • sb-concurrency:    • sb-cover:    • sb-grovel:    • sb-md5:    • sb-posix:    • sb-queue:    • sb-rotate-byte:    Next: sb-concurrency, Up: Contributed Modules   [Contents][Index] 16.1 sb-aclrepl The sb-aclrepl module offers an Allegro CL-style Read-Eval-Print Loop for SBCL, with integrated inspector. Adding a debugger interface is planned. 16.1.1 Usage To start sb-aclrepl as your read-eval-print loop, put the form (require 'sb-aclrepl)  in your ~/.sbclrc initialization file. 16.1.2 Example Initialization Here’s a longer example of a ~/.sbclrc file that shows off some of the features of sb-aclrepl: (ignore-errors (require 'sb-aclrepl))  (when (find-package 'sb-aclrepl)   (push :aclrepl cl:*features*)) #+aclrepl (progn   (setq sb-aclrepl:*max-history* 100)   (setf (sb-aclrepl:alias ""asdc"")        #'(lambda (sys) (asdf:operate 'asdf:compile-op sys)))   (sb-aclrepl:alias ""l"" (sys) (asdf:operate 'asdf:load-op sys))   (sb-aclrepl:alias ""t"" (sys) (asdf:operate 'asdf:test-op sys))   ;; The 1 below means that two characaters (""up"") are required   (sb-aclrepl:alias (""up"" 1 ""Use package"") (package) (use-package package))   ;; The 0 below means only the first letter (""r"") is required,   ;; such as "":r base64""   (sb-aclrepl:alias (""require"" 0 ""Require module"") (sys) (require sys))   (setq cl:*features* (delete :aclrepl cl:*features*)))  Questions, comments, or bug reports should be sent to Kevin Rosenberg (kevin@rosenberg.net). 16.1.3 Credits Allegro CL is a registered trademark of Franz Inc. Next: sb-cover, Previous: sb-aclrepl, Up: Contributed Modules   [Contents][Index] 16.2 sb-concurrency Additional data structures, synchronization primitives and tools for concurrent programming. Similiar to Java’s java.util.concurrent package. 16.2.1 Queue sb-concurrency:queue is a lock-free, thread-safe FIFO queue datatype. The implementation is based on An Optimistic Approach to Lock-Free FIFO Queues by Edya Ladan-Mozes and Nir Shavit. Before SBCL 1.0.38, this implementation resided in its own contrib (see sb-queue) which is still provided for backwards-compatibility but which has since been deprecated. Structure: queue [sb-concurrency] Class precedence list: queue, structure-object, t Lock-free thread safe fifo queue. Use enqueue to add objects to the queue, and dequeue to remove them. Function: dequeue [sb-concurrency] queue Retrieves the oldest value in queue and returns it as the primary value, and t as secondary value. If the queue is empty, returns nil as both primary and secondary value. Function: enqueue [sb-concurrency] value queue Adds value to the end of queue. Returns value. Function: list-queue-contents [sb-concurrency] queue Returns the contents of queue as a list without removing them from the queue. Mainly useful for manual examination of queue state, as the list may be out of date by the time it is returned, and concurrent dequeue operations may in the worse case force the queue-traversal to be restarted several times. Function: make-queue [sb-concurrency] &key name initial-contents Returns a new queue with name and contents of the initial-contents sequence enqueued. Function: queue-count [sb-concurrency] queue Returns the number of objects in queue. Mainly useful for manual examination of queue state, and in print-object methods: inefficient as it must walk the entire queue. Function: queue-empty-p [sb-concurrency] queue Returns t if queue is empty, nil otherwise. Function: queue-name [sb-concurrency] instance Name of a queue. Can be assigned to using setf. Queue names can be arbitrary printable objects, and need not be unique. Function: queuep [sb-concurrency] object Returns true if argument is a queue, nil otherwise. 16.2.2 Mailbox (lock-free) sb-concurrency:mailbox is a lock-free message queue where one or multiple ends can send messages to one or multiple receivers. The difference to queues is that the receiving end may block until a message arrives. Built on top of the queue implementation. Structure: mailbox [sb-concurrency] Class precedence list: mailbox, structure-object, t Mailbox aka message queue. send-message adds a message to the mailbox, receive-message waits till a message becomes available, whereas receive-message-no-hang is a non-blocking variant, and receive-pending-messages empties the entire mailbox in one go. Messages can be arbitrary objects Function: list-mailbox-messages [sb-concurrency] mailbox Returns a fresh list containing all the messages in the mailbox. Does not remove messages from the mailbox. Function: mailbox-count [sb-concurrency] mailbox Returns the number of messages currently in the mailbox. Function: mailbox-empty-p [sb-concurrency] mailbox Returns true if mailbox is currently empty, nil otherwise. Function: mailbox-name [sb-concurrency] instance Name of a mailbox. SETFable. Function: mailboxp [sb-concurrency] object Returns true if argument is a mailbox, nil otherwise. Function: make-mailbox [sb-concurrency] &key name initial-contents Returns a new mailbox with messages in initial-contents enqueued. Function: receive-message [sb-concurrency] mailbox &key timeout Removes the oldest message from mailbox and returns it as the primary value, and a secondary value of t. If mailbox is empty waits until a message arrives. If timeout is provided, and no message arrives within the specified interval, returns primary and secondary value of nil. Function: receive-message-no-hang [sb-concurrency] mailbox The non-blocking variant of receive-message. Returns two values, the message removed from mailbox, and a flag specifying whether a message could be received. Function: receive-pending-messages [sb-concurrency] mailbox &optional n Removes and returns all (or at most N) currently pending messages from mailbox, or returns nil if no messages are pending. Note: Concurrent threads may be snarfing messages during the run of this function, so even though x,y appear right next to each other in the result, does not necessarily mean that y was the message sent right after x. Function: send-message [sb-concurrency] mailbox message Adds a message to mailbox. Message can be any object. 16.2.3 Gates sb-concurrency:gate is a synchronization object suitable for when multiple threads must wait for a single event before proceeding. Structure: gate [sb-concurrency] Class precedence list: gate, structure-object, t gate type. Gates are synchronization constructs suitable for making multiple threads wait for single event before proceeding. Use wait-on-gate to wait for a gate to open, open-gate to open one, and close-gate to close an open gate. gate-open-p can be used to test the state of a gate without blocking. Function: close-gate [sb-concurrency] gate Closes gate. Returns t if the gate was previously open, and nil if the gate was already closed. Function: gate-name [sb-concurrency] instance Name of a gate. SETFable. Function: gate-open-p [sb-concurrency] gate Returns true if gate is open. Function: gatep [sb-concurrency] object Returns true if the argument is a gate. Function: make-gate [sb-concurrency] &key name open Makes a new gate. Gate will be initially open if open is true, and closed if open is nil (the default.) name, if provided, is the name of the gate, used when printing the gate. Function: open-gate [sb-concurrency] gate Opens gate. Returns t if the gate was previously closed, and nil if the gate was already open. Function: wait-on-gate [sb-concurrency] gate &key timeout Waits for gate to open, or timeout seconds to pass. Returns t if the gate was opened in time, and nil otherwise. 16.2.4 Frlocks, aka Fast Read Locks Structure: frlock [sb-concurrency] Class precedence list: frlock, structure-object, t FRlock, aka Fast Read Lock. Fast Read Locks allow multiple readers and one potential writer to operate in parallel while providing for consistency for readers and mutual exclusion for writers. Readers gain entry to protected regions without waiting, but need to retry if a writer operated inside the region while they were reading. This makes frlocks very efficient when readers are much more common than writers. FRlocks are not suitable when it is not safe at all for readers and writers to operate on the same data in parallel: they provide consistency, not exclusion between readers and writers. Hence using an frlock to eg. protect an sbcl hash-table is unsafe. If multiple readers operating in parallel with a writer would be safe but inconsistent without a lock, frlocks are suitable. The recommended interface to use is frlock-read and frlock-write, but those needing it can also use a lower-level interface. Example:   ;; Values returned by FOO are always consistent so that   ;; the third value is the sum of the two first ones.   (let ((a 0)         (b 0)         (c 0)         (lk (make-frlock)))     (defun foo ()        (frlock-read (lk) a b c))     (defun bar (x y)        (frlock-write (lk)          (setf a x                b y                c (+ x y)))))  Macro: frlock-read [sb-concurrency] (frlock) &body value-forms Evaluates value-forms under frlock till it obtains a consistent set, and returns that as multiple values. Macro: frlock-write [sb-concurrency] (frlock &key wait-p timeout) &body body Executes body while holding frlock for writing. Function: make-frlock [sb-concurrency] &key name Returns a new frlock with name. Function: frlock-name [sb-concurrency] instance Name of an frlock. SETFable. Function: frlock-read-begin [sb-concurrency] frlock Start a read sequence on frlock. Returns a read-token and an epoch to be validated later. Using frlock-read instead is recommended. Function: frlock-read-end [sb-concurrency] frlock Ends a read sequence on frlock. Returns a token and an epoch. If the token and epoch are eql to the read-token and epoch returned by frlock-read-begin, the values read under the frlock are consistent and can be used: if the values differ, the values are inconsistent and the read must be restated. Using frlock-read instead is recommended. Example:   (multiple-value-bind (t0 e0) (frlock-read-begin *fr*)     (let ((a (get-a))           (b (get-b)))       (multiple-value-bind (t1 e1) (frlock-read-end *fr*)         (if (and (eql t0 t1) (eql e0 e1))             (list :a a :b b)             :aborted))))  Function: grab-frlock-write-lock [sb-concurrency] frlock &key wait-p timeout Acquires frlock for writing, invalidating existing and future read-tokens for the duration. Returns t on success, and nil if the lock wasn’t acquired due to eg. a timeout. Using frlock-write instead is recommended. Function: release-frlock-write-lock [sb-concurrency] frlock Releases frlock after writing, allowing valid read-tokens to be acquired again. Signals an error if the current thread doesn’t hold frlock for writing. Using frlock-write instead is recommended. Next: sb-grovel, Previous: sb-concurrency, Up: Contributed Modules   [Contents][Index] 16.3 sb-cover The sb-cover module provides a code coverage tool for SBCL. The tool has support for expression coverage, and for some branch coverage. Coverage reports are only generated for code compiled using compile-file with the value of the sb-cover:store-coverage-data optimization quality set to 3. As of SBCL 1.0.6 sb-cover is still experimental, and the interfaces documented here might change in later versions. 16.3.1 Example Usage ;;; Load SB-COVER (require :sb-cover)  ;;; Turn on generation of code coverage instrumentation in the compiler (declaim (optimize sb-cover:store-coverage-data))  ;;; Load some code, ensuring that it's recompiled with the new optimization ;;; policy. (asdf:oos 'asdf:load-op :cl-ppcre-test :force t)  ;;; Run the test suite. (cl-ppcre-test:test)  ;;; Produce a coverage report (sb-cover:report ""/tmp/report/"")  ;;; Turn off instrumentation (declaim (optimize (sb-cover:store-coverage-data 0)))  16.3.2 Functions Function: report [sb-cover] directory &key form-mode external-format Print a code coverage report of all instrumented files into directory. If directory does not exist, it will be created. The main report will be printed to the file cover-index.html. The external format of the source files can be specified with the external-format parameter. If the keyword argument form-mode has the value :car, the annotations in the coverage report will be placed on the CARs of any cons-forms, while if it has the value :whole the whole form will be annotated (the default). The former mode shows explicitly which forms were instrumented, while the latter mode is generally easier to read. Function: reset-coverage [sb-cover] Reset all coverage data back to the ‘Not executed‘ state. Function: clear-coverage [sb-cover] Clear all files from the coverage database. The files will be re-entered into the database when the fasl files (produced by compiling store-coverage-data optimization policy set to 3) are loaded again into the image. Function: save-coverage [sb-cover] Returns an opaque representation of the current code coverage state. The only operation that may be done on the state is passing it to restore-coverage. The representation is guaranteed to be readably printable. A representation that has been printed and read back will work identically in restore-coverage. Function: save-coverage-in-file [sb-cover] pathname Call save-coverage and write the results of that operation into the file designated by pathname. Function: restore-coverage [sb-cover] coverage-state Restore the code coverage data back to an earlier state produced by save-coverage. Function: restore-coverage-from-file [sb-cover] pathname read the contents of the file designated by pathname and pass the result to restore-coverage. Next: sb-md5, Previous: sb-cover, Up: Contributed Modules   [Contents][Index] 16.4 sb-grovel The sb-grovel module helps in generation of foreign function interfaces. It aids in extracting constants’ values from the C compiler and in generating SB-ALIEN structure and union types, see Defining Foreign Types. The ASDF(http://www.cliki.net/ASDF) component type GROVEL-CONSTANTS-FILE has its PERFORM operation defined to write out a C source file, compile it, and run it. The output from this program is Lisp, which is then itself compiled and loaded. sb-grovel is used in a few contributed modules, and it is currently compatible only to SBCL. However, if you want to use it, here are a few directions. 16.4.1 Using sb-grovel in your own ASDF system Create a Lisp package for the foreign constants/functions to go into. Make your system depend on the ’sb-grovel system. Create a grovel-constants data file - for an example, see example-constants.lisp in the contrib/sb-grovel/ directory in the SBCL source distribution. Add it as a component in your system. e.g. (eval-when (:compile-toplevel :load-toplevel :execute)   (require :sb-grovel))  (defpackage :example-package.system             (:use :cl :asdf :sb-grovel :sb-alien))  (in-package :example-package.system)  (defsystem example-system     :depends-on (sb-grovel)     :components     ((:module ""sbcl""               :components               ((:file ""defpackage"")                (grovel-constants-file ""example-constants""                                       :package :example-package)))))  Make sure to specify the package you chose in step 1 Build stuff. 16.4.2 Contents of a grovel-constants-file The grovel-constants-file, typically named constants.lisp, comprises lisp expressions describing the foreign things that you want to grovel for. A constants.lisp file contains two sections: a list of headers to include in the C program, for example: (""sys/types.h"" ""sys/socket.h"" ""sys/stat.h"" ""unistd.h"" ""sys/un.h""  ""netinet/in.h"" ""netinet/in_systm.h"" ""netinet/ip.h"" ""net/if.h""  ""netdb.h"" ""errno.h"" ""netinet/tcp.h"" ""fcntl.h"" ""signal.h"" )  A list of sb-grovel clauses describing the things you want to grovel from the C compiler, for example: ((:integer af-local            #+(or sunos solaris) ""AF_UNIX""            #-(or sunos solaris) ""AF_LOCAL""            ""Local to host (pipes and file-domain)."")  (:structure stat (""struct stat""                    (integer dev ""dev_t"" ""st_dev"")                    (integer atime ""time_t"" ""st_atime"")))  (:function getpid (""getpid"" int )))  There are two types of things that sb-grovel can sensibly extract from the C compiler: constant integers and structure layouts. It is also possible to define foreign functions in the constants.lisp file, but these definitions don’t use any information from the C program; they expand directly to sb-alien:define-alien-routine (see The define-alien-routine Macro) forms. Here’s how to use the grovel clauses: :integer - constant expressions in C. Used in this form:  (:integer lisp-variable-name ""C expression"" &optional doc export)  ""C expression"" will be typically be the name of a constant. But other forms are possible. :enum  (:enum lisp-type-name ((lisp-enumerated-name c-enumerated-name) ...)))  An sb-alien:enum type with name lisp-type-name will be defined. The symbols are the lisp-enumerated-names, and the values are grovelled from the c-enumerated-names. :structure - alien structure definitions look like this:  (:structure lisp-struct-name (""struct c_structure""                                (type-designator lisp-element-name                                 ""c_element_type"" ""c_element_name""                                 :distrust-length nil)                                ; ...                                ))  type-designator is a reference to a type whose size (and type constraints) will be groveled for. sb-grovel accepts a form of type designator that doesn’t quite conform to either lisp nor sb-alien’s type specifiers. Here’s a list of type designators that sb-grovel currently accepts: integer - a C integral type; sb-grovel will infer the exact type from size information extracted from the C program. All common C integer types can be grovelled for with this type designator, but it is not possible to grovel for bit fields yet. (unsigned n) - an unsigned integer variable that is n bytes long. No size information from the C program will be used. (signed n) - an signed integer variable that is n bytes long. No size information from the C program will be used. c-string - an array of char in the structure. sb-grovel will use the array’s length from the C program, unless you pass it the :distrust-length keyword argument with non-nil value (this might be required for structures such as solaris’s struct dirent). c-string-pointer - a pointer to a C string, corresponding to the sb-alien:c-string type (see Foreign Type Specifiers). (array alien-type) - An array of the previously-declared alien type. The array’s size will be determined from the output of the C program and the alien type’s size. (array alien-type n) - An array of the previously-declared alien type. The array’s size will be assumed as being n. Note that c-string and c-string-pointer do not have the same meaning. If you declare that an element is of type c-string, it will be treated as if the string is a part of the structure, whereas if you declare that the element is of type c-string-pointer, a pointer to a string will be the structure member. :function - alien function definitions are similar to define-alien-routine definitions, because they expand to such forms when the lisp program is loaded. See Foreign Function Calls. (:function lisp-function-name (""alien_function_name"" alien-return-type                                                      (argument alien-type)                                                      (argument2 alien-type)))  16.4.3 Programming with sb-grovel’s structure types Let us assume that you have a grovelled structure definition:  (:structure mystruct (""struct my_structure""                        (integer myint ""int"" ""st_int"")                        (c-string mystring ""char[]"" ""st_str"")))  What can you do with it? Here’s a short interface document: Creating and destroying objects: Function (allocate-mystruct) - allocates an object of type mystructand returns a system area pointer to it. Function (free-mystruct var) - frees the alien object pointed to by var. Macro (with-mystruct var ((member init) [...]) &body body) - allocates an object of type mystruct that is valid in body. If body terminates or control unwinds out of body, the object pointed to by var will be deallocated. Accessing structure members: (mystruct-myint var) and (mystruct-mystring var) return the value of the respective fields in mystruct. (setf (mystruct-myint var) new-val) and (setf (mystruct-mystring var) new-val) sets the value of the respective structure member to the value of new-val. Notice that in (setf (mystruct-mystring var) new-val)’s case, new-val is a lisp string. 16.4.3.1 Traps and Pitfalls Basically, you can treat functions and data structure definitions that sb-grovel spits out as if they were alien routines and types. This has a few implications that might not be immediately obvious (especially if you have programmed in a previous version of sb-grovel that didn’t use alien types): You must take care of grovel-allocated structures yourself. They are alien types, so the garbage collector will not collect them when you drop the last reference. If you use the with-mystruct macro, be sure that no references to the variable thus allocated leaks out. It will be deallocated when the block exits. Next: sb-posix, Previous: sb-grovel, Up: Contributed Modules   [Contents][Index] 16.5 sb-md5 The sb-md5 module implements the RFC1321 MD5 Message Digest Algorithm. [FIXME cite] Function: md5sum-file [sb-md5] pathname Calculate the MD5 message-digest of the file designated by pathname. Function: md5sum-sequence [sb-md5] sequence &key start end Calculate the MD5 message-digest of data bounded by start and end in sequence , which must be a vector with element-type (UNSIGNED-BYTE 8). Function: md5sum-stream [sb-md5] stream Calculate an MD5 message-digest of the contents of stream, whose element-type has to be (unsigned-byte 8). Function: md5sum-string [sb-md5] string &key external-format start end Calculate the MD5 message-digest of the binary representation of string (as octets) in external-format. The boundaries start and end refer to character positions in the string, not to octets in the resulting binary representation. 16.5.1 Credits The implementation for CMUCL was largely done by Pierre Mai, with help from members of the cmucl-help mailing list. Since CMUCL and SBCL are similar in many respects, it was not too difficult to extend the low-level implementation optimizations for CMUCL to SBCL. Following this, SBCL’s compiler was extended to implement efficient compilation of modular arithmetic (see Modular arithmetic), which enabled the implementation to be expressed in portable arithmetical terms, apart from the use of rotate-byte for bitwise rotation. Next: sb-queue, Previous: sb-md5, Up: Contributed Modules   [Contents][Index] 16.6 sb-posix Sb-posix is the supported interface for calling out to the operating system.10 The scope of this interface is “operating system calls on a typical Unixlike platform”. This is section 2 of the Unix manual, plus section 3 calls that are (a) typically found in libc, but (b) not part of the C standard. For example, we intend to provide support for opendir() and readdir(), but not for printf(). That said, if your favourite system call is not included yet, you are encouraged to submit a patch to the SBCL mailing list. Some facilities are omitted where they offer absolutely no additional use over some portable function, or would be actively dangerous to the consistency of Lisp. Not all functions are available on all platforms. • Lisp names for C names:    • Types:    • Function Parameters:    • Function Return Values:    • Lisp objects and C structures:    • Functions with idiosyncratic bindings:    Next: Types, Up: sb-posix   [Contents][Index] 16.6.1 Lisp names for C names All symbols are in the SB-POSIX package. This package contains a Lisp function for each supported Unix system call or function, a variable or constant for each supported Unix constant, an object type for each supported Unix structure type, and a slot name for each supported Unix structure member. A symbol name is derived from the C binding’s name, by (a) uppercasing, then (b) removing leading underscores (#\_) then replacing remaining underscore characters with the hyphen (#\-). The requirement to uppercase is so that in a standard upcasing reader the user may write sb-posix:creat instead of sb-posix:|creat| as would otherise be required. No other changes to “Lispify” symbol names are made, so creat() becomes CREAT, not CREATE. The user is encouraged not to (USE-PACKAGE :SB-POSIX) but instead to use the SB-POSIX: prefix on all references, as some of the symbols symbols contained in the SB-POSIX package have the same name as CL symbols (OPEN, CLOSE, SIGNAL etc). Next: Function Parameters, Previous: Lisp names for C names, Up: sb-posix   [Contents][Index] 16.6.2 Types Generally, marshalling between Lisp and C data types is done using SBCL’s FFI. See Foreign Function Interface. Some functions accept objects such as filenames or file descriptors. In the C binding to POSIX these are represented as strings and small integers respectively. For the Lisp programmer’s convenience we introduce designators such that CL pathnames or open streams can be passed to these functions. For example, rename accepts both pathnames and strings as its arguments. • File-descriptors:    • Filenames:    Next: Filenames, Up: Types   [Contents][Index] 16.6.2.1 File-descriptors Type: file-descriptor [sb-posix] A fixnum designating a native file descriptor. sb-sys:make-fd-stream can be used to construct a file-stream associated with a native file descriptor. Note that mixing I/O operations on a file-stream with operations directly on its descriptor may produce unexpected results if the stream is buffered. Type: file-descriptor-designator [sb-posix] Designator for a file-descriptor: either a fixnum designating itself, or a file-stream designating the underlying file-descriptor. Function: file-descriptor [sb-posix] file-descriptor Converts file-descriptor-designator into a file-descriptor. Previous: File-descriptors, Up: Types   [Contents][Index] 16.6.2.2 Filenames Type: filename [sb-posix] A string designating a filename in native namestring syntax. Note that native namestring syntax is distinct from Lisp namestring syntax:   (pathname ""/foo*/bar"")  is a wild pathname with a pattern-matching directory component. sb-ext:parse-native-namestring may be used to construct Lisp pathnames that denote posix filenames as understood by system calls, and sb-ext:native-namestring can be used to coerce them into strings in the native namestring syntax. Note also that posix filename syntax does not distinguish the names of files from the names of directories: in order to parse the name of a directory in posix filename syntax into a pathname my-defaults for which   (merge-pathnames (make-pathname :name ""FOO"" :case :common)                     my-defaults)  returns a pathname that denotes a file in the directory, supply a true :as-directory argument to sb-ext:parse-native-namestring. Likewise, to supply the name of a directory to a posix function in non-directory syntax, supply a true :as-file argument to sb-ext:native-namestring. Type: filename-designator [sb-posix] Designator for a filename: a string designating itself, or a designator for a pathname designating the corresponding native namestring. Function: filename [sb-posix] filename Converts filename-designator into a filename. Next: Function Return Values, Previous: Types, Up: sb-posix   [Contents][Index] 16.6.3 Function Parameters The calling convention is modelled after that of CMUCL’s UNIX package: in particular, it’s like the C interface except that: Length arguments are omitted or optional where the sensible value is obvious. For example, read would be defined this way: (read fd buffer &optional (length (length buffer))) => bytes-read  Where C simulates “out” parameters using pointers (for instance, in pipe() or socketpair()) these may be optional or omitted in the Lisp interface: if not provided, appropriate objects will be allocated and returned (using multiple return values if necessary). Some functions accept objects such as filenames or file descriptors. Wherever these are specified as such in the C bindings, the Lisp interface accepts designators for them as specified in the ’Types’ section above. A few functions have been included in sb-posix that do not correspond exactly with their C counterparts. These are described in See Functions with idiosyncratic bindings. Next: Lisp objects and C structures, Previous: Function Parameters, Up: sb-posix   [Contents][Index] 16.6.4 Function Return Values The return value is usually the same as for the C binding, except in error cases: where the C function is defined as returning some sentinel value and setting errno on error, we instead signal an error of type SYSCALL-ERROR. The actual error value (errno) is stored in this condition and can be accessed with SYSCALL-ERRNO. We do not automatically translate the returned value into “Lispy” objects – for example, SB-POSIX:OPEN returns a small integer, not a stream. Exception: boolean-returning functions (or, more commonly, macros) do not return a C integer, but instead a Lisp boolean. Next: Functions with idiosyncratic bindings, Previous: Function Return Values, Up: sb-posix   [Contents][Index] 16.6.5 Lisp objects and C structures Sb-posix provides various Lisp object types to stand in for C structures in the POSIX library. Lisp bindings to C functions that accept, manipulate, or return C structures accept, manipulate, or return instances of these Lisp types instead of instances of alien types. The names of the Lisp types are chosen according to the general rules described above. For example Lisp objects of type STAT stand in for C structures of type struct stat. Accessors are provided for each standard field in the structure. These are named structure-name-field-name where the two components are chosen according to the general name conversion rules, with the exception that in cases where all fields in a given structure have a common prefix, that prefix is omitted. For example, stat.st_dev in C becomes STAT-DEV in Lisp. Because sb-posix might not support all semi-standard or implementation-dependent members of all structure types on your system (patches welcome), here is an enumeration of all supported Lisp objects corresponding to supported POSIX structures, and the supported slots for those structures. flock Class: flock [sb-posix] Class precedence list: flock, standard-object, t Slots: type — initarg: :type; reader: sb-posix:flock-type; writer: (setf sb-posix:flock-type) Type of lock; F_RDLCK, F_WRLCK, F_UNLCK. whence — initarg: :whence; reader: sb-posix:flock-whence; writer: (setf sb-posix:flock-whence) Flag for starting offset. start — initarg: :start; reader: sb-posix:flock-start; writer: (setf sb-posix:flock-start) Relative offset in bytes. len — initarg: :len; reader: sb-posix:flock-len; writer: (setf sb-posix:flock-len) Size; if 0 then until eof. pid — reader: sb-posix:flock-pid Process id of the process holding the lock; returned with F_GETLK. Class representing locks used in fcntl(2). passwd Class: passwd [sb-posix] Class precedence list: passwd, standard-object, t Slots: name — initarg: :name; reader: sb-posix:passwd-name; writer: (setf sb-posix:passwd-name) User’s login name. passwd — initarg: :passwd; reader: sb-posix:passwd-passwd; writer: (setf sb-posix:passwd-passwd) The account’s encrypted password. uid — initarg: :uid; reader: sb-posix:passwd-uid; writer: (setf sb-posix:passwd-uid) Numerical user id. gid — initarg: :gid; reader: sb-posix:passwd-gid; writer: (setf sb-posix:passwd-gid) Numerical group id. gecos — initarg: :gecos; reader: sb-posix:passwd-gecos; writer: (setf sb-posix:passwd-gecos) User’s name or comment field. dir — initarg: :dir; reader: sb-posix:passwd-dir; writer: (setf sb-posix:passwd-dir) Initial working directory. shell — initarg: :shell; reader: sb-posix:passwd-shell; writer: (setf sb-posix:passwd-shell) Program to use as shell. Instances of this class represent entries in the system’s user database. stat Class: stat [sb-posix] Class precedence list: stat, standard-object, t Slots: mode — initarg: :mode; reader: sb-posix:stat-mode Mode of file. ino — initarg: :ino; reader: sb-posix:stat-ino File serial number. dev — initarg: :dev; reader: sb-posix:stat-dev Device id of device containing file. nlink — initarg: :nlink; reader: sb-posix:stat-nlink Number of hard links to the file. uid — initarg: :uid; reader: sb-posix:stat-uid User id of file. gid — initarg: :gid; reader: sb-posix:stat-gid Group id of file. size — initarg: :size; reader: sb-posix:stat-size For regular files, the file size in bytes. For symbolic links, the length in bytes of the filename contained in the symbolic link. rdev — initarg: :rdev; reader: sb-posix:stat-rdev For devices the device number. atime — initarg: :atime; reader: sb-posix:stat-atime Time of last access. mtime — initarg: :mtime; reader: sb-posix:stat-mtime Time of last data modification. ctime — initarg: :ctime; reader: sb-posix:stat-ctime Time of last status change. Instances of this class represent posix file metadata. termios Class: termios [sb-posix] Class precedence list: termios, standard-object, t Slots: iflag — initarg: :iflag; reader: sb-posix:termios-iflag; writer: (setf sb-posix:termios-iflag) Input modes. oflag — initarg: :oflag; reader: sb-posix:termios-oflag; writer: (setf sb-posix:termios-oflag) Output modes. cflag — initarg: :cflag; reader: sb-posix:termios-cflag; writer: (setf sb-posix:termios-cflag) Control modes. lflag — initarg: :lflag; reader: sb-posix:termios-lflag; writer: (setf sb-posix:termios-lflag) Local modes. cc — initarg: :cc; reader: sb-posix:termios-cc; writer: (setf sb-posix:termios-cc) Control characters. Instances of this class represent I/O characteristics of the terminal. timeval Class: timeval [sb-posix] Class precedence list: timeval, standard-object, t Slots: sec — initarg: :tv-sec; reader: sb-posix:timeval-sec; writer: (setf sb-posix:timeval-sec) Seconds. usec — initarg: :tv-usec; reader: sb-posix:timeval-usec; writer: (setf sb-posix:timeval-usec) Microseconds. Instances of this class represent time values. Previous: Lisp objects and C structures, Up: sb-posix   [Contents][Index] 16.6.6 Functions with idiosyncratic bindings A few functions in sb-posix don’t correspond directly to their C counterparts. getcwd Function: getcwd [sb-posix] Returns the process’s current working directory as a string. readlink Function: readlink [sb-posix] pathspec Returns the resolved target of a symbolic link as a string. syslog Function: syslog [sb-posix] priority format &rest args Send a message to the syslog facility, with severity level priority. The message will be formatted as by cl:format (rather than C’s printf) with format string format and arguments args. Next: sb-rotate-byte, Previous: sb-posix, Up: Contributed Modules   [Contents][Index] 16.7 sb-queue Since SBCL 1.0.38, the sb-queue module has been merged into the sb-concurrency module (see sb-concurrency.) Previous: sb-queue, Up: Contributed Modules   [Contents][Index] 16.8 sb-rotate-byte The sb-rotate-byte module offers an interface to bitwise rotation, with an efficient implementation for operations which can be performed directly using the platform’s arithmetic routines. It implements the specification at http://www.cliki.net/ROTATE-BYTE. Bitwise rotation is a component of various cryptographic or hashing algorithms: MD5, SHA-1, etc.; often these algorithms are specified on 32-bit rings. [FIXME cite cite cite]. Function: rotate-byte [sb-rotate-byte] count bytespec integer Rotates a field of bits within integer; specifically, returns an integer that contains the bits of integer rotated count times leftwards within the byte specified by bytespec, and elsewhere contains the bits of integer. Next: Concept Index, Previous: Contributed Modules, Up: Top   [Contents][Index] 17 Deprecation In order to support evolution of interfaces in SBCL as well as in user code, SBCL allows declaring functions, variables and types as deprecated. Users of deprecated things are notified by means of warnings while the deprecated thing in question is still available. This chapter documents the interfaces for being notified when using deprecated thing and declaring things as deprecated, the deprecation process used for SBCL interfaces, and lists legacy interfaces in various stages of deprecation. Deprecation in this context should not be confused with those things the ANSI Common Lisp standard calls deprecated: the entirety of ANSI CL is supported by SBCL, and none of those interfaces are subject to censure. • Why Deprecate?:    • The Deprecation Pipeline:    • Deprecation Conditions:    • Introspecting Deprecation Information:    • Deprecation Declaration:    • Deprecation Examples:    • Deprecated Interfaces in SBCL:    Next: The Deprecation Pipeline, Up: Deprecation   [Contents][Index] 17.1 Why Deprecate? While generally speaking we try to keep SBCL changes as backwards compatible as feasible, there are situations when existing interfaces are deprecated: Broken Interfaces Sometimes it turns out that an interface is sufficiently misdesigned that fixing it would be worse than deprecating it and replacing it with another. This is typically the case when fixing the interface would change its semantics in ways that could break user code subtly: in such cases we may end up considering the obvious breakage caused by deprecation to be preferable. Another example are functions or macros whose current signature makes them hard or impossible to extend in the future: backwards compatible extensions would either make the interface intolerably hairy, or are sometimes outright impossible. Internal Interfaces SBCL has several internal interfaces that were never meant to be used in user code – or at least never meant to be used in user code unwilling to track changes to SBCL internals. Ideally we’d like to be free to refactor our own internals as we please, without even going through the hassle of deprecating things. Sometimes, however, it turns out that our internal interfaces have several external users who aren’t using them advisedly, but due to misunderstandings regarding their status or stability. Consider a deprecated internal interface a reminder for SBCL maintainers not to delete the thing just yet, even though it is seems unused – because it has external users. When internal interfaces are deprecated we try our best to provide supported alternatives. Aesthetics & Ease of Maintenance Sometimes an interface isn’t broken or internal, but just inconsistent somehow. This mostly happens only with historical interfaces inherited from CMUCL which often haven’t been officially supported in SBCL before, or with new extensions to SBCL that haven’t been around for very long in the first place. The alternative would be to keep the suboptimal version around forever, possibly alongside an improved version. Sometimes we may do just that, but because every line of code comes with a maintenance cost, sometimes we opt to deprecate the suboptimal version instead: SBCL doesn’t have infinite developer resources. We also believe that sometimes cleaning out legacy interfaces helps keep the whole system more comprehensible to users, and makes introspective tools such as apropos more useful. Next: Deprecation Conditions, Previous: Why Deprecate?, Up: Deprecation   [Contents][Index] 17.2 The Deprecation Pipeline SBCL uses a deprecation pipeline with multiple stages: as time goes by, deprecated things move from earlier stages of deprecation to later stages before finally being removed. The intention is making users aware of necessary changes early but allowing a migration to new interfaces at a reasonable pace. Deprecation proceeds in three stages, each lasting approximately a year. In some cases it might move slower or faster, but one year per stage is what we aim at in general. During each stage warnings (and errors) of increasing severity are signaled, which note that the interface is deprecated, and point users towards any replacements when applicable. Early Deprecation During early deprecation the interface is kept in working condition. However, when a thing in this deprecation stage is used, an early-deprecation-warning [sb-ext], which is a style-warning [cl], is signaled at compile-time. The internals may change at this stage: typically because the interface is re-implemented on top of its successor. While we try to keep things as backwards-compatible as feasible (taking maintenance costs into account), sometimes semantics change slightly. For example, when the spinlock API was deprecated, spinlock objects ceased to exist, and the whole spinlock API became a synonym for the mutex API – so code using the spinlock API continued working, but silently switched to mutexes instead. However, if someone relied on (typep lock 'spinlock) returning NIL for a mutexes, trouble could ensue. Late Deprecation During late deprecation the interface remains as it was during early deprecation, but the compile-time warning is upgraded: when a thing in this deprecation stage is used, a late-deprecation-warning [sb-ext], which is a full warning [cl], is signaled at compile-time. Final Deprecation During final deprecation the symbols still exist. However, when a thing in this deprecation stage is used, a final-deprecation-warning [sb-ext], which is a full warning [cl], is signaled at compile-time and an error [cl] is signaled at run-time. After Final Deprecation The interface is deleted entirely. Next: Introspecting Deprecation Information, Previous: The Deprecation Pipeline, Up: Deprecation   [Contents][Index] 17.3 Deprecation Conditions deprecation-condition [sb-ext] is the superclass of all deprecation-related warning and error conditions. All common slots and readers are defined in this condition class. Condition: deprecation-condition [sb-ext] Class precedence list: deprecation-condition, condition, t Superclass for deprecation-related error and warning conditions. Condition: early-deprecation-warning [sb-ext] Class precedence list: early-deprecation-warning, style-warning, warning, deprecation-condition, condition, t This warning is signaled when the use of a variable, function, type, etc. in :early deprecation is detected at compile-time. The use will work at run-time with no warning or error. Condition: late-deprecation-warning [sb-ext] Class precedence list: late-deprecation-warning, warning, deprecation-condition, condition, t This warning is signaled when the use of a variable, function, type, etc. in :late deprecation is detected at compile-time. The use will work at run-time with no warning or error. Condition: final-deprecation-warning [sb-ext] Class precedence list: final-deprecation-warning, warning, deprecation-condition, condition, t This warning is signaled when the use of a variable, function, type, etc. in :final deprecation is detected at compile-time. An error will be signaled at run-time. Condition: deprecation-error [sb-ext] Class precedence list: deprecation-error, error, serious-condition, deprecation-condition, condition, t This error is signaled at run-time when an attempt is made to use a thing that is in :final deprecation, i.e. call a function or access a variable. Next: Deprecation Declaration, Previous: Deprecation Conditions, Up: Deprecation   [Contents][Index] 17.4 Introspecting Deprecation Information The deprecation status of functions and variables can be inspected using the sb-cltl2:function-information and sb-cltl2:variable-information functions provided by the sb-cltl2 contributed module. Next: Deprecation Examples, Previous: Introspecting Deprecation Information, Up: Deprecation   [Contents][Index] 17.5 Deprecation Declaration The sb-ext:deprecated declaration can be used to declare objects in various namespaces11 as deprecated. Declaration: deprecated [sb-ext] Syntax: sb-ext:deprecated stage since {object-clause}*  stage ::= {:early | :late | :final}  since ::= {version | (software version)}  object-clause ::= (namespace name [:replacement replacement])  namespace ::= {cl:variable | cl:function | cl:type}  were name is the name of the deprecated thing, version and software are strings describing the version in which the thing has been deprecated and replacement is a name or a list of names designating things that should be used instead of the deprecated thing. Currently the following namespaces are supported: cl:function Declare functions, compiler-macros or macros as deprecated. note: When declaring a function to be in :final deprecation, there should be no actual definition of the function as the declaration emits a stub function that signals a deprecation-error [sb-ext] at run-time when called. cl:variable Declare special and global variables, constants and symbol-macros as deprecated. note: When declaring a variable to be in :final deprecation, there should be no actual definition of the variable as the declaration emits a symbol-macro that signals a sb-ext:deprecation-error at run-time when accessed. cl:type Declare named types (i.e. defined via deftype), standard classes, structure classes and condition classes as deprecated. Next: Deprecated Interfaces in SBCL, Previous: Deprecation Declaration, Up: Deprecation   [Contents][Index] 17.6 Deprecation Examples Marking functions as deprecated: (defun foo ()) (defun bar ()) (declaim (deprecated :early (""my-system"" ""1.2.3"")                      (function foo :replacement bar)))  ;; Remember: do not define the actual function or variable in case of ;; :final deprecation: (declaim (deprecated :final (""my-system"" ""1.2.3"")                      (function fez :replacement whoop)))  Attempting to use the deprecated functions: (defun baz ()   (foo)) | STYLE-WARNING: The function CL-USER::FOO has been deprecated... => BAZ (baz) => NIL ; no error  (defun danger ()   (fez)) | WARNING: The function CL-USER::FEZ has been deprecated... => DANGER (danger) |- ERROR: The function CL-USER::FEZ has been deprecated...  Previous: Deprecation Examples, Up: Deprecation   [Contents][Index] 17.7 Deprecated Interfaces in SBCL This sections lists legacy interfaces in various stages of deprecation. 17.7.1 List of Deprecated Interfaces 17.7.1.1 Early Deprecation SOCKINT::WIN32-* Deprecated in favor of the corresponding prefix-less functions (e.g. sockint::bind replaces sockint::win32-bind) as of 1.2.10 in March 2015. Expected to move into late deprecation in August 2015. SB-EXT:QUIT Deprecated in favor of sb-ext:exit as of 1.0.56.55 in May 2012. Expected to move into late deprecation in May 2013. The design of sb-ext:quit proved too broken to fix in a backwards-compatible manner, so it had to be deprecated and replaced. Problems with it were manifold: when called in the main thread it cause the entire process to exit. When called in another thread with :recklessly-p it also caused the entire process to exit. However, when called in another thread without :recklessly-p it instead caused that thread to terminate abnormally without terminating the process. Its behaviour versus other threads than the one it was called in was also underspecified, and dependent on things such as the current session. Any conceivable change that would have made it sane would also have silently broken code that depended on the old behaviour. Remedy For code needing to work with legacy SBCLs, if you were calling quit with :recklessly-p t, use (defun system-exit (&optional (code 0))   (alien-funcall (extern-alien ""exit"" (function void int)) code))  instead. In modern SBCLs simply call either sb-posix:exit or sb-ext:exit. If you were calling it without :recklessly-p, be advised that your code may not function as expected when called from threads other than the main one (see above) – in any case, you can support legacy SBCLs using the following conditionalization: (defun lisp-exit (&key (code 0) abort)   #+#.(cl:if (cl:find-symbol ""EXIT"" :sb-ext) '(and) '(or))   ;; Assuming process exit is what is desired -- if thread termination   ;; is intended, use SB-THREAD:ABORT-THREAD instead.   (sb-ext:exit :code code :abort abort)   #-#.(cl:if (cl:find-symbol ""EXIT"" :sb-ext) '(and) '(or))   (sb-ext:quit :unix-status code :recklessly-p abort))  SB-UNIX:UNIX-EXIT Deprecated as of 1.0.56.55 in May 2012. Expected to move into late deprecation in May 2013. When the SBCL process termination was refactored as part of changes that led to sb-ext:quit being deprecated, sb-unix:unix-exit ceased to be used internally. Since SB-UNIX is an internal package not intended for user code to use, and since we’re slowly in the process of refactoring things to be less Unix-oriented, sb-unix:unix-exit was initially deleted as it was no longer used. Unfortunately it became apparent that it was used by several external users, so it was re-instated in deprecated form. While the cost of keeping sb-unix:unix-exit indefinitely is trivial, the ability to refactor our internals is important, so its deprecation was taken as an opportunity to highlight that SB-UNIX is an internal package and SB-POSIX should be used by user-programs instead – or alternatively calling the foreign function directly if the desired interface doesn’t for some reason exist in SB-POSIX. Remedy For code needing to work with legacy SBCLs, use e.g. system-exit as show above in remedies for sb-ext:quit. In modern SBCLs simply call either sb-posix:exit or sb-ext:exit with appropriate arguments. SB-C::MERGE-TAIL-CALLS Compiler Policy Deprecated as of 1.0.53.74 in November 2011. Expected to move into late deprecation in November 2012. This compiler policy was never functional: SBCL has always merged tail calls when it could, regardless of this policy setting. (It was also never officially supported, but several code-bases have historically used it.) Remedy Simply remove the policy declarations. They were never necessary: SBCL always merged tail-calls when possible. To disable tail merging, structure the code to avoid the tail position instead. Spinlock API Deprecated as of 1.0.53.11 in August 2011. Expected to move into late deprecation in August 2012. Spinlocks were an internal interface, but had a number of external users and were hence deprecated instead of being simply deleted. Affected symbols: sb-thread::spinlock, sb-thread::make-spinlock, sb-thread::with-spinlock, sb-thread::with-recursive-spinlock, sb-thread::get-spinlock, sb-thread::release-spinlock, sb-thread::spinlock-value, and sb-thread::spinlock-name. Remedy Use the mutex API instead, or implement spinlocks suiting your needs on top of sb-ext:compare-and-swap, sb-ext:spin-loop-hint, etc. SOCKINT::HANDLE->FD, SOCKINT::FD->HANDLE Internally deprecated in 2012. Declared deprecated as of 1.2.10 in March 2015. Expected to move into final deprecation in August 2015. 17.7.1.2 Late Deprecation SB-THREAD:JOIN-THREAD-ERROR-THREAD and SB-THREAD:INTERRUPT-THREAD-ERROR-THREAD Deprecated in favor of sb-thread:thread-error-thread as of 1.0.29.17 in June 2009. Expected to move into final deprecation in June 2012. Remedy For code that needs to support legacy SBCLs, use e.g.: (defun get-thread-error-thread (condition)   #+#.(cl:if (cl:find-symbol ""THREAD-ERROR-THREAD"" :sb-thread)              '(and) '(or))   (sb-thread:thread-error-thread condition)   #-#.(cl:if (cl:find-symbol ""THREAD-ERROR-THREAD"" :sb-thread)              '(and) '(or))   (etypecase condition    (sb-thread:join-thread-error     (sb-thread:join-thread-error-thread condition))    (sb-thread:interrupt-thread-error     (sb-thread:interrupt-thread-error-thread condition))))  SB-INTROSPECT:FUNCTION-ARGLIST Deprecated in favor of sb-introspect:function-lambda-list as of 1.0.24.5 in January 2009. Expected to move into final deprecation in January 2012. Renamed for consistency and aesthetics. Functions have lambda-lists, not arglists. Remedy For code that needs to support legacy SBCLs, use e.g.: (defun get-function-lambda-list (function)   #+#.(cl:if (cl:find-symbol ""FUNCTION-LAMBDA-LIST"" :sb-introspect)              '(and) '(or))   (sb-introspect:function-lambda-list function)   #-#.(cl:if (cl:find-symbol ""FUNCTION-LAMBDA-LIST"" :sb-introspect)              '(and) '(or))   (sb-introspect:function-arglist function))  Stack Allocation Policies Deprecated in favor of sb-ext:*stack-allocate-dynamic-extent* as of 1.0.19.7 in August 2008, and are expected to be removed in August 2012. Affected symbols: sb-c::stack-allocate-dynamic-extent, sb-c::stack-allocate-vector, and sb-c::stack-allocate-value-cells. These compiler policies were never officially supported, and turned out the be a flawed design. Remedy For code that needs stack-allocation in legacy SBCLs, conditionalize using: #-#.(cl:if (cl:find-symbol ""*STACK-ALLOCATE-DYNAMIC-EXTENT*"" :sb-ext)            '(and) '(or)) (declare (optimize sb-c::stack-allocate-dynamic-extent))  However, unless stack allocation is essential, we recommend simply removing these declarations. Refer to documentation on sb-ext:*stack-allocate-dynamic* for details on stack allocation control in modern SBCLs. SB-SYS:OUTPUT-RAW-BYTES Deprecated as of 1.0.8.16 in June 2007. Expected to move into final deprecation in June 2012. Internal interface with some external users. Never officially supported, deemed unnecessary in presence of write-sequence and bivalent streams. Remedy Use streams with element-type (unsigned-byte 8) or :default – the latter allowing both binary and character IO – in conjunction with write-sequence. 17.7.1.3 Final Deprecation No interfaces are currently in final deprecation. 17.7.2 Historical Interfaces The following is a partial list of interfaces present in historical versions of SBCL, which have since then been deleted. SB-KERNEL:INSTANCE-LAMBDA Historically needed for CLOS code. Deprecated as of 0.9.3.32 in August 2005. Deleted as of 1.0.47.8 in April 2011. Plain lambda can be used where sb-kernel:instance-lambda used to be needed. SB-ALIEN:DEF-ALIEN-ROUTINE, SB-ALIEN:DEF-ALIEN-VARIABLE, SB-ALIEN:DEF-ALIEN-TYPE Inherited from CMUCL, naming convention not consistent with preferred SBCL style. Deprecated as of 0.pre7.90 in December 2001. Deleted as of 1.0.9.17 in September 2007. Replaced by sb-alien:define-alien-routine, sb-alien:define-alien-variable, and sb-alien:define-alien-type. Next: Function Index, Previous: Deprecation, Up: Top   [Contents][Index] Appendix A Concept Index Jump to:   A   B   C   D   E   F   G   H   I   L   M   O   P   Q   R   S   T   U   V   W   Index Entry   Section A Actual Source:   The Parts of a Compiler Diagnostic Actual Source:   The Original and Actual Source Arithmetic, hardware:   Modular arithmetic Arithmetic, hardware:   sb-rotate-byte Arithmetic, modular:   Modular arithmetic Arithmetic, modular:   sb-rotate-byte Availability of debug variables:   Variable Value Availability B Block compilation, debugger implications:   Entry Point Details Block, basic:   Source Location Availability Block, start location:   Source Location Availability C Cleanup, stack frame kind:   Entry Point Details Code Coverage:   sb-cover Compatibility with other Lisps:   Getting Existing Programs to Run Compile time type errors:   Type Errors at Compile Time Compiler Diagnostic Severity:   Diagnostic Severity Compiler messages:   Diagnostic Messages Concurrency:   sb-concurrency D Debug optimization quality:   Variable Value Availability Debug optimization quality:   Source Location Availability Debug optimization quality:   Debugger Policy Control Debug variables:   Variable Access Debugger:   Debugger debugger, disabling:   Enabling and Disabling the Debugger debugger, enabling:   Enabling and Disabling the Debugger declaration, dynamic-extent:   Dynamic-extent allocation Declarations:   Package Lock Violations Deprecation Conditions:   Deprecation Conditions Deprecation Declaration:   Deprecation Declaration Deprecation Examples:   Deprecation Examples disabling debugger:   Enabling and Disabling the Debugger disabling ldb:   Runtime Options disabling ldb:   Enabling and Disabling the Debugger dynamic-extent declaration:   Dynamic-extent allocation E Efficiency:   Efficiency Entry points, external:   Entry Point Details Errors, run-time:   Unknown Locations and Interrupts Existing programs, to run:   Getting Existing Programs to Run External entry points:   Entry Point Details External formats:   Foreign Type Specifiers External formats:   External Formats External, stack frame kind:   Entry Point Details F Fast Read Lock:   sb-concurrency Finalization:   Garbage Collection Foreign Function Interface, generation:   sb-grovel Frlock:   sb-concurrency Function, tracing:   Function Tracing G Garbage collection:   Garbage Collection Garbage Collection, conservative:   History and Implementation of SBCL Garbage Collection, generational:   History and Implementation of SBCL Gate:   sb-concurrency H Hash tables:   Hash Table Extensions Hashing, cryptographic:   sb-md5 I Inline expansion:   Open Coding and Inline Expansion Inline expansion:   Debugger Policy Control Interpreter:   Interpreter Interrupts:   Unknown Locations and Interrupts Introspecting Deprecation Information:   Introspecting Deprecation Information L ldb:   Reporting Bugs ldb:   Runtime Options ldb:   Runtime Options ldb, disabling:   Runtime Options ldb, disabling:   Enabling and Disabling the Debugger ldb, enabling:   Enabling and Disabling the Debugger Locations, unknown:   Unknown Locations and Interrupts Logical pathnames:   Lisp Pathnames M Macroexpansion:   The Processing Path Macroexpansion, errors during:   Errors During Macroexpansion Mailbox, lock-free:   sb-concurrency Messages, Compiler:   Diagnostic Messages Modular arithmetic:   Modular arithmetic Modular arithmetic:   sb-rotate-byte O Open-coding:   Open Coding and Inline Expansion Operating System Interface:   sb-posix optimization quality, safety:   Dynamic-extent allocation Optimize declaration:   Debugger Policy Control Optional, stack frame kind:   Entry Point Details Original Source:   The Parts of a Compiler Diagnostic Original Source:   The Original and Actual Source P Package-Local Nicknames:   Package-Local Nicknames Packages, locked:   Package Locks Pathnames:   Pathnames Pathnames, logical:   Lisp Pathnames Policy, debugger:   Debugger Policy Control Posix:   sb-posix Precise type checking:   Precise Type Checking Processing Path:   The Parts of a Compiler Diagnostic Processing Path:   The Processing Path Profiling:   Profiling Profiling, deterministic:   Deterministic Profiler Profiling, statistical:   Statistical Profiler Q Queue, FIFO:   sb-queue Queue, lock-free:   sb-concurrency R Random Number Generation:   Random Number Generation Read errors, compiler:   Read Errors Read-Eval-Print Loop:   sb-aclrepl Reader Extensions:   Reader Extensions Recursion, tail:   Debug Tail Recursion REPL:   sb-aclrepl S Safety optimization quality:   Declarations as Assertions Safety optimization quality:   Dynamic-extent allocation safety optimization quality:   Dynamic-extent allocation Sb-concurrency:   sb-concurrency Semi-inline expansion:   Debugger Policy Control Severity of compiler messages:   Diagnostic Severity Single Stepping:   Single Stepping Slot access:   Slot access Sockets, Networking:   Networking Source location printing, debugger:   Source Location Printing Source-to-source transformation:   The Processing Path Stack frames:   Stack Frames Static functions:   Open Coding and Inline Expansion Stepper:   Single Stepping System Calls:   sb-posix T Tail recursion:   Debug Tail Recursion The Deprecation Pipeline:   The Deprecation Pipeline Tracing:   Function Tracing Type checking, at compile time:   Type Errors at Compile Time Type checking, precise:   Precise Type Checking Types, portability:   Getting Existing Programs to Run U Unknown code locations:   Unknown Locations and Interrupts V Validity of debug variables:   Variable Value Availability Variables, debugger access:   Variable Access W Weak pointers:   Garbage Collection Why Deprecate?:   Why Deprecate? Jump to:   A   B   C   D   E   F   G   H   I   L   M   O   P   Q   R   S   T   U   V   W   Next: Variable Index, Previous: Concept Index, Up: Top   [Contents][Index] Appendix B Function Index Jump to:   (   ?   A   B   C   D   E   F   G   H   I   J   L   M   N   O   P   Q   R   S   T   U   V   W   Index Entry   Section ( (setf:   Extensible Sequences (setf:   Simple Iterator Protocol (setf logical-pathname-translations [cl]):   Lisp Pathnames (setf slot-value-using-class [sb-mop]):   Metaobject Protocol ? ?:   Information Commands A abort:   Exiting Commands abort-thread:   Threading basics add-implementation-package:   Package Lock Dictionary add-package-local-nickname:   Package-Local Nicknames addr:   Coercing Foreign Values adjust-sequence:   Extensible Sequences adjust-sequence [sb-sequence]:   Extensible Sequences age:   Unicode Support alien-funcall:   The alien-funcall Primitive alien-sap:   Coercing Foreign Values alphabetic-p:   Unicode Support always-bound:   Global and Always-Bound variables array-storage-vector:   Miscellaneous Extensions assert-version->=:   Miscellaneous Extensions atomic-decf:   Atomic Operations atomic-incf:   Atomic Operations atomic-pop:   Atomic Operations atomic-push:   Atomic Operations atomic-update:   Atomic Operations B backtrace:   Information Commands barrier:   Barriers bidi-class:   Unicode Support bidi-mirroring-glyph:   Unicode Support both-case-p [cl]:   Unicode Support bottom:   Stack Motion bytes-consed-between-gcs:   Garbage Collection C cancel-finalization:   Garbage Collection cas:   Atomic Operations case-ignorable-p:   Unicode Support cased-p:   Unicode Support casefold:   Unicode Support cast:   Coercing Foreign Values char-block:   Unicode Support char-downcase [cl]:   Unicode Support class-name [cl]:   Metaobject Protocol class-of [cl]:   Metaobject Protocol class-prototype [sb-mop]:   Metaobject Protocol clear-coverage:   sb-cover clear-semaphore-notification:   Semaphores close:   Methods common to all streams close-gate:   sb-concurrency coerce [cl]:   Extensible Sequences combining-class:   Unicode Support compare-and-swap:   Atomic Operations compute-effective-method [sb-mop]:   Metaobject Protocol concatenate:   Extensible Sequences condition-broadcast:   Waitqueue/condition variables condition-notify:   Waitqueue/condition variables condition-wait:   Waitqueue/condition variables confusable-p:   Unicode Support cons [cl]:   Dynamic-extent allocation continue:   Exiting Commands copy function:   Iterator Protocol copy-seq [cl]:   Extensible Sequences D decimal-value:   Unicode Support declare [cl]:   Package Lock Violations default-ignorable-p:   Unicode Support defcas:   Atomic Operations defclass [cl]:   Metaobject Protocol defclass [cl]:   Metaobject Protocol defconstant [cl]:   Defining Constants defglobal:   Global and Always-Bound variables define-alien-routine:   The define-alien-routine Macro define-alien-variable:   External Foreign Variables define-cas-expander:   Atomic Operations define-hash-table-test:   Hash Table Extensions defmethod [cl]:   Metaobject Protocol defpackage:   Package-Local Nicknames defpackage:   Package Lock Dictionary defpackage [cl]:   Package-Local Nicknames defpackage [cl]:   Implementation Packages defstruct [cl]:   Metaobject Protocol delete-directory:   Miscellaneous Extensions deprecated:   Deprecation Declaration deprecated [sb-ext]:   Deprecation Declaration dequeue:   sb-concurrency deref:   Accessing Foreign Values describe:   Information Commands describe-compiler-policy:   Compiler Policy digit-value:   Unicode Support disable-debugger:   Enabling and Disabling the Debugger disable-package-locks:   Package Lock Dictionary disable-package-locks [sb-ext]:   Package Lock Violations dolist [cl]:   Extensible Sequences dosequence:   Extensible Sequences down:   Stack Motion dynamic-space-size:   Garbage Collection E east-asian-width:   Unicode Support ed:   Customization Hooks for Users element function:   Iterator Protocol elt:   Extensible Sequences emptyp:   Extensible Sequences enable-debugger:   Enabling and Disabling the Debugger enable-package-locks:   Package Lock Dictionary enable-package-locks [sb-ext]:   Package Lock Violations endp function:   Iterator Protocol enqueue:   sb-concurrency ensure-class [sb-mop]:   Metaobject Protocol ensure-class-using-class [sb-mop]:   Metaobject Protocol ensure-generic-function [cl]:   Metaobject Protocol error:   Information Commands eval [cl]:   Interpreter exit:   Exit extern-alien:   External Foreign Variables F file-descriptor:   File-descriptors filename:   Filenames finalize:   Garbage Collection finalize-inheritance [sb-mop]:   Metaobject Protocol find [cl]:   Extensible Sequences find-class [cl]:   Metaobject Protocol find-class [cl]:   Metaobject Protocol find-method [cl]:   Metaobject Protocol flet [cl]:   Dynamic-extent allocation flet [cl]:   Package Lock Violations frame:   Stack Motion free-alien:   Foreign Dynamic Allocation frlock-name:   sb-concurrency frlock-read:   sb-concurrency frlock-read-begin:   sb-concurrency frlock-read-end:   sb-concurrency frlock-write:   sb-concurrency funcallable-standard-instance-access [sb-mop]:   Metaobject Protocol G gate-name:   sb-concurrency gate-open-p:   sb-concurrency gatep:   sb-concurrency gc:   Garbage Collection gc-logfile:   Garbage Collection general-category:   Unicode Support generation-average-age:   Garbage Collection generation-bytes-allocated:   Garbage Collection generation-bytes-consed-between-gcs:   Garbage Collection generation-minimum-age-before-gc:   Garbage Collection generation-number-of-gcs:   Garbage Collection generation-number-of-gcs-before-promotion:   Garbage Collection generic-function-declarations [sb-mop]:   Metaobject Protocol get-bytes-consed:   Garbage Collection get-cas-expansion:   Atomic Operations get-errno:   External Foreign Variables get-host-by-address:   Name Service get-host-by-name:   Name Service get-protocol-by-name:   INET Domain Sockets get-time-of-day:   Miscellaneous Extensions getcwd:   Functions with idiosyncratic bindings global:   Global and Always-Bound variables grab-frlock-write-lock:   sb-concurrency grab-mutex:   Mutex Support grapheme-break-class:   Unicode Support graphemes:   Unicode Support H hangul-syllable-type:   Unicode Support hash-table-synchronized-p:   Hash Table Extensions hash-table-weakness:   Hash Table Extensions help:   Information Commands hex-digit-p:   Unicode Support host-ent-address:   Name Service I ideographic-p:   Unicode Support index function:   Iterator Protocol inspect [cl]:   Tools To Help Developers int-sap:   Accessing Foreign Values intern [cl]:   Reader Extensions intern-eql-specializer [sb-mop]:   Metaobject Protocol interrupt-thread:   Threading basics iterator-copy:   Simple Iterator Protocol iterator-element:   Simple Iterator Protocol iterator-endp:   Simple Iterator Protocol iterator-index:   Simple Iterator Protocol iterator-step:   Simple Iterator Protocol J join-thread:   Threading basics L labels [cl]:   Dynamic-extent allocation labels [cl]:   Package Lock Violations length:   Extensible Sequences let [cl]:   Miscellaneous Efficiency Issues let [cl]:   Package Lock Violations let* [cl]:   Miscellaneous Efficiency Issues let* [cl]:   Package Lock Violations line-break-class:   Unicode Support lines:   Unicode Support list [cl]:   Dynamic-extent allocation list* [cl]:   Dynamic-extent allocation list-all-threads:   Threading basics list-all-timers:   Timers list-locals:   Variable Access list-mailbox-messages:   sb-concurrency list-queue-contents:   sb-concurrency load-shared-object:   Loading Shared Object Files lock-package:   Package Lock Dictionary logand [cl]:   Modular arithmetic logical-pathname-translations [cl]:   Lisp Pathnames lowercase:   Unicode Support lowercase-p:   Unicode Support M macrolet [cl]:   Package Lock Violations mailbox-count:   sb-concurrency mailbox-empty-p:   sb-concurrency mailbox-name:   sb-concurrency mailboxp:   sb-concurrency main-thread:   Threading basics main-thread-p:   Threading basics make-alien:   Foreign Dynamic Allocation make-alien-string:   Foreign Dynamic Allocation make-array [cl]:   Dynamic-extent allocation make-frlock:   sb-concurrency make-gate:   sb-concurrency make-hash-table:   Hash Table Extensions make-inet-address:   INET Domain Sockets make-inet6-address:   INET Domain Sockets make-instance [cl]:   Extensible Sequences make-mailbox:   sb-concurrency make-method-lambda [sb-mop]:   Metaobject Protocol make-method-specializers-form [sb-pcl]:   Metaobject Protocol make-mutex:   Mutex Support make-queue:   sb-concurrency make-semaphore:   Semaphores make-semaphore-notification:   Semaphores make-sequence-iterator:   Iterator Protocol make-sequence-iterator [sb-sequence]:   Iterator Protocol make-sequence-iterator [sb-sequence]:   Iterator Protocol make-sequence-like:   Extensible Sequences make-sequence-like [sb-sequence]:   Extensible Sequences make-simple-sequence-iterator:   Simple Iterator Protocol make-simple-sequence-iterator [sb-sequence]:   Iterator Protocol make-thread:   Threading basics make-timer:   Timers make-waitqueue:   Waitqueue/condition variables make-weak-pointer:   Garbage Collection map:   Extensible Sequences math-p:   Unicode Support md5sum-file:   sb-md5 md5sum-sequence:   sb-md5 md5sum-stream:   sb-md5 md5sum-string:   sb-md5 merge:   Extensible Sequences mirrored-p:   Unicode Support muffle-conditions:   Controlling Verbosity mutex-name:   Mutex Support mutex-owner:   Mutex Support mutex-value:   Mutex Support N name-conflict-symbols [sb-ext]:   Resolution of Name Conflicts native-namestring:   Native Filenames native-pathname:   Native Filenames next:   Single Stepping non-blocking-mode:   General Sockets normalize-string:   Unicode Support normalized-p:   Unicode Support numeric-value:   Unicode Support O open [cl]:   External Formats open-gate:   sb-concurrency out:   Single Stepping P package-implemented-by-list:   Package Lock Dictionary package-implements-list:   Package Lock Dictionary package-local-nicknames:   Package-Local Nicknames package-locally-nicknamed-by-list:   Package-Local Nicknames package-locked-error-symbol:   Package Lock Dictionary package-locked-p:   Package Lock Dictionary parse-native-namestring:   Native Filenames parse-specializer-using-class [sb-pcl]:   Metaobject Protocol posix-getenv:   Querying the process environment print:   Information Commands process-alive-p:   Running external programs process-close:   Running external programs process-core-dumped:   Running external programs process-error:   Running external programs process-exit-code:   Running external programs process-input:   Running external programs process-kill:   Running external programs process-output:   Running external programs process-p:   Running external programs process-status:   Running external programs process-wait:   Running external programs profile:   Deterministic Profiler profile-call-counts:   Statistical Profiler proplist-p:   Unicode Support purify:   Efficiency Hacks Q queue-count:   sb-concurrency queue-empty-p:   sb-concurrency queue-name:   sb-concurrency queuep:   sb-concurrency R readlink:   Functions with idiosyncratic bindings readtable-normalization:   Reader Extensions receive-message:   sb-concurrency receive-message-no-hang:   sb-concurrency receive-pending-messages:   sb-concurrency release-frlock-write-lock:   sb-concurrency release-mutex:   Mutex Support remove-implementation-package:   Package Lock Dictionary remove-package-local-nickname:   Package-Local Nicknames report:   Deterministic Profiler report:   Statistical Profiler report:   sb-cover require:   Customization Hooks for Users reset:   Deterministic Profiler reset:   Statistical Profiler reset-coverage:   sb-cover restart:   Exiting Commands restart-frame:   Exiting Commands restore-coverage:   sb-cover restore-coverage-from-file:   sb-cover restrict-compiler-policy:   Compiler Policy return:   Exiting Commands return-from-thread:   Threading basics rotate-byte:   sb-rotate-byte rotate-byte [sb-rotate-byte]:   sb-md5 run-program:   Running external programs S sap-alien:   Coercing Foreign Values sap-ref-32:   Accessing Foreign Values sap=:   Accessing Foreign Values satisfies [cl]:   Handling of Types save-coverage:   sb-cover save-coverage-in-file:   sb-cover save-lisp-and-die:   Saving a Core Image schedule-timer:   Timers script:   Unicode Support seed-random-state:   Random Number Generation semaphore-count:   Semaphores semaphore-name:   Semaphores semaphore-notification-status:   Semaphores send-message:   sb-concurrency sentence-break-class:   Unicode Support sentences:   Unicode Support set-sbcl-source-location:   Lisp Pathnames setf element function:   Iterator Protocol setf [cl]:   Miscellaneous Efficiency Issues setq [cl]:   Miscellaneous Efficiency Issues signal-semaphore:   Semaphores slot:   Accessing Foreign Values slot-boundp-using-class [sb-mop]:   Metaobject Protocol slot-definition-name [sb-mop]:   Metaobject Protocol slot-value-using-class [sb-mop]:   Metaobject Protocol socket-accept:   General Sockets socket-bind:   General Sockets socket-close:   General Sockets socket-connect:   General Sockets socket-error:   General Sockets socket-listen:   General Sockets socket-make-stream:   General Sockets socket-make-stream:   General Sockets socket-name:   General Sockets socket-open-p:   General Sockets socket-peername:   General Sockets socket-receive:   General Sockets socket-send:   General Sockets socket-shutdown:   General Sockets sockopt-broadcast:   Socket Options sockopt-bsd-compatible:   Socket Options sockopt-debug:   Socket Options sockopt-dont-route:   Socket Options sockopt-keep-alive:   Socket Options sockopt-oob-inline:   Socket Options sockopt-pass-credentials:   Socket Options sockopt-reuse-address:   Socket Options sockopt-tcp-nodelay:   Socket Options soft-dotted-p:   Unicode Support source:   Source Location Printing standard-instance-access [sb-mop]:   Metaobject Protocol start:   Single Stepping start-profiling:   Statistical Profiler step:   Single Stepping step:   Single Stepping step function:   Iterator Protocol stop:   Single Stepping stop-profiling:   Statistical Profiler stream-advance-to-column:   Character output stream methods stream-clear-input:   Input stream methods stream-clear-output:   Output stream methods stream-element-type:   Methods common to all streams stream-external-format [cl]:   External Formats stream-file-position:   Methods common to all streams stream-finish-output:   Output stream methods stream-force-output:   Output stream methods stream-fresh-line:   Character output stream methods stream-line-column:   Character output stream methods stream-line-length:   Character output stream methods stream-listen:   Character input stream methods stream-peek-char:   Character input stream methods stream-read-byte:   Binary stream methods stream-read-char:   Character input stream methods stream-read-char-no-hang:   Character input stream methods stream-read-line:   Character input stream methods stream-read-sequence:   Input stream methods stream-start-line-p:   Character output stream methods stream-terpri:   Character output stream methods stream-unread-char:   Character input stream methods stream-write-byte:   Binary stream methods stream-write-char:   Character output stream methods stream-write-sequence:   Output stream methods stream-write-string:   Character output stream methods string-upcase [cl]:   Unicode Support subseq [cl]:   Extensible Sequences subseq [cl]:   Extensible Sequences subseq [cl]:   Extensible Sequences subtypep [cl]:   Metaobject Protocol symbol-macrolet [cl]:   Package Lock Violations symbol-value-in-thread:   Threading basics syslog:   Functions with idiosyncratic bindings T terminate-thread:   Threading basics thread-alive-p:   Threading basics thread-error-thread:   Threading basics thread-name:   Threading basics thread-yield:   Threading basics timer-name:   Timers timer-scheduled-p:   Timers titlecase:   Unicode Support top:   Stack Motion toplevel:   Exiting Commands trace:   Function Tracing trace [cl]:   Tools To Help Developers truly-the:   Efficiency Hacks try-semaphore:   Semaphores typep [cl]:   Metaobject Protocol U unicode-1-name:   Unicode Support unicode-equal:   Unicode Support unicode<:   Unicode Support unicode<=:   Unicode Support unicode=:   Unicode Support unicode>:   Unicode Support unicode>=:   Unicode Support unload-shared-object:   Loading Shared Object Files unlock-package:   Package Lock Dictionary unmuffle-conditions:   Controlling Verbosity unparse-specializer-using-class [sb-pcl]:   Metaobject Protocol unprofile:   Deterministic Profiler unprofile-call-counts:   Statistical Profiler unschedule-timer:   Timers untrace:   Function Tracing up:   Stack Motion uppercase:   Unicode Support uppercase-p:   Unicode Support V validate-superclass [sb-mop]:   Metaobject Protocol validate-superclass [sb-mop]:   Metaobject Protocol var:   Variable Access vector [cl]:   Dynamic-extent allocation W wait-for:   Miscellaneous Extensions wait-on-gate:   sb-concurrency wait-on-semaphore:   Semaphores waitqueue-name:   Waitqueue/condition variables weak-pointer-value:   Garbage Collection whitespace-p:   Unicode Support with-alien:   Local Foreign Variables with-compilation-unit:   Compiler Policy with-compilation-unit [cl]:   The Parts of a Compiler Diagnostic with-locked-hash-table:   Hash Table Extensions with-mutex:   Mutex Support with-open-file [cl]:   External Formats with-profiling:   Statistical Profiler with-recursive-lock:   Mutex Support with-sampling:   Statistical Profiler with-sequence-iterator:   Iterator Protocol with-sequence-iterator-functions:   Iterator Protocol with-unlocked-packages:   Package Lock Dictionary without-package-locks:   Package Lock Dictionary word-break-class:   Unicode Support words:   Unicode Support Jump to:   (   ?   A   B   C   D   E   F   G   H   I   J   L   M   N   O   P   Q   R   S   T   U   V   W   Next: Type Index, Previous: Function Index, Up: Top   [Contents][Index] Appendix C Variable Index Jump to:   *   + Index Entry   Section * *after-gc-hooks*:   Garbage Collection *compiler-print-variable-alist*:   Controlling Verbosity *core-pathname*:   Saving a Core Image *current-thread*:   Threading basics *debug-print-variable-alist*:   Debugger Command Loop *ed-functions*:   Customization Hooks for Users *evaluator-mode*:   Interpreter *evaluator-mode* [sb-ext]:   Interpreter *exit-hooks*:   Initialization and Exit Hooks *gc-run-time*:   Garbage Collection *init-hooks*:   Initialization and Exit Hooks *invoke-debugger-hook*:   Debugger Invocation *max-samples*:   Statistical Profiler *max-trace-indentation*:   Function Tracing *module-provider-functions*:   Customization Hooks for Users *muffled-warnings*:   Customization Hooks for Users *on-package-variance*:   Package Variance *package* [cl]:   Implementation Packages *posix-argv* [sb-ext]:   Shebang Scripts *posix-argv* [sb-ext]:   Command-line arguments *sample-interval*:   Statistical Profiler *save-hooks*:   Saving a Core Image *stack-allocate-dynamic-extent*:   Dynamic-extent allocation *sysinit-pathname-function*:   Saving a Core Image *trace-encapsulate-default*:   Function Tracing *trace-indentation-step*:   Function Tracing *userinit-pathname-function*:   Saving a Core Image + +slot-unbound+ [sb-pcl]:   Metaobject Protocol Jump to:   *   + Next: Colophon, Previous: Variable Index, Up: Top   [Contents][Index] Appendix D Type Index Jump to:   B   C   D   E   F   G   H   I   J   L   M   N   P   Q   S   T   V   W   Index Entry   Section B built-in-class [cl]:   Metaobject Protocol C code-deletion-note:   Diagnostic Severity code-deletion-note [sb-ext]:   Diagnostic Severity compiler-note:   Diagnostic Severity compiler-note [sb-ext]:   Diagnostic Severity D deprecation-condition:   Deprecation Conditions deprecation-error:   Deprecation Conditions E early-deprecation-warning:   Deprecation Conditions error [cl]:   Diagnostic Severity F file-descriptor:   File-descriptors file-descriptor-designator:   File-descriptors filename:   Filenames filename-designator:   Filenames final-deprecation-warning:   Deprecation Conditions flock:   Lisp objects and C structures frlock:   sb-concurrency funcallable-standard-class [sb-mop]:   Metaobject Protocol funcallable-standard-object [sb-mop]:   Metaobject Protocol funcallable-standard-object [sb-mop]:   Metaobject Protocol function [cl]:   Metaobject Protocol function [cl]:   Metaobject Protocol fundamental-binary-input-stream:   Gray Streams classes fundamental-binary-output-stream:   Gray Streams classes fundamental-binary-stream:   Gray Streams classes fundamental-character-input-stream:   Gray Streams classes fundamental-character-output-stream:   Gray Streams classes fundamental-character-stream:   Gray Streams classes fundamental-input-stream:   Gray Streams classes fundamental-output-stream:   Gray Streams classes fundamental-stream:   Gray Streams classes G gate:   sb-concurrency generic-function [cl]:   Metaobject Protocol H host-ent:   Name Service I inet-socket:   INET Domain Sockets inet6-socket:   INET Domain Sockets interrupt-thread-error:   Threading basics J join-thread-error:   Threading basics L late-deprecation-warning:   Deprecation Conditions list [cl]:   Extensible Sequences local-socket:   Local (Unix) Domain Sockets M mailbox:   sb-concurrency mutex:   Mutex Support N name-conflict [sb-ext]:   Resolution of Name Conflicts P package-error [cl]:   Package Lock Violations package-lock-violation:   Package Lock Dictionary package-lock-violation [sb-ext]:   Package Lock Violations package-locked-error:   Package Lock Dictionary package-locked-error [sb-ext]:   Package Lock Violations passwd:   Lisp objects and C structures protocol-unimplemented:   Extensible Sequences Q queue:   sb-concurrency S semaphore:   Semaphores semaphore-notification:   Semaphores sequence [cl]:   Extensible Sequences sequence [cl]:   Extensible Sequences sequence [cl]:   Extensible Sequences sequence [cl]:   Iterator Protocol socket:   General Sockets standard-class [cl]:   Metaobject Protocol standard-generic-function [cl]:   Metaobject Protocol standard-object [cl]:   Metaobject Protocol standard-object [cl]:   Extensible Sequences stat:   Lisp objects and C structures structure-class [cl]:   Metaobject Protocol style-warning [cl]:   Diagnostic Severity symbol-package-locked-error:   Package Lock Dictionary symbol-package-locked-error [sb-ext]:   Package Lock Violations T t [cl]:   Metaobject Protocol termios:   Lisp objects and C structures thread:   Threading basics thread-error:   Threading basics timer:   Timers timeval:   Lisp objects and C structures V vector [cl]:   Extensible Sequences W waitqueue:   Waitqueue/condition variables warning [cl]:   Diagnostic Severity Jump to:   B   C   D   E   F   G   H   I   J   L   M   N   P   Q   S   T   V   W   Previous: Type Index, Up: Top   [Contents][Index] Colophon This manual is maintained in Texinfo, and automatically translated into other forms (e.g. HTML or pdf). If you’re reading this manual in one of these non-Texinfo translated forms, that’s fine, but if you want to modify this manual, you are strongly advised to seek out a Texinfo version and modify that instead of modifying a translated version. Even better might be to seek out the Texinfo version (maintained at the time of this writing as part of the SBCL project at http://sbcl.sourceforge.net/) and submit a patch. Footnotes (1) Historically, the ILISP package at http://ilisp.cons.org/ provided similar functionality, but it does not support modern SBCL versions. (2) Actually, this declaration is unnecessary in SBCL, since it already knows that position returns a non-negative fixnum or nil. (3) A deprecated extension sb-ext:inhibit-warnings is still supported, but liable to go away at any time. (4) Since the location of an interrupt or hardware error will always be an unknown location, non-argument variable values will never be available in the interrupted frame. See Unknown Locations and Interrupts. (5) The variable bindings are actually created using the Lisp symbol-macrolet special form. (6) A motivation, rationale and additional examples for the design of this extension can be found in the paper Rhodes, Christophe (2007): User-extensible sequences in Common Lisp available for download at http://www.doc.gold.ac.uk/~mas01cr/papers/ilc2007/sequences-20070301.pdf. (7) In SBCL versions prior to 1.0.13, sb-ext:run-program searched for executables in a manner somewhat incompatible with other languages. As of this version, SBCL uses the system library routine execvp(3), and no longer contains the function, find-executable-in-search-path, which implemented the old search. Users who need this function may find it in run-program.lisp versions 1.67 and earlier in SBCL’s CVS repository here http://sbcl.cvs.sourceforge.net/sbcl/sbcl/src/code/run-program.lisp?view=log. However, we caution such users that this search routine finds executables that system library routines do not. (8) Please note that the codepoint U+1F5CF (PAGE) introduced in Unicode 7.0 is named UNICODE_PAGE, since the name “Page” is required to be assigned to form-feed (U+0C) by the ANSI standard. (9) See chapter 7 ""Testing widely used RNGs"" in TestU01: A C Library for Empirical Testing of Random Number Generators by Pierre L’Ecuyer and Richard Simard, ACM Transactions on Mathematical Software, Vol. 33, article 22, 2007. (10) The functionality contained in the package SB-UNIX is for SBCL internal use only; its contents are likely to change from version to version. (11) See “namespace” entry in the glossary of the Common Lisp Hyperspec."	"null"	"null"	"A fork of CMUCL; compiles to machine code.. Public domain, with some parts under and."	"true"
"Build Systems"	"ASDF"	"https://common-lisp.net/project/asdf/"	"Another System Definition Facility; a build system for Common Lisp.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"null"	"null"	"null"	"ASDF - Another System Definition Facility ASDF Another System Definition Facility What it is What it is not Supported Implementations Examples Documentation Getting it Extensions Reporting Bugs Mailing Lists Changelog ASDF 3 ASDF 3 is the current successor to Daniel Barlow's ASDF. It was rewritten for improved portability, robustness, usability, extensibility, configurability, internal consistency, and the ability to deliver standalone executables. Its notable versions include pre-release 2.27 on February 1st 2013, first stable release 3.0.1 on May 16th 2013, major release 3.1.2 on May 6th 2014, and latest release 3.1.6 on October 17th 2015. What it is ASDF stands for Another System Definition Facility, the successor of the Lisp DEFSYSTEM of yore. ASDF 3 contains two parts: asdf/defsystem and uiop. asdf/defsystem is a tool to describe how Lisp source code is organized in systems, and how to build a system in term of actions that depend on previous actions. Typical actions consist in compiling a Lisp source file (if not up to date) and loading the resulting compilation output (if not both loaded and up to date). And you must typically compile and load files that define packages, macros, variables, before you may compile and load other files that use them. ASDF is what Common Lisp hackers use to build and load software, where C hackers might use GNU Make to build software and ld.so to load it. asdf/defsystem is the part that people usually refer to as ASDF, with uiop being only a supporting library, that happens to be distributed at the same time, by necessity. uiop also known as asdf/driver, the Utilities for Implementation- and OS- Portability, is a Common Lisp portability library and runtime support system that helps you write Common Lisp software in a portable way. In addition to many general-purpose Lisp utilities, it notably provides portable abstractions to gloss over implementation quirks, support hot-upgrade of code, manipulate pathnames, create programs, use command-line arguments, access the environment, use the filesystem, call other programs and parse their output, compile Lisp code, muffle conditions, or configure Lisp software. See its README.md for an overview, and the documentation as extracted from its docstrings by HEΛP (beware: you can, though it's not obvious, scroll the list of packages with a scrollbar on the right of the top-left pane, and then click on the package you're interested in to browse its symbols). uiop is distributed as part of the ASDF, its source code is transcluded in the single-file asdf.lisp being distributed and the precompiled fasls provided by Lisp implementations. ASDF relies heavily on it for its portability layer and runtime support, particularly so as to handle pathnames and filesystem access. uiop is useful on its own and can also be compiled and distributed separately. What it is not ASDF will not download missing software components for you. For that, you want Quicklisp, that builds upon ASDF, and is great for pulling and installing tarballs of packages you may depend upon; we also recommend clbuild, that now builds upon Quicklisp, as a great tool for pulling from version control packages you need to modify or want to contribute to. We recommend you should not use asdf-install anymore, as it is an older similar piece of software that is both unmaintained and obsolete. ASDF is also not a tool to build or run Common Lisp software from the Unix command-line. For that, you want cl-launch, or perhaps buildapp. If you're unsatisfied with ASDF, beside helping with our TODO list, you might be interested in other build systems for Common-Lisp: Alastair Bridgewater's small and simple one-package-per-file quick-build (also reimplemented as the ASDF extension asdf-package-system, now part of ASDF 3; similar to faslpath below). François-René Rideau's XCVB (building object and image files deterministically and in parallel, but not actively maintained since 2012; a hypothetical ASDF 4 could conceivably be evolved to support these features thanks to the groundwork laid by ASDF 3). Drew McDermott's YTools (the polar opposite, trying to maintain coherence of the current Lisp image at a fine grain). Dmitriy Ivanov's ASDlite (a somewhat improved incompatible variant of ASDF 1, less featureful than ASDF 3), Mark Kantrowitz's mk-defsystem (free software successor of the old proprietary DEFSYSTEM's and predecessor of ASDF, obsolete), Sean Ross's mudballs (an attempt at making things cleaner than in ASDF 2, aborted), Peter von Etter's faslpath (a much simpler system establishing a mapping between packages and files, abandoned but see asdf-package-system and quick-build above). Alexander Kahl's evol (a reimplementation in Lisp of the GNU autotools stack, abandoned), There are probably more. However, none of these systems seems to ever have had the traction of ASDF, probably because none was technically superior enough (if at all) to compensate for the first mover advantage. Supported Implementations ASDF 3 now supports all CL implementations that seem to have any current user base, and then some. Most implementations provide ASDF as a module, and you can simply (require ""asdf""). (All of them but CLISP also accept :asdf, ""ASDF"" or 'asdf as an argument.) Most of these implementations provide ASDF 3. Some implementations don't provide ASDF 3 yet, but have announced they will in their next release. As for remaining implementations, they are obsolete and/or mostly unmaintained. Provide ASDF 3 Will provide ASDF 3 Unmaintained Free abcl ccl clasp clisp cmucl ecl mkcl sbcl gcl mcl xcl Proprietary allegro lispworks cormanlisp genera mocl scl To deal with an implementation that does not yet provide ASDF 3, we provide a script that can install ASDF 3 where your implementation goes looking for it when you (require ""asdf"") . Note that upgrading from an old version of ASDF is possible, but quite complex to do right in a robust way, and we do not recommend it. Also note that mocl only supports a heavily modified variant of ASDF 2, and will require robust cross-compilation support to be added to ASDF 3 before it is actually supported. If there is an old or new implementation that we are missing, it shouldn't be hard to adapt ASDF to support it. Ask us! Examples Download any of the many packages available through Quicklisp to see as many examples. Documentation You can read our manual: as one HTML file split into one HTML file per section as a PDF document as texinfo source Regarding the internal design of ASDF in general, and the work we did on ASDF 3, see the extended version (26 pages) of our paper ASDF 3, or Why Lisp is Now an Acceptable Scripting Language (PDF, git). The shorter version (8 pages), submitted to ELS 2014, focuses on ASDF 3 and misses historical and technical information (PDF, HTML). Regarding ASDF 3, see also the slides of the ASDF 3 tutorial presented at ELS 2013, and for an introduction to the source code, this video: ASDF 3.1 walkthrough. For more details about our work on ASDF 2, see the last draft version of our paper for ILC 2010, Evolving ASDF: More Cooperation, Less Coordination (git). Finally, while the manual covers all the basics, some advanced or new features remain underdocumented. Please contact our mailing-list (see below) for any issue that isn't well-documented enough. Until we write more documentation on the further innovations of ASDF 3, the documentation strings, the source code, the changelog and the git log are unfortunately your best chances for discovering the available functionality. Getting it Though they may lag behind the version here, ASDF comes bundled with most Lisps. To get the greatest and latest, you can: download just the latest release source for asdf.lisp; download the latest release tarball to get all bells and whistles; pull the latest development tree from our git repository git clone https://gitlab.common-lisp.net/asdf/asdf.git (note that our ""master"" branch is for current development; get our ""release"" branch for the latest stable release. Run make to create build/asdf.lisp); browse the latest development tree from our git repository: gitlab download the tarball of a past release: archives Extensions Known extensions to ASDF include: asdf-dependency-grovel, to compute the actual dependencies in a big ASDF system. asdf-encodings, to compile Lisp source files with character encodings other than UTF-8. asdf-finalizers, to allow macros to include code to be evaluated at the end of a file being compiled. asdf-flv, to bind file-local variables around the compilation of some files. asdf-system-connections, lets you specify systems that are automatically loaded when two other systems are loaded, to connect them. cffi, lets you interface between with functions and datastructures written in C and functions written in Lisp, including support for automatically detecting constants from C macros, linking to dynamic libraries, and writing your own wrapper code in C. poiu, to compile a system in parallel on a multiprocessor machine. Former extensions, now superseded, include: asdf-binary-locations used to allow one to redirect where ASDF 1 created its output files, so they don't clash between implementations and don't pollute source directories. It is superseded by asdf/defsystem's builtin asdf-output-translations mechanism; a limited compatibility mode is available to easily convert your former ABL configuration into an AOT configuration. common-lisp-controller and cl-launch used to provide similar mechanisms, and have also been superseded by asdf-output-translations (built into ASDF 2 and later). asdf-bundle, née asdf-ecl, allowed you to create a single-file bundle out of a system, for easier delivery. It is now a builtin part of asdf/defsystem, and allows users to deliver a single FASL for a system, a standalone executable program (on supported implementations), or an image containing your system precompiled. asdf-condition-control, initially part of XCVB's xcvb-driver, allowed you to muffle uninteresting conditions during compilation. Is now superseded by equivalent functionality in uiop. asdf-contrib, an empty package that used to collect dependencies on other systems in the list above and below. asdf-package-system, to compile Lisp source files with one package per file that also determines dependencies, in the style of quick-build or faslpath (this functionality is built into recent versions of ASDF 3.1 and later, but this package exists for backward compatibility with earlier versions of ASDF 3; search the manual for package-inferred-system). asdf-utils was a collection of utilities that originated with ASDF. It is now superseded by uiop, aka asdf/driver, which is part of ASDF, and exports its functionality in its own package uiop. Contributing Join our mailing list, check the code out from git, send questions, ideas and patches! Reporting Bugs To report bugs, you can use our launchpad project. If you're unsure about the bug or want to discuss how to fix it, you can send email to the project mailing-list below. Mailing Lists asdf-devel A list for questions, suggestions, bug reports, patches, and so on. It's for everyone and everything. Please join the conversation! asdf-devel mailman site to subscribe asdf-announce A low-volume mailing-list for announcements only, mostly regarding new releases. Posting is restricted to project administrators and to important notices. Please subscribe to it if you're a Lisp implementation or distribution vendor, who needs to know when to upgrade the ASDF you distribute, but are otherwise not interested in day to day design and development. asdf-announce mailman site to subscribe Contributing Join our mailing list, check the code out from git, send questions, ideas and patches! What is happening March 2016 Release of 3.1.7, another bug fix release for the 3.1.x series. October 2015 Although we had hoped that ASDF 3.1.5 would be the final release in the ASDF 3.1 series, a number of bug reports led us to prepare release 3.1.6. Support for Windows continues to improve, and we wished to release a number of bug fixes, and support the recent Allegro Common Lisp 10.0 release. July 2015 An extensive bout of bug-fixing, notably on Windows, leads to release of ASDF 3.1.5 on 21 July 2015. XDG handling has been improved to be more compliant with the standard. Preliminary support for immutable systems has been added. May 2015 With the LispWorks 7.0 release, all actively maintained CL implementations are now providing ASDF 3.0 or later, and support for older variants is now officially dropped. October 2014 More bug fixing leads to release of 3.1.4 on 10 October 2014. There should be no incompatibilities. See the Changelog for more details. August 2014 The ASDF mailing lists have been reestablished, in particular asdf-announce, which should allow CL implementers better access to only the information they want about ASDF development. May 2014 to July 2014 ASDF bug fixing from 3.1.2 leads to release of 3.1.3, a major bug fix release. We strongly urge implementors that have shipped with 3.1.2 to upgrade to 3.1.3. There should be no incompatibilities, and some very important bug fixes are provided. See the Changelog for more details. July 2013 to May 2014 François-René Rideau has resigned as maintainer but remained an active developer. Robert P. Goldman is interim maintainer until someone more gifted, charming, dedicated, and better-looking can be secured to fill the role. ASDF 3.0.2 was released in July 2013, 3.0.3 in October 2013, and 3.1.2 in May 2014. In addition to significant improvements and bug fixes, notably better Windows support, ASDF 3.1.2 notably sports the package-inferred-system extension. November 2012 to June 2013 François-René Rideau completely rewrites ASDF and publishes ASDF 3, pre-released as 2.27 in February 2013, and released as 3.0.1 in May 2013. It now includes both the traditional asdf/defsystem and a formalized portability library uiop (née asdf/driver). asdf/defsystem is a backward-compatible reimplementation of ASDF with correct timestamp propagation based on a consistent dependency model, and featuring support for bundle output, deferred warnings check, and more. uiop provides many abstractions to write portable Common Lisp programs. Last version: 3.0.1. December 2009 to October 2012 François-René Rideau is de facto maintainer, with notable contributions from Robert P. Goldman, but also Juanjo Garcia-Ripoll and James Anderson. ASDF 2.000 is released in May 2010 with many clean-ups, better configurability, some new features, and updated documentation. The ASDF 2 series culminates with ASDF 2.26 in October 2012, which in addition to many bug fixes and small features includes support for file encodings, around-compile and compile-check hooks. Last version: 2.26. May 2006 to November 2009 Gary King is de facto maintainer, with notable contributions from Robert P. Goldman, Nikodemus Siivola, Christophe Rhodes, Daniel Herring. Many small features and bug fixes, making the project more maintainable, moving to using git and common-lisp.net. Last version: 1.369. May 2004 to April 2006 Christophe Rhodes is de facto maintainer, with notable contributions from Nikodemus Siivola, Peter Van Eynde, Edi Weitz, Kevin Rosenberg. The system made slightly more robust, a few more features. Last version: 1.97. August 2001 to May 2004 Created then developed by Daniel Barlow, with notable contributions from Christophe Rhodes, Kevin Rosenberg, Edi Weitz, Rahul Jain. Last version: 1.85. ASDF has an MIT style license Last updated 2015-07-21"	"null"	"null"	"Another System Definition Facility; a build system for Common Lisp.."	"true"
"Build Systems"	"asdf-linguist"	"https://github.com/eudoxia0/asdf-linguist"	"Extensions for ASDF.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"14"	"4"	"0"	"GitHub - eudoxia0/asdf-linguist: ASDF extensions. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 4 Star 14 Fork 0 eudoxia0/asdf-linguist Code Issues 0 Pull requests 0 Pulse Graphs ASDF extensions. 76 commits 1 branch 0 releases Fetching contributors Common Lisp 98.3% CSS 1.4% Makefile 0.3% Common Lisp CSS Makefile Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src t .gitignore .travis.yml README.md asdf-linguist-test.asd asdf-linguist.asd README.md asdf-linguist ASDF-linguist is a set of extensions to the ASDF build system for Common Lisp for compiling various languages and running various preprocessing tools (Sass, LESS, etc.) on files in your project. ASDF is very easy to extend to handle other languages within the same project, eg. compiling C source files, but this ease of extensibility leads to people reimplementing these basic capabilities in different, ad-hoc ways. This system attempts to solve this by providing one and only one way to do these things. Extensions Languages C C++ Fortran Web CSS preprocessors LESS ✓ Myth ✓ Sass ✓ Tools CSS/JSS Minifiers YUI Compressor ✓ Compile-to-Javascript CoffeeScript ✓ ParenScript Roy ✓ Build systems Make ✓ CMake Tools Text Processing org-mode pandoc Graphics dot ✓ ditaa ✓ License Copyright (c) 2014-2015 Fernando Borretti eudoxiahp@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/eudoxia0/asdf-linguist"	"Extensions for ASDF.."	"true"
"Crypto"	"crypto-shortcuts"	"https://github.com/Shinmera/crypto-shortcuts"	"Collection of common crypto shortcuts.."	"null"	"null"	"null"	"Artistic License 2.0"	"http://directory.fsf.org/wiki/License:ArtisticLicense2.0"	"null"	"null"	"10"	"1"	"0"	"GitHub - Shinmera/crypto-shortcuts: Collection of common cryptography functions Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 1 Star 10 Fork 0 Shinmera/crypto-shortcuts Code Issues 0 Pull requests 0 Pulse Graphs Collection of common cryptography functions http://shinmera.github.io/crypto-shortcuts/ 15 commits 2 branches 0 releases Fetching contributors HTML 67.6% Common Lisp 32.4% HTML Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. LICENSE README.md about.html crypto-shortcuts.asd crypto.lisp digests.lisp documentation.lisp encode.lisp hashing.lisp package.lisp README.md About Crypto Shortcuts This is a small wrapper library around ironclad and cl-base64 to provide quick and easy access to frequently used cryptography functionality like hashing, encoding and encrypting. How To (cryptos:from-base64 (cryptos:to-base64 ""ＣＬがすごいです。""))  (cryptos:decrypt (cryptos:encrypt ""Lispy Secrets, oooOOooo"" ""1234567890123456"") ""1234567890123456"")  (cryptos:pbkdf2-hash ""My passwords have never been this secure, whoa nelly!"" ""salty snacks"")  (cryptos:simple-hash ""I guess not everyone can afford PBKDF2."" ""crisps"")  (cryptos:md5 ""MD5 hashes are weak, but still sometimes useful."")  (cryptos:sha512 ""If you don't need hash iterations or salts like simple-hash provides, this will do too."")  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Shinmera/crypto-shortcuts"	"Collection of common crypto shortcuts.."	"true"
"Crypto"	"Ironclad"	"http://method-combination.net/lisp/ironclad/"	"A library of crypto functions for Common Lisp. Not considered secure, but is still useful for the message digest functions.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"71"	"13"	"30"	"GitHub - froydnj/ironclad: A cryptographic toolkit written in Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 13 Star 71 Fork 30 froydnj/ironclad Code Issues 8 Pull requests 8 Pulse Graphs A cryptographic toolkit written in Common Lisp http://method-combination.net/lisp/ironclad/ 259 commits 1 branch 7 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v0.33 v0.32.1 v0.32 v0.31 v0.30 v0.29 v0.28 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. doc src Use Montgomery ladder algorithm for modular exponentiation by default. Feb 14, 2016 testing .gitignore .travis.yml LICENSE NEWS README Initial commit. Nov 11, 2009 TODO ironclad-text.asd ironclad.asd README This is the README for Ironclad, a cryptography package for ANSI Common Lisp.  It includes several popular block encryption algorithms and several popular hash functions.  This release also includes some initial public-key cryptography functionality with the addition of DSA signing and verification.  (As a bonus, this software used to sign this release was written in pure Common Lisp.)  This release is intended as a prototype and as a basis for discussion and refinement.  Most of the algorithms were written with efficiency for specific Common Lisp implementations in mind, although portable code is provided as an alternative in nearly all instances.  The framework should be flexible enough to accomodate implementation-specific optimizations when possible.  Documentation is currently minimal.  Documentation strings for most of the exported functions should be provided; these strings provide a decent overview of what the library is capable of.  Test vectors for many of the algorithms are included to provide a level of confidence in the correctness of the implementations.  A (incomplete) TODO list is included with the package.  The NEWS file provides a high-level overview of what has changed since the last release.  ASDF packaging is provided; (asdf:oos 'asdf:load-op :ironclad) should be all you need to get started.  Comments, criticisms, additions, and optimizations are welcome at the below email address.  Nathan Froyd froydnj@gmail.com 30 January 2006  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/froydnj/ironclad"	"A library of crypto functions for Common Lisp. Not considered secure, but is still useful for the message digest functions.."	"true"
"Crypto"	"trivial-ssh"	"https://github.com/eudoxia0/trivial-ssh"	"An SSH client library.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"10"	"5"	"2"	"GitHub - eudoxia0/trivial-ssh: An SSH client library for Common Lisp (Built on libssh2) Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 10 Fork 2 eudoxia0/trivial-ssh Code Issues 0 Pull requests 0 Pulse Graphs An SSH client library for Common Lisp (Built on libssh2) 23 commits 1 branch 0 releases Fetching contributors Common Lisp 97.9% NewLisp 2.1% Common Lisp NewLisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. libssh2 src t .gitignore .travis.yml README.md Vagrantfile trivial-ssh-libssh2.asd trivial-ssh-test.asd trivial-ssh.asd README.md trivial-ssh A simple SSH/SCP library for Common Lisp. Usage Overview (ssh:with-connection (conn ""example.com"" (ssh:pass ""username"" ""password""))   (ssh:with-command (conn iostream ""ls -a"")     ;; Write or read to/from the iostream     )   (ssh:download-file #p""/remote/file"" #p""/local/file"")   (ssh:upload-file #p""/local/file"" #p""/remote-file"")) License Copyright (c) 2014-2015 Fernando Borretti (eudoxiahp@gmail.com) Licensed under the MIT License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/eudoxia0/trivial-ssh"	"An SSH client library.."	"true"
"Database"	"cl-dbi"	"https://github.com/fukamachi/cl-dbi"	"A database-independent interface for Common Lisp.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"69"	"15"	"14"	"GitHub - fukamachi/cl-dbi: Database independent interface for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 15 Star 69 Fork 14 fukamachi/cl-dbi Code Issues 6 Pull requests 2 Pulse Graphs Database independent interface for Common Lisp 122 commits 4 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags ci-test-impls gh-pages master travis-abcl Nothing to show Nothing to show New pull request Latest commit 18f4099 Feb 20, 2016 fukamachi Run ql:quickload silently. Permalink Failed to load latest commit information. src Run ql:quickload silently. Feb 20, 2016 t Drop 'w' from my name. Jan 21, 2015 .gitignore .travis.yml README.markdown Add dbi:connect-cached. Mar 22, 2015 cl-dbi.asd dbd-mysql.asd dbd-postgres.asd Drop 'w' from my name. Jan 21, 2015 dbd-sqlite3.asd Drop 'w' from my name. Jan 21, 2015 dbi-test.asd dbi.asd README.markdown CL-DBI - Database independent interface for Common Lisp Usage Connecting and executing a query (defvar *connection*   (dbi:connect :mysql                :database-name ""test""                :username ""nobody""                :password ""1234""))  (let* ((query (dbi:prepare *connection*                            ""SELECT * FROM somewhere WHERE flag = ? OR updated_at > ?""))        (result (dbi:execute query 0 ""2011-11-01"")))   (loop for row = (dbi:fetch result)      while row      ;; process ""row"".        )) Using dbi:with-connection to ensure connections are closed (dbi:with-connection (conn :sqlite3 :database-name ""/home/fukamachi/test.db"")   (let* ((query (dbi:prepare conn ""SELECT * FROM People""))          (result (dbi:execute query)))     (loop for row = (dbi:fetch result)        while row        do (format t ""~A~%"" row)))) Description CL-DBI provides the same interface for multiple SQL databases. You need not learn the API of each database. This library is especially convenient when you want to use different databases in different environments. For example, you may use MySQL as a production database, but use SQLite3 on your development system. To switch database backends you need only change the arguments to dbi:connect. Databases SQLite3 PostgreSQL MySQL Installation This library will be available on Quicklisp when ready for use. API User-Level API connect [driver-name & params] => <dbi-connection> connect-cached [driver-name & params] => <dbi-connection> disconnect [<dbi-connection>] => T or NIL prepare [conn sql] => <dbi-query> execute [query & params] => something fetch [result] => a row data as plist fetch-all [result] => a list of all row data do-sql [conn sql & params] list-all-drivers [] => (<dbi-driver> ..) find-driver [driver-name] => <dbi-driver> with-transaction [conn] begin-transaction [conn] commit [conn] rollback [conn] ping [conn] => T or NIL row-count [conn] =&gt a number of rows modified by the last executed INSERT/UPDATE/DELETE with-connection [connection-variable-name &body body] Driver-Level API <dbi-driver> <dbi-connection> make-connection [driver params] disconnect [<dbi-connection>] => T or NIL prepare [conn sql] => <dbi-query> fetch-using-connection [conn result] => a row data as plist do-sql [conn sql & params] execute-using-connection => something escape-sql => string begin-transaction [conn] commit [conn] rollback [conn] ping [conn] => T or NIL row-count [conn] =&gt a number of rows modified by the last executed INSERT/UPDATE/DELETE Creating a new driver Create a subclass of <dbi-driver> and implement following methods. make-connection disconnect [<dbi-connection>] => T or NIL execute-using-connection These methods can be overriden if needed. prepare fetch-using-connection do-sql escape-sql Dependencies cl-annot CL-Syntax SPLIT-SEQUENCE closer-mop Author Eitaro Fukamachi (e.arrows@gmail.com) Copyright Copyright (c) 2011 Eitaro Fukamachi (e.arrows@gmail.com) License Licensed under the LLGPL License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/cl-dbi"	"A database-independent interface for Common Lisp.."	"true"
"XML"	"LLGPL"	"http://opensource.franz.com/preamble.html"	"A basic parser.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Preamble to the Gnu Lesser General Public License Preamble to the Gnu Lesser General Public License Copyright (c) 2000 Franz Incorporated, Berkeley, CA 94704 The concept of the GNU Lesser General Public License version 2.1 (""LGPL"") has been adopted to govern the use and distribution of above-mentioned application. However, the LGPL uses terminology that is more appropriate for a program written in C than one written in Lisp. Nevertheless, the LGPL can still be applied to a Lisp program if certain clarifications are made. This document details those clarifications. Accordingly, the license for the open-source Lisp applications consists of this document plus the LGPL. Wherever there is a conflict between this document and the LGPL, this document takes precedence over the LGPL. A ""Library"" in Lisp is a collection of Lisp functions, data and foreign modules. The form of the Library can be Lisp source code (for processing by an interpreter) or object code (usually the result of compilation of source code or built with some other mechanisms). Foreign modules are object code in a form that can be linked into a Lisp executable. When we speak of functions we do so in the most general way to include, in addition, methods and unnamed functions. Lisp ""data"" is also a general term that includes the data structures resulting from defining Lisp classes. A Lisp application may include the same set of Lisp objects as does a Library, but this does not mean that the application is necessarily a ""work based on the Library"" it contains. The Library consists of everything in the distribution file set before any modifications are made to the files. If any of the functions or classes in the Library are redefined in other files, then those redefinitions ARE considered a work based on the Library. If additional methods are added to generic functions in the Library, those additional methods are NOT considered a work based on the Library. If Library classes are subclassed, these subclasses are NOT considered a work based on the Library. If the Library is modified to explicitly call other functions that are neither part of Lisp itself nor an available add-on module to Lisp, then the functions called by the modified Library ARE considered a work based on the Library. The goal is to ensure that the Library will compile and run without getting undefined function errors. It is permitted to add proprietary source code to the Library, but it must be done in a way such that the Library will still run without that proprietary code present. Section 5 of the LGPL distinguishes between the case of a library being dynamically linked at runtime and one being statically linked at build time. Section 5 of the LGPL states that the former results in an executable that is a ""work that uses the Library."" Section 5 of the LGPL states that the latter results in one that is a ""derivative of the Library"", which is therefore covered by the LGPL. Since Lisp only offers one choice, which is to link the Library into an executable at build time, we declare that, for the purpose applying the LGPL to the Library, an executable that results from linking a ""work that uses the Library"" with the Library is considered a ""work that uses the Library"" and is therefore NOT covered by the LGPL. Because of this declaration, section 6 of LGPL is not applicable to the Library. However, in connection with each distribution of this executable, you must also deliver, in accordance with the terms and conditions of the LGPL, the source code of Library (or your derivative thereof) that is incorporated into this executable. End of Document"	"null"	"null"	"A basic parser.."	"true"
"Database"	"cl-memcached"	"https://github.com/quasi/cl-memcached"	"Fast, thread-safe interface to the Memcached object caching system.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"16"	"5"	"3"	"GitHub - quasi/cl-memcached: Fast, thread-safe interface to the Memcached object caching system. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 16 Fork 3 quasi/cl-memcached Code Issues 0 Pull requests 0 Pulse Graphs Fast, thread-safe interface to the Memcached object caching system. http://quasilabs.com/cl-memcached 30 commits 2 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. doc LICENSE README.md cl-memcached.asd cl-memcached.lisp packages.lisp README.md CL-MEMCACHED CL-MEMCACHED is a simple, fast & thread-safe library to interface with the memcached object caching system. It implements the Memcached TEXT protocol. According to the home page : memcached is a high-performance, distributed memory object caching system, generic in nature, but intended for use in speeding up dynamic web applications by alleviating database load. Tested on SBCL, CCL & CMUCL. Global variables *memcache* Most commands have this as a fallback binding. Useful if we are only using one cache or if we want to bind it to a cache and then use it multiple places. *mc-use-pool* If this is true then the connection pool will be used. On SBCL this is about 3x faster. *mc-default-encoding* Babel is used for encodeing/decoding the data. Memcached expects octets. Default encoding is UTF-8. make-memcache &key (ip ""127.0.0.1"") (port 11211) (name ""Memcache"") (pool-size 2) Makes a memcached data-structure. We use this for further transactions. This has a inbuilt pool and know how to make new pool items. mc-set key data &key (memcache *memcache*) (timeout 0) (flags 0) (noreply nil) (cas-unique nil) (mc-use-pool *mc-use-pool*) Stores data for the key in the memcache. The parameters have same value as the memcached server commands. We have similar mc-add, mc-replace, mc-append, mc-prepend functions available. mc-cas key data cas-unique &key (memcache *memcache*) (timeout 0) (flags 0) (noreply nil) (external-format *mc-default-encoding*) (mc-use-pool *mc-use-pool*) This is a Check & Store operation. mc-get keys-list &key (memcache *memcache*) (mc-use-pool *mc-use-pool*) Returns a list of lists corresponding to responses to found keys in the keys-list. mc-get+ key-or-list-of-keys &key (memcache *memcache*) (mc-use-pool *mc-use-pool*) This is a wrapper around mc-get. It accepts 1 or many keys. Returns 1 or many memcache-response type structures containing all the pieces of the response. The memcache-response structure has these slots : key, flags, bytes, cas-unique, data-raw. All the slot accessors start with mc- mc-data response &key (external-format *mc-default-encoding*) Takes the data-raw, which is in octets, and converts it to string using the external-format. mc-get-value key &key (memcache *memcache*) (mc-use-pool *mc-use-pool*) (external-format *mc-default-encoding*) A wrapper around mc-data and mc-get+. Give it a key and it gets a string value in return. Misuse is entierly the users responsibility. :) mc-del key &key (memcache *memcache*) (noreply nil) (mc-use-pool *mc-use-pool*) Deletes key from the cache. mc-incr key &key (value 1) (noreply nil) (memcache *memcache*) (mc-use-pool *mc-use-pool*) Increments key in place by value. If key not found then will return NOT_FOUND. mc-decr key &key (value 1) (noreply nil) (memcache *memcache*) (mc-use-pool *mc-use-pool*) Decrements key by value. If key not found then will return NOT_FOUND. mc-touch key expiry-time &key ( noreply nil ) ( memcache *memcache* ) ( mc-use-pool *mc-use-pool* ) Change expiry time of key. mc-flush-all &key ( delay 0 ) ( noreply nil) ( memcache *memcache* ) ( mc-use-pool *mc-use-pool* ) expires all the current keys. mc-version &key ( memcache *memcache* ) ( mc-use-pool *mc-use-pool* ) Returns a text string with the version of the memcached server mc-verbosity &key ( level 1 ) ( noreply nil) ( memcache *memcache* ) ( mc-use-pool *mc-use-pool* ) Sets the verbosity level of the logging output mc-stats &key (memcache *memcache*) (noreply nil) (mc-use-pool *mc-use-pool*) Returns a alist of the stats. mc-stats-summary &key (memcache *memcache*) Prints all the details from the alist. ;) Not too hot, but hey. Example Usage for testing. CL-USER> (require 'cl-memcached) NIL  CL-MEMCACHED> (in-package :cl-memcached) #<PACKAGE ""CL-MEMCACHED"">  CL-MEMCACHED> (setf *memcache* (make-memcache)) #<MEMCACHED-SERVER Name:Memcache IP:127.0.0.1 Port:11211 >  CL-MEMCACHED> (mc-quick-test ""foo"" ""bar"") Success SET Success GET NIL  CL-MEMCACHED> (mc-set ""t1"" ""oooooooooooooooooooooo"") STORED :INTERNAL  CL-MEMCACHED> (mc-get+ ""t1"") #<MEMCACHED-RESPONSE Key:t1 Data-Length:22 >  CL-MEMCACHED> (describe *) #<MEMCACHED-RESPONSE Key:t1 Data-Length:22 >   [structure-object]  Slots with :INSTANCE allocation:   KEY         = ""t1""   FLAGS       = ""0""   BYTES       = 22   CAS-UNIQUE  = NIL   DATA-RAW    = #(111 111 111 111 111 111 111 111 111 111 111 111 111 111 111 111 111.. ; No value  CL-MEMCACHED> (mc-data (mc-get+ ""t1"")) ""oooooooooooooooooooooo""  CL-MEMCACHED> (mc-get-value ""t1"") ""oooooooooooooooooooooo""  CL-MEMCACHED> (mc-set ""t2"" ""0"") STORED :INTERNAL  CL-MEMCACHED> (mc-incr ""t3"") NOT_FOUND  CL-MEMCACHED> (mc-incr ""t2"") 1 1  CL-MEMCACHED> (mc-incr ""t2"") 2 1  CL-MEMCACHED> (mc-decr ""t2"") 1 1   AUTHORS: Abhijit 'quasi' Rao quasi@quasilabs.in DEPENDENCIES: usocket http://www.cliki.net/usockes split-sequence http://www.cliki.net/SPLIT-SEQUENCE babel http://common-lisp.net/project/babel/ pooler https://github.com/quasi/pooler Note : The http://common-lisp.net/project/cl-memcached/ is the homepage. But the version there is older and the documentation out of date. I have lost the creds, :-). Till I manage to set that right please ignore that one. Benchmark Host OS : OSX 10.8.4 Dataset: 1024 bytes (1kb) text string. Repeat 10000 times. |-------------------+------------------+---------------+------------------+---------------| | implementation    | SET without pool | SET with pool | GET without pool | GET with pool | |-------------------+------------------+---------------+------------------+---------------| | SBCL 1.1.10       |            4.942 |         0.713 |            4.905 |         0.690 | | CCL 1.9-r15759    |            4.711 |         0.847 |            4.506 |         0.648 | | CMUCL 20D Unicode |            4.460 |         0.970 |            4.290 |         0.810 | |-------------------+------------------+---------------+------------------+---------------| | Dalli on Ruby 1.9 |                  |         0.957 |                  |         1.033 | |-------------------+------------------+---------------+------------------+---------------|  When we do not use the pool we make a new socket connection every time. The Ruby 'dalli' client, which implements the binary protocol, uses the same socket (I think) so this should be comparable with our with-pool. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/quasi/cl-memcached"	"Fast, thread-safe interface to the Memcached object caching system.."	"true"
"Database"	"cl-mongo"	"https://github.com/fons/cl-mongo"	"MongoDB client.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"106"	"17"	"24"	"GitHub - fons/cl-mongo: lisp interface to mongo db Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 17 Star 106 Fork 24 fons/cl-mongo Code Issues 10 Pull requests 4 Wiki Pulse Graphs lisp interface to mongo db http://fons.github.com/cl-mongo 90 commits 2 branches 0 releases 4 contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Latest commit 141518d Apr 24, 2016 fons Merge pull request #30 from gitter-badger/gitter-badge … Add a Gitter chat badge to README.md Permalink Failed to load latest commit information. doc fix typos in readme Nov 27, 2010 perf performance upgrade;multithreading support Oct 7, 2010 src some changes Sep 4, 2013 test added split-sequence depd; fixed decsribe-object in documenr; fixed c… Jun 13, 2011 .gitignore added .DS_Store Aug 17, 2012 COPYING 20100117-01 Jan 17, 2010 README.md Add Gitter badge Apr 14, 2016 cl-mongo.asd changed cl-mongo.asd to older version; newer version broke a few things Sep 5, 2013 test.lisp fixed decoder for empty lists; get-elemens support for . operator Jun 12, 2011 README.md cl-mongo Intro mongo is a scalable, high-performance, open source, schema-free, document-oriented database.. This is a common lisp interface that allows you to work with a mongo document database. This is not a driver (yet) as specified in the mongo documents; There is still some functionality I need to implement. Except for gridfs most features have been implemented. cl-mongo provides the ability to insert, update and delete documents, indexing, searching using regexs etc. In addition it supports javascript in the repl (using a commonly available lisp to javascript compiler). This allows you to do use mongodb's map-reduce from the lisp repl. I developed this primarily using sbcl and to some extend clozure common lisp on the linux and mac osx platforms. This should also work on clisp and allegro common lisp and windows. multi-threading The do-query function uses multithreading to process the results of a batch as a query is in progress. This obviously requires that multi-threading is supported. I've found that as of now (2010-10-23) sbcl on mac osx doesn't support multithreading out of the box. So you'd need to compile a new sbcl with multithreading enabled, which is easy to do. Version Version 0.9.0 I've added regression testing for all features currently supported by cl-mongo. Installation Use asdf to install cl-mongo. cl-mongo depends on many other lisp libraries (which in turn have their own dependecies). asdf is not a dependency manager, so you would need to install all dependencies as they come up as unavailable when you try to install cl-mongo. On the other hand, cl-mongo is included in quicklisp, which should make life easier. Testing The cl-mongo-test package contains regression tests for all the features currently supported. cl-mongo-test is asdf-installable, but does not export it's tests. To run the quick test, do this : (use-package :cl-mongo-test) (quick-test) Quick test will connected to a locally running mongodb instance. It uses the ""foo"" collection in the ""test"" database. A sample session This connects to the test database on the local mongo server listening on its default port. (use-package :cl-mongo) (db.use ""test"")  Insert a key-value pair as the first document into collection ""foo"". (db.insert ""foo"" (kv ""document"" ""one"") ) Pretty-print the documents returned by the find command. iter will ensure that the cursor is fully iterated over. (pp (iter (db.find ""foo"" :all)))`   {     ""_id"" -> objectid(4B5CF28970DFF196A75FE1F0)     ""document""  ->  one  }  Create a document. A document is collection of key-value pairs and a unique identifier called ""_id"". (defvar *DOC* (make-document)) Add various elements to the document.    (add-element ""tag"" ""key"" *DOC*)`      {  DOCUMENT      {    tag  -> key     }    }   (add-element ""array"" (list 1 2 3 ""hello"") *DOC*)  {  DOCUMENT   { tag  -> key       1       2       3       hello   array  -> NIL   }  }  Insert document into the database. (db.insert ""foo"" *DOC*) Print the current contents.    (pp (iter (db.find ""foo"" 'all)))     {    ""_id"" -> objectid(4B5CF28970DFF196A75FE1F0)    ""document""  ->  one    }     {    ""_id"" -> objectid(8B508D5CBB5D451D961F046D)    ""array""  -> [ 1, 2, 3, hello,]    ""tag""  ->  key    }  Bind variable *DOC* to the second document returned by the find command, add an other element and save back to the collection.   (defvar *DOC* (cadr (docs (db.find ""foo"" :all))))`   (add-element ""tags"" (list 'good 'bad 'ugly) *DOC*)   (db.save ""foo"" *DOC*)   (pp (db.find ""foo"" :all))    { ""_id"" -> objectid(4B5CF28970DFF196A75FE1F0)     ""document""  ->  one   }    {     ""_id"" -> objectid(8B508D5CBB5D451D961F046D)     ""tags""  -> [ GOOD, BAD, UGLY,]     ""tag""  ->  key     ""array""  -> [ 1, 2, 3, hello,]   }  Check the status of the server.   (db.use ""admin"")   (nd (db.run-command :serverstatus))      ""ok""  ->  1.0d0   ""mem""  ->      ""mapped""  ->  80     ""virtual""  ->  177         ""resident""  ->  3     ""globalLock""  ->        ""ratio""  ->  4.644753171959394d-5       ""lockTime""  ->  6493354.0d0     ""totalTime""  ->  1.39799764586d11     ""uptime""  ->  139799.0d0  $ syntax I've added various $.. macros which allow for a more declarative programming style. In stead of doing something like : (db.find ""foo"" (kv ""k"" (kv ""$lte"" 3)))  you can use : (db.find ""foo"" ($<= ""k"" 3))  To declare a unique ascending index on ""k"" in collection ""foo"" , you can say : ($index ""foo"" :unique :asc ""k"")  What's missing At least the following is missing : Request id/ Response id are left 0 in the header. GridFS ...... API documentation I use Edi Weitz's documentation template to generate an api description based on embedded comments. News 2010-10-23 I've improved the read performance several orders of magnitude. This also reduces the memory foot pront quite a bit. In addition I've added a multi-threaded reader called do-query. CL-MONGO - api reference   Abstract The code comes with a MIT-style license so you can basically do with it whatever you want. Download shortcut: http://github.com/fons/cl-mongo.   Contents Download The CL-MONGO dictionary $ $!= $!in $+ $- $/ $< $<= $> $>= $add-to-set $all $em $exists $in $inc $index $map-reduce $mod $not $pop-back $pop-front $pull $pull-all $push $push-all $set $unset $where *mongo-default-db* *mongo-default-host* *mongo-default-port* *repo-root* add-element cwd date-time db.add-user db.auth db.collections db.collections db.count db.create-collection db.delete db.distinct db.ensure-index db.eval db.find db.indexes db.indexes db.insert db.iter db.next db.run-command db.save db.sort db.stop db.update db.use defjs defsrvjs do-query doc-id docs document generate-readme get-element ht->document install-js iter jsdef kv make-document mapdoc mongo mongo mongo-close mongo-registered mongo-show mongo-swap mr.gc mr.gc.all mr.p nd now nwd pp remove-js ret rm rm-element show time-zone with-mongo-connection Acknowledgements   Download CL-MONGO together with this documentation can be downloaded from http://github.com/fons/cl-mongo. The current version is 0.1.0.   The CL-MONGO dictionary [Macro] $ &rest args => result [Macro] $!= &rest args => result [Macro] $!in &rest args => result [Macro] $+ arg &rest args => result [Macro] $- arg &rest args => result [Macro] $/ regex options => result [Macro] $< &rest args => result [Macro] $<= &rest args => result [Macro] $> &rest args => result [Macro] $>= &rest args => result [Macro] $add-to-set &rest args => result [Macro] $all &rest args => result [Macro] $em array &rest args => result [Macro] $exists &rest args => result [Macro] $in &rest args => result [Macro] $inc &rest args => result [Macro] $index collection &rest args => result [Macro] $map-reduce collection map reduce &key query limit out keeptemp finalize verbose => result Run map reduce on the mongo server. map and reduce are either the names of the javascript functions, created with defjs or defsrvjs or are function definitions in javascript. The keywords refer to option available for map reduce in mongo. This returns a result summary document. When using :keeptemp t without specificing :out the collection is mr.<collection> [Macro] $mod &rest args => result [Macro] $not &rest args => result [Macro] $pop-back &rest args => result [Macro] $pop-front &rest args => result [Macro] $pull &rest args => result [Macro] $pull-all &rest args => result [Macro] $push &rest args => result [Macro] $push-all &rest args => result [Macro] $set &rest args => result [Macro] $unset &rest args => result [Macro] $where &rest args => result [Special variable] *mongo-default-db* database opened by the default connection [Special variable] *mongo-default-host* host for the default connection. [Special variable] *mongo-default-port* port for the default connection. [Special variable] *repo-root* root of the repository; used for documentation generation [Generic function] add-element key value document => result add element with key and value to a document [Function] cwd &key mongo => result Show the current database. [Function] date-time second minute hour day month year &optional time-zone => result Generate a time stamp the mongo/bson protocol understands. [Generic function] db.add-user username password &key mongo readonly => result Add a user to the database. [Generic function] db.auth username password &key mongo => result authenticate a user with a password [Generic function] db.collections &key mongo => result [Function] db.collections &key mongo => result Show all the collections in the current database. [Generic function] db.count collection selector &key mongo => result Count all the collections satifying the criterion set by the selector. :all can be used to return a count of all the documents in the collection. [Generic function] db.create-collection collection &key => result create a collection [Generic function] db.delete collection object &key mongo => result Delete a document from a collection. The *document* field is used to identify the document to be deleted. You can enter a list of documents. In that the server will be contacted to delete each one of these. It may be more efficient to run a delete script on the server side. [Generic function] db.distinct collection key &key mongo => result Return all the distinct values of this key in the collection [Generic function] db.ensure-index collection keys &key drop-duplicates unique mongo asc => result Create an index specified by the keys in a collection [Generic function] db.eval code &rest rest => result run javascript code server side [Generic function] db.find collection kv &key selector limit skip options mongo => result Find documents in the collection using the selector specified by kv. Methods take two keywords. ':limit' sets the maximum number of documents returned. The default is 1. ':skip' sets the number of documents to skip in this query. It's default is 0. Since the default value of the limit is one, db.find by default is the equivalant of *findOne* in the mongo documentation. [Generic function] db.indexes &key mongo => result [Function] db.indexes &key mongo => result Return all indexes in the database. [Generic function] db.insert collection document &key mongo => result Insert a document in a collection. A document is typically generated by `(make-document)`, but it can also be a hash table, a key-value pair or kv list (see the kv functions). [Generic function] db.iter result &key limit mongo => result next document iteration [Generic function] db.next collection cursor-id &key limit mongo => result Executes the next call on the iterator identified by cursor-id. [Generic function] db.run-command cmd &key arg mongo collection index => result Run a database command on the server. See the mongo documentation for a list of commands. For most commands you can just uses the key-value shown in the mongo documentation. [Generic function] db.save collection document &key mongo => result Save a document to the collection. If the document has a unique `_id` value (i.e. if it's generated by `(make-document)` ) it will be 'upserted' (that is: it will be inserted if the document doesn't exist). If the document a hash table or a kv set, it will be inserted. In other words this a a helper-function build around *db.insert* and *db.update*. [Macro] db.sort collection query &rest args => result sort macro : Takes the same arguments and keywords as db.find but converts the query so it works as a sort. use the :field keyword to select the field to sort on. Set :asc to nil to reverse the sort order [Generic function] db.stop cursor &key mongo => result Stop iterating and clean up the iterator on the server by making a server call. [Generic function] db.update collection selector new-document &key mongo upsert multi => result In a collection update the document(s) identified by the selector statement. This method has two keywords. ':upsert' : If t insert the document if the document cannot be found in the collection. ':multi' : Update all documents identified by the selector. [Generic function] db.use db &key mongo => result Use a database on the mongo server. Opens a connection if one isn't already established. (db.use -) can be used to go to a previosuly visited database, similar to cd -. [Macro] defjs name args declaration* statement* => result Define client side javascript. Works like defun; body is in lisp, with parenscript additions, like return. So (defjs hello (x y) (return (+ x y))) defines an adder. macro creates a lisp function which sends the javascript function over to the mongo server to be evaluated. Result is processed and returned to the reader. This will execute 10 times on the server : (mapcar (lambda (x) (hello 10 x)) (list 1 2 3 4 5 6 7 8 9 10)) [Macro] defsrvjs name args declaration* statement* => result Creates a function which stores and executes javascript on the server. The first time the function is called the javascript function is stored on the server. Subsequent calls will call out to the server. Works like defun; the function body is defined in lisp, with parenscript additions. Since the body of the function already resides on the server this should have less impact on the network. Use :install t to reinstall. [Function] do-query coll &key map-fn reduce-fn initial-value query mongo limit selector => result Performs a multi-threaded query on a mongo database. coll is the collection name. The reduce-fn keyword is used to specify a function which will be called for each member of a batch of data returned from mongodb. The reduce-fn function is executed while the query for the next batch is in progress. The default for reduce-fn is the identity function. The reduction keyword is used to specify a function which is executed when the database queries have finished. It's default implementation is to return a hash table, with the mongodb id as the hash key. The query, mongo, limit and selector keywords are used in the same way as for db.find. [Function] doc-id doc => result return the unique document id [Function] docs result => result Stop the iterator (if any) and return the list of documents returned by the query. Typical ue would be in conjunction with db.find like so (docs (iter (db.find 'foo' 'll))) [Standard class] document document Document class. A document consists of key/value pairs stored in a internal hash table plus an internally generated unique id. Accessors are : 'elements' which returns the internal hash table; '_id' which returns the unique id and '_local_id' which if true means that the document was generated by the client (as opposed to having been read from the server). [Function] generate-readme &key path => result This function generates a README.md file with the latest api description. The :path keyword specifies the location. It expects a sub-directory <path>/doc. Api documentation is generated on the fly, by extracting comments from the classes, generics and fuctions exported in the packages file. The resulting file is <path>/doc/index.html. <path>/README.md is generated by appending the api documentation to <path>/doc/readme-base.md. :path or *REPO-ROOT* are typically set to the root of the repository. [Generic function] get-element key document => result Get an element identified by key from the document. [Function] ht->document ht => result Convert a hash-table to a document. [Macro] install-js name => result Allows server based javascripts the be installed without being run. [Function] iter result &key mongo max-per-call => result Exhaustively iterate through a query. The maximum number of responses per query can be specified using the max-per-call keyword. [Macro] jsdef name => result Return the body of the javascript function; otherwise nill. [Generic function] kv a &rest rest => result This a helper function for key-value pairs and sets of key-value pairs. In a key-value pair like (kv key value) the key has to be a string and the value something which is serializable. key-value pairs can be combined using kv as well : (kv (kv key1 val1) (kv key2 val2)). This combination of key-value pairs is equivalent to a document without a unique id. The server will assign a unique is if a list of key-value pairs is saved. [Function] make-document &key oid size => result Constructor. key ':oid' is a user supplied unique id. An internal id will be generated if none is supplied. [Function] mapdoc fn document => result [Standard class] mongo Encapsulates the connection to the mongo database. Each connection is a added to a global registry. [Generic function] mongo &key host port db name host port db name => result This method returns the connection referred to by the name identifier from the connection registry. The connection name is unique. If no connection with that name exists, a new connection with the supplied or default host, port and db parameters will be created. The default host is localhost; the default port is 27017; the default db is admin. [Generic function] mongo-close name => result Close the connection to the mongo database. The name should uniquely identify the connection to close. This is either a mongo object or the name the object is bound to in the connection registry. To close all open connections use the special symbol 'all [Generic function] mongo-registered name => result Return a conection registered by this name or nil.. [Function] mongo-show => result Show all registered connections and their session id [Generic function] mongo-swap left right => result Swap the names of the left and right connections. Typical use would be `(mongo-swap :default :alt)`. After the function call :default will refer to the connection previously referred to as :alt. A connection named :default is returned by `(mongo)` and is the default used in the api. The connections are returned in the order they were passed in (but with the names swapped between them). To re-open a connection you can say `(mongo-close (mongo-swap :default (mongo :host <newhost> :portid <portid> :name :temp)))` and a new default connection is registered. [Function] mr.gc &key mongo => result remove the temporary collections created by map-reduce [Function] mr.gc.all &key mongo => result remove the all collections created by map-reduce, temporary as well as permanent [Function] mr.p results => result show the contents of the results collection map-reduce created [Function] nd result &key stream => result Pretty-print for non-document responses, like the response to a database command. [Function] now => result Return the current date and time in bson format. [Function] nwd => result Show the database set by the `(db.use -)` command [Generic function] pp result &key nd stream => result Pretty-print the results returned from a query. To be used on the repl. This will format each server reply as if it were a document. This is obviously ok in mosty cases. See nd for an alternative. [Macro] remove-js name => result [Function] ret result => result return value bound to retval in a return document. Used for db.count, db.distinct, functions etc.. [Function] rm collection query &key mongo => result Delete all the documents returned by a query. This is not an efficient way of deleting documents as it invloves multiple trips to the server. Mongo allows for execution of java-script on the server side, which provides an alternative. Typical use would be (rm (iter (db.find 'foo' (kv 'key' 1)))), which deletes all documents in foo, with field key equal to 1. [Generic function] rm-element key document => result Remove element identified by key from a document [Generic function] show things &key msg nl order => result Print a list of things. Things can be users, databases, collections in the current database, the profile and more. Things is a keyword so (show :users) will show all users. [Function] time-zone => result Set the time zone appropriate for the current environment. [Macro] with-mongo-connection args &rest body => result Creates a connection to a mongodb, makes it the default connection and evaluates the body form. args uses the same keyword set as mongo (:db :localhost :port) args is passed on to make-mongo when the connection is created.   Acknowledgements This documentation was prepared with DOCUMENTATION-TEMPLATE. $Header: /usr/local/cvsrep/documentation-template/output.lisp,v 1.14 2008/05/29 08:23:37 edi Exp $ BACK TO MY HOMEPAGE Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fons/cl-mongo"	"MongoDB client.."	"true"
"Database"	"cl-redis"	"https://github.com/vseloved/cl-redis"	"Redis client.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"100"	"7"	"22"	"GitHub - vseloved/cl-redis: Redis client for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 100 Fork 22 vseloved/cl-redis Code Issues 0 Pull requests 1 Wiki Pulse Graphs Redis client for Common Lisp 103 commits 1 branch 8 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show latest 2.3.0 2.2.0 2.1.0 2.0.0 1.6.0 1.5.0 1.0.0 Nothing to show New pull request Latest commit 268dce5 Jun 6, 2016 vseloved Merge pull request #26 from D4ryus/master … strings inside objects get converted to symbols Permalink Failed to load latest commit information. .gitignore LICENSE Metainformation update Nov 4, 2012 README.md fix default port typo in readme Oct 13, 2015 cl-redis.asd merge Mar 2, 2015 commands.lisp Add section support to command INFO May 24, 2016 connection.lisp Add :AUTH keyword to convenience connection macros. Dec 26, 2013 float.lisp Support for Redis 2.6. Simplified connection handling, added WITH-PER… Nov 3, 2012 package.lisp Updated to v.3.0.0 Mar 2, 2015 redis.lisp strings inside objects get converted to symbols Jun 5, 2016 test.lisp merge Mar 2, 2015 README.md CL-REDIS — A fast and robust Common Lisp client for Redis (tested with Redis version 3.0.0 (2.9.104 to be precise)) Usage Quickstart Make sure a Redis server is running. (ql:quickload 'cl-redis) Connect to the server to the given host and port with (redis:connect :host <host> :port <port>) (host defaults to 127.0.0.1, port — to 6379). Interact with the server using Redis commands from the red package. CL-USER> (red:ping) ""PONG""  Disconnect from the server with (redis:disconnect). Alternatively, wrap the whole interaction session in with-connection macro, which accepts the same arguments as connect does, opens a socket connection, executes the body of the macro with the current connection (*connection*) bound to this new connection, and ensures that the connection is closed afterwards. Available commands Code organization The system provides 2 packages: REDIS and RED. All the functionality is available from the REDIS package. Not to cause symbol clashes, Redis commands are defined in this package with a prefix (which defaults to red- and is set at compilation time). The package RED is a syntactic sugar — it just provides the Redis commands without a prefix. So it is not intended to be imported to avoid symbol conflicts with package COMMON-LISP — just use the package-qualified symbol names: i.e. the same Redis command (for instance GET) can be called as RED-GET (if you import the REDIS package) or RED:GET. Installation Available through quicklisp. Dependencies usocket flexi-streams rutils only for tests: nuts, bordeaux-threads Debugging and error recovery If *echo-p* is T, all client-server communications will be echoed to the stream *echo-stream*, which defaults to *standard-output*. Error handling is mimicked after Postmodern. In particular, whenever an error occurs that breaks the communication stream, a condition of type redis-connection-error is signalled offering a :reconnect restart. If it is selected the whole Redis command will be resent, if the reconnection attempt succeeds. Furthermore, connect checks if a connection to Redis is already established, and offers two restarts (:leave and :replace) if this is the case. When the server respondes with an error reply (i.e., a reply that starts with -), a condition of type redis-error-reply is signalled. There's also a high-level with-persistent-connection macro, that tries to do the right thing™ (i.e. automatically reopen the connection once, if it is broken). Advanced usage PubSub Since there's no special command to receive messages from Redis via PubSub here's how you do it: (bt:make-thread (lambda ()                   (with-connection ()                     (red:subscribe ""foo"")                     (loop :for msg := (expect :anything) :do                       (print msg))))                 ""pubsub-listener"")  To publish, obviously: (with-connection ()   (red:publish ""foo"" ""test""))  Pipelining For better performance Redis allows to pipeline commands and delay receiving results until the end, and process them all in oine batch afterwards. To support that there's with-pipelining macro. Compare execution times in the following examples (with pipelining and without: 6.567 secs vs. 2023.924 secs!): (let ((names (let (acc)                (dotimes (i 1000 (nreverse acc))                  (push (format nil ""n~a"" i) acc))))       (vals  (let (big-acc)                (dotimes (i 1000 (nreverse big-acc))                  (let (acc)                    (dotimes (i (random 100))                      (push (list (random 10) (format nil ""n~a"" i)) acc))                    (push (nreverse acc) big-acc))))))   (time (redis:with-connection ()           (redis:with-pipelining             (loop :for k :in names :for val :in vals :do               (dolist (v val)                 (apply #'red:zadd k v)))             (red:zunionstore ""result"" (length names) names)             (red:zrange ""result"" 0 -1))))    ;; Evaluation took:   ;;  6.567 seconds of real time   ;;  3.900243 seconds of total run time (3.200200 user, 0.700043 system)    (time (redis:with-connection ()           (loop :for k :in names :for val :in vals :do             (dolist (v val)               (apply #'red:zadd k v)))           (red:zunionstore ""result"" (length names) names)           (red:zrange ""result"" 0 -1))))    ;; Evaluation took:   ;; 2023.924 seconds of real time   ;; 3.560222 seconds of total run time (2.976186 user, 0.584036 system)  Note, that with-pipelining calls theoretically may nest, but the results will only be available to the highest-level pipeline, all the nested pipelines will return :PIPELINED. So a warining is signalled in this situation. Internals Generic functions tell and expect implement the Redis protocol according to the spec. tell specifies how a request to Redis is formatted, expect — how the response is handled. The best way to implement another method on expect is usually with def-expect-method, which arranges reading data from the socket and provides a variable reply, which holds the decoded reply data from the server with the initial character removed. For example: (def-expect-method :ok   (assert (string= reply ""OK""))   reply)  Redis operations are defined as ordinary functions by def-cmd for which only arguments and return type should be provided. def-cmd prefixes all the defined functions' names with *cmd-prefix*, which defaults to 'red. (Note, that setting of *cmd-prefix* will have its effects at compile time). It also exports them from REDIS package, and from RED package without the prefix. An example of command definition is given below: (def-cmd KEYS (pattern) :multi   ""Return all the keys matching the given pattern."")  See commands.lisp for all defined commands. Not implemented The following commands are not implemented, because they are not intended for use in client: MONITOR, DEBUG OBJECT, and DEBUG SEGFAULT. Support for Unix domain sockets — planned Consistent hashing isn't built-in. Actually, such thing is orthogonal to the functionality of this library and, probably, should be implemented in a separate library. Connection pooling is also not implemented, because in the presence of with-persistent-connection it is actually not needed so much. Persistent connections are more simple, efficient and less error-prone for dedicated threads. But there are other use-cases for pooling, so it will probably be implemented in future releases. Credits The library is developed and maintained by Vsevolod Dyomkin vseloved@gmail.com. At the initial stages Alexandr Manzyuk manzyuk@googlemail.com developed the connection handling code following the implementation in Postmodern. It was since partially rewritten to accommodate more advanced connection handling strategies, like persistent connection. License MIT (See LICENSE file for details). Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/vseloved/cl-redis"	"Redis client.."	"true"
"Database"	"cl-disque"	"https://github.com/CodyReichert/cl-disque"	"Disque client.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"6"	"1"	"1"	"GitHub - CodyReichert/cl-disque: A Disque client for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 1 Star 6 Fork 1 CodyReichert/cl-disque Code Issues 0 Pull requests 0 Pulse Graphs A Disque client for Common Lisp 20 commits 1 branch 0 releases Fetching contributors Common Lisp 98.3% Makefile 1.7% Common Lisp Makefile Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src t .gitignore LICENSE Makefile README.org cl-disque-test.asd cl-disque.asd README.org CL-DISQUE A Disque client for Common Lisp. Disque is an in-memory job queue and message broker. It’s distributed and fault-tolerant so it works as a middle layer among processes that want to exchange messages. Learn more about message queues here, and more about the Disque implementation here. cl-disque provides a client for working with Disque through sending and receiving jobs and commands. Usage Quickstart First, make sure a Disque server is running. Load cl-disque and connect to the Disque server on the given host and port: (ql:quickload 'cl-disque)  ; host defaults to 127.0.0.1, port defaults to 7711 (cl-disque:connect :host <host> :port <port>) You can interact with the server using commands from the disque package. (disque:hello) ;=> (1 ""node-id"" ;    (""node-ids"" ""host"" ""7711"" ""1"")) Disconnect from the Disque server with: (cl-disque:disconnect) Alternatively, you can wrap all interactions in the with-connection macro, which creates a new connection to execute the given body, and assures a disconnect afterwards: (cl-disque:with-connection ()   (disque:addjob ""queue"" ""job"" 0)   (disque:getjob ""queue"" 1)) ;=> ((""queue"" ""job-hash"" ""job"")) The Makefile offers a couple of commands for running the test-suite and loading cl-disque into an SBCL repl: # To run the test suite $ make test # To load an SBCL repl $ make sbcl-repl Available commands Cl-Disque supports all of the Disque client commands and their arguments. See The Disque Documentation for more specifics on each command INFO Args: () Response-type: :bulk HELLO Args: () Response-type: :multi QLEN Args: (queue) Response-type: :integer QPEEK Args: (queue count) Response-type: :multi QSCAN Args: (&rest args &key count busyloop minlen maxlen importrate) Response-type: :multi GETJOB Args: (queues &rest args &key nohang timeout count withcounters) Reponse-type: :multi Note: queues can either be a single queue or a list of queues: (disque:getjob ""queue1"") ;; or (disque:getjob '(""queue1"" ""queue2"" ""queue3"") ADDJOB Args: (queue job timeout &rest args &key replicate delay retry ttl maxlen async) Response-type: :status ACKJOB Args: (job &rest jobs) Response-type: :integer FASTACK Args: (job &rest jobs) Response-type: :integer WORKING Args: (job) Response-type: :integer NACK Args: (job &rest jobs) Response-type: :integer ENQUEUE Args: (job &rest jobs) Reponse-type: :integer DEQUEUE Args: (job &rest jobs) Response-type :integer DELJOB Args: (job &rest jobs) Response-type: :integer SHOW Args: (job) Response-type: :multi JSCAN Args: (cursor &rest args &key count blocking queue state reply) Response-type: :multi Code organization The system provides two packages: CL-DISQUE and DISQUE. Everything is available in the CL-DISQUE package. The DISQUE package contains all of the commands for interacting with a Disque server. This is simply syntactic sugar, as all of the commands are also available in the CL-DISQUE package with a command prefix. For Example: (disque:info) ; is the same as (cl-disque:disque-info) Installation Git clone this repo into your ~/quicklisp/local-projects/ directory, and (ql:quickload :cl-disque). Dependencies usocket flexi-streams rutils prove (only for tests) Debugging and error recovery If *echo-p* is T, all client-server communications will be echoed to the stream *echo-stream*, which defaults to *standard-output*. Error handling is mimicked after Postmodern. In particular, whenever an error occurs that breaks the communication stream, a condition of type disque-connection-error is signalled offering a :reconnect restart. If it is selected the whole Disque command will be resent, if the reconnection attempt succeeds. Furthermore, connect checks if a connection to Disque is already established, and offers two restarts (:leave and :replace) if this is the case. When the server respondes with an error reply a condition of type disque-error-reply is signalled. There’s also a high-level with-persistent-connection macro, that tries to do the right thing™ (i.e. automatically reopen the connection once, if it is broken). Advanced usage Pipelining For better performance Disque allows to pipeline commands and delay receiving results until the end, and process them all in oine batch afterwards. To support that there’s with-pipelining macro. Note, that with-pipelining calls theoretically may nest, but the results will only be available to the highest-level pipeline, all the nested pipelines will return :PIPELINED. So a warining is signalled in this situation. Note: Pipelining has not been tested since being ported form cl-redis. Credits Cody Reichert <codyreichert@gmail.com> is the maintainer of CL-DISQUE. CL-DISQUE is a ported of the CL-REDIS client, which is developed and maintained by Vsevolod Dyomkin <vseloved@gmail.com>. Many thanks to him for implementing the protocol and providing most of the internals. Alexandr Manzyuk <manzyuk@googlemail.com> also contributed to CL-REDIS client and developed the connection handling code following the implementation in Postmodern. It was since partially rewritten to accommodate more advanced connection handling strategies, like persistent connection. License MIT (See LICENSE file for details). Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/CodyReichert/cl-disque"	"Disque client.."	"true"
"Database"	"cl-rethinkdb"	"https://github.com/orthecreedence/cl-rethinkdb"	"RethinkDB client.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"37"	"3"	"5"	"GitHub - orthecreedence/cl-rethinkdb: RethinkDB driver for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 37 Fork 5 orthecreedence/cl-rethinkdb Code Issues 7 Pull requests 0 Pulse Graphs RethinkDB driver for Common Lisp 211 commits 5 branches 0 releases Fetching contributors Common Lisp 56.9% Protocol Buffer 42.2% Shell 0.9% Common Lisp Protocol Buffer Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master v1.11.x v1.12.4 v1.15.x v2.0.x Nothing to show Nothing to show New pull request Latest commit f435e72 Jul 8, 2016 orthecreedence fixing ref to non-existent state var, replacing with :wait state. hon… … …estly, not too sure of the implications here, but it seems having a :wait state is fine? Permalink Failed to load latest commit information. reql scripts test LICENSE README.md cl-rethinkdb-test.asd cl-rethinkdb.asd config.lisp connection.lisp fixing some promise junk. this makes a few things work more as expect… May 17, 2015 package.lisp fixing some promise junk. this makes a few things work more as expect… May 18, 2015 protocol.lisp query.lisp util.lisp README.md cl-rethinkdb - RethinkDB driver for Common Lisp This is an async RethinkDB driver for everyone's favorite programming language. It does its best to follow the query language specification. If it's missing any functions or has implemented any of them incorrectly, please open an issue. This driver is up to date with RethinkDB's v2.0.x protocol. As with most of my drivers, cl-rethinkdb requires cl-async, and makes heavy use of cl-async's promises. This driver is built so that later on, more than one TCP backend can be used. Right now, the only one implemented is cl-async, but usocket/IOLib could just as easily be used if someone puts in the time. Documentation The driver makes extensive use of promises, as mentioned, so be sure to know your way around the promise syntax macros when using it. Everything needed to use the driver is exported out of the cl-rethinkdb package, which has the nickname r. DSL cl-rethinkdb makes use of a query DSL that maps keyword function calls to normal function calls. It does this so that predefined common lisp functions can be used instead of giving them rediculous names to avoid naming clashes. The DSL is activated by using either the r macro (used to build query forms) or the fn macro (used to build anonymous functions). Note that this section only covers the DSL itself. Check out the full list of commands to start building the query of your dreams. r (macro) This macro translates keyword functions into ReQL function calls: ;; grab first 10 records from the `users` table (r (:limit (:table ""users"") 10)) This translates to (cl-rethinkdb-reql::limit (cl-rethinkdb-reql::table ""users"") 10) fn (macro) This macro creates an anonymous function for use in a RethinkDB query. It works very much like the r macro, and in fact wraps its inner forms in r so that you can use the query DSL from within a function. ;; return an anonymous function that adds `3` to the given argument (fn (x) (:+ x 3)) Functions can be mixed in with r queries: ;; find all users older than 24 (r (:filter (:table ""users"")             (fn (user)               (:< 24 (:attr user ""age""))))) Note how inside the fn body, we're still using functions prefixed with :. Sending queries and getting results Once you've constructed a query via r, you need to send it to the server. When the server responds successfully, you will get either an atom (a single value: integer, boolean, hash, array, etc). or a cursor which provides an interface to iterate over a set of atoms. connect (function) (defun connect (host port &key db use-outdated noreply profile read-timeout auth))   => promise (tcp-socket) Connects a socket to the given host/port and returns a promise that's finished with the socket. Usage: (alet ((sock (connect ""127.0.0.1"" 28015 :db ""test"")))   ;; ... do stuff ...   (disconnect sock)) run (function) (defun run (sock query-form))   => promise (atom/cursor profile-data) Run a query against the given socket (connected using connect). Returns a promise finished with either the atom the query returns or a cursor to the query results. If profile is t when calling connect, the second promise value will be the profile data returned with the query. run can signal the following errors on the promise it returns: query-client-error query-compile-error query-runtime-error Example (alet* ((sock (connect ""127.0.0.1"" 28015))         (query (r (:get (:table ""users"") 12)))  ; get user id 12         (value (run sock query)))   (format t ""My user is: ~s~%"" value)   (disconnect sock)) wait-complete (function) (defun wait-complete (sock))   => promise (t) Waits for all queries sent on this socket with noreply => t to finish. This lets you queue up a number of write operations on a socket. You can then call wait-complete on the socket and it will return the response when all the queued operations finish. cursor (class) The cursor class keeps track of queries where a sequence of results is returned (as opposed to an atom). It is generally opaque, having no public accessors. Cursor functions/methods: cursorp next has-next to-sequence to-array each stop stop/disconnect cursorp (function) (defun cursorp (cursor))   => t/nil Convenience function to tell if the given object is a cursor. next (function) (defun next (sock cursor))   => promise (atom) Gets the next result from a cursor. Returns a promise that's finished with the next result. The result could be stored locally already, but it also may need to be retrieved from the server. next can signal two errors on the promise it returns: cursor-overshot cursor-no-more-results (alet* ((sock (connect ""127.0.0.1"" 28015))         (query (r (:table ""users"")))  ; get all users         (cursor (run sock query)))   ;; grab the first result from the cursor.   (alet ((user (next sock cursor)))     (format t ""first user is: ~s~%"" user)     ;; let's grab another user     (alet ((user (next sock cursor)))       (format t ""second user is: ~s~%"" user)       ;; let the server/driver know we're done with this result set       (stop/disconnect sock cursor)))) has-next (function) (defun has-next (cursor))   => t/nil Determines if a cursor has more results available. to-sequence (function) (defun to-sequence (sock cursor))   => promise (sequence) Given a socket and a cursor, to-sequence grabs ALL the results from the cursor, going out to the server to get more if it has to, and returns them as a sequence through the returned promise. The sequence type (vector/list) depends on the value of *sequence-type*. to-array (function) (defun to-array (sock cursor))   => promise (vector) Given a socket and a cursor, to-array grabs ALL the results from the cursor, going out to the server to get more if it has to, and returns them as an array through the returned promise. (alet* ((sock (connect ""127.0.0.1"" 28015))         (query (r (:table ""users"")))  ; get all users         (cursor (run sock query))         (all-records (to-array sock cursor)))   (format t ""All users: ~s~%"" all-records)   ;; cleanup   (stop/disconnect sock cursor)) Don't call to-array on a cursor returned from a changefeed. It will just sit there endlessly saving results to a list it will never return. each (function) (defun each (sock cursor function))   => promise Call the given function on each of the results of a cursor. The returned promise is finished when all results have been iterated over. (alet* ((sock (connect ""127.0.0.1"" 28015))         (cursor (run sock (r (:table ""users"")))))   ;; print each user   (wait (each sock cursor           (lambda (x) (format t ""user: ~s~%"" x)))     ;; cleanup     (wait (stop sock cursor)       (disconnect sock)))) each is the function you want to use for listening to changes on a cursor that is returned from a changefeed. stop (function) (defun stop (sock cursor))   => promise Stops a currently open query/cursor. This cleans up the cursor locally, and also lets RethinkDB know that the results for this cursor are no longer needed. Returns a promise that is finished with no values when the operation is complete. stop/disconnect (function) (defun stop/disconnect (sock cursor))   => nil Calls stop on a cursor, and after the stop operation is done closes the passed socket. Useful as a final termination to an operation that uses a cursor. Note that this function checks if the object passed is indeed a cursor, and if not, just disconnects the socket without throwing any errors. disconnect (function) (defun disconnect (sock))   => nil Disconnect a connection to a RethinkDB server. Binary data Binary data is now part of the driver. Using it is simple...you pass in an unsigned byte array (ie (simple-erray (unsigned-byte 8) (*))) and the driver will handle encoding of the binary data for you. Binary data passed in must be of the unsigned-byte type, or your data will just be encoded as an array (or whatever type it actually is). When an object is returned that has binary data, the driver converts it back to an unsigned byte array. You can also force usage of the binary type by using the (:binary ...) type in the DSL. It takes 1 argument: a base64 string of your data. Note, however, that if you do use (:binary ""ZG93biB3aXRoIHRoZSBvcHByZXNzaXZlIGNhcGl0YWxpc3QgcmVnaW1l""), when you pull that document out, the data will be encoded as a raw unsigned-byte array (not a base64 string). Config These mainly have to do with how you want data returned. *sequence-type* When a sequence is returned from RethinkDB, it can be either returned as a list (if *sequence-type* is :list or as a vector (if *sequence-type* is :array). It's really a matter of preference on how you're going to access the data. (But you may also want to read on-sequence-type for a warning about round tripping rethinkdb documents while using :list). Default: :list *object-type* If an object (as in, key/value object) is returned from RethinkDB, it can be encoded as a hash table (if *object-type* is :hash) or as an association list (if *object-type* is :alist). Hash tables are almost always more performant, but alists can be easier to debug. Your choice. Default: :hash Thread safety cl-rethinkdb stores all its global state in one variable: *state*, which is exported in the cl-rethinkdb package. The *state* variable is an instance of the cl-rethinkdb:state CLOS class. This lets you declare a thread-local variable when starting a thread so there are no collisions when accessing the library from multiple threads: (let ((cl-rethinkdb:*state* (make-instance 'cl-rethinkdb:state)))   (as:with-event-loop ()     ;; run queries in this context     )) Using let in the above context declares *state* as a thread local variable, as opposed to using setf, which will just modify the global, shared context. Be sure that the let form happens at the start of the thread and encompasses the event loop form. Commands All of the following are accessible via the r DSL macro by prefixing the name with a :. So (table ""users"") becomes (:table ""users""). These are almost 100% compatible with the ReQL specification, so if you familiarize yourself with the query language, you will automatically get a good handle on the following. For a better understanding of the return types of the following commands, see the REQL type hierarchy in the protobuf specification. db (db-name) => database db-drop (db-name) => object db-list () => object table-create (db table-name &key datacenter primary-key durability) => object table-drop (db table-name) => object table-list (db) => object sync (table) => object index-create (table name &key function multi) => object index-drop (table name) => object index-list (table) => array index-status (table &rest names) => array index-wait (table &rest names) => array changes (select &key squash include-states) => cursor args (arg-list) => special binary (base64-string) => binary insert (table sequence/object &key conflict durability return-changes) => object update (select object/function &key non-atomic durability return-changes) => object replace (select object/function &key non-atomic durability return-changes) => object delete (select &key durability return-changes) => object db (db-name) => db table (db table-name &key read-mode identifier-format) => sequence get (table item-id) => object get-all (table key/keys &key index) => array (key/keys can be either a string type or a list of string types) between (sequence left right &key index) => sequence minval () => constant maxval () => constant filter (sequence object/function &key default) => sequence inner-join (sequence1 sequence2 function) => sequence outer-join (sequence1 sequence2 function) => sequence eq-join (sequence1 field sequence2 &key index) => sequence zip (sequence) => sequence map (sequence function) => sequence with-fields (sequence &rest strings) => sequence concat-map (sequence function) => sequence order-by (sequence field &rest fields) => sequence asc (field) => field desc (field) => field skip (sequence number) => sequence limit (sequence number) => sequence slice (sequence start end) => sequence nth (sequence number) => object offsets-of (sequence object/reql-function) => sequence is-empty (sequence) => boolean union (sequence &rest sequences) => sequence sample (sequence count) => sequence random (lower &optional upper &key float) => number group (sequence fields-or-functions &key index) => grouped_sequence ungroup (grouped-sequence) => sequence reduce (sequence function) => object count (sequence &optional object/reql-function) => number sum (sequence &optional field-or-function) => number avg (sequence &optional field-or-function) => number min (sequence &optional field-or-function) => type-of-object-in-sequence max (sequence &optional field-or-function) => type-of-object-in-sequence distinct (sequence) => sequence contains (sequence object) => boolean count-reduce () => function sum-reduce (field) => function avg-reduce (field) => function attr (object field) => object row (&optional field) => object pluck (sequence/object field &rest fields) => sequence/object without (sequence/object field &rest fields) => sequence/object merge (object &rest objects) => object append (array object) => array prepend (array object) => array difference (array1 array2) => array set-insert (array object) => array set-intersection (array1 array2) => array set-union (array1 array2) => array set-difference (array1 array2) => array has-fields (object string &rest strings) => bool insert-at (array index object) => array splice-at (array1 index array2) => array delete-at (array index) => array change-at (array index object) => array keys (object) => array object (key val &rest) => object \+ (number/string &rest numbers/strings) => number/string \- (number &rest numbers) => number \* (number &rest numbers) => number / (number &rest numbers) => number % (number mod) => number && (boolean &rest booleans) => boolean || (boolean &rest booleans) => boolean == (object &rest objects) => boolean != (object &rest objects) => boolean < (object &rest objects) => boolean <= (object &rest objects) => boolean > (object &rest objects) => boolean >= (object &rest objects) => boolean ~ (boolean) => boolean match (string string-regex) => object split (string &optional separator max-splits) => array upcase (string) => string downcase (string) => string now () => time time (timezone year month day &optional hour minute second) => time epoch-time (timestamp) => time iso8601 (date &key timezone) => time in-timezone (time timezone) => time timezone (time) => string during (time start end) => boolean date (time) => time time-of-day (time) => number year (time) => number month (time) => number day (time) => number day-of-week (time) => number day-of-year (time) => number hours (time) => number minutes (time) => number seconds (time) => number to-iso8601 (time) => string to-epoch-time (time) => number monday () => time tuesday () => time wednesday () => time thursday () => time friday () => time saturday () => time sunday () => time january () => time february () => time march () => time april () => time may () => time june () => time july () => time august () => time september () => time october () => time november () => time december () => time do (function &rest args) => object branch (boolean true-expr false-expr) => object for-each (sequence function) => object error (message) => error default (top1 top2) => top expr (lisp-object) => RethinkDB object js (javascript-str) => object/function coerce-to (object type) => object typeof (object) => type-string info (object) => object json (string) => object to-json-string (object) => string literal (&optional object) => object geojson (object)) => geometry to-geojson (geo)) => object point (lat long)) => geometry line (&rest array/geo)) => geometry polygon (&rest array/geo)) => geometry distance (geo-from geo-to &key geo-system unit)) => number intersects (geo1 geo2)) => bool includes (geo1 geo2)) => bool circle (geo radius &key num-vertices geo-system unit fill)) => geometry get-intersecting (table geo &key index)) => stream fill (geo)) => geometry get-nearest (table geo &key index max-results max-dist geo-system unit)) => array polygon-sub (geo1 geo2)) => geometry Errors These are the errors you may encounter while using this driver. Most (if not all) errors will be signalled on a promise instead of thrown directly. Errors on a promise can be caught via catcher. query-error A general query error. query-client-error extends query-error Thrown when the driver sucks. If you get this, open an issue. query-compile-error extends query-error Thrown when a query cannot compile. If you get this, take a close look at your query forms. query-runtime-error extends query-error Thrown when the database has a runtime error. cursor-error A general error with a cursor. cursor-overshot extends cursor-error Thrown when next is called on a cursor, but the cursor is currently grabbing more results. cursor-no-more-results extends cursor-error Thrown when next is called on a cursor that has no more results. You can test this by using has-next. reql-error A REQL error. This is thrown when there's an error in the returned REQL data from the database. For instance, if a time value comes back without a timestamp or binary data type comes back without the payload. Generally, if the database itself is functioning correctly, you won't see this error. License MIT. Enjoy. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/orthecreedence/cl-rethinkdb"	"RethinkDB client.."	"true"
"Database"	"cl-sqlite"	"https://github.com/dmitryvk/cl-sqlite"	"Bindings for SQLite. Public domain."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"27"	"5"	"10"	"GitHub - dmitryvk/cl-sqlite: Common Lisp binding for SQLite Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 27 Fork 10 dmitryvk/cl-sqlite Code Issues 4 Pull requests 3 Pulse Graphs Common Lisp binding for SQLite http://common-lisp.net/project/cl-sqlite/ 38 commits 2 branches 7 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show 0.2 0.1.6 0.1.5 0.1.4 0.1.3 0.1.2 0.1.1 Nothing to show New pull request Latest commit c738e66 May 10, 2011 galdor committed with dmitryvk implement the asdf test-op for the sqlite system Permalink Failed to load latest commit information. cache.lisp index.html sqlite-ffi.lisp sqlite-tests.asd sqlite-tests.lisp sqlite.asd sqlite.lisp style.css Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/dmitryvk/cl-sqlite"	"Bindings for SQLite. Public domain."	"true"
"Database"	"clsql"	"http://www.cliki.net/CLSQL"	"An SQL database with a Common Lisp interface.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"CLiki: CLSQL CLiki - CLSQL CLSQL CLSQL is a Database interface that can access a number of different SQL database engines. It also includes a CLOS ORM. It is maintained by Kevin Rosenberg. CLSQL now includes the CommonSQL API interface. CLSQL's manual is online at http://clsql.kpe.io/documentation.html. CLSQL uses the UFFI interface so it works on: SBCL CMUCL OpenMCL AllegroCL Lispworks SCL CLISP CLSQL supports a number of database interfaces: PostgreSQL C library API PostgreSQL Socket API MySQL SQLite 2 SQLite 3 Oracle ODBC (On all platforms) AODBC (Allegro's ODBC database interface) Not all features are supported on all DBMSes. For example, CLSQL's OODDL does not support :auto-increment on sqlite3. There are CLSQL packages in the Debian and Gentoo distributions. CLSQL is covered by the LGPL license. CLSQL can be downloaded from its web site or ASDF-install package (obsolete) http://files.kpe.io/clsql/clsql-latest.tar.gz Additional Documentation Bill Clementson has written two entries about CLSQL, in his web log: CL-SQL - Part 1 - discussing some of the advantages of CLSQL and how to install it. CL-SQL - Part 2 - an interactive, annotated session using CLSQL, illustrating some of the characteristics of working with CLSQL To quote his Part 1: If you would like to see some more examples of how to use CLSQL, the CLSQL tutorial is quite useful. Also, the tremendous CommonSQL tutorial that Nick Levine gave at ILC2002 is an excellent introduction to CLSQL. Even though his tutorial is targetted towards LispWorks CommonSQL, the examples work equally well in CLSQL (with the occasional minor tweak). Looping over query result Iterate supports looping over CLSQL queries through the use of iterate-clsql extension. Lispbox workaround You may get an error claiming that CLSQL can't find ""foreign libraries."" Find the directory where those files are located, and use clsql:push-library-path. They will likely be wherever CLSQL was installed, for example: (clsql:push-library-path #p""/home/myusername/.sbcl/site/clsql-3.5.6/db-mysql/"") ;installed here by asdf-install This may also occur with OpenMCL; same solution. Multithreaded usage This is not obvious from the documentation, but just using CONNECT gives you a single database connection - if you try to use that connection in multiple threads, you will get nasty race conditions. One convenient way to use CLSQL with multiple threads is to use the WITH-DATABASE macro around any code that talks to the database. Using connection pools, this is quite efficient, and thread-safe. Current version History Backlinks Edit Create Home Recent Changes About Text Formatting Tools Search CLiki CLiki the common lisp wiki Account name Password register"	"null"	"null"	"An SQL database with a Common Lisp interface.."	"true"
"Database"	"clache"	"https://github.com/html/clache"	"General caching facility. No license specified."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"0"	"2"	"1"	"GitHub - html/clache: General Caching Facility for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 0 Fork 1 html/clache forked from m2ym/clache Code Pull requests 0 Pulse Graphs General Caching Facility for Common Lisp 15 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Pull request Compare This branch is 2 commits ahead of m2ym:master. Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. examples src tests .gitignore README.markdown clache-test.asd clache.asd version.lisp-expr README.markdown CLACHE CLACHE is a general caching library for Common Lisp. Overview CLACHE provides a general caching facility for Common Lisp. The API is similar with standard hash-table interface. Let me show you an overview of API. getcache - Get cache from storage setcache - Store cache into storage remcache - Remove cache from storage clrcache - Clear all cache in storage As you can see, it is easy to use. Here is an example: ;; Store cache (setcache 1 ""foo"") ;;=> 1  ;; Get cache (getcache 1) ;;=> 1, T  ;; Get non-exited cache (getcache 42) ;;=> NIL, NIL  ;; Remove cache (remcache 1) ;;=> T  ;; Clear all cache (clrcache)  API Caches A cache is a triple of a key, a value, and an expiration time. Cache Keys Any object can be used as a cache key if the object can be converted into a string properly by using cache-key-to-string. Cache Values Same as cache keys, any object can be used as a cache value. However, a type of cache values can be limited by storages. So you have to be careful what storage are you using. Expiration Time An expiration time describes how long caches live in seconds. If an expiration time is nil, such caches will never be expired: persistent cache. Cache Existence If a cache is stored in a storage and has not yet been expired or a persitent cache, we express the cache exists in the storage. Storages Storage is an abstract layer of maintaining caches. You can access storages via API. Default Storage Function: getcache getcache key &optional storage  Retrieve a cache value from storage indicated by key and return values of the cache value and a boolean whether the cache exists in storage. The cache value will be nil if such the cache doesn't exist. For example, (getcache ""not-existed-cache"") will return nil, nil. Function: setcache setcache key value &optional expire storage  Store a cache value into storage with key and expire. expire is an expiration time in seconds. If expire is nil, the cache will never be expired. The return value is value that has been stored. Function: (setf getcache) (setf getcache) value key &optional expire storage  Same as setcache. Function: remcache remcache key &optional storage  Remove a cache from storage indicated by key. If the cache has been successfully removed, this function returns t, otherwise returns nil. Function: clrcache clrcache &optional storage  Remove all caches from storage. The return value is undefined. Macro: with-cache Annotation: cache Protocol Supported Implementations Allegro CL v8.2 SBCL v1.0.47 CMU CL v20b Clozure CL v1.6 ECL v11.1.1 GNU CLISP v2.48 Copyright (C) 2011 Tomohiro Matsuyama <tomo@cx4a.org> Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/html/clache"	"General caching facility. No license specified."	"true"
"Database"	"clouchdb"	"https://common-lisp.net/project/clouchdb/"	"Library for interacting with CouchDB.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"null"	"null"	"null"	"clouchdb  clouchdb A Common Lisp library for interacting with CouchDb databases. Overview Clouchdb is a Common Lisp library for interacting with CouchDb databases. CouchDb is a document based database server. Clouchdb comes with a BSD Style License for maximum agreeableness. Author: Peter Eddy (peter.eddy at the gmail.com) Contents Download and Installation Examples Support and mailing lists API Reference Symbol Index Download and Installation The current download link for clouchdb can be found at Clicki.net. Clouchdb may also be installed with ASDF. Requirements: Drakma cl-json Parenscript LIFT testing framework An available CouchDb server, current supported version is 0.7 ASDF Install Something like the following should be all that's necessary to install and load clouchdb using ASDF-INSTALL:  (asdf-install:install 'clouchdb)   (asdf:oos 'asdf:load-op '#:clouchdb)  ASDF-INSTALL will install library dependencies, though you must install a CouchDb server separately. Unit tests The clouchdb distribution comes with a unit test suite which uses the LIFT testing framework. To run the tests, follow the following steps:  (asdf:oos 'asdf:load-op '#:clouchdb-tests) (in-package :clouchdb-tests) (run-all-tests)  Note that if the CouchDb server is not running on the same host you will have to modify tests.lisp to point it to the appropriate host. Examples The distribution also includes an examples package:  (asdf:oos 'asdf:load-op '#:clouchdb-examples) (in-package :clouchdb-examples) (example1) (example2)  Be sure to look at examples.lisp to understand what each example is doing. Support and mailing lists The following email lists have been provided by the common-lisp.net for clouchdb development and information: clouchdb-announce clouchdb-devel Examples The following clouchdb SLIME sessions demonstrate various aspects of the three major functional areas of the CouchDb API: Database API, Document API and View API. NB: If you try these examples I suggest also viewing the results via CouchDb's HTML UI at http://localhost:8888/_utils/browse/index.html, of course you'll need to adjust the URL for the actual CouchDb server and port in use. Example 1 The following example session demonstrates: Setting the CouchDb host and database name Finding CouchDb server version Creation of a database Creation of a document in that database Fetching a document and adding a new field  ;; Create a package to try out clouchdb CL-USER> (defpackage :clouchdb-user (:use :cl :clouchdb :parenscript)) #<Package ""CLOUCHDB-USER""> CL-USER> (in-package :clouchdb-user) #<Package ""CLOUCHDB-USER""> ;; Set our CouchDb host (default is ""localhost""), and the database name for  ;; the examples CLOUCHDB-USER> (set-connection :host ""odeon"" :db-name ""test-db"") ; No value ;; Get CouchDb Server Information by specifying a nil DB name CLOUCHDB-USER> (get-db-info :db-name nil) ((:COUCHDB . ""Welcome"") (:VERSION . ""0.7.0a575"")) ;; Create the database CLOUCHDB-USER> (create-db) ((:OK . T)) ;; Create a document with one field, and give it an ID of ""gjc"" CLOUCHDB-USER> (create-document '((:name . ""Gaius Julius Caesar"")) :id ""gjc"") ((:OK . T) (:ID . ""gjc"") (:REV . ""1479031852"")) ;; Fetch the document we just created  CLOUCHDB-USER> (get-document ""gjc"") ((:_ID . ""gjc"") (:_REV . ""1479031852"") (:NAME . ""Gaius Julius Caesar"")) ;; Add a field to ""gjc"" CLOUCHDB-USER> (put-document (cons '(:lover . ""Servilia Caepionis"") *)) ((:OK . T) (:ID . ""gjc"") (:REV . ""1460552879"")) ;; Get the updated document CLOUCHDB-USER> (get-document ""gjc"") ((:_ID . ""gjc"") (:_REV . ""1460552879"") (:LOVER . ""Servilia Caepionis"")   (:NAME . ""Gaius Julius Caesar""))  Example 2 Demonstrating: Recreating a database Creating a document that uses a CouchDb generated ID Updating a document value Viewing document revision information Fetching an old document revision Creating a document with array and map field values  ;; Create, or drop and recreate, the current database CLOUCHDB-USER> (create-db :if-exists :recreate) ((:OK . T)) ;; Create a document that will have it's ID assigned by the CouchDb server CLOUCHDB-USER> (create-document '((:size . ""medium"") (:color . ""blue""))) ((:OK . T) (:ID . ""C731D3A3698DA144FB35EDA9737917F2"") (:REV . ""3363852140"")) ;; CouchDb generated IDs are too large to use easily in an ;; interactive example like this, so create another document ;; with a shorter ID to demonstrate property value updates CLOUCHDB-USER> (create-document '((:size . ""large"") (:color . ""blue""))                                  :id ""someid"") ((:OK . T) (:ID . ""someid"") (:REV . ""3181950830"")) ;; Change :color property CLOUCHDB-USER> (let ((doc (get-document ""someid"")))                  (setf (document-property :color doc) ""green"")                  (put-document doc)) ((:OK . T) (:ID . ""someid"") (:REV . ""4275808446"")) ;; Show that the new property stuck CLOUCHDB-USER> (get-document ""someid"") ((:_ID . ""someid"") (:_REV . ""4275808446"") (:SIZE . ""large"") (:COLOR . ""green"")) ;; Get revision information for this document (formatted for legibility) CLOUCHDB-USER> (get-document ""someid"" :revision-info t) ((:_ID . ""someid"") (:_REV . ""4275808446"") (:SIZE . ""large"") (:COLOR . ""green"")   (:_REVS_INFO    ((:REV . ""4275808446"") (:STATUS . ""disk""))    ((:REV . ""3181950830"") (:STATUS . ""disk"")))) ;; Since the first revision is still available (:status . ""disk"") we  ;; can still retrieve it CLOUCHDB-USER> (get-document ""someid"" :revision ""3181950830"") ((:_ID . ""someid"") (:_REV . ""3181950830"") (:SIZE . ""large"") (:COLOR . ""blue""))  ;; In the following document, the :tags field has an array value, ;; the :demographics field has a map value, and the :religion map  ;; key also has an associated map value. CLOUCHDB-USER> (create-document '((:name . ""Czech Republic"")                                   (:tags . (""country"" ""European""))                                   ;; Field using map property value:                                   (:demographics . ((:population . 10230000)                                                      ;; A nested map property:                                                      (:religion . ((:agnostic . 0.59)                                                                    (:roman-catholic . 0.26)                                                                    (:protestant . 2.5)))                                                      (:political-system . ""democracy""))))                                 :id ""czechrepublic"") ((:OK . T) (:ID . ""czechrepublic"") (:REV . ""4272625130"")) ;; Let's see what this document looks like (formatted for legibility) CLOUCHDB-USER> (get-document ""czechrepublic"") ((:_ID . ""czechrepublic"") (:_REV . ""3929202819"")   (:NAME . ""Czech Republic"") (:TAGS ""country"" ""european"")   (:DEMOGRAPHICS (:POPULATION . 10230000)                  (:RELIGION (:AGNOSTIC . 0.59) (:ROMAN-CATHOLIC . 0.26) (:PROTESTANT . 2.5))                  (:POLITICAL-SYSTEM . ""democracy""))) ;; Get all documents, results again formatted for legibility CLOUCHDB-USER> (get-all-documents) ((:TOTAL_ROWS . 3) (:OFFSET . 0)   (:ROWS    ((:ID . ""C731D3A3698DA144FB35EDA9737917F2"") (:KEY . ""C731D3A3698DA144FB35EDA9737917F2"")     (:VALUE (:REV . ""3363852140"")))   ((:ID . ""czechrepublic"") (:KEY . ""czechrepublic"") (:VALUE (:REV . ""4272625130"")))    ((:ID . ""someid"") (:KEY . ""someid"") (:VALUE (:REV . ""4275808446"")))))  Example 3 Demonstrating: Conditionally creating a database if it does not exist The use of Parenscript in defining a view Invoking persistent views to query database documents  ;; Create current database if it doesn't already exist. ;; An (:IGNORED . T) result indicates that the create ;; was ignored because the database already existed. CLOUCHDB-USER> (create-db :if-exists :ignore) ((:OK . T) (:IGNORED . T))  ;; Create some documents representing various cities and their  ;; associated countries. CLOUCHDB-USER> (create-document '((:city . ""New York City"")                                   (:country . ""US""))                                 :id ""nyc"") ((:OK . T) (:ID . ""nyc"") (:REV . ""1023292373"")) CLOUCHDB-USER> (create-document '((:city . ""Amsterdam"")                                   (:country . ""NL""))                                 :id ""amst"")  ((:OK . T) (:ID . ""amst"") (:REV . ""3679905075"")) CLOUCHDB-USER> (create-document '((:city . ""Chicago"")                                   (:country . ""US""))                                 :id ""chi"")  ((:OK . T) (:ID . ""chi"") (:REV . ""1627558845""))  ;; Create a persistent view document to find cities in the ;; Netherlands and also to find cities by country key.  ;; Note: Expressions within the (ps) expressions are Parenscript, ;; a lispy way to generate JavaScript. CLOUCHDB-USER> (create-view ""cities""                             (cons ""country""                                   (ps (lambda (doc)                                         (with-slots (country) doc                                           (map country doc)))))                             (cons ""nl""                                   (ps (lambda (doc)                                         (with-slots (country) doc                                           (if (eql ""NL"" country)                                               (map country doc))))))) ((:OK . T) (:ID . ""_design/cities"") (:REV . ""3690565831""))  ;; Invoke ""nl"" view to find cities in the Netherlands CLOUCHDB-USER> (invoke-view ""cities"" ""nl"") ((:TOTAL_ROWS . 1) (:OFFSET . 0)   (:ROWS    ((:ID . ""amst"") (:KEY . ""NL"") (:VALUE (:_ID . ""amst"")     (:_REV . ""3679905075"") (:CITY . ""Amsterdam"") (:COUNTRY . ""NL"")))))  ;; Invoke ""country"" view created above and search for US cities CLOUCHDB-USER> (invoke-view ""cities"" ""country"" :key ""US"") ((:TOTAL_ROWS . 3) (:OFFSET . 1)   (:ROWS    ((:ID . ""chi"") (:KEY . ""US"") (:VALUE (:_ID . ""chi"")     (:_REV . ""1627558845"") (:CITY . ""Chicago"") (:COUNTRY . ""US"")))    ((:ID . ""nyc"") (:KEY . ""US"") (:VALUE (:_ID . ""nyc"")     (:_REV . ""1023292373"") (:CITY . ""New York City"") (:COUNTRY . ""US"")))))  ;; Note: the two responses above have been formatted for legibility. Also, ;; see CouchDb documentation for why 3 is returned for TOTAL_ROWS when ;; there are only two results.  API ReferenceServer Connection and Database Management API The functions described in this section have to do with setting CouchDb connection values, creating, deleting and getting information about databases and information about the CouchDb server. [Function] create-db &key db-name if-exists Create a database. The db-name can be specified, otherwise attempts to create the database named in the current context (either through (set-connection) or (with-connection). The if-exists parameter defaults to :fail, which will raise an error if the database already exists. A value of :ignore will simply ignore the this error. A value of :recreate will delete the database if it exists, and then recreate it. [Function] delete-db &key db-name if-missing Delete a database. The db-name can be specified, otherwise attempts to delete the database named in the current context (either through (set-connection) or (with-connection). If :ignore is specified for the if-missing parameter, errors resulting from the attempt to delete a non-existent database are ignored. [Function] get-db-info &key db-name Returns database information for the connection and database in the current context, or, if the db-name key parameter is specified, for that database. Example:  (get-db-info) => ((:DB_NAME . ""test-db"") (:DOC_COUNT . 3) (:UPDATE_SEQ . 4))  [Function] list-dbs Returns a list of database names available in the current connection. [Function] set-connection &key host db-name protocol port => no value Sets the host name, database name, protocol (""http"" or ""https"") and port number for the top-level connection to the CouchDb server. Default connection settings are host=""localhost"", protocol=""http"", port=""8888"" and database=""default"". See (with-connection) [Macro] with-connection (&key host db-name protocol port) &body body => value returned by body Executes the contained statements in the context of any of the specified connection values. Sets the host name, database name, protocol (""http"" or ""https"") or port number of the CouchDb server to use in the expressions in the body. Example:  ;; Get document from specified host and database (with-connection (:host ""cornichon.cucumber.net"" :db-name ""rfc"")   (get-document ""2616""))  See (set-connection) Document API Documents in clouchdb are identified by a document ID, their content takes the form of an associative list. The native document representation in CouchDb is a JSON object. Using cl-json, clouchdb automatically translates documents between JSON and Lisp associative lists. Special Properties When a document is created CouchDb assigns special properties to that document, these properties cannot be modified by clients. The special properties include the document's ID (:_id) and the document revision number (:_rev). All special properties begin with an underscore (_) symbol.  (create-document '((:name . ""Maxwell Smart"") (:agent . 86)) :id ""max"") => ((:OK . T) (:ID . ""max"") (:REV . ""3789799231""))  (get-document ""max"") => ((:_ID . ""max"") (:_REV . ""3789799231"") (:NAME . ""Maxwell Smart"") (:AGENT . 86))  Please refer to the CouchDb Document API for general CouchDb document information. [Function] create-document doc &key id Create a new document, optionally specifying the document's ID. This method simply calls (post-document) if an ID is specified, otherwise (put-document). Example:  (create-document '((:string . ""string"")                     (:number . 42)                    (:array . (""one"" 2 ""nine""))                    (:map . ((:foo . ""bar"")                             (:size . 3)                             (:colors . (""red"" ""blue"" ""green"")))))                  :id ""example"")  See (put-document) (post-document) [Function] delete-document &key document id revision Delete the specified document, which must include the standard CouchDb special variables :_ID and :_REV. The document may also identified by ID. If revision is specified, delete the specific revision of identified document, otherwise, delete the most current revision by fetching the document by ID and using its :_rev value for the deletion. [Function] document-property name doc Get the value of the named document property or nil if property does not exist. This function can be used with setf to set property values as well:  (create-document '((:name . ""Maxwell Smart"") (:agent . 86)) :id ""max"")  (document-property :name (get-document ""max"")) => ""Maxwell Smart""  (let ((max (get-document ""max"")))   (setf (document-property :name max) ""Maxwell Smart, Secret Agent"")   (put-document max))  (get-document ""max"") => ""Maxwell Smart, Secret Agent""  [Function] get-all-documents &key descending Return ID and current revision information for all documents, ordered by ascending document ID. If descending is non-nil, returns documents in reverse order. [Function] get-document id &key revision revisions revision-info Get document by ID. If revision is specified attempts to retrieve specified revision of identified document. If revisions is non-nil, returns brief revision information for identified document. If revision-info is non-nil, returns more detailed revision information for document. The revision, revisions, and revision-info parameters are mutually exclusive. This function returns nil if no document matching ID is found. [Function] post-document doc Create a document and let the server assign an ID. See (create-document) (put-document) [Function] put-document doc &key id Create a new document or update an existing one. If the document is new, the ID must be specified. If the document has been fetched from the server (and still retains its :_* CouchDb special properties) then no ID need be specified. If an ID is specified and it differs from the existing :_id value, then a new document is created with the specified ID and any non-special properties of the document. Example:  ;; Create document ""A"" (put-document '((:name . ""Laraby"")) :id ""A"")  ;; Copy to new document ""B"" (put-document (get-document ""A"") :id ""B"")  ;; Add field to document ""B"" (put-document (cons '(:new-field . ""new-value"")) (get-document ""B""))  See (create-document) (post-document) Views API Views are the mechanism with which documents are queried in CouchDb. There are two types of views in CouchDb: ad hoc and persistent. As you might expect, persistent views are stored in the database. Ad hoc views are not, they are sent from the client each time they're used. Native CouchDb views are expressed in JavaScript though it is not necessary to use JavaScript directly thanks to Parenscript. Please refer to CouchDb View API Documentation for general information about CouchDb views. [Function] ad-hoc-view view Executes a one-time, non persistent view (query). The view is specified as a JavaScript anonymous function. Example:  (create-document '((:name . ""Laraby""))) (ad-hoc-view ""function(doc) { if (doc.name == 'Laraby') { map(null,doc.name) } }"")  Ok, but this is Lisp and JavaScript looks exotic and scary. To solve this problem we use Parenscript. The following expression generates the same view with a more familiar syntax:  (create-document '((:name . ""Laraby""))) (ad-hoc-view (ps (lambda (doc)                    (with-slots (name) doc                      (if (eql name ""Laraby"")                        (map nil doc))))))  Note that it is not necessary for every document in the database to have a field called 'name'. This view will return only those documents that have a name field and where the value of that name field is ""Laraby"". No errors result from documents with no name field. The (with-slots) expression above can be eliminated, if desired, like so:  (ad-hoc-view (ps (lambda (doc)                    (if (eql doc.name ""Laraby"")                      (map nil doc))))))  See (create-view) [Function] create-view {view-definition}* Creates a view document containing one or more view definitions Example:  ;; Views defined with Parenscript (create-view ""names""   (cons ""laraby""         (ps (lambda (doc)               (with-slots (name) doc                 (if (eql ""Laraby"" name)                   (map name doc))))))   (cons ""name""         (ps (lambda (doc)               (with-slots (name) doc                 (map name doc))))))  See (invoke-view) [Function] delete-view id &key rev Delete view document identified by id. If revision is specified, delete specific revision of view document. See (create-view) [Function] invoke-view id view :key key Invoke specified view in identified view document. Example:  ;; Document to query (create-document '((:name . ""Laraby"")))  ;; Views defined with Parenscript (create-view ""names""   (cons ""laraby""         (ps (lambda (doc)  ;; parameter-less view               (with-slots (name) doc                 (if (eql ""Laraby"" name)                   (map nil doc))))))   (cons ""name""         (ps (lambda (doc)  ;; parameter view               (with-slots (name) doc                 (map name doc))))))  ;; Find document by invoking parameter-less ""laraby"" view (invoke-view ""names"" ""laraby"")  ;; Find document by invoking ""name"" view with key parameter (invoke-view ""names"" ""name"" :key ""Laraby"")  See (create-view) (ad-hoc-view) Symbol Index ad-hoc-view create-db create-document create-view delete-db delete-document delete-view document-property get-all-documents get-db-info get-document invoke-view list-dbs post-document put-document set-connection with-connection Back to Common-lisp.net. Valid XHTML 1.0 Strict"	"null"	"null"	"Library for interacting with CouchDB.."	"true"
"Database"	"crane"	"https://github.com/eudoxia0/crane"	"Another ORM.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"146"	"19"	"19"	"GitHub - eudoxia0/crane: An ORM for Common Lisp. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 19 Star 146 Fork 19 eudoxia0/crane Code Issues 13 Pull requests 2 Pulse Graphs An ORM for Common Lisp. http://eudoxia.me/crane/ 570 commits 3 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master rewrite Nothing to show Nothing to show New pull request Latest commit 1a85295 Jan 16, 2016 eudoxia0 Merge pull request #50 from PuercoPop/patch-2 … deftable: use &body for slots-and-options Permalink Failed to load latest commit information. docs Fix table docs Feb 28, 2015 src deftable: use &body for slots-and-options Jan 16, 2016 t Add more tests Jan 17, 2015 .gitignore Update .gitignore Jul 28, 2014 .travis.yml Clone sxql and cl-dbi Feb 9, 2015 README.md Add QL badge Nov 22, 2015 crane-test.asd Add more tests Jan 17, 2015 crane.asd Add more tests Jan 17, 2015 README.md Crane Crane is an ORM for Common Lisp, providing a simple bridge between CLOS and relational databases, and out of the box migrations. Usage Defining Tables (deftable user ()   (name :type text :uniquep t)   (age :type integer :nullp nil :initform 18)   (friend :type integer :foreign user))) The foreign argument accepts a symbol that represents another table or a sexp of the form (table &key on-delete on-update)), where acceptable values are :no-action :restrict :cascade :set-null :set-default. Migrating (deftable user ()   (name :type text :uniquep t :nullp nil)   (age :type integer :nullp t :initform 18)   (description :type text)) Just make the changes, and Crane will compute the diffs and perform all the ALTER TABLEs for you. Connecting (setup  :migrations-directory  (asdf:system-relative-pathname :myapp #p""migrations/"")  :databases  '(:main    (:type :postgres     :name ""myapp_db""     :user ""user""     :pass ""user"")))  (connect) For configuration management and switching databases in development/production environments, you might want to use Envy. Creating, Saving, and Deleting Objects (let ((instance (create 'ship :name ""Dalliance""                               :tonnage 77)))   ;; FIXME: It's back luck to rename a ship   (setf (name instance) ""Serenity"")   ;; Expand the cargo hold   (incf (tonnage instance) 25)   ;; Save these changes!   (save instance)   ;; Time to retire   (del instance)) Filtering (filter 'user) ;; Returns everything  (filter 'user :name ""Eudoxia"")  (filter 'user (:> :age 21))  ;; Returns a single object (single 'user :name ""Eudoxia"")  ;; Throws an error if this returns more ;; than one object (single! 'user (:< age 35))  ;; t if a match exists, nil otherwise (exists 'user :name ""Eudoxia"")  ;; If this record doesn't exist create it (get-or-create 'user :name ""Eudoxia"" :age 19) Transactions ;;;; Automatic (with-transaction ()   (let ((restaurants (filter 'restaurant ...)))     (loop for restaurant in restaurants do           ...           (save restaurant))))  ;;;; Manual (progn   (begin-transaction)   (let ((restaurants (filter 'restaurant ...)))     (loop for restaurant in restaurants do           ...           (save restaurant)))   (commit)) Fixtures ;;;; initial-data.lisp (app:user   (:name ""eudoxia""    :groups (:admin :staff))   (:name ""joe""    :groups (:admin))) (app:company   (:name ""Initech""    :city ""Denver""))  ;;;; myapp.asd (asdf:defsystem myapp   :defsystem-depends-on (:clos-fixtures)   :components ((:module ""src""                 :components                 ((:fixture ""initial-data""))))) Inflate/Deflate (definflate (stamp 'timestamp)   ;; Inflate a timestamp value   ;; into a timestamp object   (local-time:universal-to-timestamp stamp))  (defdeflate (stamp local-time:timestamp)   ;; Deflate a timestamp object   ;; into a string   (local-time:format-timestring nil stamp)) Documentation I'm in the process of moving the documentation to Codex, so for now you can check it out in the website. License Copyright (c) 2013 Fernando Borretti (eudoxiahp@gmail.com) Released under the MIT license. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/eudoxia0/crane"	"Another ORM.."	"true"
"Database"	"datafly"	"https://github.com/fukamachi/datafly"	"A lightweight database library.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"36"	"8"	"4"	"GitHub - fukamachi/datafly: A lightweight database library for Common Lisp. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 8 Star 36 Fork 4 fukamachi/datafly Code Issues 4 Pull requests 2 Pulse Graphs A lightweight database library for Common Lisp. 30 commits 4 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags allow-statement-in-has-a fix-has-a jojo master Nothing to show Nothing to show New pull request Latest commit d2b753e Feb 8, 2016 fukamachi Replace Jonathan by CL-JSON. Permalink Failed to load latest commit information. src Replace Jonathan by CL-JSON. Feb 8, 2016 t Replace Jonathan by CL-JSON. Feb 8, 2016 .gitignore Initial commit. Apr 16, 2014 .travis.yml Use the official release of Roswell. Feb 8, 2016 LICENSE Drop 'w' from my name. Aug 4, 2014 README.markdown Add build status badge. Jul 15, 2015 datafly-test.asd Drop 'w' from my name. Aug 4, 2014 datafly.asd Replace Jonathan by CL-JSON. Feb 8, 2016 README.markdown datafly Datafly is a lightweight database library for Common Lisp. Quickstart Datafly provides 3 functions which wrap CL-DBI — retrieve-one, retrieve-all and execute. They take a SxQL statement. (use-package :sxql)  (connect-toplevel :sqlite3 :database-name #P""myapp.db"")  (retrieve-one   (select :*     (from :user)     (where (:= :name ""nitro_idiot"")))) ;=> (:ID 1 :NAME ""nitro_idiot"" :EMAIL ""nitro_idiot@example.com"" :REGISTERED-AT ""2014-04-14T19:20:13"")  (retrieve-all   (select :*     (from :user))) ;=> ((:ID 1 :NAME ""nitro_idiot"" :EMAIL ""nitro_idiot@example.com"" :REGISTERED-AT ""2014-04-14T19:20:13"") ;    (:ID 2 :NAME ""m2ym"" :EMAIL ""m2ym@example.com"" :REGISTERED-AT ""2014-04-15T01:03:42""))  (execute  (insert-into :tweet    (set= :id 1          :user_id 1          :body ""Hi.""          :created_at (princ-to-string *now*)))) If you specify :as option with a class name to retrieval functions, they create instances of the class for each rows. (defstruct user   id   name   email   registered-at)  (retrieve-one   (select :*     (from :user)     (where (:= :name ""nitro_idiot"")))   :as 'user) ;=> #S(USER :ID 1 :NAME ""nitro_idiot"" :EMAIL ""nitro_idiot@example.com"" :REGISTERED-AT ""2014-04-14T19:20:13"")  (retrieve-all   (select :*     (from :user))   :as 'user) ;=> (#S(USER :ID 1 :NAME ""nitro_idiot"" :EMAIL ""nitro_idiot@example.com"" :REGISTERED-AT ""2014-04-14T19:20:13"") ;    #S(USER :ID 2 :NAME ""m2ym"" :EMAIL ""m2ym@example.com"" :REGISTERED-AT ""2014-04-15T01:03:42"")) The structure doesn't require having slots same as an existing table's in a database. It is acceptable even if the names are different. This might be convenient when you'd like to treat a JOINed table result as a structure object. Model Definitions Datafly provides a macro defmodel which defines a flavored structure class. (defmodel (user (:inflate registered-at #'datetime-to-timestamp))   id   name   email   registered-at)   ;; Same as the above. (syntax:use-syntax :annot)  @model (defstruct (user (:inflate registered-at #'datetime-to-timestamp))   id   name   email   registered-at) (:inflate <columns> <inflation-function>) options mean inflation-function will be applied to each <columns> when creating an instance. (defvar *user*   (retrieve-one     (select :*       (from :user)       (where (:= :name ""nitro_idiot"")))     :as 'user))  ;; Returns a local-time:timestamp. (user-registered-at *user*) ;=> @2014-04-15T04:20:13.000000+09:00 defmodel also allows :has-a and :has-many options. (use-package :sxql)  (defmodel (user (:inflate registered-at #'datetime-to-timestamp)                 (:has-a config (where (:= :user_id id)))                 (:has-many (tweets tweet)                  (select :*                    (from :tweet)                    (where (:= :user_id id))                    (order-by (:desc :created_at)))))   id   name   email   registered-at)  (defvar *user*   (retrieve-one     (select :*       (from :user)       (where (:= :name ""nitro_idiot"")))     :as 'user))  (user-config *user*) ;=> #S(CONFIG :ID 4 :USER-ID 1 :TIMEZONE ""JST"" :COUNTRY ""jp"" :LANGUAGE ""ja"")  (user-tweets *user*) ;=> (#S(TWEET :ID 2 :USER-ID 1 :BODY ""Is it working?"" :CREATED-AT @2014-04-16T11:02:31.000000+09:00) ;    #S(TWEET :ID 1 :USER-ID 1 :BODY ""Hi."" :CREATED-AT @2014-04-15T18:58:20.000000+09:00)) Provided inflation functions tinyint-to-boolean datetime-to-timestamp unixtime-to-timestamp string-to-keyword octet-vector-to-string Tips: Getting Association List or Hash Table for each rows retrieve-one and retrieve-all return row(s) as a property list or a list of property lists by default. If you'd like they were other types, for example ""Association List"" or ""Hash Table"", you can do it by passing :as parameter. (retrieve-one   (select :*     (from :user)     (where (:= :name ""nitro_idiot"")))   :as 'trivial-types:association-list) ;=> ((:ID . 1) (:NAME . ""nitro_idiot"") (:EMAIL . ""nitro_idiot@example.com"") (:REGISTERED-AT . ""2014-04-14T19:20:13""))  (retrieve-one   (select :*     (from :user)     (where (:= :name ""nitro_idiot"")))   :as 'hash-table) ;=> #<HASH-TABLE :TEST EQL :COUNT 4 {1007AE3CD3}> If no :as parameter is specified, *default-row-type* will be used. (let ((*default-row-type* 'hash-table))   (retrieve-all     (select :*       (from :user)))) ;=> (#<HASH-TABLE :TEST EQL :COUNT 4 {100815FA03}> #<HASH-TABLE :TEST EQL :COUNT 4 {100815FE43}>) See Also SxQL CL-DBI cl-annot, CL-SYNTAX function-cache Author Eitaro Fukamachi (e.arrows@gmail.com) Copyright Copyright (c) 2014 Eitaro Fukamachi (e.arrows@gmail.com) License Licensed under the BSD 3-Clause License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/datafly"	"A lightweight database library.."	"true"
"Database"	"mito"	"https://github.com/fukamachi/mito"	"An ORM for Common Lisp with migrations, relationships and PostgreSQL support."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"23"	"9"	"3"	"GitHub - fukamachi/mito: An ORM for Common Lisp with migrations, relationships and PostgreSQL support Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 9 Star 23 Fork 3 fukamachi/mito Code Issues 4 Pull requests 3 Pulse Graphs An ORM for Common Lisp with migrations, relationships and PostgreSQL support 165 commits 4 branches 0 releases Fetching contributors Common Lisp 99.8% Shell 0.2% Common Lisp Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags debug fix-references master more-impls Nothing to show Nothing to show New pull request Latest commit 7c99c00 Apr 18, 2016 fukamachi Allow NIL for timestamps. Permalink Failed to load latest commit information. roswell Fix mito.ros a little bit. Feb 16, 2016 src Allow NIL for timestamps. Apr 18, 2016 t KEY in CREATE TABLE is not allowed in PostgreSQL. Feb 17, 2016 .gitignore Initial commit. Sep 8, 2015 .travis.yml Use PostgreSQL 9.4. Feb 7, 2016 CONTRIBUTING.md Add CONTRIBUTING.md. Feb 5, 2016 README.markdown Mention mito-attachment & mito-auth in README. Feb 19, 2016 mito-core.asd Add record-timestamps-mixin which adds created_at and updated_at auto… Feb 5, 2016 mito-migration.asd Move some implementations from mito.ros to mito.migration. Feb 8, 2016 mito-test.asd Add migration (WIP). Sep 11, 2015 mito.asd Separate mito.migration as an individual system. Feb 3, 2016 README.markdown Mito Mito is yet another object relational mapper and it aims to be a successor of Integral. Supports MySQL, PostgreSQL and SQLite3 Adds id (serial primary key), created_at and updated_at by default like Ruby's ActiveRecord Migrations DB schema versioning Warning This software is still ALPHA quality. The APIs will be likely to change. Should work fine with MySQL, PostgreSQL and SQLite3 on SBCL/Clozure CL. Usage (mito:connect-toplevel :mysql :database-name ""myapp"" :username ""fukamachi"" :password ""c0mon-1isp"") ;=> #<DBD.MYSQL:<DBD-MYSQL-CONNECTION> {100691BFF3}>  (defclass user ()   ((name :col-type (:varchar 64)          :initarg :name          :accessor user-name)    (email :col-type (or (:varchar 128) :null)           :initarg :email           :accessor user-email))   (:metaclass mito:dao-table-class)) ;=> #<MITO.DAO.TABLE:DAO-TABLE-CLASS COMMON-LISP-USER::USER>  (mito:table-definition 'user) ;=> (#<SXQL-STATEMENT: CREATE TABLE user (id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(64) NOT NULL, email VARCHAR(128))>)  (defclass tweet ()   ((status :col-type :text            :initarg :status            :accessor tweet-status)    (user :col-type user          :initarg :user          :accessor tweet-user))   (:metaclass mito:dao-table-class)) ;=> #<MITO.DAO.TABLE:DAO-TABLE-CLASS COMMON-LISP-USER::TWEET>  (mito:table-definition 'tweet) ;=> (#<SXQL-STATEMENT: CREATE TABLE tweet (id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, status TEXT NOT NULL, user_id BIGINT UNSIGNED NOT NULL, created_at TIMESTAMP, updated_at TIMESTAMP)>) Connecting to DB Mito provides a function connect-toplevel and disconnect-toplevel to establish a connection to RDBMS. connect-toplevel takes the same arguments as dbi:connect, typically the driver-type, the database name to connect, user name and password. (mito:connect-toplevel :mysql :database-name ""myapp"" :username ""fukamachi"" :password ""c0mon-1isp"") connect-toplevel sets *connection* the new connection and returns it. If you want to use a connection lexically, just bind it: (let ((mito:*connection* (dbi:connect :sqlite3 :database-name #P""/tmp/myapp.db"")))   (unwind-protect (progn ...)     ;; Ensure that the connection is closed.     (dbi:disconnect mito:*connection*))) Class Definitions In Mito, you can define a class which corresponds to a database table by specifying (:metaclass mito:dao-table-class). (defclass user ()   ((name :col-type (:varchar 64)          :initarg :name          :accessor user-name)    (email :col-type (or (:varchar 128) :null)           :initarg :email           :accessor user-email))   (:metaclass mito:dao-table-class)) The above defines a Common Lisp normal class except that it allows additional options. (defclass {class-name} ()   ({column-definition}*)   (:metaclass mito:dao-table-class)   [[class-option]])  column-definition ::= (slot-name [[column-option]]) column-option ::= {:col-type col-type} |                   {:primary-key boolean} |                   {:inflate inflation-function} |                   {:deflate deflation-function} |                   {:references {class-name | (class-name slot-name)}} |                   {:ghost boolean} col-type ::= { keyword |               (keyword . args) |               (or keyword :null) |               (or :null keyword) } class-option ::= {:primary-key symbol*} |                  {:unique-keys {symbol | (symbol*)}*} |                  {:keys {symbol | (symbol*)}*} |                  {:table-name table-name}                  {:auto-pk boolean}                  {:record-timestamps boolean}  Note the class automatically adds some slots -- a primary key named id if there's no primary keys, created_at and updated_at for recording timestamps. To disable these behaviors, specify :auto-pk nil or :record-timestamps nil to defclass forms. (mito.class:table-column-slots (find-class 'user)) ;=> (#<MITO.DAO.COLUMN:DAO-TABLE-COLUMN-CLASS MITO.DAO.MIXIN::ID> ;    #<MITO.DAO.COLUMN:DAO-TABLE-COLUMN-CLASS COMMON-LISP-USER::NAME> ;    #<MITO.DAO.COLUMN:DAO-TABLE-COLUMN-CLASS COMMON-LISP-USER::EMAIL> ;    #<MITO.DAO.COLUMN:DAO-TABLE-COLUMN-CLASS MITO.DAO.MIXIN::CREATED-AT> ;    #<MITO.DAO.COLUMN:DAO-TABLE-COLUMN-CLASS MITO.DAO.MIXIN::UPDATED-AT>) The class inherits mito:dao-class implicitly. (find-class 'user) ;=> #<MITO.DAO.TABLE:DAO-TABLE-CLASS COMMON-LISP-USER::USER>  (c2mop:class-direct-superclasses *) ;=> (#<STANDARD-CLASS MITO.DAO.TABLE:DAO-CLASS>) This may be useful when you define methods which can be applied for all table classes. Generating Table Definitions (mito:table-definition 'user) ;=> (#<SXQL-STATEMENT: CREATE TABLE user (id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(64) NOT NULL, email VARCHAR(128), created_at TIMESTAMP, updated_at TIMESTAMP)>)  (sxql:yield *) ;=> ""CREATE TABLE user (id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(64) NOT NULL, email VARCHAR(128), created_at TIMESTAMP, updated_at TIMESTAMP)"" ;   NIL Creating DB tables (mapc #'mito:execute-sql (mito:table-definition 'user))  (mito:ensure-table-exists 'user) CRUD (defvar me   (make-instance 'user :name ""Eitaro Fukamachi"" :email ""e.arrows@gmail.com"")) ;=> USER  (mito:insert-dao me) ;-> ;; INSERT INTO `user` (`name`, `email`, `created_at`, `updated_at`) VALUES (?, ?, ?, ?) (""Eitaro Fukamachi"", ""e.arrows@gmail.com"", ""2016-02-04T19:55:16.365543Z"", ""2016-02-04T19:55:16.365543Z"") [0 rows] | MITO.DAO:INSERT-DAO ;=> #<USER {10053C4453}>  ;; Same as above (mito:create-dao 'user :name ""Eitaro Fukamachi"" :email ""e.arrows@gmail.com"")  ;; Getting the primary key value (mito:object-id me) ;=> 1  ;; Retrieving from the DB (mito:find-dao 'user :id 1) ;-> ;; SELECT * FROM `user` WHERE (`id` = ?) LIMIT 1 (1) [1 row] | MITO.DB:RETRIEVE-BY-SQL ;=> #<USER {10077C6073}>  ;; Updating (setf (slot-value me 'name) ""nitro_idiot"") ;=> ""nitro_idiot""  (mito:save-dao me) ;-> ;; UPDATE `user` SET `id` = ?, `name` = ?, `email` = ?, `created_at` = ?, `updated_at` = ? WHERE (`id` = ?) (2, ""nitro_idiot"", ""e.arrows@gmail.com"", ""2016-02-04T19:56:11.408927Z"", ""2016-02-04T19:56:19.006020Z"", 2) [0 rows] | MITO.DAO:UPDATE-DAO  ;; Deleting (mito:delete-dao me) ;-> ;; DELETE FROM `user` WHERE (`id` = ?) (1) [0 rows] | MITO.DAO:DELETE-DAO Relationship To define a relationship, use :references at the slot: (defclass user ()   ((name :col-type (:varchar 64)          :initarg :name          :accessor user-name)    (email :col-type (or (:varchar 128) :null)           :initarg :email           :accessor user-email))   (:metaclass mito:dao-table-class))  (defclass tweet ()   ((status :col-type :text            :initarg :status            :accessor tweet-status)    ;; This slot refers to USER class    (user-id :references (user id)             :initarg :user-id             :accessor tweet-user-id))   (:metaclass mito:dao-table-class))  ;; The :col-type of USER-ID column is retrieved from the foreign class. (table-definition (find-class 'tweet)) ;=> (#<SXQL-STATEMENT: CREATE TABLE tweet ( ;        id BIGSERIAL NOT NULL PRIMARY KEY, ;        status TEXT NOT NULL, ;        user_id BIGINT NOT NULL, ;        created_at TIMESTAMP, ;        updated_at TIMESTAMP ;    )>) You can also specify another foreign class at :col-type for defining a relationship: (defclass tweet ()   ((status :col-type :text            :initarg :status            :accessor tweet-status)    ;; This slot refers to USER class    (user :col-type user          :initarg :user          :accessor tweet-user))   (:metaclass mito:dao-table-class))  (table-definition (find-class 'tweet)) ;=> (#<SXQL-STATEMENT: CREATE TABLE tweet ( ;        id BIGSERIAL NOT NULL PRIMARY KEY, ;        status TEXT NOT NULL, ;        user_id BIGINT NOT NULL, ;        created_at TIMESTAMP, ;        updated_at TIMESTAMP ;    )>)  ;; You can specify :USER arg, instead of :USER-ID. (defvar *user* (mito:create-dao 'user :name ""Eitaro Fukamachi"")) (mito:create-dao 'tweet :user *user*)  (mito:find-dao 'tweet :user *user*) The later example allows you to create/retrieve TWEET by a USER object, not a USER-ID. Mito doesn't add foreign key constraints for refering tables since I'm not sure it's still handful while using with ORMs. Inflation/Deflation Inflation/Deflation is a function to convert values between Mito and RDBMS. (defclass user-report ()   ((title :col-type (:varchar 100)           :initarg :title           :accessor report-title)    (body :col-type :text          :initarg :body          :initform """"          :accessor report-body)    (reported-at :col-type :timestamp                 :initarg :reported-at                 :initform (local-time:now)                 :accessor report-reported-at                 :inflate #'local-time:universal-to-timestamp                 :deflate #'local-time:timestamp-to-universal))   (:metaclass mito:dao-table-class)) Eager loading One of the pains in the neck to use ORMs is ""N+1 query"" problem. ;; BAD EXAMPLE  (use-package '(:mito :sxql))  (defvar *tweets-contain-japan*   (select-dao 'tweet     (where (:like :status ""%Japan%""))))  ;; Getting names of tweeted users. (mapcar (lambda (tweet)           (user-name (tweet-user tweet)))         *tweets-contain-japan*) This example sends a query to retrieve a user like ""SELECT * FROM user WHERE id = ?"" for each iterations. To prevent this performance issue, add includes to the above query which only sends a single WHERE IN query instead of N queries: ;; GOOD EXAMPLE with eager loading  (use-package '(:mito :sxql))  (defvar *tweets-contain-japan*   (select-dao 'tweet     (includes 'user)     (where (:like :status ""%Japan%"")))) ;-> ;; SELECT * FROM `tweet` WHERE (`status` LIKE ?) (""%Japan%"") [3 row] | MITO.DB:RETRIEVE-BY-SQL ;-> ;; SELECT * FROM `user` WHERE (`id` IN (?, ?, ?)) (1, 3, 12) [3 row] | MITO.DB:RETRIEVE-BY-SQL ;=> (#<TWEET {1003513EC3}> #<TWEET {1007BABEF3}> #<TWEET {1007BB9D63}>)  ;; No additional SQLs will be executed. (tweet-user (first *)) ;=> #<USER {100361E813}> Migrations (ensure-table-exists 'user) ;-> ;; CREATE TABLE IF NOT EXISTS ""user"" ( ;       ""id"" BIGSERIAL NOT NULL PRIMARY KEY, ;       ""name"" VARCHAR(64) NOT NULL, ;       ""email"" VARCHAR(128), ;       ""created_at"" TIMESTAMP, ;       ""updated_at"" TIMESTAMP ;   ) () [0 rows] | MITO.DAO:ENSURE-TABLE-EXISTS  ;; No changes (mito:migration-expressions 'user) ;=> NIL  (defclass user ()   ((name :col-type (:varchar 64)          :initarg :name          :accessor user-name)    (email :col-type (:varchar 128)           :initarg :email           :accessor user-email))   (:metaclass mito:dao-table-class)   (:unique-keys email))  (mito:migration-expressions 'user) ;=> (#<SXQL-STATEMENT: ALTER TABLE user ALTER COLUMN email TYPE character varying(128), ALTER COLUMN email SET NOT NULL> ;    #<SXQL-STATEMENT: CREATE UNIQUE INDEX unique_user_email ON user (email)>)  (mito:migrate-table 'user) ;-> ;; ALTER TABLE ""user"" ALTER COLUMN ""email"" TYPE character varying(128), ALTER COLUMN ""email"" SET NOT NULL () [0 rows] | MITO.MIGRATION.TABLE:MIGRATE-TABLE ;   ;; CREATE UNIQUE INDEX ""unique_user_email"" ON ""user"" (""email"") () [0 rows] | MITO.MIGRATION.TABLE:MIGRATE-TABLE ;-> (#<SXQL-STATEMENT: ALTER TABLE user ALTER COLUMN email TYPE character varying(128), ALTER COLUMN email SET NOT NULL> ;    #<SXQL-STATEMENT: CREATE UNIQUE INDEX unique_user_email ON user (email)>) Schema versioning $ ros install mito $ mito Usage: mito command [option...]  Commands:     generate-migrations     migrate  Options:     -t, --type DRIVER-TYPE          DBI driver type (one of ""mysql"", ""postgres"" or ""sqlite3"")     -d, --database DATABASE-NAME    Database name to use     -u, --username USERNAME         Username for RDBMS     -p, --password PASSWORD         Password for RDBMS     -s, --system SYSTEM             ASDF system to load (several -s's allowed)     -D, --directory DIRECTORY       Directory path to keep migration SQL files (default: ""/Users/nitro_idiot/Programs/lib/mito/db/"")     --dry-run                       List SQL expressions to migrate  Inheritance and Mixin A subclass of DAO-CLASS is allowed to be inherited. This may be useful when you need classes which have similar columns: (defclass user ()   ((name :col-type (:varchar 64)          :initarg :name          :accessor user-name)    (email :col-type (:varchar 128)           :initarg :email           :accessor user-email))   (:metaclass mito:dao-table-class)   (:unique-keys email))  (defclass temporary-user (user)   ((registered-at :col-type :timestamp                   :initarg :registered-at                   :accessor temporary-user-registered-at))   (:metaclass mito:dao-table-class))  (mito:table-definition 'temporary-user) ;=> (#<SXQL-STATEMENT: CREATE TABLE temporary_user ( ;        id BIGSERIAL NOT NULL PRIMARY KEY, ;        name VARCHAR(64) NOT NULL, ;        email VARCHAR(128) NOT NULL, ;        registered_at TIMESTAMP NOT NULL, ;        created_at TIMESTAMP, ;        updated_at TIMESTAMP, ;        UNIQUE (email) ;    )>) If you need a 'template' for tables which doesn't related to any database tables, you can use DAO-TABLE-MIXIN: (defclass has-email ()   ((email :col-type (:varchar 128)           :initarg :email           :accessor object-email))   (:metaclass mito:dao-table-mixin)   (:unique-keys email)) ;=> #<MITO.DAO.MIXIN:DAO-TABLE-MIXIN COMMON-LISP-USER::HAS-EMAIL>  (defclass user (has-email)   ((name :col-type (:varchar 64)          :initarg :name          :accessor user-name))   (:metaclass mito:dao-table-class)) ;=> #<MITO.DAO.TABLE:DAO-TABLE-CLASS COMMON-LISP-USER::USER>  (mito:table-definition 'user) ;=> (#<SXQL-STATEMENT: CREATE TABLE user ( ;       id BIGSERIAL NOT NULL PRIMARY KEY, ;       name VARCHAR(64) NOT NULL, ;       email VARCHAR(128) NOT NULL, ;       created_at TIMESTAMP, ;       updated_at TIMESTAMP, ;       UNIQUE (email) ;   )>) mito-attachment mito-auth Triggers Since insert-dao, update-dao and delete-dao are defined as generic functions, you can define :before, :after or :around methods to those. (defmethod mito:insert-dao :before ((object user))   (format t ""~&Adding ~S...~%"" (user-name object)))  (mito:create-dao 'user :name ""Eitaro Fukamachi"" :email ""e.arrows@gmail.com"") ;-> Adding ""Eitaro Fukamachi""... ;   ;; INSERT INTO ""user"" (""name"", ""email"", ""created_at"", ""updated_at"") VALUES (?, ?, ?, ?) (""Eitaro Fukamachi"", ""e.arrows@gmail.com"", ""2016-02-16 21:13:47"", ""2016-02-16 21:13:47"") [0 rows] | MITO.DAO:INSERT-DAO ;=> #<USER {100835FB33}> Installation $ mkdir -p ~/common-lisp $ cd ~/common-lisp $ git clone https://github.com/fukamachi/mito $ ros -L ~/common-lisp/mito/mito.asd install mito  (ql:quickload :mito) See Also CL-DBI SxQL Author Eitaro Fukamachi (e.arrows@gmail.com) Copyright Copyright (c) 2015 Eitaro Fukamachi (e.arrows@gmail.com) License Licensed under the LLGPL License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/mito"	"An ORM for Common Lisp with migrations, relationships and PostgreSQL support."	"true"
"Database"	"postmodern"	"http://marijnhaverbeke.nl/postmodern/"	"A library for interacting with PostgreSQL.."	"null"	"null"	"null"	"zlib"	"http://directory.fsf.org/wiki/License:Zlib"	"null"	"null"	"null"	"null"	"null"	"Postmodern Postmodern Postmodern is a Common Lisp library for interacting with PostgreSQL databases. Features are: Efficient communication with the database server without need for foreign libraries. Support for UTF-8 on Unicode-aware Lisp implementations A syntax for mixing SQL and Lisp code Convenient support for prepared statements and stored procedures A metaclass for simple database-access objects The biggest differences between this library and CLSQL/CommonSQL are that Postmodern has no intention of being portable across different SQL implementations (it embraces non-standard Postgres features), and approaches extensions like lispy SQL and database access objects in a quite different way. This library was written because the CLSQL approach did not really work for me, your mileage may vary. Contents News Dependencies License Download and installation Support and mailing lists Quickstart Reference Caveats and to-dos Resources News 28-11-2012: Version 1.19: Fix ECL incompatibilities, add upsert-dao function, add support for notifications and bulk copying, and make unix sockets work on CCL. 19-10-2011: Version 1.18: Improve support for array literals, add array slicing. Switch test suite over to Eos. Added make-dao, :dao query selectors, and define-dao-finalization. Support PostGIS operators, locking, and constraint deferring syntax in S-SQL. Add a !unique operator for defining table constraints. Add a database-error-constraint-name condition object accessor. 02-02-2011: Version 1.17: Another modest maintenance release. Fixes day-of-week in simple-date. Makes the :plist query format actually work. Adds sql-escape as an exported symbol for client code that needs to escape stuff. Adds support for multi-dimensional arrays. Adds the *ignore-unknown-columns* configuration variable. 02-04-2010: Version 1.16: Introduces a save-dao/transaction, because the old semantics were broken (originally inside of transactions, after fixing that outside of them). Add support for passing vectors as argument to prepared queries, and reading them from query results. Add :on-update and :on-delete arguments to !foreign. Add :plist and :plists query result formats. Guarantee that deftable definitions are executed in the order they were defined in. Moves the ieee-floats and trivial-utf-8 dependencies into the repository, so they don't have to separately fetched. 02-04-2010: We are moving from common-lisp.net to marijnhaverbeke.nl, and from darcs to git. New project home: http://marijnhaverbeke.nl/postmodern. 01-03-2009: Version 1.15: Almost a year since the last release. Postmodern is still alive—it is just so perfect it hardly needs updates anymore. In this release: Stop depending on the usocket library in Allegro CL and SBCL, just use the built-in socket bindings instead. Allow connecting over a Unix socket in SBCL. Support natural joins in :select. Add :if-exists argument to :drop-... operators, add support for :add-column form to :alter-table. Add :between-symmetric operator. Introduce ""ghost slot"" hack to DAO system to support fetching OIDs. Extend doquery to also handle parameterised queries. 07-03-2009: Version 1.14: Some more syntax supported in S-SQL, add *silently-truncate-rationals* and *query-callback*, export dao-keys, and fix some small bugs. 28-08-2008: Version 1.13: A few small fixes and optimisations, and there is once again a deftable ― though it has a different role than it used to have. 30-04-2008: Version 1.12: Restores the save-dao function (though you should still be careful with it), adds support for SSL connections, makes some error messages clearer, adds some S-SQL operators, and fixes a few bugs. 09-04-2008: Version 1.11: Fixes bugs, most importantly one that caused CL-postgres to blow up whenever a connection parameter was changed for an open connection. Also adds automatic escaping of reserved words to S-SQL, a *max-pool-size* parameter and a coalesce function to Postmodern 19-03-2008: Version 1.10: Note that this release is not entirely backwards-compatible. It introduces a new, more flexible approach to DAO objects, a more pluggable handling of custom data types, and a bunch of small clean-ups, optimizations, and enhancements. See the migration guide for details. Dependencies The library depends on usocket (except on SBCL and ACL, where the built-in socket library is used), md5, closer-mop, bordeaux-threads if you want thread-safe connection pools, and CL+SSL when SSL connections are needed. Postmodern itself is split into four different packages, some of which can be used independently. Simple-date is a very basic implementation of date and time objects, used to support storing and retrieving time-related SQL types. CL-postgres is the low-level library used for interfacing with a PostgreSQL server over a socket. S-SQL is used to compile s-expressions to strings of SQL code, escaping any Lisp values inside, and doing as much as possible of the work at compile time. Finally, Postmodern itself is the library that tries to put all these things together into a convenient programming interface. License Postmodern is released under a zlib-style license. Which approximately means you can use the code in whatever way you like, except for passing it off as your own or releasing a modified version without indication that it is not the original. Download and installation The latest release of Postmodern can be downloaded from http://marijnhaverbeke.nl/postmodern/postmodern.tgz, or installed with asdf-install. A git repository with the most recent changes can be checked out with: > git clone http://marijnhaverbeke.nl/git/postmodern You can also view the repository on github. The file http://marijnhaverbeke.nl/postmodern/postmodern-latest.tgz always contains a snapshot of the current repository head. Support and mailing lists The postmodern-devel can be used for questions, discussion, bug-reports, patches, or anything else relating to this library. To subscribe, send a message to postmodern-devel+subscribe@common-lisp.net. Or mail the author/maintainer directly: Marijn Haverbeke. Quickstart This quickstart is intended to give you a feel of the way coding with Postmodern works. Further details about the workings of the library can be found in the reference manual. Assuming you have already installed it, first load and use the system:  (asdf:oos 'asdf:load-op :postmodern) (use-package :postmodern) If you have a PostgreSQL server running on localhost, with a database called 'testdb' on it, which is accessible for user 'foucault' with password 'surveiller', you can connect like this:  (connect-toplevel ""testdb"" ""foucault"" ""surveiller"" ""localhost"") Which will establish a connection to be used by all code, except for that wrapped in a with-connection form, which takes the same arguments but only establishes the connection locally. Now for a basic sanity test:  (query ""select 22, 'Folie et déraison', 4.5"") ;; => ((22 ""Folie et déraison"" 9/2)) That should work. query is the basic way to send queries to the database. The same query can be expressed like this:  (query (:select 22 ""Folie et déraison"" 4.5)) ;; => ((22 ""Folie et déraison"" 9/2)) In many contexts, query strings and lists starting with keywords can be used interchangeably. The lists will be compiled to SQL. The S-SQL manual describes the syntax used by these expressions. Lisp values occurring in them are automatically escaped. In the above query, only constant values are used, but it is possible to transparently use run-time values as well:  (defun database-powered-addition (a b)   (query (:select (:+ a b)) :single)) (database-powered-addition 1030 204) ;; => 1234 That last argument, :single, indicates that we want the result not as a list of lists (for the result rows), but as a single value, since we know that we are only selecting one value. Some other options are :rows, :row, :column, :alists, and :none. Their precise effect is documented in the reference manual. You do not have to pull in the whole result of a query at once, you can also iterate over it with the doquery macro:  (doquery (:select 'x 'y :from 'some-imaginary-table) (x y)   (format t ""On this row, x = ~A and y = ~A.~%"" x y)) This is what a database-access class looks like:  (defclass country ()   ((name :col-type string :initarg :name          :reader country-name)    (inhabitants :col-type integer :initarg :inhabitants                 :accessor country-inhabitants)    (sovereign :col-type (or db-null string) :initarg :sovereign               :accessor country-sovereign))   (:metaclass dao-class)   (:keys name)) The above defines a class that can be used to handle records in a table with three columns: name, inhabitants, and sovereign. In simple cases, the information above is enough to define the table as well:  (dao-table-definition 'country) ;; => ""CREATE TABLE country ( ;;      name TEXT NOT NULL, ;;      inhabitants INTEGER NOT NULL, ;;      sovereign TEXT, ;;      PRIMARY KEY (name))"" (execute (dao-table-definition 'country)) This defines our table in the database. execute works like query, but does not expect any results back. Let us add a few countries:  (insert-dao (make-instance 'country :name ""The Netherlands""                                     :inhabitants 16800000                                     :sovereign ""Willem-Alexander"")) (insert-dao (make-instance 'country :name ""Croatia""                                     :inhabitants 4400000)) Then, to update Croatia's population, we could do this:  (let ((croatia (get-dao 'country ""Croatia"")))   (setf (country-inhabitants croatia) 4500000)   (update-dao croatia)) (query (:select '* :from 'country)) ;; => ((""The Netherlands"" 16800000 ""Willem-Alexander"") ;;     (""Croatia"" 4500000 :NULL)) Next, to demonstrate a bit more of the S-SQL syntax, here is the query the utility function list-tables uses to get a list of the tables in a database:  (sql (:select 'relname :from 'pg-catalog.pg-class       :inner-join 'pg-catalog.pg-namespace :on (:= 'relnamespace 'pg-namespace.oid)       :where (:and (:= 'relkind ""r"")                    (:not-in 'nspname (:set ""pg_catalog"" ""pg_toast""))                    (:pg-catalog.pg-table-is-visible 'pg-class.oid)))) ;; => ""(SELECT relname FROM pg_catalog.pg_class  ;;      INNER JOIN pg_catalog.pg_namespace ON (relnamespace = pg_namespace.oid) ;;      WHERE ((relkind = 'r') and (nspname NOT IN ('pg_catalog', 'pg_toast')) ;;             and pg_catalog.pg_table_is_visible(pg_class.oid)))"" sql is a macro that will simply compile a query, it can be useful for seeing how your queries are expanded or if you want to do something unexpected with them. As you can see, lists starting with keywords are used to express SQL commands and operators (lists starting with something else will be evaluated and then inserted into the query). Quoted symbols name columns or tables (keywords can also be used but might introduce ambiguities). The syntax supports subqueries, multiple joins, stored procedures, etc. See the S-SQL reference manual for a complete treatment. Finally, here is an example of the use of prepared statements:  (defprepared sovereign-of   (:select 'sovereign :from 'country :where (:= 'name '$1))   :single!) (sovereign-of ""The Netherlands"") ;; => ""Willem-Alexander"" The defprepared macro creates a function that takes the same amount of arguments as there are $X placeholders in the given query. The query will only be parsed and planned once (per database connection), which can be faster, especially for complex queries.  (disconnect-toplevel) Reference The reference manuals for the different components of postmodern are kept in separate files. For using the library in the most straightforward way, you only really need to read the Postmodern reference and glance over the S-SQL reference. The simple-date reference explains the time-related data types included in Postmodern, and the CL-postgres reference might be useful if you just want a low-level library for talking to a PostgreSQL server. Postmodern S-SQL Simple-date CL-postgres Caveats and to-dos Timezones Simple-date has no concept of time zones. This means that using it is rather error-prone, and if you really need your time-keeping to be reliable and/or universal you should either not use the types it provides or think really hard about the way you handle time zones. Recently, a lot of work has been done on local-time, which solves the same problem as simple-date, but does understand time zones. The 1.0 repository currently has code for integration with CL-postgres, though this might not be stable yet. Portability The Lisp code in Postmodern is theoretically portable across implementations, and seems to work on all major ones. I am not actively testing against new releases or obscure implementations, but if you run into problems you are welcome to contact me through the mailing list, and we can try to solve them. Implementations that do not have meta-object protocol support will not have DAOs, but all other parts of the library should work (all widely used implementations do support this). The library will definitely not work for PostgreSQL versions older than 7.4 (it uses a client/server protocol that was introduced in that version). On versions prior to 8.1, retrieving date and time objects is broken, because their binary representation was changed. Part of the functionality of insert-dao (automatic defaulting of unbound slots) only works in PostgreSQL 8.2 and up. Things that should be implemented It would be a nice feature if Postmodern could help you with defining your database schemas and, more importantly, updating your databases when your code changes. It would theoretically not be hard to build a function that compares a schema on the lisp side with the state of the database, and helps you to interactively update your database. PostgreSQL has a quite complete introspection system. Unfortunately it would be a lot of work to implement this, since databases can contain so many different types of entities (tables, views, indices, procedures, constraints, sequences, etc.) which are all created, changed, and dropped in different ways. Resources A collection of Postmodern examples The PostgreSQL manuals The wire protocol Postmodern uses CLSQL Common Lisp Postgis library Local-time"	"null"	"null"	"A library for interacting with PostgreSQL.."	"true"
"Database"	"sxql"	"https://github.com/fukamachi/sxql"	"A DSL for generating SQL.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"69"	"14"	"10"	"GitHub - fukamachi/sxql: A SQL generator for Common Lisp. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 14 Star 69 Fork 10 fukamachi/sxql Code Issues 5 Pull requests 1 Pulse Graphs A SQL generator for Common Lisp. 156 commits 8 branches 0 releases 7 contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags composable-statement fix-ci fix-sql-expression having master merge-and-sort-select-clauses sqlite-autoincrement travis Nothing to show Nothing to show New pull request Latest commit fa68755 Apr 1, 2016 fukamachi (fixes #30) Add :if-not-exists to create-index. Permalink Failed to load latest commit information. src (fixes #30) Add :if-not-exists to create-index. Apr 1, 2016 t (fixes #30) Add :if-not-exists to create-index. Apr 1, 2016 .gitignore Initial commit. Oct 20, 2013 .travis.yml Stop testing with CMUCL because named-readtables doesn't support it. Aug 20, 2015 LICENSE Drop 'w' from my name. Aug 4, 2014 README.markdown Add :a> and :a< operators Feb 17, 2016 sxql-test.asd Replace cl-test-more by prove. Jan 28, 2015 sxql.asd subquery Feb 18, 2015 README.markdown SxQL - A SQL generator. Usage (select (:id :name :sex)   (from (:as :person :p))   (where (:and (:>= :age 18)                (:< :age 65)))   (order-by (:desc age))) ;=> #<SXQL-STATEMENT: SELECT id, name, sex FROM (person AS p) WHERE ((age >= 18) AND (age < 65)) ORDER BY age DESC>  (yield *)  ;=> ""SELECT id, name, sex FROM (person AS p) WHERE ((age >= ?) AND (age < ?)) ORDER BY age DESC"" ;   (18 65)  (sql-compile **) ;=> #<SXQL-COMPILED: SELECT id, name, sex FROM (person AS p) WHERE ((age >= ?) AND (age < ?)) ORDER BY age DESC [18, 65]>  (union-queries * (select (:id :name :sex) (from '(:as animal a)))) ;=> #<SXQL-OP: (SELECT id, name, sex FROM (person AS p) WHERE ((age >= ?) AND (age < ?)) ORDER BY age DESC) UNION (SELECT id, name, sex FROM (animal AS a))>  (yield *) ;=> ""(SELECT id, name, sex FROM (person AS p) WHERE ((age >= ?) AND (age < ?)) ORDER BY age DESC) UNION (SELECT id, name, sex FROM (animal AS a))"" ;   (18 65) SQL Statements select (field &body clauses) Creates a SELECT query. It takes a field (or a list of fields) and SQL Clauses. (select ((:+ 1 1))) ;=> #<SXQL-STATEMENT: SELECT (1 + 1)>  (select :name   (from :person)   (where (:> :age 20))) ;=> #<SXQL-STATEMENT: SELECT name FROM person WHERE (age > 20)>  (select (:id :name)   (from (:as :person :p))   (left-join :person_config :on (:= :person.config_id :person_config.id))   (where (:and (:> :age 20)                (:<= :age 65)))   (order-by :age)   (limit 5)) ;=> #<SXQL-STATEMENT: SELECT id, name FROM (person AS p) LEFT JOIN person_config ON (person.config_id = person_config.id) WHERE ((age > 20) AND (age <= 65)) ORDER BY age LIMIT 5>  (select (:sex (:count :*)) (from :person) (group-by :sex)) ;=> #<SXQL-STATEMENT: SELECT sex, COUNT(*) FROM person GROUP BY sex>  (select (:sex (:as (:count :*) :num))    (from :person)   (group-by :sex)   (order-by (:desc :num))) ;=> #<SXQL-STATEMENT: SELECT sex, COUNT(*) AS num FROM person GROUP BY sex ORDER BY num DESC> insert-into (table &body clauses) (insert-into :person   (set= :sex ""male""         :age 25         :name ""Eitaro Fukamachi"")) ;=> #<SXQL-STATEMENT: INSERT INTO person SET sex = 'male', age = 25, name = 'Eitaro Fukamachi'>  (insert-into :users   (set= :name ""Jack""         :jinbei-size ""small"")   (returning :id)) ;=> #<SXQL-STATEMENT: INSERT INTO `users` (`name`, `jinbei-size`) VALUES ('Jack', 'small') RETURNING `id`>  (insert-into :person   (:id :name)   (select (:id :name)     (from :person_tmp))) ;=> #<SXQL-STATEMENT: INSERT INTO person (id, name) SELECT id, name FROM person_tmp> update (table &body clauses) (update :person   (set= :age 26)   (where (:like :name ""Eitaro %""))) ;=> #<SXQL-STATEMENT: UPDATE person SET age = 26 WHERE (name LIKE 'Eitaro %')> delete-from (table &body clauses) (delete-from :person   (where (:= :name ""Eitaro Fukamachi""))) ;=> #<SXQL-STATEMENT: DELETE FROM person WHERE (name = 'Eitaro Fukamachi')> union-queies (&rest statements) (union-queries  (select (:name :birthday) (from :fulltime))  (select (:name :birthday) (from :parttime))) ;=> #<SXQL-OP: (SELECT name, birthday FROM fulltime) UNION (SELECT name, birthday FROM parttime)> union-all-queries (&rest statements) (union-all-queries  (select (:name :birthday) (from :fulltime))  (select (:name :birthday) (from :parttime))) ;=> #<SXQL-OP: (SELECT name, birthday FROM fulltime) UNION ALL (SELECT name, birthday FROM parttime)> create-table (table column-definitions &body options) (create-table :enemy     ((name :type 'string            :primary-key t)      (age :type 'integer           :not-null t)      (address :type 'text               :not-null nil)      (fatal_weakness :type 'text                      :not-null t                      :default ""None"")      (identifying_color :type '(:char 20)                         :unique t))) ;=> #<SXQL-STATEMENT: CREATE TABLE enemy (name STRING PRIMARY KEY, age INTEGER NOT NULL, address TEXT, fatal_weakness TEXT NOT NULL DEFAULT 'None', identifying_color CHAR(20) UNIQUE)>  (yield *) ;=> ""CREATE TABLE enemy (name STRING PRIMARY KEY, age INTEGER NOT NULL, address TEXT, fatal_weakness TEXT NOT NULL DEFAULT ?, identifying_color CHAR(20) UNIQUE)"" ;   (""None"")  (create-table (:enemy :if-not-exists t)     ((name :type 'string            :primary-key t)      (age :type 'integer           :not-null t)      (address :type 'text               :not-null nil)      (fatal_weakness :type 'text                      :not-null t                      :default ""None"")      (identifying_color :type '(:char 20)                         :unique t))) ;=> #<SXQL-STATEMENT: CREATE TABLE IF NOT EXISTS enemy (name STRING PRIMARY KEY, age INTEGER NOT NULL, address TEXT, fatal_weakness TEXT NOT NULL DEFAULT 'None', identifying_color CHAR(20) UNIQUE)> drop-table (table &key if-exists) (drop-table :enemy) ;=> #<SXQL-STATEMENT: DROP TABLE enemy>  (drop-table :enemy :if-exists t) ;=> #<SXQL-STATEMENT: DROP TABLE IF EXISTS enemy> alter-table (table &body clauses) (alter-table :tweet   (add-column :id :type 'bigint :primary-key t :auto-increment t :first t)   (add-column :updated_at :type 'timestamp)) ;=> #<SXQL-STATEMENT: ALTER TABLE tweet ADD COLUMN id BIGINT AUTO_INCREMENT PRIMARY KEY FIRST, ADD COLUMN updated_at TIMESTAMP> create-index (index-name &key unique using on) (create-index ""index_name""               :unique t               :using :btee               :on '(:table :column1 :column2)) ;=> #<SXQL-STATEMENT: CREATE UNIQUE INDEX index_name USING BTEE ON table (column1, column2)> drop-index (index-name &key if-exists on) (drop-index ""index_name"" :if-exists t :on :person) ;=> #<SXQL-STATEMENT: DROP INDEX IF EXISTS index_name ON person> SQL Clauses fields (fields :id) ;=> #<SXQL-CLAUSE: id>  (fields (:count :id)) ;=> #<SXQL-CLAUSE: COUNT(id)>  (fields :id (:sum :amount)) ;=> #<SXQL-CLAUSE: id, SUM(amount)> from (from :person) ;=> #<SXQL-CLAUSE: FROM person>  (from :person :person_config) ;=> #<SXQL-CLAUSE: FROM person, person_config>  (from (select :* (from :person) (where (:= :is_active 1)))) ;=> #<SXQL-CLAUSE: FROM (SELECT * FROM person WHERE (is_active = 1))> where (where (:and (:> :age 20) (:<= :age 65))) ;=> #<SXQL-CLAUSE: WHERE ((age > 20) AND (age <= 65))>  (yield *) ;=> ""WHERE ((age > ?) AND (age <= ?))"" ;   (20 65) order-by (order-by :age) ;=> #<SXQL-CLAUSE: ORDER BY age>  (order-by :age (:desc :id)) ;=> #<SXQL-CLAUSE: ORDER BY age, id DESC> ;   NIL group-by (group-by :sex) ;=> #<SXQL-CLAUSE: GROUP BY sex> having (having (:>= (:sum :hoge) 88)) ;=> #<SXQL-CLAUSE: HAVING (SUM(`hoge`) >= 88)> returning (returning :id) ;=> #<SXQL-CLAUSE: RETURNING `id`> limit (limit 10) ;=> #<SXQL-CLAUSE: LIMIT 10>  (limit 0 10) ;=> #<SXQL-CLAUSE: LIMIT 0, 10>  (yield *) ;=> ""LIMIT 0, 10"" ;   NIL offset (offset 0) ;=> #<SXQL-CLAUSE: OFFSET 0>  (yield *) ;=> ""OFFSET 0"" ;   NIL inner-join, left-join, right-join, full-join (inner-join :person_config :on (:= :person.config_id :person_config.id)) ;=> #<SXQL-CLAUSE: INNER JOIN person_config ON (person.config_id = person_config.id)>  (left-join :person_config :on (:= :person.config_id :person_config.id)) ;=> #<SXQL-CLAUSE: LEFT JOIN person_config ON (person.config_id = person_config.id)>  (left-join :person_config :using :config_id) ;=> #<SXQL-CLAUSE: LEFT JOIN person_config USING config_id> primary-key (primary-key :id) ;=> #<SXQL-CLAUSE: PRIMARY KEY (id)>  (primary-key '(:id)) ;=> #<SXQL-CLAUSE: PRIMARY KEY (id)>  (primary-key ""id_index"" '(:id)) ;=> #<SXQL-CLAUSE: PRIMARY KEY 'id_index' (id)> unique-key (unique-key '(:name :country)) ;=> #<SXQL-CLAUSE: UNIQUE (name, country)>  (unique-key ""name_and_country_index"" '(:name :country)) ;=> #<SXQL-CLAUSE: UNIQUE 'name_and_country_index' (name, country)> index-key (index-key (:name :country)) ;=> #<SXQL-CLAUSE: KEY (name, country)>  (index-key ""name_and_country_index"" '(:name :country)) ;=> #<SXQL-CLAUSE: KEY 'name_and_country_index' (name, country)> foreign-key (foreign-key '(:project_id) :references '(:project :id)) ;=> #<SXQL-CLAUSE: FOREIGN KEY (project_id) REFERENCES project (id)>  (foreign-key '(:user_id) :references '(:user :id) :on-delete :cascade) ;=> #<SXQL-CLAUSE: FOREIGN KEY (user_id) REFERENCES user (id) ON DELETE CASCADE> add-column (add-column :updated_at :type 'integer :default 0 :not-null t :after :created_at) ;=> #<SXQL-CLAUSE: ADD COLUMN updated_at INTEGER NOT NULL DEFAULT 0 AFTER created_at> modify-column (modify-column :updated_at :type 'datetime :not-null t) ;=> #<SXQL-CLAUSE: MODIFY COLUMN updated_at DATETIME NOT NULL> alter-column (alter-column :user :type '(:varchar 64)) ;=> #<SXQL-CLAUSE: ALTER COLUMN user TYPE VARCHAR(64)>  (alter-column :id :set-default 1) ;=> #<SXQL-CLAUSE: ALTER COLUMN id SET DEFAULT 1>  (alter-column :id :drop-default t) ;=> #<SXQL-CLAUSE: ALTER COLUMN id DROP DEFAULT>  (alter-column :profile :not-null t) ;=> #<SXQL-CLAUSE: ALTER COLUMN profile SET NOT NULL> change-column (change-column :updated_at :updated_on) ;=> #<SXQL-CLAUSE: CHANGE COLUMN updated_at updated_on> drop-column (drop-column :updated_on) ;=> #<SXQL-CLAUSE: DROP COLUMN updated_on> add-primary-key (add-primary-key :id :name) ;=> #<SXQL-CLAUSE: ADD PRIMARY KEY (id, name)> drop-primary-key (drop-primary-key) ;=> #<SXQL-CLAUSE: DROP PRIMARY KEY> rename-to (rename-to :users) ;=> #<SXQL-CLAUSE: RENAME TO `users`>  (alter-table :user   (rename-to :users)) ;=> #<SXQL-STATEMENT: ALTER TABLE `user` RENAME TO `users`> on-duplicate-key-update Support MySQL's INSERT ... ON DUPLICATE KEY UPDATE syntax. (on-duplicate-key-update :age (:+ :age 1)) ;=> #<SXQL-CLAUSE: ON DUPLICATE KEY UPDATE `age` = (`age` + 1)>  (insert-into :person   (set= :sex ""male""         :age 25         :name ""Eitaro Fukamachi"")   (on-duplicate-key-update :age (:+ :age 1))) ;=> #<SXQL-STATEMENT: INSERT INTO `person` (`sex`, `age`, `name`) VALUES ('male', 25, 'Eitaro Fukamachi') ON DUPLICATE KEY UPDATE `age` = (`age` + 1)> SQL Operators :not :is-null, :not-null :asc, :desc :distinct :=, :!= :<, :>, :<= :>= :a<, :a> :as :in, :not-in :like :and, :or :+, :-, :* :/ :% :raw Set a quote character *quote-character* is the character that a table or column name will be quoted with. The default value is NIL (not quote). (yield (select :* (from 'table))) ;=> ""SELECT * FROM table"" ;   NIL  ;; for MySQL (let ((*quote-character* #\`))   (yield (select :* (from 'table)))) ;=> ""SELECT * FROM `table`"" ;   NIL  ;; for PostgreSQL (let ((*quote-character* #\""))   (yield (select :* (from 'table)))) ;=> ""SELECT * FROM ""table"""" ;   NIL Author Eitaro Fukamachi (e.arrows@gmail.com) Copyright Copyright (c) 2013-2014 Eitaro Fukamachi (e.arrows@gmail.com) License Licensed under the BSD 3-Clause License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/sxql"	"A DSL for generating SQL.."	"true"
"C"	"CFFI"	"https://github.com/cffi/cffi"	"Portable, easy-to-use C foreign function interface.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"125"	"27"	"48"	"GitHub - cffi/cffi: The Common Foreign Function Interface Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 27 Star 125 Fork 48 cffi/cffi Code Pull requests 2 Wiki Pulse Graphs The Common Foreign Function Interface http://common-lisp.net/project/cffi 1,102 commits 6 branches 23 releases Fetching contributors Common Lisp 94.1% C 5.2% Other 0.7% Common Lisp C Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags bugfix-v0.10.7.1 enable-travis-osx foreign-string grovel++ master wip-better-load-library-error Nothing to show v0.17.1 v0.17.0 v0.16.1 v0.16.0 v0.15.0 v0.14.0 v0.13.0 v0.12.0 v0.11.2 v0.11.1 v0.11.0 v0.10.7.1 v0.10.7 v0.10.6 v0.10.5 v0.10.4 v0.10.3 v0.10.2 v0.10.1 v0.10.0 v0.9.2 v0.9.1 v0.9.0 Nothing to show New pull request Latest commit 4b706f4 Jun 21, 2016 dkochmanski committed with luismbo ecl: defcallback: fix calling-convention (#93) … This is for bytecmp and the C compiler compatibility. :cdecl doesn't work on Android, but :default works just fine. For C compiled code there is no difference. Permalink Failed to load latest commit information. doc Added expand-into-foreign-memory Apr 27, 2016 examples Make CFFI-grovel play well with ASDF 3.1.6 Oct 19, 2015 grovel grovel: fix pkg-config-cflags and use grovel-error Feb 5, 2016 libffi Fix the reinstating of :sizet, this time also considering the load or… Feb 24, 2016 scripts scripts/release: better new-version-number-candidates implementation Aug 12, 2013 src ecl: defcallback: fix calling-convention (#93) Jun 21, 2016 tests Fully liberate defcenum base-type until final decision is made. Feb 24, 2016 toolchain Avoid using uoip:os-cond Jun 11, 2016 uffi-compat Make CFFI-grovel play well with ASDF 3.1.6 Oct 19, 2015 .gitignore doc: generate an info directory file Nov 4, 2012 .travis.yml Revert ""travis: sbcl32 is flaky"" Apr 3, 2016 COPYRIGHT New example: mapping.lisp Apr 13, 2007 HEADER New example: mapping.lisp Apr 13, 2007 Makefile Makefile: rename acl to alisp Jun 4, 2008 README.md Fix badge URL Dec 6, 2014 TODO TODO cleanup Sep 12, 2008 cffi-examples.asd New example: mapping.lisp Apr 13, 2007 cffi-grovel.asd Make CFFI-grovel play well with ASDF 3.1.6 Oct 19, 2015 cffi-libffi.asd Refactor libffi code, get rid of type descriptor caching. Jan 19, 2016 cffi-tests.asd Fix libffi with enum argument Dec 19, 2015 cffi-toolchain.asd cffi-toolchain: depend on cffi Mar 12, 2016 cffi-uffi-compat.asd More copyright header year updates. May 3, 2006 cffi.asd Add ASDF:VERSION-SATISFIES method Mar 3, 2016 README.md CFFI, the Common Foreign Function Interface, purports to be a portable foreign function interface for Common Lisp. The CFFI library is composed of a Lisp-implementation-specific backend in the CFFI-SYS package, and a portable frontend in the CFFI package. The CFFI-SYS backend package defines a low-level interface to the native FFI support in the Lisp implementation. It offers operators for allocating and dereferencing foreign memory, calling foreign functions, and loading shared libraries. The CFFI frontend provides a declarative interface for defining foreign functions, structures, typedefs, enumerated types, etc. It is implemented in portable ANSI CL making use of the low-level operators exported by CFFI-SYS. Please consult the manual for further details, including installation instructions. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/cffi/cffi"	"Portable, easy-to-use C foreign function interface.."	"true"
"C"	"cl-autowrap"	"https://github.com/rpav/cl-autowrap"	"Automatically parses header files into CFFI definitions.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"71"	"6"	"12"	"GitHub - rpav/cl-autowrap: (c-include ""file.h"") => complete FFI wrapper Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 6 Star 71 Fork 12 rpav/cl-autowrap Code Issues 6 Pull requests 0 Pulse Graphs (c-include ""file.h"") => complete FFI wrapper 233 commits 3 branches 0 releases Fetching contributors Common Lisp 99.0% C 1.0% Common Lisp C Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags child-wrapper-removal master revert-46-uiop Nothing to show Nothing to show New pull request Latest commit cd30484 Jun 23, 2016 rpav Support anonymous record *fields* (#60) Permalink Failed to load latest commit information. autowrap Support anonymous record *fields* (#60) Jun 23, 2016 plus-c Fix dereferencing string field members Apr 29, 2016 t Fix dependency; further disable test loading until something robust i… Jul 24, 2013 .gitignore Ignore CCL fasls Sep 16, 2014 FAQ.md Typos Nov 20, 2014 LICENSE mv COPYING LICENSE Nov 26, 2013 README.md typo Oct 1, 2014 cl-autowrap-test.asd Fix dependency; further disable test loading until something robust i… Jul 24, 2013 cl-autowrap.asd Replace CFFI-SYS %FOREIGN-ALLOC / %FOREIGN-FREE with malloc/realloc/free Apr 12, 2016 cl-plus-c.asd First cut of cl-plus-c. Oct 11, 2013 cl-plus-c.md Remove THE from c-val Apr 22, 2016 README.md Issues? If you have issues, do not hesitate to file an issue! See the FAQ for some quick tips. cl-autowrap This is a new c2ffi-based wrapper generator for Common Lisp with a focus, performance, convenience, and completeness. It works like this: (c-include ""file.h"") That's it. This calls c2ffi and generates architecture-specific .spec files you can distribute with your project. Neither c2ffi, nor any compiler (or even .h files!) are necessary for your users! Types: structs (including bitfields!), unions, enums, typedefs, etc. Wrappers: Thin wrappers for structs, unions, and aliases of structs and unions: pointers and validation only, no expensive translation Accessors: Complete recursive accessors for structs and unions, including anonymous struct members, arrays, and pointers for each field. Functions: Macros which expand into foreign calls via CFFI-SYS Metadata: Full access to all the information about all types, functions, etc. For instance: /* test.h - abbreviated from example */ typedef struct foo {   int a, b;   char c[3];    struct {     unsigned int b0 : 2, b1 : 3;      struct {       char x, y;     } s;   } x[2]; } foo_t;  foo_t* get_foo(); void free_foo(foo_t *foo); int* get_int(); Out of this, we can do the following. (Note: dots are just part of the function names for disambiguation, this doesn't alter the reader): (c-include ""test.h"")  (let ((foo (get-foo)))   (setf (foo-t.a foo) 5)             ;; foo.a = 5;   (setf (foo-t.x[].b0 foo 0) #b10)   ;; foo.x[0].b0 = 2;   (print (foo-t.x[].s.x foo 1))      ;; anonymous struct   (foo-t.x[].s foo 0)                ;; => child wrapper   (foo-t.x[].s& foo 0)               ;; &(foo.x[0].s) => pointer   (free-foo foo)) Alternatively, there is now cl-plus-c, which can optionally be loaded for a different access mechanism and much quicker compile times: (asdf:load-system :cl-plus-c) (use-package :plus-c)  ;;; This allocates a FOO-T and frees it at the end: (c-let ((foo foo-t :free t))   (print foo)                        ;; => wrapper   (setf (foo :a) 5)                  ;; foo.a = 5;   (setf (foo :x 0 :b0) #b10)         ;; foo.x[0].b0 = 2;   (print (foo :x 1 :s :x))           ;; anonymous struct: foo.x[1].s.x   (foo :x 0 :s)                      ;; => child wrapper   (foo :x 0 :s &))                   ;; &(foo.x[0].s) => pointer See cl-plus-c.md for more information. Overview Using cl-autowrap is meant to get you to the ""lispifying"" stage of your wrapper as quickly and conveniently as possible: Make sure you have c2ffi Load your library as you normally would with CFFI Make a file for your c-include Examine wrappers and tweak if necessary Back to lisp! c2ffi You will need to build c2ffi if you have not already done so. This requires a repository version of LLVM and Clang, but the build process is straightforward. Again, note that your users do not need this, assuming you distribute the .spec files appropriate to their architecture. cl-autowrap should generate everything for you, though. If you decide not to install c2ffi, you can specify its path directly by setting autowrap:*c2ffi-program*, e.g.: (setf autowrap:*c2ffi-program* ""/path/to/my/c2ffi"") This should be part of your local configuration; do not set this in code you distribute. This includes LET forms around C-INCLUDE. Loading Libraries This should be done normally with CFFI. Either the high-level interface with CFFI:DEFINE-FOREIGN-LIBRARY and CFFI:USE-FOREIGN-LIBRARY or the low-level interface with CFFI-SYS:%LOAD-FOREIGN-LIBRARY work. Writing the c-include It's highly recommended that you use a separate package and file for cl-autowrap. The reasons are simple: A lot of symbols will be generated without regard. Many symbols will also be exported. A rather large number of functions and structs will be generated, resulting in a hefty compile time. With a separate file, this only needs to happen once. (In fact, you can now specify individual packages for each set of symbols that are generated. See below.) Once you have this, you can write a simple c-include. This must be a top-level statement: (c-include ""somefile.h"") This will look for somefile.h and generate .spec files in *default-pathname-defaults*, which is probably not very helpful! To fix this, use the following: (c-include (function-that-finds ""somefile.h"")            :spec-path #P""/path/to/spec"") (Note that while these parameters are eval'd, this happens at compile time, so if you use a *special-variable*, its definition needs surrounded by an EVAL-WHEN.) Hardcoded paths and reinventing functionality aren't very nice though; In both cases you can specify a complete ""ASDF path"" (starting with the system name), and it'll query the path from ASDF. For example, if we have an ASDF system called my-wrapper, we can do the following: (c-include '(my-wrapper some-module ""localfile.h"")            :spec-path '(my-wrapper spec-module)) Assuming you had defined ""localfile.h"" as a :static-file of some-module in my-wrapper, as well as spec-module, everything would work as intended. This is especially useful because you can have a single local header that includes all the files you wish to wrap, and those will be found by c2ffi in the standard include paths. Tweaking While c2ffi and cl-autowrap do quite a lot, there are a few times where you may want to or be required to intervene. You can look at any errors that occur, or the symbols that are exported, or even simply macroexpand the c-include and examine the output. By default, c2ffi outputs everything and likewise cl-autowrap imports everything. Thus you get a rather large sampling of libc where you probably don't need it. Thus you may want to exclude some definitions. You can do this in two ways: (c-include ""file.h""            :exclude-sources (""/path/to/source1""                              ""/path/.*source2"" ...)            :exclude-definitions (""SomeFunc1""                                  ""_suffix$"")) The first, :exclude-sources, looks at the source information generated by c2ffi for each definition. This is an easy way to exclude the majority of irrelevant definitions. You can make exceptions to this list via :include-sources: (c-include ""file.h""            :exclude-sources (""/path/to/source1""                              ""/path/.*source2"" ...)            :include-sources (""/path/to/source1/but-include-this"")) While everything else matching ""/path/to/source1"" will be excluded, in this example, definitions in ""/path/to/source1/but-include-this"" will still be included (if they exist). The next specifier, :exclude-definitions, excludes specific definitions by name. These may be conflicting or unnecessary. For instance, SDL2 includes a number of functions ending in _inline and some functions which use stdargs, all of which are unnecessary (or unusable). Both of these use cl-ppcre regular expressions to match, thus you have a great deal of flexibility with a few strings. You may also wish to simply rename some symbols. The default routine generally translates symbols like you want, but you may occasionally find C functions named in a way that breaks this. The default rules are as follows: XYZFooBar => XYZ-FOO-BAR foo_barBaz => FOO-BAR-BAZ _x_y => _X_Y (because I think -X-Y looks worse) However if you encounter something like ""FOObar"", it is likely you want ""FOO-BAR"", not ""FO-OBAR"", which is what you would get. Thus you can specify an exception: (c-include ""file.h""            :symbol-exceptions ((""FOObar"" . ""FOO-BAR"") ...)) These are simple, case-sensitive string matches and replacements. The replacement is interned exactly, so if you specify lowercase here, you will get a symbol with lowercase characters. There is also a more complex cl-ppcre-based match and replace facility: (c-include ""file.h""            :symbol-regex ((""^MATCH_string"" (PARAMS)                             (lambda (string matches regex) ..                                NEW-STRING)))) Using this facility, you may specify regex-function pairs. PARAMS specifies further parameters to PPCRE:CREATE-SCANNER, e.g., :case-insensitive-mode. If a symbol matches the given regex, the function will be called with the string, any substring matches, and the original regex (in case you want to further apply it). You must return a string, which will then be converted by the above rules into a final string. This should usually be unnecessary. The use case for its creation was handling names that vary unpredictably only by case: CLUTTER_KEY_OMEGA CLUTTER_KEY_omega CLUTTER_KEY_THORN CLUTTER_KEY_Thorn CLUTTER_KEY_Adiaeresis CLUTTER_KEY_adiaeresis In this situation, the more complicated regex-function matching is necessary. Alternatively, as was actually decided for the above clutter case, since there was ""no rhyme or reason"" to the naming scheme of the #define'd constants, one may filter constant names to be interned, opting, instead, for referencing them through a separate constant-accessor macro: (c-include ""file.h""             :exclude-constants ("".*"")             :constant-accessor clutter-constant) ;; Access constants like this: (clutter-constant ""CLUTTER_Z"") (clutter-constant ""CLUTTER_z"")  By default all ""known"" architectures (at the time of writing, windows, mac, linux on i686 and x86_64) are generated by default. This may not always work; for instance, one architecture may require header files your system lacks. You can exclude it using the following: (c-include ""file.h""            :exclude-arch (""i686-pc-win32"" ...)) This will exclude that target triple from being generated and causing a warning or output if it fails. You can also specify individual packages for symbol exports. This can be useful if, for instance, you wish to import all accessors, or all functions, or similar, while not necessarily importing everything: (c-include ""file.h""            :definition-package PACKAGE            :function-package PACKAGE            :wrapper-package PACKAGE            :accessor-package PACKAGE            :constant-package PACKAGE            :extern-package PACKAGE) :definition-package PACKAGE: All ""definition"" symbols, which include type names and function names (not to be confused with function macros which you use in your code) :function-package PACKAGE: All ""function"" symbols, which are all macros expanding to foreign calls :wrapper-package PACKAGE: All ""wrapper"" symbols, which are all structs generated to wrap foreign record types :accessor-package PACKAGE: All ""accessor"" symbols, which are all functions generated to access record fields :constant-package PACKAGE: All ""constant"" symbols, which are all +symbols+ representing C constants :extern-package PACKAGE: All ""extern"" symbols, which are all symbols (which are symbol-macros) representing C extern symbols Wrappers and FFI At this point you probably have definitions generated (or are hopefully submitting a question or bug report!). But how to use them? While cl-autowrap uses CFFI, it almost exclusively uses the low-level CFFI-SYS interface. It does not use the high-level type translation interface, or even cffi:defcfun. Pointers are still whatever your Lisp provides. Instead, cl-autowrap defines a ""new"" higher-level interface I call SFFI, for ""simplified FFI"". While CFFI's high-level interface is nice for manually defining types and functions, it proves difficult when trying to automatically generate things or exercise precise control over various things like field layout. You should never have to deal with SFFI directly, but all the fine-grained type information is available should you require access. This is occasionally useful. See below in the SFFI section for details. However, you cannot use CFFI constructs from another wrapper directly with SFFI-defined functions, or vice versa, but you can always use pointers between the two. Functions cl-autowrap defines macros which wrap C calls with a few helpful features: Wrappers (see below) or pointers are accepted for any pointer-to-struct (or union) Symbols or integers are accepted for any enum Lisp strings will be temporarily converted to C strings, then freed, for char* or unsigned char*. (If you need these to persist, you must provide your own pointer!) For char* and unsigned char* returns, both a lisp string and a pointer are returned as VALUES, so you can free the pointer if necessary. You may prevent this conversion, and receive only the pointer, if you wrap the call in INHIBIT-STRING-CONVERSION: (inhibit-string-conversion (function-returning-string ...))   ;; => pointer Otherwise, the call will be like any C call; there is no other type translation. In my experience, all but the most trivial C functions benefit from some wrapping, so this shouldn't be a big issue. However, see ""Other Features"" below for some other helpful features, such as bitmasks. Wrappers Instead of merely returning pointers, cl-autowrap defines very thin wrappers for non-atomic named types. Wrappers are structs which contain two things: A pointer, which is accessible with AUTOWRAP:PTR A VALID-P field, which is used for storing pointer validity, and can be checked by AUTOWRAP:VALID-P Wrappers are extremely useful for ""safely"" managing pointers, and are meant to be safe and ""pretty"" enough for users of your wrapper to use directly. Any dereference using PTR automatically checks validity, and you can use finalizers to clean them up. Note however that this is up to you: cl-autowrap merely provides the facility, nothing else. See ""Garbage Collection and Wrappers"" below. Additionally, cl-autowrap generates a correct ""type hierarchy"", as much as such applies to C: struct x { ... }; typedef struct x y; Results in: (defstruct (x (:include wrapper))) (defstruct (y (:include x))) This ensures type compatibility where the C side may arbitrarily specify compatible type aliases. You may also obtain a ""child"" wrapper for a struct which is a field in another struct, using accessors: struct foo_t {    :    struct { int a, b; } x; }; (let* ((foo (get-foo-somehow))        (x (foo-t.x foo)))   :   :   ... ) This keeps a reference to the parent. These may also be safely dereferenced using AUTOWRAP:PTR, and checked using AUTOWRAP:VALID-P. Because there is a reference is kept to the parent, even if a reference is discarded by the user, the child is still safe to use. Garbage Collection and Wrappers One of the primary motivators behind wrappers is the ability to easily garbage collect C data. However, this still requires some care. To this end, the AUTOCOLLECT macro has been added; see below. First, nothing besides checking is done automatically. Pointers are assumed valid when they are returned and made into wrappers. Any further invalidation and garbage collection must be handled by the one writing the wrapper. Important: Absolutely no effort is made to keep wrappers unique or manage duplicates. Again: YOU CAN HAVE DUPLICATE WRAPPERS AND THIS CAN LEAD TO BAD THINGS. Generally this should only occur if you obtain the same pointer from a C API multiple times, such as a function which returns a global context pointer. It is up to you to handle this. Beware. Once you are aware of this, you can use something like trivial-garbage to free pointers when you need: (defun lispy-get-thing ()   (let* ((thing (get-thing))          (ptr (autowrap:ptr thing)))     (tg:finalize thing (lambda () (free-thing ptr)))     thing)) Note as as always to never reference the object, only the pointer, in the finalizer, or it will never be collected. It is often useful to free things when you still have a reference. In this case, the pointer becomes invalid, and this is also handled by WRAPPER: (defun lispy-free-thing (thing)   (unwind-protect (free-thing thing)     (tg:cancel-finalization thing)     (autowrap:invalidate thing))) In this case, further attempts to dereference THING via AUTOWRAP:PTR will result in an INVALID-WRAPPER error. You may be tempted to do this: (defun bad-free-thing (thing)   (tg:cancel-finalization thing)   (autowrap:invalidate thing)   (free-thing thing)) Unfortunately, since you invalidated THING, when you pass it to FREE-THING, it will be invalid ... resulting in an error. Never manage ""child"" wrapper objects. This probably goes without saying, but they're tied to the parent object, and not meant to be managed separately. Also, you may be tempted to do this, to avoid ""dangling pointers"": (defun terrible-get-thing ()   (let* ((thing (get-thing))          (ptr (autowrap:ptr thing)))     (tg:finalize thing       (lambda ()         (free-thing ptr)         (setf (autowrap:wrapper-ptr thing)               (cffi:null-pointer))))     thing)) This is both wrong and silly: there is a reference to THING in the finalizer, so it will never get freed. And if you had gotten here normally, there would be no references, so nothing would have the dangling pointer! To facilitate doing this correctly, the AUTOCOLLECT macro has been added: (autocollect (&optional PTR) WRAPPER-FORM &body) => WRAPPER-FORM-RESULT If you are using trivial-garbage, this will extract the pointer from WRAPPER-FORM and call tg:finalize on the wrapper. The body forms should use POINTER to free the object. If you are not using trivial-garbage, it will produce an error. For instance: (autocollect (pointer)     (get-thing)   (free-thing pointer)) ;; => THING-WRAPPER This will call GET-THING and finalize the resulting wrapper with the body. POINTER is the pointer; this defaults to the symbol PTR. This is not fool-proof. Things to watch out for: If you reference the wrapper, and not the pointer, it will never be collected. If you try to autocollect a child wrapper, you will probably crash. If you provide a function to manually free resources, you must use tg:cancel-finalization or this finalizer will still be called, likely double-freeing the memory and crashing. It's still up to you to call something to free the pointer. Accessors Having wrappers and functions are nice, but getting at the data is important too. Accessors are generated recursively (up to a depth of 5, barring recursive types) for highly convenient access. From the top: typedef struct foo {   int a, b;   char c[3];    struct {     unsigned int b0 : 2, b1 : 3;      struct {       char x, y;     } s;   } x[2]; } foo_t; Accessors are named starting with their type name (in this case, FOO and FOO-T), followed by fields, separated by dots. There is no reader magic here: these are functions with dots as part of the name. (Dots were used mostly for disambiguation; if only dashes were used, name collision would be probable, since underscores are converted to dashes by default.) The following special cases are available: type.foo in the case of foo being a record type (struct or union), will return a child wrapper. type.foo in the case of foo being a pointer will return the pointer type.foo& will return a pointer to the field, not a wrapper, regardless of the type of foo. If foo is a pointer, then you get a pointer-pointer. This is just the same as &(x.foo) in C. This does not exist for bitfields. type.foo* will dereference foo where foo is a pointer to a well-defined type, including record fields. E.g., type.foo*.bar; there is no type.foo.bar. type.foo[] references an array element, where foo is declared as an array (not just as a pointer). Array indices are specified in order after the object: (type.foo[].bar[] obj i0 i1) is the equivalent of C's obj.foo[i0].bar[i1]. Additionally, SETF can set almost any field. The exceptions are any accessor which dereferences a record (i.e. returns a child wrapper), or is suffixed with &. Bitfields are supported under the assumption that they are packed LSB-to-MSB on little endian and MSB-to-LSB on big endian architectures. If you actually encounter a problem with this, file a bug report with full details: the architecture, OS, lisp, C compiler, and an example struct. Theoretical possibilities are not considered bugs. Note that bitfield operations cannot be done atomically and may not be done field-atomically (that is, you may have to lock the entire struct). Additionally, you cannot take the address of a bitfield. However, you can get information from SFFI metadata, or simply using the convenience function AUTOWRAP:BITFIELD-MASK. Other Features cl-autowrap has a number of other features that have not been discussed: Allocation Enums Bitmasks Callbacks SFFI metadata and functions Allocation Since autowrap implements its own higher-level constructs over lower-level CFFI, you can't use CFFI's FOREIGN-ALLOC or similar functions and macros to easily allocate foreign records. Thus there are new constructs for doing so: (let ((thing (autowrap:alloc 'type)))   :   (autowrap:free thing)) As you might expect, ALLOC will allocate memory of sufficient size for TYPE, and FREE will free it (and invalidate the wrapper for you). Note that if you are doing garbage collection as above, this does NOT remove finalizers for you: you MUST take care of this yourself where applicable. There are also macros which will help with temporary allocation: (with-alloc (thing 'type)    :    :    ) This will take care of allocation and freeing within the block. You should not use finalizers here. If you try to reference the value outside of the scope of the block, it will be invalid. If you wish to allocate multiple objects and free them, you can use the following: (with-many-alloc ((thing1 'type1)                   (thing2 'type2)                   :                    )   :   ) Note that while any typedef type aliases can be referenced simply by symbol as in C, record types are called (:struct (NAME)) or (:union (NAME)), and also like C, you must write this out if there is no type alias for NAME. For example: struct X { ... }; typedef struct Y { ... } Y;  int main() {     struct X foo;    /* No type alias */     Y bar;           /* Type alias */ } (with-many-alloc ((foo '(:struct (X))) ;; No type alias                   (bar 'Y))            ;; Type alias     :     ) Arrays In addition to single objects, autowrap also allows allocation and reference to arrays of objects. This is less safe, however: there are no provisions for bounds-checking, since the data is simply not there. (While in theory, we could add size data on the lisp side, this is a false sense of security, since you will often be dealing arrays from C.) Allocation methods all take an optional COUNT parameter: (alloc x 'type 3)  (with-alloc (x 'type 5) ...)  (with-many-alloc ((x 'type 5)                   (y 'type 2))   ...) To reference these, you can use C-APTR and C-AREF: (c-aptr x 1) ;; => raw pointer (c-aref y 2) ;; => wrapper Unfortunately, this may present some performance issues, since unlike record accessors, the type must be looked up at runtime. In theory, autowrap could generate array accessors for all types, but this would vastly increase the number of accessors generated with little value, since most will not be used. Instead, you may specify the type explicitly: (c-aptr x 1 'type) ;; => pointer (c-aptr y 2 'type) ;; => wrapper In this case, as long as 'type is constant-p, the compiler macro should expand it at compile-time. Basic C types (e.g., :int, :char, etc) are also supported; in this case, a wrapper is not returned, but the value itself: (c-aref x 1 :int) ;; => number You can also set array members for basic types only: (setf (c-aref x 1 :int) 10) In both of these cases, since autowrap does not provide additional wrappers for basic types, you must specify the type explicitly. Enums Enums are imported and created as types, but they're typically used by specifying a keyword: enum E {   FOO_X, FOO_Y, FOO_Z };  void fun(E); (fun :x) As you can see, common prefixes are eliminated and the symbols are interned as keywords. Additionally, functions taking enum symbols can also take numbers: (fun 1) You can also find the value or keyword for an enum as follows: (autowrap:enum-key '(:enum (enum-name)) :key) (autowrap:enum-value '(:enum (enum-name)) 1) An actual AUTOWRAP:FOREIGN-ENUM can be used in place of 'enum-name if desired; otherwise it will be looked up via AUTOWRAP:FIND-TYPE. Bitmasks Bitmasks aren't actually a type in C, and are often defined as constants instead of enums or similar. Therefore, there is no real automatic way to determine a bitmask. Thus cl-autowrap provides a number of convenience facilities for doing this: (autowrap:define-bitmask 'NAME   '((:key1 . #x0001)      :       ...)) This defines a bitmask called NAME, which is separate from other C types, and can be used with the MASK function: (some-function (autowrap:mask 'NAME :key1 :key5))  This also has a compiler macro which will expand to an integer constant if the value can be determined at compile-time. Additionally, to aid in converting predefined constants to bitmasks, there is the following macro, which expands to an AUTOWRAP:DEFINE-BITMASK call: (autowrap:define-bitmask-from-constants (name)   +some-foo+   +some-bar+   +some-baz+) This essentially expands to the following: (autowrap:define-bitmask 'name   (list `(:foo . ,+some-foo+)         `(:bar . ,+some-bar+)         `(:baz . ,+some-baz+))) Callbacks Autowrap now provides a thin layer on top of CFFI-SYS:%DEFCALLBACK: (autowrap:defcallback NAME RETURN-TYPE     ((PARAM TYPE)      ...)   ...) The main difference is that you may specify SFFI type aliases as parameters, since these are not available to the higher-level CFFI:DEFCALLBACK. Additionally, there is the following: (autowrap:callback 'name) This simply expands to CFFI-SYS:%CALLBACK, but is provided for convenience. SFFI Metadata and Functions This is not fully-documented at the moment, but full access to metadata and definition functions is available. For instance: (autowrap:find-type '(:struct (struct-name))) This will return the object that represents struct struct_name, or nil. If nothing else, it should be fairly easy to inspect this value and look at fields, types, etc. Accessors are exported for all types (or should be); see package.lisp for a complete list. These values can certainly be useful when doing various tricky things with C data, and it's also certainly possible to manually write definitions for every type and generate lisp functions, though for records (i.e. struct and union), this requires explicitly specifying bit sizes and field layouts. While probably not directly useful (or necessary) for importing C types, these could be useful for generating similar definitions via other means than c2ffi. Copying This is licensed under the BSD 2-Clause license. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/rpav/cl-autowrap"	"Automatically parses header files into CFFI definitions.."	"true"
"Java"	"cl+j"	"https://common-lisp.net/project/cl-plus-j/"	"A JNI-based interface to a JVM via CFFI. Not available on Quicklisp. Does not reliably work with all implementations.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"null"	"null"	"null"	"CL+J: A Common Lisp Interface to Java CL+J A Common Lisp Interface to Java. Introduction CL+J is a JNI based interface to a Java Virtual Machine through CFFI. It targets safe, exact and complete access to Java from Common Lisp with as high integration as possible of the Java and CL respective runtime environments (especially at the condition/exception level). CL+J uses a set of reader dispatch-macros to simplify the Java code interface. In CL+J the traditional ""Hello World!"" becomes: (#_System.out.println (jstr ""Hello World!"")) Printing the list of System properties to the Java standard output stream is simply: (#_list (#_System.getProperties) #?System.out) Download The current version of CL+J is 0.3 and should be considered of good ""beta"" reliability. You can download it from here: cl+j-0.3.tar.gz Implementation support Co-existence with such an elaborate set of foreign code as a full Java Virtual Machine certainly is, constitutes pretty much the ultimate acid test for a Common Lisp Foreign Function Interface subsystem. Only a few Common Lisp environments can meet such a challenge. Here is a non-exhaustive list of CL systems known to work with CL+J 0.3, in decreasing order of reliability: ManKai Common Lisp (MKCL): CL+J 0.3 works fully on MKCL on any platforms supported by MKCL (Linux/x86 (32bits), Linux/x86_64 (64 bits), Windows XP (Win32), Windows 7 (Win64)). No special JVM option is required on any of the widely available JVMs such as Oracle's HotSpot, IcedTea or IBM's JVM. MKCL is the reference platform for the development and debugging of CL+J. Clozure Common Lisp (CCL): CL+J 0.3 works on CCL for Linux/x86 or Linux/x86_64 if IBM's JVM is used with option -Xrs but will crash during JVM initialization without that option or if Oracle's HotSpot or IcedTea is used. CL+J 0.3 seems to work fully on CCL for Windows XP (Win32) or Windows 7 (Win64) with any of the widely available JVMs (Oracle's HotSpot, IBM's JVM) and this without any special JVM option. CL+J 0.3 may work on CCL for some the other platforms supported by CCL (such as Mac OS X, Solaris, ...). Note that on CCL the reader macro #_ is replaced by #] since the former is already used by CCL for its foreign function interface. ECL: CL+J 0.3 should work on ECL for Linux (32 bits or 64 bits) as long as the foreign code (JVM included) behaves strictly according to ECL's requirements on Unix signal masks. Such a compliance on the part of the foreign code is not very likely. CL+J 0.3 should most probably (but this has not been tried) work fully on ECL for Windows XP (Win32) or Windows 7 (Win64) with any of the widely available JVMs (Oracle's HotSpot, IBM's JVM) and this without any special JVM option. Steel Bank Common Lisp (SBCL): CL+J 0.3 does NOT work reliably on SBCL for Linux/x86 or Linux/x86_64 due to SBCL's inability to handle Unix signals properly in the presence of foreign threads. The problem is clearly observable under SLIME since SLIME generates a fairly intense signal activity through timers. In such a context SBCL crashes into its low level debugger LDB claiming memory corruption within 20 to 30 minutes of even unattended use. On Windows XP (Win32) SBCL is still considered ""experimental"" and does not build with thread support by default, CL+J 0.3 may work on it but has not been tried. A port of SBCL on Win64 does not seem to exist officially yet (2012/07/22) but is in progress according to the SBCL web site. Library Requirements ASDF 2 CFFI 0.10.6 which in turn requires: Babel 0.3.0 alexandria (2008-08-02 or later) trivial-features 0.6 Trivial-garbage 0.19 Bordeaux-Threads 0.8.0 Getting Started You need to specify the location of your JRE like this: (defvar cl-user:*jre-home* ""/some/path/leading/to/your/jre"") or tell the exact location of your JVM shared library like this (would end in jvm.dll on MS-Windows): (defvar cl-user:*jvm-path* ""/some/path/to/your/libjvm.so"") You should also provide some options to be read at JVM creation time with something like this: (defvar cl-user:*jvm-options* '(""-Djava.class.path=/your/path/to/cl_j.jar:/and/maybe/some/other.jar"")) or, if you need more options to be passed during initialization of the JVM: (defvar cl-user:*jvm-options* '(""-Djava.class.path=/your/path/to/cl_j.jar:/and/maybe/some/other.jar"" ""-Xrs"")) Now that the context is set, you can ask ASDF to compile and load CL+J this way: (asdf:oos 'asdf:load-op :cl+j) You are then ready to initialize the Java VM by calling: (cl+j:java-init) At this point Java is fully accessible. Documentation Proper documentation of the CL+J public interface has yet to be written. In the meantime you could have a look at the code in the demos directory. Currently the small programs in the demos directory should be loaded from a package that uses package ""CL+J"" like this: CL-USER> (cl+j:java-init) CL-USER> (use-package :cl+j) CL-USER> (load ""demos/hello_swing.lisp"") TODO Document the public interface of CL+J. Mailing Lists cl-plus-j-devel for developers cl-plus-j-cvs CVS log feed. cl-plus-j-announce for announcements. News 2012-07-22: CL+J 0.3 released. 2011-06-01: CL+J 0.2 released. 2009-03-19: CL+J 0.1 released."	"null"	"null"	"A JNI-based interface to a JVM via CFFI. Not available on Quicklisp. Does not reliably work with all implementations.."	"true"
"Miscellaneous"	"Foil"	"http://foil.sourceforge.net/"	"A foreign object interface; works with the JVM and CLI. Not available on Quicklisp.."	"null"	"null"	"null"	"CPL 1.0"	"http://directory.fsf.org/wiki/License:CPLv1.0"	"null"	"null"	"null"	"null"	"null"	"Foil - a Foreign Object Interface for Lisp Foil - a Foreign Object Interface for Lisp Copyright (c) Rich Hickey and Eric Thorsen. All rights reserved. The use and distribution terms for this software are covered by the Common Public License 1.0, which can be found in the file CPL.TXT at the root of this distribution. By using this software in any fashion, you are agreeing to be bound by the terms of this license. You must not remove this notice, or any other, from this software. Contents Description Download Quick Start API Reference Foreign VMs Foreign References Wrapper Generation Object Creation Object Services Vectors Miscellaneous Proxies and Callbacks Marshalling Runtime Servers Protocol Summary Description and Rationale Foil consists of a protocol and a set of libraries that facilitate access to popular object runtimes, such as the JVM and the CLI/CLR, and their libraries, from Lisp. A protocol is defined which abstracts out the common features provided by Java-like environments - object construction, method, field, and property access, object lifetime management etc. The protocol defines a set of features as well as an s-expression based stream format for communication. Runtime server applications are provided that utilize Java and C# libraries to implement the object runtime side of the protocol for Java and the CLI. Source for the applications is provided so that custom hosts can be built. A library for Common Lisp is provided that implements the consumer side of the protocol, and offers seamless access to the foreign objects in a Lisp-like manner. The design of Foil owes much to jfli, an in-process solution to the same problem for Java, and it remains extremely similar in its Lisp interface. Several factors motivated the significant difference in the Foil design - its use of an out-of-process instance of the foreign runtime: jfli did not see wide porting, due to its use of LispWorks' sophisticated FLI to access JNI, and the lack of corresponding facilities in some other Lisps I found that I needed to access already-running instances of the JVM, for instance servlet containers, as done in Lisplets, and felt I could accomplish similar things with less effort with Foil + marshallers I wanted to access the CLR/CLI in a similar fashion to Java It allows for more flexibility in dealing with threading issues The major tradeoff in stream-based access to out-of-proc runtimes is a significant drop in per-call performance. However, even with jfli, which was very fast, the overhead of reflection per call could be high in certain scenarios, since the APIs of these platforms tend to be very 'chatty'. Foil includes a marshalling system that allows for efficient transfer of large and composite objects with minimal call overhead, in a manner that doesn't pollute the Lisp code on the consumer side. Foil provides all the facilities of jfli and more - Features of jfli that are retained/enhanced: Automatic function generation for constructors, fields, methods, and properties either by named class, or entire package (sub)trees given a jar file or assembly name. Java/CLI -> Lisp package and name mapping with an eye towards lack of surprise, lack of conflict, and useful editor completion. setf-able setter generation for fields and properties Java/CLI vector creation and aref-like access to Java/CLI vectors. Constructors that allow for keyword-style property initialization. Typed references to Java/CLI objects with an inheritance hierarchy on the Lisp side mirroring that on the Java/CLI side - allowing for Lisp methods specialized on Java/CLI class and interface types. Implementation of arbitrary Java/CLI interfaces in Lisp, and callbacks from Java/CLI to Lisp via those interfaces. Automatic lifetime maintenance of Lisp-referenced Java/CLI objects, boxing/unboxing of primitive args/returns, string conversions, Java/CLI exception handling, overload resolution etc. Some of the additions are: (Hopefully) Much improved portability (n.b. it has not been ported, but is mostly standard CL) Access to the CLR with the same API Support for CLR and JavaBean properties Simultaneous access to multiple runtimes Simultaneous access to the CLR and Java A marshalling system which can, in a single call, pull across the types, hashcodes, and/or values of reference objects to an arbitrary depth, with user customizable value marshallers. All references to the same remote object are eq on the Lisp side ensure-typed-ref, which makes a remote reference its most fully derived type in Lisp, works in place, using change-class vector argument boxing, so lightweight vectors-as-arguments can be created in-place without the overhead of multiple calls to create and initialize the vector keyword-style init of properties in constructor calls is supported by the ctor functions, and can be leveraged in apply and mapping scenarios (this feature was limited in jfli to the new macro) Download and Communication Foil is hosted on SourceForge We are going to try using SourceForge facilities for all communication regarding Foil, so please use the project tracker and forums there. Quick Start Build and start the Java or CLI runtime server of your choice.  (compile-file ""/dev/foil/foil.lisp"") (load ""/dev/foil/foil"") (use-package :foil) ;this is specific to LispWorks' sockets support (require ""comm"") ;create a foreign VM (setf *fvm* (make-instance 'foreign-vm                            :stream                            (comm:open-tcp-stream ""localhost"" 13579)))  ;;;;;;;;; if Java ;;;;;;;;;;; ;create a wrapper for dialog class (def-foil-class ""javax.swing.JOptionPane"") ;use the wrapper (use-package ""javax.swing"") ;show it (joptionpane.showmessagedialog nil ""Hello World from Lisp"")  ;;;;;;;;; if CLI ;;;;;;;;;;;; ;create a wrapper for dialog class (def-foil-class ""System.Windows.Forms.MessageBox"") ;use the wrapper (use-package ""System.Windows.Forms"") ;show it (messagebox.show ""Hello World from Lisp"") Typically you wouldn't define single class wrappers by hand, but would instead pre-generate wrappers for entire packages using get-library-classnames and dump-wrapper-defs-to-file. See foil-java.lisp and foil-cli.lisp for examples. Lisp API Reference Other than 2 wrapper-generator helpers, all of the code for the Lisp side of foil resides in foil.lisp, and is runtime server independent. Foil is designed to be very portable, and is 99% pure Common Lisp. A complete port requires some facility for weak hash tables and object finalization. Foreign VMs Foil is built upon the notion of interactions with one or more foreign VMs, instances of the JVM or CLR, running the Foil libraries, in another process on the same or another machine. The connection to a specific VM is via one or more bidirectional streams. Note that the instantiation of the foreign VM and the establishment of the streams is outside the scope of this Lisp API. It is presumed you might utilize one of the supplied runtime servers, creating stream connections via sockets or pipes with the API provided by your Lisp implementation. Many scenarios are possible, including embedding the Foil support libraries into your existing Java or C# application, multiple streams to different threads in the same VM, etc. A foreign VM is represented by an instance of the foreign-vm class. Each instance has a primary default stream over which communication will occur. The special variable *fvm* represents the default VM to which any unqualified Foil calls will be directed, and can be bound in a specific context, thus allowing for multiple VMs. Note - instance property/method calls will always be routed to the VM hosting that instance. Foreign VMs maintain their own foreign reference pools, type caches etc, and objects from one VM cannot be passed to another, even if they are both Java or CLI. However, in multi-thread, multi-stream scenarios, references are valid across threads in the same VM, and the runtime server implementations are thread safe. A simple startup scenario would look like this: - First, outside of Lisp, start the Java or CLI Foil runtime server supplied with Foil, running on port 13579, then:     (load ""/dev/foil/foil"")    (use-package :foil)    (require ""comm"") ;LispWorks-specific socket library    (setf *fvm* (make-instance 'foreign-vm                            :stream                            (comm:open-tcp-stream ""localhost"" 13579)))     ;use Foil  Special Variable *fvm* This must be bound to an instance of foreign-vm. Default: nil Direct use of this other than during initial setup is not recommended, use instead with-vm or with-vm-of Special Variable *thread-fvm* If set, this thread is waiting on a callback from this VM. Default: nil This is only used for advanced multi-thread scenarios Special Variable *thread-fvm-stream* If this thread is waiting on a callback (i.e. *thread-fvm* is bound), and (eql *fvm* *thread-fvm*), use this stream instead of the primary default stream for the VM. Default: nil This is only used for advanced multi-thread scenarios Class foreign-vm Manages a foreign VM. Requires the initarg :stream be set to a bidirectional stream with an instance of the Foil runtime services on the other end. Macro (with-vm vm &body body) Causes the body to be evaluated in a context where *fvm* is bound to vm Macro (with-vm-of this &body body) Causes the body to be evaluated in a context where *fvm* is bound to the source VM of this Foreign References Foil programs invariably create instances of objects in the foreign VM. Those objects are tracked by Lisp in instances of the fref class. The Foil API and the runtime server cooperate to ensure that objects referenced by Lisp are kept alive in the foreign runtime, and that when no longer referenced by Lisp, they become available for collection in the foreign VM. frefs maintain their source VM, an ID and revision counter for this purpose. In addition, frefs can cache hash codes, types, and values that have been marshalled. Only a single fref will be created for each remote object, thus any 2 frefs that reference the same object are themselves eq. Class fref Reference to a foreign object. fref is the superclass of all of the Foil classes generated to mirror the foreign hierarchy. Method (fref-vm fref) ->The foreign-vm from which this reference originated Method (fref-id fref) ->An integer ID, unique within a VM Method (fref-type fref) ->A Class or Type fref This will only be set if the type has been marshalled or get-type has been called on this fref. Method (fref-hash fref) ->int This will only be set if the hash code has been marshalled or hash has been called on this fref. Method (fref-val fref) -> A Lisp object representing the value of the object This will only be set if the value has been marshalled. Function (ensure-typed-reference fref) -> fref, whose class may have been changed Given a generic Foil fref, determines the full type of the object and uses change-class to convert the fref to that type. Since we don't want to always incur the cost of type determination, the wrapper-generated API functions return generic references. Use this function to convert to a typed reference corresponding to the full actual type of the object when desired:  CL-USER 42 > (setf string-class (get-type-for-name ""java.lang.String"")) #}1  CL-USER 43 > (type-of string-class) FREF  CL-USER 44 > (ensure-typed-ref string-class) #}1  CL-USER 45 > (type-of string-class) CLASS.      Wrapper Generation Macro (def-foil-class full-class-name) -> unspecified Given the package-qualified, case-correct name of a Java/CLI class as a string, will generate wrapper functions for its public constructors, fields, properties and methods. The core API for generating interfaces to Java/CLI is the def-foil-class macro. This macro will, at expansion time, use Java/CLI reflection to find all of the public constructors, fields, properties and methods of the given class and generate functions to access them. The Generated API When you e.g. (def-foil-class ""java.lang.ClassName"") you get several symbols/functions: A package named |java.lang| (note case) from which the following are exported: A class-symbol: classname. (note the dot is part of the name) which can usually be used where a typename is required. It also serves as the name of the Lisp typed reference class. Every non-interface class with a public constructor will get; A constructor, (classname.new &rest args) -> fref, which returns a foreign-reference (fref) to the newly created object. Note that the constructor function, and therefore everything built upon it, can take the actual arguments to the Java/CLI ctor, followed by zero or more property initializers, which take the form: :keywordized-propertyname value e.g. (window.new parent :width 200 :height 200) thus supporting the creation and some setup of a new object in a single call A method defined on make-new, ultimately calling classname.new, specialized on (the value of) the class-symbol Note that if the constructor is overloaded, there is just one function generated, which handles overload resolution. The function documentation string describes the constructor signature(s) from the Java/CLI perspective. The same argument conversions are performed as are for fields (see below). All public fields will get a getter function: (classname.fieldname [instance]) -> field value and a setter: (setf classname.fieldname [instance]) Instance field wrappers take a first arg which is the instance. Static fields get a symbol-macro *classname.fieldname* If the type of the field is primitive, the field value will be converted to a native Lisp value. If it is a Java/CLI String, it will be converted to a Lisp string. Otherwise, a foreign reference to the Java/CLI object is returned. Similarly, when setting, Lisp values will be accepted for primitives, Lisp strings for Strings, or foreign references for reference types. All public properties (explicit properties in the case of the CLI, implied properties in the case of Java as specified by the JavaBeans protocol) will get a getter function if the property supports get: (classname.propertyname [instance] [args]) -> property value and a setter if the property supports set: (setf classname.propertyname [instance] [args]) Instance property wrappers take a first arg which is the instance. Static properties get a symbol-macro *classname.propertyname* Every public method will get a wrapper function: (classname.methodname &rest args) -> return-value As with constructors, if a method is overloaded a single wrapper is created that handles overload resolution. The same argument and return value conversions are performed as are for fields. The function documentation string describes the method signature(s) from the Java/CLI perspective. A Lisp class with the class-symbol as its name. It will have as its superclasses other Lisp classes corresponding to the Java/CLI superclass/superinterfaces, some of which may be forward-referenced-classes, and will be ultimately derived from fref. An instance of this class will be returned by ensure-typed-ref, at which point the entire hierarchy will consist of finalized standard-classes. Note that, due to the need to reference other Java/CLI types during the definition of a class wrapper, symbols, classes, and packages relating to those other types may also be created. In all cases they will be created with names and packages as described above. Function (get-library-classnames jar-or-assembly-filename &rest packages) -> list-of-strings Returns a list of class name strings. Packages should be strings of the form ""java/lang"" or ""System/IO"" for recursive lookup and ""java/util/"" or ""System/IO/"" (note trailing slash) for non-recursive. Function (dump-wrapper-defs-to-file filename classnames) -> filename Given a list of classnames (say from get-library-classnames), writes the consolidated expansions of calls to def-foil-class to a file:  (dump-wrapper-defs-to-file ""/lisp/java-lang.lisp""   (get-library-classnames ""/j2sdk1.4.2_01/jre/lib/rt.jar "" ""java/lang/"")) (compile-file ""/lisp/java-lang"") (load ""/lisp/java-lang"") (use-package ""java.lang"") ;Wrappers for all of java.lang are now available  This is the recommended way to access entire library packages. In particular, it has the advantage that the dumped code does not require a foreign runtime to either compile or load. Object Creation In addition to the generated ctor wrappers (classname.new described above), the following, built upon the same, add some additional capabilites and ease of use: Generic Function (make-new classname. &rest args) -> fref Allows for definition of before/after methods on constructors. Calls classname.new ctor. The new macro expands into a call to this. Macro (new class-spec args &body body) -> fref class-spec -> class-sym | (class-sym this-name) class-sym -> classname. args -> as per ctors and make-newCreates a new instance of class, using the make-new generic function, then runs the body replacing all top-level calls of the form (.anything whatever) with (classname.anything new-object whatever) If this-name is supplied it will be bound to the newly-allocated object and available to the body (note - but not to the args!) Example:  (new shell. (*display* :text ""SWT Apropos"" :layout (gridlayout.new 1 t ))                   (.setsize 800 600)                   (.setlocation 100 100))            Expands into:  (LET ((#:G2249 (MAKE-NEW SHELL. *DISPLAY* :TEXT ""SWT Apropos"" :LAYOUT (GRIDLAYOUT.NEW 1 T))))   (PROGN     (SHELL.SETSIZE #:G2249 800 600)     (SHELL.SETLOCATION #:G2249 100 100))   #:G2249) Object Services These functions provide access to basic facilities provided by all runtimes (usually through syntax or the Object class), but should be used instead, as they are portable and can be more efficient, caching and resolving some things locally on the Lisp side. Function (equals fref1 fref2) -> boolean Portable Object.equals/Equals Function (instance-of fref type) -> boolean Portable instanceof/is Function (to-string fref) -> string Portable Object.toString/ToString Function (hash fref &key rehash) -> int Portable Object.hasCode/GetHashCode. Note: will cache the value on the fref. If already cached, will return that, unless :rehash is t. Function (get-type fref) -> Class or Type fref Portable Object.getClass/GetType. Note: will cache the value on the fref. Note also that obtaining the exact type of the object is completely independent of the coercion of the fref to its corresponding Lisp type (see ensure-typed-ref) Function (iref indexable-obj &rest indexes) -> a value Calls the default indexer for the object. CLI only. Settable. Vectors Function (make-new-vector type length &rest inits) -> array fref Creates a foreign vector of specified type and length. There can be fewer inits than the length, in which case the remaining values take the default. Function (vref vector index) -> value Returns the value at the index. Settable. Function (vlength vector index) -> int Returns the length of the vector. Miscellaneous Arguments and Boxing In most cases argument matching and conversion should be transparent. Lisp strings can be passed where Strings are required, Lisp numbers where int float etc are required. t and nil can be passed where booleans are required etc. nil can be passed for null. Some Foil APIs (e.g. make-new-vector) require type arguments, and unless specified otherwise, any of the following are acceptable: (the value of) A class-symbol - classname. A primitive designator keyword - :boolean|:byte|:char|:double|:float|:int|:long|:short A fref referring to an actual Class/Type instance A ""package.qualified.ClassName"" string, case-sensitive. This is least efficient and should only be used in dynamic scenarios. Note that this only applies to Foil APIs, if a foreign runtime API takes a Class/Type argument, you must supply a fref referring to an actual Class/Type instance. Occasionally it may be necessary to provide a hint as to the intended type of a numeric argument in order to force resolution to a particular overload. Function (box type val) Type must be a primitive designator keyword - :boolean|:byte|:char|:double|:float|:int|:long|:short Produces an object that when passed to a Foil-generated function will be interpreted by the runtime as that type. Note that silent truncation may occur. It is also possible to create vectors in-line as arguments, which will avoid multiple round-trips vs. calling make-new-vector in place. Note this is only good for ephemeral vectors, as there is no way to retain a reference to the newly-created vector. Function (box-vector type &rest vals) Produces an object that when passed to a Foil-generated function will be an array of type with the supplied values. Example:  CL-USER 102 > (vref (box-vector string. ""a"" ""b"" ""c"" ""d"") 2) ;only one round-trip ""c"" Class/Type Helpers Function (get-type-for-name full-class-name) Returns a Class/Type instance corresponding to name. Portable Class.forName/Type.GetType. Function (full-class-name class-symbol) Returns the package qualified name string corresponding to the class symbol:  CL-USER 104 > (full-class-name string.) ""java.lang.String"" Proxies and Callbacks Proxies allow the creation of foreign objects that implement one or more interfaces (or in the case of CLI, one or more interfaces or a single delegate) in Lisp, and thus callbacks from the foreign VM to Lisp. Foil supports Lisp calling foreign runtime calling Lisp... to an arbitrary (probably stack-limited) depth. Generic Function (handle-proxy-call method-symbol proxy &rest args)) The proxy infrastructure routes all callbacks to this generic function. If a proxy p implements an interface i, and the foreign VM ends up invoking i.foo on p, it will map to a call to handle-proxy-call with the first 2 arguments of 'i.foo and p, followed by the actual arguments to the invocation. So, callback handlers can be defined by specializing methods on the method-symbol, the proxy object, or both. The unspecialized method spews out ""unhandled proxy call"" to standard output and returns nil to the foreign VM. Any unhandled errors that occur on the Lisp side during a callback turn into exceptions on the runtime server. Function (make-new-proxy arg-marshall-flags arg-marshall-depth &rest interface-types) -> proxy fref Creates and returns a proxy object that implements the given interface types or delegate type. arg-marshall-flags and arg-marshall-depth will be used to marshall the arguments to the callback. No handlers are defined by this function. Macro (new-proxy proxy arg-marshall-flags arg-marshall-depth &rest interface-defs) -> proxy fref Creates and returns a proxy object that implements the given interface types or delegate. proxy -> a symbol interface-def -> (interface-name method-defs+) interface-name -> classname. (must name an interface or delegate type) method-def -> (method-name (args*) body) method-name -> symbol (without classname) The symbol proxy will be bound to the proxy instance in the body of the method implementations. Example:  (new-proxy p +MARSHALL-ID+ 0            (keylistener.              (keyreleased (event)                (when (eql *SWT.CR* (keyevent.character event))                  (gob)))))                Marshalling Foil supports an extensible marshalling system which allows the values of reference/composite types to be returned in addition to, or even instead of, the references themselves. Used appropriately, this can substantially reduce the number of round trips between processes and avoid significant 'chatter' overhead. Marshalling comes into play whenever a reference type is returned from a Foil function. With certain settings, it is possible to return any or all of a reference, its hash code, its type, and its value (and the same for any of its value's reference members), to a specific depth. The nature and depth of the marshalling is governed by two special variables on the Lisp side - *marshalling-flags* and *marshalling-depth*. The format of marshalled values is determined by the runtime servers, and both the Java and CLI servers provided with Foil have facilities for adding new marshallers for specific types. The way an object's value is marshalled is a function of its type. Class or Types will always marshall the string representing the packageQualifiedTypeName, ignoring *marshalling-depth* By default, the following marshalling will be performed when requested, i.e. *marshalling-depth* > 0 Arrays marshall as simple Lisp vectors Collections and other enumerable entities marshall as simple Lisp lists Default, if no other marshaller applies - a Lisp assoc-list of keywordized-property-name/value pairs for any public properties of the object Special Variable *marshalling-depth* Default: 0 A depth of 0 means no values are marshalled, a setting of 1 means that values will be marshalled for the returned object (if it is a reference), but not any nested references. When > 1 nested reference types will marshall, to that depth of nesting. Special Variable *marshalling-flags* Either +MARSHALL-NO-IDS+, or the logical or-ing of +MARSHALL-ID+ and zero or more of: +MARSHALL-HASH+ and +MARSHALL-TYPE+ Default: +MARSHALL-ID+ A setting of +MARSHALL-NO-IDS+ means that no frefs will be returned, and thus no references will be held on the VM side. If *marshalling-depth* is 0 then nil will be returned. If *marshalling-depth* > 0 then the value will be returned instead of the fref. Otherwise, +MARSHALL-ID+ must be set, and frefs will be returned for reference types. If *marshalling-depth* > 0, then the marshalled values will be in the fref-val slot. If +MARSHALL-HASH+ is set then the object's hash code will be calculated and stored in the fref-hash slot. Similarly, if +MARSHALL-TYPE+ is set then the object's class/type will be determined and stored in the fref-type slot. Macro (with-marshalling (depth &rest flags) &body body) Evaluates the body in a context in which the *marshalling-depth* is set to depth and *marshalling-flags* to the logior of flags. Function (marshall fref) Explicitly marshalls the object with the current *marshalling-flags* and *marshalling-depth* settings, and returns the marshalled object (which may be the same fref, but with additional data in its type/hash/val slots) Marshalling example:  CL-USER 79 > (setf string-class (get-type-for-name ""java.lang.String"")) #}1  CL-USER 88 > (class.getpackage string-class) #}12  CL-USER 90 > (pprint (with-marshalling (1 +MARSHALL-NO-IDS+)                        (class.getpackage string-class)))  ((:IMPLEMENTATIONTITLE . ""Java Runtime Environment"")  (:IMPLEMENTATIONVENDOR . ""Sun Microsystems, Inc."")  (:IMPLEMENTATIONVERSION . ""1.4.2_05"")  (:NAME . ""java.lang"")  (:SEALED)  (:SPECIFICATIONTITLE . ""Java Platform API Specification"")  (:SPECIFICATIONVENDOR . ""Sun Microsystems, Inc."")  (:SPECIFICATIONVERSION . ""1.4"")) Runtime Servers Foil includes 2 complete implementations of the runtime server portion of the protocol, one for Java/JVM, the other for C#/CLI. The implementations are 100% Java/Managed, and use only standard libraries. Both will run the protocol over one or more TCP sockets specified on the command line, or, if none specified, via standard IO. Project files are included for Eclipse and Visual Studio. All of the Java code is in com/richhickey/foil and the stand-alone server is in RuntimeServer.Main. The CLI implementation is in 2 projects, one for the Foil library itself - FoilCLI, and the other for the stand-alone server - FoilCLISvr. After building, you can invoke the Java server as follows: java -cp . com.richhickey.foil.RuntimeServer 13579 Make sure the classpath includes the libraries and .jars you will want to use via Foil. After building, you can invoke the CLI server as follows: foilclisvr 13479 Protocol The foil protocol describes the on-stream interface between a Lisp instance and a runtime instance, and should not be confused with the foil library which provides the interface to the protocol for Common Lisp. A user of Foil will not need to know the protocol, but if you intend to add support for another runtime environment (Python anyone?) or host language (Scheme anyone?), hopefully this section will help. Note that the protocol docs are not formal, and mostly consists of notes to myself and Eric. This will be improved when I get time. For the moment, should there be any omissions or inaccuracies here, the Lisp and Java implementations should be considered canonic. Connection Services Foil is a stream-based protocol. However, no protocol is provided for the establishment of the streams - that is an implementation detail of the runtime and Lisp libraries. It is suggested that any foil runtime implementation provide at least a stand-alone executable server that implements the protocol over its standard IO ports, as well as being able to run over a TCP/IP socket. Many other scenarios are possible, including multi-socket servers, pre-existing Lisp and runtime instances discovering each other etc. The remainder of the protocol description presumes a bi-directional stream has been established. Sendable messages: (:cref (:call (:free (:new (:marshall (:hash (:equals (:type-of (:is-a (:str (:tref (:bases (:members (:vector (:vget (:vset (:vlen (:proxy (:iget (:iset Returnable messages: (:ret (:err (:proxy-call ;only async or from withing a :call Invocation Services Obtaining callable references (crefs) (:cref member-type tref|""packageQualifiedTypeName"" ""memberName"") Where member-type is an integer representing one of: method (0) field (1) property-get (3) property-set (4) Note that both Java and the CLI support overloading, so a single member name might map to multiple overloads. The resolution of the overloading must occur in the runtime server at the time of invocation, i.e. any of the overloads may be called through the same cref. Returns -> A reference to a callable thing is returned in the standard return format (see below). (:ret #{:ref ...}) Creating new object instances (:new tref marshall-flags marshall-value-depth-limit (args ...) property-inits ...) where property-inits is a set of :keyword-style-name value pairs Calling a callable (:call cref marshall-flags marshall-value-depth-limit target args ...) Example: (:call #}101 1 0 2 #}17 ""fred"") Where cref is an cref that has been obtained via :cref, or, only in the case of calls to Lisp, a symbol that names a function. marshalling-flags is an integer representing a bitwise-or'ing of: marshall-id (1) marshall-type (2) marshall-hash (4) a marshall-value-depth-limit of 0 means no reference values are marshalled, a setting of 1 means that reference values will be marshalled for the return value (if it is a reference), but not any nested references. When > 1 nested reference types will marshall to that depth of nesting. If marshalling-flags is 0, no references will be returned (only values) and if depth is also 0 then nil will be returned. target is the object upon which to invoke the method/field/property - pass nil if static args are zero or more args as per below. Return Format one of: (:ret value) All normal returns are packaged in a form as above, value is as per below. If a function has a void return type, nil should be returned. (:proxy-call ...) A nested callback, in the proxy-call format described below. The receiver should process the call, send back its return, then re-read the stream for the return value of the original call. (:err ""error description"" ""stack trace"") returned if an exception occurred while processing the request Argument and Return Values Primitives and Value Types ""Strings are in double quotes"" Numbers are unadorned decimal numbers with or without a decimal point,leading -, e etc nil is null nil is false t is true Boxed Primitives Occasionally it may be necessary to provide a hint as to the intended type of a numeric argument in order to force resolution to a particular overload. #{:box typename value} Where typename is one of :byte :int :long :short :float :double N.B. silent truncation may occur Return values should never be boxed vector literals A vector can be specified in-line as an argument #{:vector ""packageQualifiedTypeName""|tref|:int(etc) value ...} References Reference types are returned with the following tagged syntax: #{:ref id rev :type a-ref :hash an-int :val marshalled-value} :ref, id, and rev must be supplied, all others are optional id - A unique integer reference that identifies the object. The object will be kept alive on the hosting side until it is freed. Multiple references to the same object will always have the same id. :type - A reference to the Type (CLI) or Class (Java) object that is the type of the object. Note that this may be the first time this reference is seen (and thus it must be registered for lifetime maintenance) This will only be available if the marshall-type flag is set. :hash - An integer representing the hash value of the object. This will only be available if the marshall-hash flag is set. :val - A Lisp-readable representation of the value of the object. This will be obtained by using the marshaller registered for the type of the object. This will only be available when marshall-value-depth-limit is > 0. Note #{ and #} user-space read macros are used by the implementation of foil. Note that it is possible to return marshalled values of reference objects without maintaining the reference object on the hosting side (by setting the marshall-id flag to 0 and having marshall-value-depth-limit > 0 A reference (obtained previously) is passed back to its host like this: #}123 The host will look up the object with that id and pass it along to the call. Exception Reporting All exceptions are reported via a return of the form: (:err ""error description"" ""stack trace"") if an exception occurred while processing the request. Unless the exception originated in the reflection API, it is preferred that the stack trace be of the inner (reflection-invoked) call. Object support services Object references Object lifetime management (:free refid refrev ...) -> nil a list of id/rev pairs is passed. Allows one or more refs to be GC-ed on the hosting side. It is an error to refer to these refids again. Object marshalling It is anticipated that runtime servers will provide for user-installable marshallers, associated with types, that will render the value of an object of that type on a stream in a form readable by Lisp. By default at least the following marshallers should be provided: Type|Class - must always marshall the string representing the packageQualifiedTypeName, ignoring marshalling-depth arrays - should marshall as simple vector literals: #(...) collections and other enumerable entities - should marshall as simple lists (...) default, if no other marshaller applies - should yield an assoc-list of keywordized-property-name/value pairs In addition to marshalling returns during calls, the value of an object reference can be explicitly marshalled: (:marshall ref marshall-flags marshall-value-depth-limit) -> Lisp-readable-value Hash values (:hash ref) -> int Object equality (:equals ref ref) -> t|nil, per Object.Equals ToString (:str ref) -> ""string value"" Reflection Services Note, when trefs are returned by these reflection calls, the :val field of the reference is always (default) marshalled, i.e. set to the packageQualifiedTypeName as a string. Obtaining a reference to a Type/Class object (:tref ""packageQualifiedTypeName"") -> tref Object type (:type-of ref) -> tref (:is-a ref tref) -> t|nil (:bases tref|""packageQualifiedTypeName"")  -> (:ret (""packageQualifiedTypeName"" ...))    ;most-derived to least-derived  (:members tref|""packageQualifiedTypeName"")  -> (:ret ( (:ctors doc-string ...)         (:methods ((:name string)                    (:static bool)                    (:doc doc-string)) ...)         (:fields ((:name string)                   (:static bool)                   (:doc doc-string)) ...)         (:properties ((:name string)                       (:static bool)                       (:get-doc doc-string)                       (:set-doc doc-string)) ...))) Proxies  (:proxy marshall-flags marshall-value-depth-limit interface-trefs ...)  -> (:ret proxy-ref)  Creates a proxy object that implements the given interface(s). When any of the object's methods are called, sends a :proxy-call message of the form: (:proxy-call method-symbol proxy-ref args ...) where the proxy-ref is the same one originally returned from the :proxy message, and the args are marshalled with the flags and depth requested in the :proxy message. method-symbol has the form |package.name|::classname.methodname note this means that the Lisp names are not independent, hmmm... Vectors Creating an vector: (:vector tref|""packageQualifiedTypeName"" length value ...) Creates an vector of the specified type with the specified length Initial values are optional and may be fewer than the length. -> aref (:vget aref marshall-flags marshall-value-depth-limit index) -> value (:vset aref index value) -> nil (:vlen aref) -> int Summary I'd like to thank my good friend Eric Thorsen for his hard work on the CLI/C# port. I hope you find Foil useful. It is my sincere intent that it enhance the utility and interoperability of Common Lisp. I welcome comments and code contributions. Rich Hickey, February, 2005"	"null"	"null"	"A foreign object interface; works with the JVM and CLI. Not available on Quicklisp.."	"true"
"Python"	"burgled-batteries"	"https://github.com/pinterface/burgled-batteries"	"A bridge between Python and Common Lisp. Not available on Quicklisp. No license specified."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"22"	"7"	"5"	"GitHub - pinterface/burgled-batteries: A bridge between Python and Lisp (FFI bindings, etc.) Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 22 Fork 5 pinterface/burgled-batteries Code Issues 3 Pull requests 2 Pulse Graphs A bridge between Python and Lisp (FFI bindings, etc.) 140 commits 2 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master mmontone Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. t LICENSE README.org api.lisp burgled-batteries-tests.asd burgled-batteries.asd cffi-output-args.lisp ffi-callbacks.lisp ffi-conditions.lisp ffi-definers.lisp ffi-interface.lisp grovel-guess.lisp grovel-include-dir.lisp grovel.lisp packages.lisp README.org burgled-batteries: A Common Lisp / Python Bridge burgled-batteries provides a shim between Python (specifically, the CPython implementation of Python) and Common Lisp. Synopsis (asdf:load-system ""burgled-batteries"") (in-package #:burgled-batteries) (startup-python)  (run ""1+1"") ; => 2  (import ""feedparser"") (defpyfun ""feedparser.parse"" (thing)) (documentation 'feedparser.parse 'function) ; => ""Parse a feed from a URL, file, stream, or string"" (feedparser.parse ""http://pinterface.livejournal.com/data/atom"") ; => #<HASH-TABLE>  (shutdown-python) Why burgled-batteries CLPython is great when it works. However, if you’re using a low-resource computer—perhaps an underpowered VPS, or a Linux box salvaged from the 90s—, or need access to a Python library written in C, or there’s a bug and you can’t be bothered to narrow it down to a small test case, CLPython can’t help you. Two out of three of those are more your problem than CLPython’s, but hey, I’m not here to judge. While a number of other Python-by-FFI options exist, burgled-batteries aims for a CLPython-esque level of integration. In other words, deep integration. You shouldn’t have to care that the library you’re using was written in Python—it should Just Work. Certainly, b-b is not there yet. It may never be there completely. But we’ll try, dagnabbit. Basic Type Mapping Python objects are converted to a Lisp object where possible. Where a conversion is unknown, a pointer to the CPython object is returned (or, if inside a refcnt barrier, a wrapper around the pointer which will become invalid upon exiting the barrier). In general, this mapping follows the lead of CLPython. Python Type Lisp Type Boolean (member T NIL) Integer, Long Integer Float Double-float Dict Hashtable Unicode String List Adjustable vector Tuple List Complex Complex ByteArray Octet vector Exception Condition <Unknown> <pointer> CPython FFI Anything dealing with the CPython API can be found in the PYTHON.CFFI package. See the docstring for that package for more information, as well as Python’s C API. Calling Python from Lisp IMPORT Equivalent to “import <foo>” in Python. RUN Mimicks the RUN function from CLPython. DEFPYFUN Similar to CFFI’s DEFCFUN—defines a Lisp function which calls a Python function. Ideally, this will eventually be obviated by something which uses Python introspection to figure out an apropriate argument list so you don’t have to, but it’ll get you going for now. Calling Lisp from Python Not yet supported, but see ffi-callbacks.lisp for some experimentation and notes along those lines. Avoid the Hassle of Reference Counts Because dealing with reference counts is Just No Fun and Not Lispy At All, as well as Inevitable—at some point there will be an object for which no translation is known—, b-b provides multiple options to avoid dealing with refcnts for those untranslatable pointers. See the macro CPYTHON:WITH-UNKNOWN-TRANSLATION-POLICY. Note that this policy also also affects the EXCEPTION-* slots of PYTHON-CONDITION, and so they may or may not be available for inspection depending on the translation policy in effect and the manner of handling. For example, under the default policy of :DISCARD, you would see something like: (defun reveal-effect (c)   (format t ""~A~%"" (slot-value c 'exception-type)))  (handler-bind ((python-condition #'reveal-effect))   (burgled-batteries:run ""1/0"")) ; prints #.(SB-SYS:INT-SAP #X?????)  (handler-case (burgled-batteries:run ""1/0"")   (python-condition (c) (reveal-effect c))) ; prints NIL If you’d like access to Python types without a known translation, :BARRIER or :FINALIZE are highly recommended over :PASS-THROUGH. They do, however, come with some caveats which you should be aware of. Requirements Burgled-batteries links with C code, and accordingly requires the appropriate headers and library files. On Debian-based systems, you can get these via: sudo apt-get install python-dev Testing (asdf:test-system ""burgled-batteries"")  Tests have been run under SBCL, Clozure CL, and CLISP. To Do Output redirection Callbacks Whole-module import (into own package?) Python object <-> CLOS mappings Provide facilities for user code to define own Lisp-Python mappings Better integrate Quickcheck tests, so LIFT knows about quickcheck failures Pathname support (requires FILE* support) Prior Art / Other Solutions Python-on-Lisp It was a good try back in 2006, but unfortunately has experienced significant bitrot. It did manage to provide callbacks and writing to Lisp streams, however (both of which are still on b-b’s TODO list). Very handy features! pythononlisp-ex A fork of Python-on-Lisp which shimmies things between Lisp and Python using JSON. As you might expect, this falls down as soon as you hit something which can’t be represented in JSON, which covers quite a lot of types. Pyffi A more streamlined, and less featureful, Python FFI which came after PoL. Technically, burgled-batteries began life as some patches to Pyffi because it seemed to be the best place to start. (Almost nothing of Pyffi remains.) CLPython A very fine Python compiler written in Common Lisp. It requires a somewhat beefier machine than CPython. Unfortunately, it doesn’t work with Python libraries written in C (e.g., numpy), and so is unable to handle the full gamut of Python libraries one might wish to borrow. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/pinterface/burgled-batteries"	"A bridge between Python and Common Lisp. Not available on Quicklisp. No license specified."	"true"
"Game Development"	"Xelf"	"http://xelf.me/"	"Extensible game library. Not available on Quicklisp.."	"null"	"null"	"null"	"GNU LGPL2.1"	"http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html"	"null"	"null"	"null"	"null"	"null"	"Welcome to Xelf Xelf is a simple 2-D game engine written in Common Lisp. Along with a Common Lisp compiler such as Steel Bank Common Lisp, Xelf can be used to write games that compile from a single codebase into optimized native executables for Windows, Mac, and GNU/Linux. Xelf is a work in progress, but has been used to create several fun games, including 2x0ng and 3x0ng. Please see the user documentation for more info. Freedom Xelf is Free Software, licensed under the GNU LGPL v3, and requires only Free Software to run. With the use of SBCL and Wine, Lisp games for Windows can be cross-compiled from GNU/Linux using only Free Software. All this combined with the ability of SBCL to make binaries for GNU/Linux and Mac OSX when running on those platforms, makes it possible to create Common Lisp games, animations and other multimedia projects and deliver them to a wide audience without using any proprietary programs. This is important for games-as-speech, for if a game is to count as an act of truly free expression, both its creators and its players must be free of proprietary restrictions insofar as they meet together in the experience. Please also visit our friends at the lisp games wiki to find out more about the use of Lisp in games. Resources Work-in-progress programmer's guide. ""3x0ng"" is a recent game made with Xelf. See the 3x0ng page. Xelf source code repository at gitlab the lisp games wiki irc.freenode.org, channel #xelf author's home page Author: David O'Toole Created: 2016-06-11 Sat 19:16 Emacs 24.5.1 (Org mode 8.2.10) Validate"	"null"	"null"	"Extensible game library. Not available on Quicklisp.."	"true"
"Graphics"	"cl-cairo2"	"https://github.com/rpav/cl-cairo2"	"Cairo bindings."	"null"	"null"	"null"	"Boost 1.0"	"http://directory.fsf.org/wiki/License:Boost1.0"	"null"	"null"	"34"	"7"	"10"	"GitHub - rpav/cl-cairo2: Cairo bindings for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 34 Fork 10 rpav/cl-cairo2 Code Issues 0 Pull requests 1 Wiki Pulse Graphs Cairo bindings for Common Lisp https://github.com/rpav/cl-cairo2/wiki 123 commits 3 branches 0 releases Fetching contributors Common Lisp 90.9% TeX 7.4% Other 1.7% Common Lisp TeX Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags dev master merge Nothing to show Nothing to show New pull request Latest commit 41ae45a Apr 25, 2016 rpav Merge pull request #20 from BradWBeer/master … I needed cairo_has_current_point for cl-pango... Permalink Failed to load latest commit information. demos src tutorial .gitignore LICENSE_1_0.txt README README.quartz README.win32 TODO a-cl-cairo2-loader.asd cl-cairo2-demos.asd cl-cairo2-gtk2.asd cl-cairo2-quartz.asd Changed license to BOOST 1.0. Jan 24, 2012 cl-cairo2-win32.asd cl-cairo2-xcb.asd cl-cairo2-xlib.asd cl-cairo2.asd README Please read the tutorial to get started.  To compile the tutorial from source, you will need a reasonably complete LaTeX installation with dvipdfm.  The project webpage is at http://common-lisp.net/project/cl-cairo2, where you will find the repository, mailing lists, contact information etc.  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/rpav/cl-cairo2"	"Cairo bindings."	"true"
"Graphics"	"cl-gd"	"http://weitz.de/cl-gd/"	"A library providing an interface to the GD graphics library.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"5"	"3"	"2"	"GitHub - edicl/cl-gd: UFFI bindings to the GD graphics library Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 5 Fork 2 edicl/cl-gd Code Issues 5 Pull requests 0 Pulse Graphs UFFI bindings to the GD graphics library 39 commits 4 branches 3 releases Fetching contributors Common Lisp 96.6% C 3.1% Makefile 0.3% Common Lisp C Makefile Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags animations cffi-uffi-warning master revert-8-issue/3 Nothing to show v0.6.1 v0.6.0 v0.5.8 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. doc test .gitignore CHANGELOG Makefile README animated-gif.lisp cl-gd-glue.c cl-gd-test.asd cl-gd-test.lisp cl-gd.asd colors-aux.lisp colors.lisp drawing.lisp gd-uffi.lisp images.lisp init.lisp misc.lisp packages.lisp specials.lisp strings.lisp transform.lisp util.lisp README Complete documentation for CL-GD can be found in the 'doc' directory.  CL-GD also supports Nikodemus Siivola's HYPERDOC, see <http://common-lisp.net/project/hyperdoc/> and <http://www.cliki.net/hyperdoc>.  1. Installation (see doc/index.html for Windows instructions)  1.1. Download and install a recent version of GD and its supporting      libraries.  Please use your operating system's package manager to      install the ""development"" version of the GD library.  On Ubuntu      Linux, this can be achieved with the command:         apt-get install libgd2-xpm-dev       GD depends on several other libraries to handle different      graphics formats.  These should be installed by your package      manager automatically.  If you cannot use or do not have a      package manager that includes GD, you'll have to follow the GD      installation instructions (http://www.boutell.com/gd/).  Note      that you won't be able to compile CL-GD unless you have installed      all supporting libraries. This is different from using GD      directly from C where you only have to install the libraries you      intend to use.  1.2. Install cl-gd and its Lisp dependencies using quicklisp      (http://quicklisp.org/).  1.3. Compile cl-gd-glue.c into a shared library for your platform.  A      simple Makefile is included in the cl-gd source directory.       For FreeBSD and Linux, just type         make       For OSX, type          make cl-gd-glue.dylib   2. Test  CL-GD comes with a simple test suite that can be used to check if it's basically working. Note that this'll only test a subset of CL-GD. To run the tests load CL-GD and then         (asdf:oos 'asdf:load-op :cl-gd-test)        (cl-gd-test:test)  If you have the georgiab.ttf TrueType font from Microsoft you can also check the FreeType support of CL-GD with         (cl-gd-test:test #p""/usr/X11R6/lib/X11/fonts/truetype/georgiab.ttf"")  where you should obviously replace the path above with the full path to the font on your machine.  (See the note about failed tests in the documentation.) Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/edicl/cl-gd"	"A library providing an interface to the GD graphics library.."	"true"
"Graphics"	"cl-horde3d"	"https://github.com/anwyn/cl-horde3d/"	"FFI bindings to the Horde3D graphics library. Not available on Quicklisp."	"null"	"null"	"null"	"EPL 1.0"	"http://directory.fsf.org/wiki/License:EPLv1.0"	"null"	"null"	"14"	"3"	"0"	"GitHub - anwyn/cl-horde3d: Common Lisp CFFI bindings to the Horde3D graphics library. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 14 Fork 0 anwyn/cl-horde3d Code Issues 0 Pull requests 0 Pulse Graphs Common Lisp CFFI bindings to the Horde3D graphics library. 40 commits 3 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags beta4-branch community-svn-branch master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. examples src test tools .gitignore COPYING README.org horde3d-examples.asd horde3d.asd README.org CL-HORDE3D What is CL-HORDE3D? A CFFI1 wrapper for the Horde3D library. Display flashy 3D graphics with Common Lisp. I use it to visualize some AI experiments I enjoy to develop in my free time. Unfortunately I do not have very much of it, so the progress on CL-HORDE3D is unlikely to be fast. What is Horde3D? From the Horde3D2 website: Horde3D is a small open source 3D rendering engine. It is written in an effort to create a graphics engine that offers the stunning visual effects expected in next-generation games while at the same time being as lightweight and conceptually clean as possible. Horde3D has a simple and intuitive interface accessible from virtually any programming language and is particularly suitable for rendering large crowds of animated characters in next-generation quality.  Horde3D is an OpenGL based graphics engine that does not use the fixed function pipeline but is built around the usage of shader programs. It only runs on OpenGL 2.0 compatible graphics hardware. It is a rather lean engine. Though it is written in C++, it exports a C API which can be easily wrapped. Dependencies Lisp Libraries CFFI Lispbuilder-sdl3 (for the examples) Foreign libraries Horde3D SDL4 (for the examples) License To make things easy, CL-HORDE3D is published under the same license as Horde3D: The Eclipse Public License - v 1.0.5 Compatibility with different Horde3D Versions cl-horde3d currently works together with the Horde3D_SDK_1.0.0-beta4. It should also run with the community svn version, as the API is compatible, but currently it crashes right at the start in the native code at h3dInit(). There is also a horde3d-beta3-branch in the GIT repository which contains an older version of cl-horde3d which should run with Horde3D 1.0.0 beta3. Compatibility with Lisps CL-HORDE3D should theoretically run on all lisps that CFFI supports. I tested cl-horde3d with the following lisps on a amd64 Gentoo Linux system: Clozure Common Lisp Works with 1.3 and 1.4. SBCL Crashes in the foreign code, in the h3dInit function, during OpenGL shader initialization. There seems to be something wrong with the shared libs loading, perhaps I shouldn’t load the libs at load time. The knight example did run with Horde3D beta3, but only without HDR (which means a big render target buffer). I need to look into this further. Clisp Like SBCL. I would like to hear about success or failure with other lisps and operating systems. I’m also grateful for tips how to debug this better. Attaching gdb to the lisp process did not yet give me the insight I needed. Translating the Horde3D API from C to CL I have chosen to not translate the API literally, but to adjust the naming to the habits in the Common Lisp world. That’s what I did: I dropped the h3d prefix from all names and used a common lisp package instead. I dropped all type suffixes from enum- and function names, in a dynamic typed language they make less sense. I `lispified’ all symbols (lower case with hyphens instead of camel case) I dropped all -Element suffixes from the enumerations (debatable) I adhered to the common-lisp tradition of not using abbreviations, so I renamed all occurrences of ‘res’ to resource ‘mat’ to ‘material’ (or ‘matrix’) ‘vert’ to ‘vertex’ ‘elem’ to ‘element’ ‘comp’ to ‘component’ ‘tex’ to ‘texture’ Horde3D Extensions There is code in CL-HORDE3D for the terrain and the sound extension, but it is totally untested and might not run at all. It is therefore disabled by default. The organization of source files for the extension will very likely change in the future. Running the examples Make sure you have Horde3D installed and that you can run the example binaries that come with it. Install Lispbuilder SDL. Either you symlink the top level Horde3D directory with the name ‘Horde3D’ into the top level directory of cl-horde3d, or you adjust the horde3d-home-directory variable in src/examples.lisp to point to your Horde3D installation. The examples will load resources and assets from there. Load the horde3d-examples system with asdf. (Use CCL, other Lisp implementations will not work right now.) run (horde3d-examples:knight) or (horde3d-examples:chicago) from the REPL. The example programs should have the same controls available as the original examples, but the mouse is not captured. Footnotes 1 http://common-lisp.net/project/cffi 2 http://horde3d.org 3 http://code.google.com/p/lispbuilder/wiki/LispbuilderSDL 4 http://www.libsdl.org 5 http://www.eclipse.org/legal/epl-v10.html Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/anwyn/cl-horde3d/"	"FFI bindings to the Horde3D graphics library. Not available on Quicklisp."	"true"
"Graphics"	"cl-opengl"	"https://github.com/3b/cl-opengl"	"CFFI bindings to OpenGL, GLU and GLUT APIs.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"151"	"26"	"41"	"GitHub - 3b/cl-opengl: cl-opengl is a set of CFFI bindings to the OpenGL, GLU and GLUT APIs. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 26 Star 151 Fork 41 3b/cl-opengl Code Issues 22 Pull requests 1 Pulse Graphs cl-opengl is a set of CFFI bindings to the OpenGL, GLU and GLUT APIs. http://common-lisp.net/project/cl-opengl/ 307 commits 4 branches 0 releases Fetching contributors Common Lisp 99.9% Makefile 0.1% Common Lisp Makefile Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gl3-new gl3-old master upstream Nothing to show Nothing to show New pull request Latest commit e46edc8 Jun 29, 2016 3b committed on GitHub Merge pull request #60 from cbaggers/master … make cffi-type-to-gl support :ushort Permalink Failed to load latest commit information. doc Some old changes to the manual.. Mar 4, 2007 examples Merge pull request #26 from dardoria/master Feb 4, 2015 gl make cffi-type-to-gl support cffi shorthand names Apr 29, 2016 glu Edge-flag should be edge-flag-data. Oct 11, 2011 glut add msys2 name for libfreeglut.dll Sep 13, 2015 spec download new spec file Aug 29, 2015 tools fix formatting in tools/README.md Aug 29, 2015 .gitignore Merge changes from 3b Oct 8, 2013 COPYING Initial revision. Jan 31, 2006 HEADER Mega patch from Bart Botta Mar 5, 2007 Makefile add some minimal docs on rebuilding %GL from .spec file Aug 29, 2015 README CL-GLUT update Jun 24, 2006 cl-glu.asd Add missing files in asd definitions. Fix number of arguments to meth… Mar 17, 2011 cl-glut-examples.asd Merge changes from 3b Oct 8, 2013 cl-glut.asd Move CLOSE event bookkeeping out of the high-level callback GF. Jun 13, 2011 cl-opengl.asd add dsa.lisp to .asd file Mar 20, 2016 README cl-opengl is a set of bindings and utilities for accessing the OpenGL, GLU and GLUT APIs using CFFI.  The examples/ directory contains a couple of examples using cl-glut, cl-opengl and cl-glu. Note, however, that you can use each of these independently. In particular, you can use a windowing toolkit other than (Free)GLUT, if you wish.  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/3b/cl-opengl"	"CFFI bindings to OpenGL, GLU and GLUT APIs.."	"true"
"Graphics"	"cl-sdl2"	"https://github.com/lispgames/cl-sdl2"	"Bindings for SDL2 using C2FFI.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"85"	"21"	"33"	"GitHub - lispgames/cl-sdl2: Common Lisp bindings for SDL2 using C2FFI. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 21 Star 85 Fork 33 lispgames/cl-sdl2 Code Issues 10 Pull requests 1 Wiki Pulse Graphs Common Lisp bindings for SDL2 using C2FFI. 331 commits 5 branches 0 releases Fetching contributors Common Lisp 98.7% Other 1.3% Common Lisp Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags autowrap master revert-56-master sdl2.kit threaded-init Nothing to show Nothing to show New pull request Latest commit 4a95667 Jun 3, 2016 rpav more idiomatic formatting Permalink Failed to load latest commit information. examples more idiomatic formatting Jun 3, 2016 src Add axion's SCANCODE-KEY-NAME, which acts like SCANCODE-NAME but take… May 13, 2016 .gitignore Add basic render drawing functions Dec 22, 2014 LICENSE Include license text Feb 15, 2016 README.md Update README.md Mar 15, 2016 plant-project.scm - pushing :sdl2 to *features* Nov 24, 2013 sdl2.asd Fix :sdl2/examples GL dependency Mar 23, 2016 README.md cl-sdl2 cl-sdl2 is a Common Lisp wrapper for the SDL 2.0 C Library, with many contributors, maintained primarily by the following: Chip Collier photex@lofidelitygames.com Ryan Pavlik rpavlik@gmail.com Peter Keller psilord@cs.wisc.edu It is licensed under the MIT license. Installation sdl2 is in Quicklisp, see below for instructions. SDL 2.0 C Library Install See https://wiki.libsdl.org/Installation On Linux, you can probably find SDL2 in your distribution's package set. For other platforms, or for building manually, download the source. Package Debian based: Ubuntu, Mint etc sudo apt-get install libsdl2-2.0 Arch sudo pacman -S sdl2 Compilation If you need to compile from source for your Linux platform: Download source code Compile Install For example: cd /tmp wget https://www.libsdl.org/release/SDL2-2.0.4.tar.gz tar -xzvf SDL2-2.?.?.tar.gz cd SDL2-2.?.? ./configure make sudo make install This will install the SDL-2.0.x C Library into your /usr/local location. It's generally a good idea to install at a minimum the version of SDL2 that was wrapped; however, sub revisions should not introduce binary incompatibility and should be fine. If you install a different version, certain features may not be available or may not work correctly. Quicklisp Install sdl2 is best installed via QuickLisp, though for cutting-edge changes, you may want to install from github as below. If you don't have Quicklisp, then follow the directions to install it. We assume you placed the Quicklisp repository in the default place as indicated by the directions and have added it to your lisp init file. github install cd $HOME/quicklisp/local-projects git clone https://github.com/rpav/cl-autowrap.git git clone https://github.com/lispgames/cl-sdl2.git Then, use quicklisp to install the libraries required by cl-sdl2: Start your lisp. Then, just: (ql:quickload ""sdl2"") Running the sdl2 examples Start your lisp: (asdf:load-system :sdl2/examples) (sdl2-examples:basic-test) This example will open a window with an opengl primitive in it. Any mouse movements or keystrokes are recorded in the terminal (or emacs SLIME output buffer *inferior-lisp*). Hitting the ESCAPE key will terminate the example. Thank you for using sdl2! Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/lispgames/cl-sdl2"	"Bindings for SDL2 using C2FFI.."	"true"
"Graphics"	"cl-svg"	"https://code.google.com/archive/p/cl-svg"	"A basic library for producing SVG files.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"null"	"null"	"null"	"Google Code Archive - Long-term storage for Google Code Project Hosting. Code Archive Skip to content Search Google About Google Privacy Terms"	"null"	"null"	"A basic library for producing SVG files.."	"true"
"Graphics"	"CLinch"	"https://github.com/BradWBeer/CLinch"	"Common Lisp 2D/3D graphics engine for OpenGL.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"153"	"34"	"15"	"GitHub - BradWBeer/clinch: Common Lisp 3D/2D Graphics Engine for OpenGL Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 34 Star 153 Fork 15 BradWBeer/clinch Code Issues 30 Pull requests 0 Wiki Pulse Graphs Common Lisp 3D/2D Graphics Engine for OpenGL 369 commits 29 branches 0 releases Fetching contributors Common Lisp 98.9% GLSL 1.1% Common Lisp GLSL Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags 2D CR43 Nodes SDL2 animations assimp classimp-old classimp cleanup clinch-0.5 clinch-0.6 clode comments ecl finalizers gl3.3 gui iss55 iss81 master quicklisp sdl2-2 sdl2 shader-program shortcuts smarterShader threading tmp vao-defunct Nothing to show Nothing to show New pull request Latest commit 5de7306 Apr 28, 2016 BradWBeer Fixed life. Permalink Failed to load latest commit information. SDL_GameControllerDB Moved gamecontrollerdb.txt to new directory with required files. Feb 2, 2016 clinch-cairo Fixed several different things. Need to check tutorials. Apr 25, 2016 clinch-classimp Renamed create-* symbols to make-* to be more regular. Apr 21, 2016 clinch-freeimage Renamed create-* symbols to make-* to be more regular. Apr 22, 2016 clinch-pango Fixed several different things. Need to check tutorials. Apr 25, 2016 examples Fixed life. Apr 28, 2016 shaders 2d tools Mar 30, 2016 .gitignore edited asd files for :serial t. modified foreign library definitions … Dec 19, 2012 README.md Comments Apr 6, 2016 README.org test Feb 1, 2016 TODO.org Update TODO.org Dec 18, 2012 animation.lisp Gui basics almost there. Apr 18, 2016 buffer.lisp Fixed several different things. Need to check tutorials. Apr 25, 2016 clinch-cairo.asd edited asd files for :serial t. modified foreign library definitions … Dec 19, 2012 clinch-classimp.asd More animation work. Mar 23, 2016 clinch-freeimage.asd Fixed issue with resizing freeimage textures for an existing texture … Feb 7, 2016 clinch-pango.asd Updated a few things for clinch-0.5 release.. Jan 25, 2016 clinch.asd Added $ and $>. Apr 20, 2016 clinch.lisp Merge Apr 20, 2016 design.org Comments Apr 6, 2016 entity.lisp Getting 2D stuff working better. Apr 21, 2016 framebuffer.lisp Comments Apr 6, 2016 index-buffer.lisp Comments Apr 6, 2016 license.txt Fixed the license file. Feb 3, 2016 node.lisp Merge Apr 21, 2016 package.lisp Added default entity and texture. Apr 19, 2016 pixel-buffer.lisp Comments Apr 6, 2016 shader-program.lisp Added several shortcuts. Apr 12, 2016 shaders.lisp Renamed create-* symbols to make-* to be more regular. Apr 22, 2016 shapes.lisp Added default entity and texture. Apr 20, 2016 texture-animation.lisp Strides toward simple animation and animator classs. Apr 12, 2016 texture.lisp Can pull and draw with a macro. Apr 22, 2016 threads.lisp Added $ and $>. Apr 20, 2016 transform.lisp Found issue with orthographic projection. Apr 20, 2016 vao.lisp Vao saved Apr 20, 2016 viewport.lisp Comments Apr 6, 2016 window.lisp Made blending the default. Apr 28, 2016 README.md Clinch Overview Clinch is a simple, yet powerful 3d game engine for Lisp. Eventually Clinch will become a stable and fast workhorse tool for developing games, visualizations and productivity software. I have plans for a graphical shell which incorporates the strengths of Lisp, 3D, shaders, 2d vector graphics, richtext support, 3d physics and much more. Features Live code in a multithreaded environment. Load plug-ins for more functionality. Modern OpenGL features such as shaders and GPU buffers. Commercial grade windowing, controller, force-feedback, sound, music and more thorough SDL2. C and other OpenGL objects on the fly. Animate any object such as textures, transforms, etc. Clinch Plug-ins: 3d physics with joints and motors using the ODE physics engine. Texture loading and saving with FreeImage. Integration with 2D vector graphics with Cairo. Integration with fonts and text positioning with Pango. 3D asset importing using ClassImp. (animations coming soon!) Design Goals Fast Clinch should be as fast or faster than most script-based graphics engines and require less development time. While it may never rival professional libraries and engines, the ability to modify the 3D engine and environment from the REPL allows skilled developers to create applications in a fast, intuitive and flexible way. Simple Clinch should be as simple as possible for someone familiar with 3D graphics programming to understand. I still remember how easy it was to write a single pixel to the screen in DOS and while I can't simplify to that degree (without losing modern power and flexibility), I can remove many of the most common difficulties. These include texture and vertex buffers, shader compiling and linking, shader variable passing, drawing text and 2D graphics, 3D transformations, etc. Intuitive Time spent looking for solutions is spent time, period. It ruins developer flow and can stop a project (especially a small one) indefinitely. Clinch should have few basic primitives which solve the general cases well and allow for easy replacements when necessary. It should be well documented and have a consistent interface. I will strive to keep abstraction leaks at a minimum. Clinch does not try to wrap other libraries inside the Clinch namespace. This keeps developers from ""relearning"" the same functionality. Flexible Clinch does not inflict any particular design onto its client applications. It can be easily modified to create a specific engine. It uses plugins to minimize it's own overhead. Architecture Although Clinch can be used as a complete engine, most parts of Clinch are independent. You can use objects by themselves as best suits your application. For example, you can use a buffer object by itself. This also helps with testing by isolating the various parts of Clinch. The following is in hierarchical order based on the default configuration. This is to explain it as clearly as possible, not to indicate a necessary design. Transforms A transform is a 4x4 matrix which is used to hold and apply a C array of 16 floating values. CL-game-math is used as the default linear algebra library and its arrays may be passed to the shader. There are funcions for creating various projection matrices. Math functions are supplied through the rtg-math package. Nodes Nodes are usually the topmost objects in the hierarchy. Nodes abstract 3D transform ""chains"" and hierarchy. Nodes encapulate transforms and can be scaled, rotated, and translated. They also may have children. Nodes are multiplied together in a hierarchy to create the current transforms which is passes to its children. A node can be used in multiple places within a hierarchy (or tree) or even in several different ones. This is done by passing a list of parents to the update function. It will then append itself and call update on its children. In this way, the transform are only calculated when they or their parent(s) have changed. Buffers Buffers abstract the shared data on the graphics card. They can carry almost any data to the graphics card in bulk, including vertexes, normals, and texture coordinates. Buffers are usually sent to a shader through the entity object. A buffer's data can be accessed directly by using the map/unmap or pullg/pushg functions. Textures Textures abstract the 2D textures and allow easy access to their raw data. Textures can be loaded from files, drawn on with vector graphics or used as render targets. A texture's data can be accessed directly by using the map/unmap or pullg/pushg functions. Pixel Buffers They use Pixel Buffer Object to make texture reading and writing faster. It's a separate buffer object which can send and/or receive data from a texture. It's a separate buffer so it can be used for several similar textures. Shaders Shaders are the compiled output from text-based source code. Clinch supports vertex, fragment and geometry shaders. Shader Programs Shader programs are complete, usable GPU programs. They take input and output to a texture (by default the screen). Shader-programs require a vertex and fragment shader and may also include a geometry shader. They require a list of uniform and attribute arguments. Entities Entities are the rendered meshes. They bring together the shader-program, buffers, textures, attributes, uniforms and transforms together into something which can be rendered on the screen. A shader and an index buffer are required although they would be useless without at least one vertex buffer. Viewports An application can have several viewports. As Clinch does not force any particular windowing implementation, it can not have a window class. Once your window is set up, however, you can use the viewport handle for drawing an area on screen. Frame Buffer objects Frame buffer objects allows OpenGL to render to a texture or textures instead of a screen. The my also have a depth and/or stencle buffer. Window Clinch creates the window for you to make things easier. By default it's launched in a separate thread. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/BradWBeer/CLinch"	"Common Lisp 2D/3D graphics engine for OpenGL.."	"true"
"Graphics"	"donuts"	"https://github.com/tkych/donuts"	"Graph drawing DSL for Common Lisp.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"10"	"1"	"0"	"GitHub - tkych/donuts: Graph Drawing DSL (or Graphviz Interface) for Common Lisp. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 1 Star 10 Fork 0 tkych/donuts Code Issues 0 Pull requests 0 Pulse Graphs Graph Drawing DSL (or Graphviz Interface) for Common Lisp. 76 commits 2 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. doc src CHANGELOG README.markdown api-package.lisp cl-utils.lisp donuts.asd in-package.lisp README.markdown Last Updated : 2012/06/29 21:28:17 tkych Version : 0.3.1 (beta) Donuts: Graph Drawing DSL (or Graphviz Interface) for CL Introduction Donuts converts a graph represented by S-expression to the image. How to use donuts is simple. <> creates a node. -> puts an edge two nodes. && makes a graph by bundling some nodes, edges and graphs. $$ outputs an image of the graph. For further details, please see index (Under Translation) or index-ja (Japanease) in doc directory. The Goal of Donuts Graphviz is a collection of library and utility for drawing a graph. Dot language is description language, used in Graphviz. Graphviz is very useful. However, I (as a lisp programmer) think there are some points to do kaizen. Since dot language is not Turing-complete, when we draw a graph, we don't take full advantage of the pattern in the graph. Because dot language is so-called compiled language, development cycle is inconvenient. Plain Common Lisp does not have ability to draw graph. The goal of donuts is to draw graph in lispic way of thought (REPL, macro, CLOS, multi-paradigm style, and so on). Dependencies Graphviz by AT&T Labs CL-PPCRE by Dr. Edmund Weitz Trivial-Shell by Gary Warren King Installation & Start CL-REPL> (ql:quickload :donuts) CL-REPL> (in-package :donuts) DONUTS> (dot-output (&& (-> 1 2))) ;output dot code in standard-output DONUTS> ($$ (&& (-> 1 2))) ;output graph image to viewer Usage Node-Constructor, <> makes node from node's identity. (<> label) => node Edge-Constructor, -> makes edge between nodes. (-> node1 node2) => edge Graph-Constructor, &&, &, [&] makes graph with nodes, edges, graphs. (&& . nodes-edges-graphs) => graph Shell-Interface, $$, $ outputs graph to viewer. ($$ graph) => NIL ;output image to viewer DOT-OUTPUT outputs dot code in standart-output. (DOT-OUTPUT graph) => NIL ;output dot code Examples   DONUTS> (dot-output             (& (:label ""example"")               (-> (<> ""a"" :shape :box) ""b"" :color :red)))    digraph graph_ID_41 {     label=""example"";     node_ID_39 [label=""a"",shape=box];     node_ID_39 -> ""b"" [color=red];   }   NIL    DONUTS> ;; Example from http://graphviz.org/content/cluster           ($ (:outfile ""cluster.pdf"")              (&& ([&] (:label ""process #1"" :style :filled :color :lightgrey)                    (with-node (:style :filled :color :white)                      (--> ""a0"" ""a1"" ""a2"" ""a3"")))                  ([&] (:label ""process #2"" :color :blue)                    (with-node (:style :filled)                      (--> ""b0"" ""b1"" ""b2"" ""b3"")))                  (->> (<> ""start"" :shape :Mdiamond) ""a0"" ""b0"")                  (==> ""a3"" ""b3"" (<> ""end"" :shape :Msquare))                  (->  ""a1"" ""b3"")                  (->  ""a3"" ""a0"")                  (->  ""b2"" ""a3"")))     ; Create cluster.pdf & Output image to viewer    NIL     DONUTS>     ;; Example from http://www.linuxjournal.com/article/7275    ;; num-day: total number of days in month    ;; starting-day: 0 as Sun, 1 as Mon, ... , 6 as Sat    (defun generate-monthly-calendar (month year num-days starting-day)      (let ((month     (generate-month-nodes month year))            (luminary7 (generate-luminary7-nodes))            (days      (generate-day-nodes num-days starting-day)))        (apply #'&& (loop :for week :in (cons luminary7 (group days 7))                           :collect (apply #'--> month week)))))     (defun generate-month-nodes (month year)      (<> (format nil ""~@(~A~)\\n~D"" month year) :shape :Msquare))     (defun generate-luminary7-nodes ()      (loop :for day :in '(""Sun"" ""Mon"" ""Tue"" ""Wed"" ""Thu"" ""Fri"" ""Sat"")            :collect (<> day :shape :egg :style :filled :color :lightgray)))     (defun generate-day-nodes (num-days starting-day)      (loop :for day :in (nconc (loop :repeat starting-day :collect """")                                (loop :for d :from 1 :to num-days :collect d)                                (loop :repeat (- (* 7 (if (and (= 28 num-days) (= 0 starting-day))                                                          4 5)) ;for Feb starting Sun in common year                                                      starting-day num-days)                                      :collect """"))            :collect (<> day :shape :box)))     ;; from On Lisp, e.g. (group '(1 2 3 4) 2) => ((1 2) (3 4))    (defun group (lst n)      (if (zerop n) (error ""zero length""))      (labels ((rec (lst acc)                 (let ((rest (nthcdr n lst)))                   (if (consp rest)                       (rec rest (cons (subseq lst 0 n)                                       acc))                       (nreverse (cons lst acc))))))        (if lst (rec lst nil) nil)))     ($$ (& (:size ""8,6"":rankdir :LR)          (generate-monthly-calendar 'may 2012 31 2)))     ; Output Calendar to Viewer    NIL     DONUTS>     ;; Example from http://www.graphviz.org/doc/info/html2.gv    ($$ (& (:rankdir :LR)      (with-node (:shape :plaintext)        (let ((a (<> (html (table :border 0 :cellborder 1 :cellspacing 0                                  (tr (td :rowspan 3 :bgcolor :yellow ""class""))                                  (tr (td :port ""here"" :bgcolor :lightblue ""qualfier""))))))              (b (<> (html (table :bgcolor :bisque                                  (tr (td :colspan 3 ""elephant"")                                      (td :rowspan 2 :bgcolor :chartreuse                                          :valign :bottom :align :right ""two""))                                  (tr (td :colspan 2 :rowspan 2                                          (table :bgcolor :grey                                                 (tr (td ""corn""))                                                 (tr (td :bgcolor :yellow ""c""))                                                 (tr (td ""f""))))                                      (td :bgcolor :white ""penguin""))                                  (tr (td :colspan 2 :border 4 :align :right :port ""there"" ""4""))))                      :shape :ellipse :style :filled))              (c (<> (html ""long line 1"" (br) ""line 2"" (br :align :left) ""line 3"" (br :align :right))))              (d (<> ""d"" :shape :triangle)))          (&&            (~ b c)            (-> (@ a :here) (@ b :there) :dir :both :arrowtail :diamond)            (-> c b)            (-> d c :label (html (table (tr (td :bgcolor :red :width 10)                                            (td ""Edge labels"" (br) ""also"")                                            (td :bgcolor :blue :width 10))))))))))     ; Output example to Viewer    NIL  Grammar   <donuts-code> ::= '('<output-op> <graph>')'|<node>|<edge>|<graph>|<html-like-label>|<tag>|<common-lisp-code>   <output-op> ::= 'dot-output'|'dot-pprint'|'$$'|'$' <attr-list>    <attr-list> ::= '('{<attr>}')'   <attr> ::= <attr-keyword> <attr-value>    <graph> ::= '(&&' <graph-elts>')'|'(&' <attr-list> <graph-elts>')'|<cluster>   <graph-elts> ::= nil|<pre-node>|<node>|<edge>|<graph>|<cluster>|<rank>|<with>|<graph-elts>{ <graph-elts>}   <cluster> ::= '([&]' <attr-list> <graph-elts>')'    <pre-node> ::= <number>|<string>   <node> ::= <pre-node>|'(<>' (<pre-node>|<html-like-label>){ <attr>}')'|<record>|'(@'<node> <port>[ <port>]')'    <record> ::= '([] ""'<record-label>'""'{ <attr>}')'   <record-label> ::= <field>{'|'<field>}   <field> ::= [<filed-port> ]{char}|'{'<record-label>'}'   <filed-port> ::= <keyword>    <port> ::= <compass-port>|<filed-port>   <compass-port> ::= :n|:ne|:e|:se|:s|:sw|:w|:nw|:c|:_    <edge> ::= '('<edge-cons> <node> <node>{ <attr>}')'|'('<multi-edge-cons>{ <node>}')'|'(?' <node>{ <attr>}')'   <edge-cons> ::= '->'|'--'   <multi-edge-cons> ::= '-->'|'->>'|'---'|'-<'|'O'    <rank> ::= '(rank' <rank-keyword>{ <node>}')'|'(~'{ <node>}')'   <rank-keyword> ::= :same|:min|:max|:source|:sink    <with> ::= '('<with-op> <attr-list> <graph-elts> ')'   <with-op> ::= 'with-node'|'with-edge'    <html-like-label> ::= '(html'{ <tag>| <txt>}')'   <txt> ::= <string>|<number>   <tag> ::= '('<tag-cons> <tag-body>')'   <tag-cons> ::= 'table'|'font'|'i'|'b'|'u'|'sub'|'sup'|'br'|'hr'|'tr'|'vr'|'td'|'img'   <tag-body> ::= <tag>|<attr>|<txt>|<tag-body>{ <tag-body>}  Author, License, Copyright Takaya OCHIAI tkych.repl@gmail.com MIT License Copyright (C) 2012 Takaya OCHIAI Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/tkych/donuts"	"Graph drawing DSL for Common Lisp.."	"true"
"Graphics"	"lispbuilder-sdl"	"https://github.com/lispbuilder/lispbuilder"	"A set of bindings for SDL.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"42"	"11"	"11"	"GitHub - lispbuilder/lispbuilder: Lispbuilder provides a range of libraries for developing useful portable Common Lisp applications Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 11 Star 42 Fork 11 lispbuilder/lispbuilder Code Issues 29 Pull requests 0 Wiki Pulse Graphs Lispbuilder provides a range of libraries for developing useful portable Common Lisp applications 1,017 commits 1 branch 2 releases 5 contributors Common Lisp 87.5% C 6.6% HTML 3.4% C++ 1.5% Objective-C 0.3% Makefile 0.3% Other 0.4% Common Lisp C HTML C++ Objective-C Makefile Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show lispbuilder-sdl-gfx-0.4.1 lispbuilder-sdl-0.7.1 Nothing to show New pull request Latest commit 44cd19e Dec 12, 2015 elliottslaughter Fix value of -1. Patch from Christophe Junke. Permalink Failed to load latest commit information. lispbuilder-cal3d Update author, license, description metadata. Jun 4, 2015 lispbuilder-clawk * Removed DOS line breaks. Oct 16, 2007 lispbuilder-lexer * Added :depends-on (:lispbuilder-regex) to lispbuilder-sdl-lexer.asd… Sep 17, 2009 lispbuilder-net Update author, license, description metadata. Jun 5, 2015 lispbuilder-opengl Update author, license, description metadata. Jun 5, 2015 lispbuilder-openrm Update author, license, description metadata. Jun 5, 2015 lispbuilder-regex Convert comments to UTF8. Mar 4, 2013 lispbuilder-sdl-gfx Update author, license, description metadata. Jun 5, 2015 lispbuilder-sdl-image Update author, license, description metadata. Jun 5, 2015 lispbuilder-sdl-mixer Update author, license, description metadata. Jun 5, 2015 lispbuilder-sdl-ttf Update author, license, description metadata. Jun 5, 2015 lispbuilder-sdl Fix value of -1. Patch from Christophe Junke. Dec 12, 2015 lispbuilder-windows Update author, license, description metadata. Jun 5, 2015 lispbuilder-yacc initial import Feb 28, 2006 net asynchronous network library, Lisp wrapper and examples May 20, 2007 survey/2013 Results from Lispbuilder User Survey 2013 Jan 4, 2014 .gitignore Add a .gitignore. May 18, 2015 README.md Tweaks to README. May 18, 2015 README.md Lispbuilder Provides several useful cross-platform packages for Common Lisp Quick Links Wiki Download & Installation Windows OS X, Linux, and BSD Screenshots Documentation User Guide API Reference Manual How-To's Community License Contributors Introduction Lispbuilder, or Common Lisp Application Builder, is an umbrella project that provides cross-platform packages for building large, interactive applications in Common Lisp. The most notable of these is Lispbuilder-SDL, a wrapper for SDL, a library commonly used for game development. Other packages provide 3D graphics and animation, networking, text processing, and other miscellaneous functionality. Game and Multimedia Development lispbuilder-sdl: SDL game and multimedia library. Straightforward event loop, supporting either event polling or event waiting, Many graphics drawing primitives, Bitmap and vector graphic support, Load diverse image types, Play samples and stream music including mp3 and OGG, Bitmap and True type font support. lispbuilder-opengl: OpenGL 3d graphics lispbuilder-openrm: OpenRM 3d scene graph lispbuilder-cal3d: Cal3d character animation Text Processing lispbuilder-regex: Regular expression support lispbuilder-clawk: Awk in CL lispbuilder-lexer: Lex in CL lispbuilder-yacc: Yacc in CL Networking lispbuilder-net Windows lispbuilder-windows (windows.h wrapper) Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/lispbuilder/lispbuilder"	"A set of bindings for SDL.."	"true"
"Graphics"	"okra"	"https://github.com/aerique/okra"	"CFFI bindings to Ogre. Not available on Quicklisp.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"20"	"2"	"3"	"GitHub - aerique/okra: CFFI bindings to Ogre Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 20 Fork 3 aerique/okra Code Issues 0 Pull requests 0 Pulse Graphs CFFI bindings to Ogre 105 commits 2 branches 4 releases Fetching contributors Common Lisp 63.6% C++ 34.9% Other 1.5% Common Lisp C++ Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags 1.6.x-cegui master Nothing to show 1.6.4.1 1.6.2.3 1.6.2.2 1.6.2.1 Nothing to show New pull request Latest commit 43413c1 Nov 5, 2014 aerique Update project status. Permalink Failed to load latest commit information. 3rd-party/moc Just muffling a MINGW compiler warning. Oct 1, 2009 bin bindings-generator cmake-modules dist doc examples lib libmygui_okra libokra ""Ogre.h"" -> <Ogre.h> Nov 10, 2009 src-bindings src-common src-mygui src CMakeLists.txt LICENSE README.md okra-bindings-generator.asd okra-bindings.asd okra-common.asd okra-mygui.asd okra.asd README.md Okra status: stalled I do not see myself working on this project anymore. Game engines like Unity and Unreal Engine 4 have come so far these days that a more interesting approach would be to try and get Common Lisp support in there by using f.e. SICL. Also, check out CLinch. CFFI bindings to Ogre     Notes to self check out: http://www.antisphere.com/Wiki/tools:anttweakbar check out: http://github.com/Ramarren/cl-geometry/ check out: http://github.com/nikodemus/sb-cga/ linux to win cross-compiling: http://www.vtk.org/Wiki/CmakeMingw Introduction Okra provides CFFI bindings to the Ogre 3D graphics engine. There's a video of the flock demo on YouTube. License This project is released under the simplified BSD license. Documentation See doc/Okra.html or doc/Okra.pdf for documentation. To Do In order of priority: Clean up the code (specfically code duplication) Document the code Make a more extensive Lisp layer on top of the direct bindings Slowly support more and more of the Ogre API Tests (lower priority since the examples suffice for now) Platforms The latest Git checkout has been tested on the following platforms: CLISP 2.44.1 / Debian Linux 2.6.30 / Ogre 1.6.2 src CLISP 2.48 / Debian Linux 2.6.30 / Ogre 1.6.2 src Clozure CL 1.4-dev-r12681M-trunk / Debian Linux 2.6.30 / Ogre 1.6.2 src SBCL 1.0.25.debian / Debian Linux 2.6.30 / Ogre 1.6.2 src SBCL 1.0.31.0.debian / Debian Linux 2.6.30 / Ogre 1.6.2 src Clozure CL ?.? / Windows XP 2 / Ogre 1.6.1 SDK Clozure CL ?.? / Windows Vista / Ogre 1.6.1 SDK SBCL 1.0.22 / Windows XP 2 / Ogre 1.6.1 SDK SBCL 1.0.29 / Windows Vista / Ogre 1.6.1 SDK Older Clozure CL checkouts had some strange problem with bugging out on a call to cl::sin both on Linux as well as on Windows. Downloads http://github.com/aerique/okra/downloads Windows executables for Okra: okra-20090910.zip. This includes executables for SBCL and CCL with Okra included. note: You'll need to have the DirectX End-User Runtime installed! A Windows executable for the Flock example: flock.zip Please download this, check it for virusses, try to run both flock-ccl.exe & flock-sbcl.exe and tell me how it went (and tell me your version of Windows). note: You'll need to have the DirectX End-User Runtime installed! note 2: I've included d3dx9_30.dll but I'm not sure if this is enough for people who don't have Direct3D installed. Comments are welcome. Version numbering Okra follows the Ogre version numbering with its own version number tagged on at the end. This way you can easily see which version of Ogre these bindings are written for and what the latest release of Okra itself is. Related projects Black Tie: A noise library in Common Lisp. Buclet: Common Lisp bindings for the Bullet physics library. clois-lane: Common Lisp bindings for the Object-Oriented Input System (OIS). Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/aerique/okra"	"CFFI bindings to Ogre. Not available on Quicklisp.."	"true"
"Graphics"	"Varjo"	"https://github.com/cbaggers/varjo"	"Lisp to GLSL translator. Not available on Quicklisp.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"58"	"9"	"8"	"GitHub - cbaggers/varjo: Lisp to GLSL Language Translator Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 9 Star 58 Fork 8 cbaggers/varjo Code Issues 15 Pull requests 1 Pulse Graphs Lisp to GLSL Language Translator 463 commits 11 branches 0 releases 2 contributors Common Lisp 99.3% NewLisp 0.7% Common Lisp NewLisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags big-refactor feature-flow feature-function-scopes feature-locations feature-spec geometry master multi-values release-quicklisp remove-external-funcs texture_redux Nothing to show Nothing to show New pull request Latest commit 2c09800 Jul 15, 2016 baggers Add explicit casts at ALL implicit cast points … This means we get glsl 4.4 implicit casting rules on all glsl versions Permalink Failed to load latest commit information. compiler Add explicit casts at ALL implicit cast points Jul 15, 2016 language remove duplicate x,y,z,w definitons Jul 15, 2016 protocode start using glsl-spec package May 19, 2016 tests add v-compile function & remove old test macros May 25, 2016 .gitignore fix some warnings Feb 28, 2016 LICENSE.txt switch to bsd license Feb 3, 2016 README.md more honest readme Sep 29, 2015 bugs some name refactoring, export more things Jan 20, 2016 package.lisp move free symbols to own package Jul 15, 2016 todo start using glsl-spec package May 19, 2016 utils-v.lisp lisp defaults for unary and empty operator calls Jul 14, 2016 varjo.asd bitwise operators << >> bit-ior bit-and bit-xor Jul 14, 2016 README.md Varjo Varjo is a Lisp to GLSL Language compiler. It currently only supports vertex & fragment shaders. Varjo has no OpenGL dependency as is designed to be itegrated into other projects, see CEPL for an example. Features Subset of common lisp. Including: Macros (Regular and Compiler - Reader macros work anyway) Multiple-value return local functions via ""labels"" defstruct which can be used across multiple shaders (Less repeated code) Type Checking - Works across shader stages Rolling translate, where out vars from one stage can be automatically fed into the next Easy to extend Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/cbaggers/varjo"	"Lisp to GLSL translator. Not available on Quicklisp.."	"true"
"Graphics"	"Vecto"	"http://www.xach.com/lisp/vecto/"	"Simple vector drawing library.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"null"	"null"	"null"	"Vecto - Simple Vector Drawing with Common Lisp Vecto - Simple Vector Drawing with Common Lisp Abstract Vecto is a simplified interface to the powerful CL-VECTORS vector rasterization library. It presents a function-oriented interface similar to CL-PDF, but the results can be saved to a PNG instead of a PDF file. Since Vecto and all supporting libraries are written completely in Common Lisp, without depending on external non-Lisp libraries, it should work in any Common Lisp environment. Vecto is available under a BSD-like license. The latest version is 1.4.10, released on October 15th, 2014. Vecto is used by Easystreet and Movie Charts. The canonical location for Vecto is http://www.xach.com/lisp/vecto/. Download shortcut: http://www.xach.com/lisp/vecto.tgz Contents Overview and Limitations Examples Dictionary Canvases with-canvas clear-canvas save-png save-png-stream Graphics State with-graphics-state set-rgba-fill set-rgb-fill set-gradient-fill set-rgba-stroke set-rgb-stroke set-line-cap set-line-join set-line-width set-dash-pattern translate rotate scale skew clip-path even-odd-clip-path Paths move-to line-to curve-to quadratic-to arc arcn ellipse-arc ellipse-arcn close-subpath stroke-to-paths rectangle rounded-rectangle centered-ellipse-path centered-circle-path Painting fill-path even-odd-fill stroke fill-and-stroke even-odd-fill-and-stroke end-path-no-op Text get-font set-font set-character-spacing *default-character-spacing* draw-string string-paths draw-centered-string centered-string-paths string-bounding-box Miscellaneous +kappa+ References Acknowledgements Feedback Overview and Limitations Vecto is a library that provides a simple interface to the the CL-VECTORS vector drawing library. It supports drawing on a canvas and saving the results to a PNG file. Vecto depends on the following libraries: CL-VECTORS ZPB-TTF Salza2 ZPNG The easiest way to install Vecto and all its dependencies is with Quicklisp. Vecto's function interface is similar to the PDF vector description and painting interface: you create images by describing vector paths, then using stroke or fill operations to paint to the canvas. Vecto's color system uses red, green, blue, and alpha color components for drawing. The results can be be saved to a PNG with an alpha channel. Vecto's coordinate system starts at the lower-left corner of the image, and increases rightwards along the X axis and upwards along the Y axis. All measurements are in pixels. PDF is a feature-rich system. Vecto supports a small subset of PDF-style operations. In particular, it does not support: sampled images pattern or functional fill complex layout of text PostScript fonts non-RGB color spaces Other limitations: No output formats other than 8-bit, truecolor-alpha PNGs No access to underlying pixel data Related libraries: Imago ch-image Poly-pen Examples All examples are available in doc/examples.lisp in the Vecto distribution. That file starts with:  (defpackage #:vecto-examples   (:use #:cl #:vecto))  (in-package #:vecto-examples)   (defun radiant-lambda (file)   (with-canvas (:width 90 :height 90)     (let ((font (get-font ""times.ttf""))           (step (/ pi 7)))       (set-font font 40)       (translate 45 45)       (draw-centered-string 0 -10 #(#x3BB))       (set-rgb-stroke 1 0 0)       (centered-circle-path 0 0 35)       (stroke)       (set-rgba-stroke 0 0 1.0 0.5)       (set-line-width 4)       (dotimes (i 14)         (with-graphics-state           (rotate (* i step))           (move-to 30 0)           (line-to 40 0)           (stroke)))       (save-png file))))   (defun feedlike-icon (file)   (with-canvas (:width 100 :height 100)     (set-rgb-fill 1.0 0.65 0.3)     (rounded-rectangle 0 0 100 100 10 10)     (fill-path)     (set-rgb-fill 1.0 1.0 1.0)     (centered-circle-path 20 20 10)     (fill-path)     (flet ((quarter-circle (x y radius)              (move-to (+ x radius) y)              (arc x y radius 0 (/ pi 2))))       (set-rgb-stroke 1.0 1.0 1.0)       (set-line-width 15)       (quarter-circle 20 20 30)       (stroke)       (quarter-circle 20 20 60)       (stroke))     (rounded-rectangle 5 5 90 90 7 7)     (set-gradient-fill 50 90                        1.0 1.0 1.0 0.7                        50 20                        1.0 1.0 1.0 0.0)     (set-line-width 2)     (set-rgba-stroke 1.0 1.0 1.0 0.1)     (fill-and-stroke)     (save-png file)))  (defun star-clipping (file)   (with-canvas (:width 200 :height 200)     (let ((size 100)           (angle 0)           (step (* 2 (/ (* pi 2) 5))))       (translate size size)       (move-to 0 size)       (dotimes (i 5)         (setf angle (+ angle step))         (line-to (* (sin angle) size)                  (* (cos angle) size)))       (even-odd-clip-path)       (end-path-no-op)       (flet ((circle (distance)                (set-rgba-fill distance 0 0                               (- 1.0 distance))                (centered-circle-path 0 0 (* size distance))                (fill-path)))         (loop for i downfrom 1.0 by 0.05               repeat 20 do               (circle i)))       (save-png file))))  Dictionary The following symbols are exported from the VECTO package. Canvases [Macro] with-canvas (&key width height) &body body Evaluates body with a canvas established with the specified dimensions as the target for drawing commands. The canvas is initially completely clear (all pixels have 0 alpha). [Function] clear-canvas => | Completely fills the canvas with the current fill color. Any marks on the canvas are cleared. [Function] save-png file => truename Writes the contents of the canvas as the PNG file, and returns the truename of file. [Function] save-png-stream stream => | Writes the contents of the canvas as a PNG to stream, which must accept (unsigned-byte 8) data. Graphics State The graphics state stores several parameters used for graphic operations. [Macro] with-graphics-state &body body Evaluates the forms of body with a copy of the current graphics state. Any modifications to the state are undone at the end of the form. [Functions] set-rgba-fill r g b alpha => | set-rgb-fill r g b => | Sets the fill color. r, g, b, and alpha should be in the range of 0.0 to 1.0. set-rgb-fill is the same as set-rgba-fill with an implicit alpha value of 1.0. The fill color is used for CLEAR-CANVAS, FILL-PATH, EVEN-ODD-FILL, FILL-AND-STROKE, EVEN-ODD-FILL-AND-STROKE, and DRAW-STRING. [Function] set-gradient-fill x0 y0 r0 g0 b0 a0 x1 y1 r1 g1 b1 a1 &key (extend-start t) (extend-end t) (domain-function 'linear-domain) Set the fill color source to an axial gradient. The start point is x0,y0 and the start color is r0,g0,b0,a0. The end point is x1, y1 and the end color is r1,g1,b1,a1. Two domain functions are available: LINEAR-DOMAIN, the default, makes a transition from the start color to the end color along the axis between the start and end points BILINEAR-DOMAIN makes a transition from the start color to the end color from the start point to the midpoint, then back to the start color from the midpoint to the end point (defun gradient-example (file)   (with-canvas (:width 200 :height 50)     (set-gradient-fill 25 0                        1 0 0 1                        175 0                        1 0 0 0)     (rectangle 0 0 200 50)     (fill-path)     (save-png file)))  (defun gradient-bilinear-example (file)   (with-canvas (:width 200 :height 50)     (set-gradient-fill 25 0                        1 0 0 1                        175 0                        1 0 0 0                        :domain-function 'bilinear-domain)     (rectangle 0 0 200 50)     (fill-path)     (save-png file)))  [Functions] set-rgba-stroke r g b alpha => | set-rgb-stroke r g b => | Sets the stroke color. r, g, b, and alpha should be in the range of 0.0 to 1.0. set-rgb-stroke is the same as set-rgba-stroke with an implicit alpha value of 1.0. The stroke color is used for STROKE, FILL-AND-STROKE, and EVEN-ODD-FILL-AND-STROKE. [Function] set-line-cap style => | Sets the line cap style to style, which must be one of :BUTT, :SQUARE, or :ROUND. The initial value is :BUTT. :BUTT :SQUARE :ROUND [Function] set-line-join style => | Sets the line join style to style, which must be one of :MITER, :BEVEL, or :ROUND. The initial value is :MITER. :MITER :BEVEL :ROUND [Function] set-line-width width => | Sets the line width for strokes to width. [Function] set-dash-pattern dash-vector phase => | Sets the dash pattern according to dash-vector and phase. dash-vector should be a vector of numbers denoting on and off patterns for a stroke. An empty dash-vector is the same as having no dash pattern at all. phase is how far along the dash pattern to proceed before applying the pattern to the current stroke. Appearance Dash Vector and Phase #() 0 #(30 30) 0 #(30 30) 15 #(10 20 10 40) 0 #(10 20 10 40) 13 #(30 30) 0, :ROUND line caps [Function] translate x y => | Offsets the coordinate system by x units horizontally and y units vertically. [Function] rotate radians => | Rotates the coordinate system by radians. [Function] scale sx sy => | Scales the coordinate system by sx horizontally and sy vertically. [Function] skew ax ay => | Skews the X axis of the coordinate system by ax radians and the Y axis by ay radians. [Function] clip-path => | Defines a clipping path based on the current path. It is not applied immediately, but is created after after the painting is done in the next call to one of FILL-PATH, EVEN-ODD-FILL, FILL-AND-STROKE, EVEN-ODD-FILL-AND-STROKE, or END-PATH-NO-OP. The clipping path initially covers the entire canvas; no clipping is done. Subsequent calls to CLIP-PATH set the clipping path to the intersection of the established clipping path and the new clipping path, and all drawing will be done within the outline of the clipping path. The outline of the clipping path is defined with the nonzero winding rule, as with FILL-PATH. There is no way to enlarge the clipping path. However, the clipping path is part of the graphics state, so changes may be localized by using WITH-GRAPHICS-STATE. A filled red rectangle, not clipped The same rectangle drawn with a circle clipping path in effect Clipped to a rounded rectangle clipping path Clipped to the intersection of the circle and rounded rectangle clipping paths [Function] even-odd-clip-path => | Like CLIP-PATH, but uses the even/odd fill rule to determine the outline of the clipping path. Paths Paths are used to create lines for stroking or outlines for filling. Paths consist of straight lines and curves. Paths consist of one or more subpaths. [Function] move-to x y => | Starts a new subpath at (x,y). move-to must be the first step of constructing a subpath. [Function] line-to x y => | Appends a straight line ending at (x,y) to the current subpath. [Function] curve-to cx1 cy1 cx2 cy2 x y => | Appends a cubic Bézier curve ending at (x,y) and with control points (cx1,cy1) and (cx2,cy2) to the current subpath. [Function] quadratic-to cx cy x y => | Appends a quadratic Bézier curve ending at (x,y) and with the control point (cx,cy) to the current subpath. [Function] arc x y radius angle1 angle2 => | Appends an arc of a circle to the current path. The center of the arc is at (x,y). The arc begins at point at a distance radius from the center and with an angle angle1 radians from the positive x axis, and ends at the point with angle2 radians. If angle2 is less than angle1, it is increased by increasing multiples of 2π until it is greater than or equal to angle1. radius, angle1, angle2 If there is a current point, a straight line is added from the current point to the start point of the arc. Otherwise, a new path is started. (defun pie-wedge (file)   (with-canvas (:width 80 :height 60)     (let ((x 0) (y 0)           (radius 70)           (angle1 (* (/ pi 180) 15))           (angle2 (* (/ pi 180) 45)))       (translate 5 5)       (set-rgb-fill 1 1 1)       (move-to 0 0)       (arc x y radius angle1 angle2)       (fill-and-stroke)       (save-png file))))  [Function] arcn x y radius angle1 angle2 => | Like ARC, but draws the arc clockwise instead of counterclockwise. If angle2 is greater than angle1, it is decreased by increasing multiples of 2π until it is less than or equal to angle1. (defun wiper (file)   (with-canvas (:width 70 :height 70)     (let ((x 0) (y 0)           (r1 40) (r2 60)           (angle1 0)           (angle2 (* (/ pi 180) 90)))       (translate 5 5)       (set-rgba-fill 1 1 1 0.75)       (arc x y r1 angle1 angle2)       (arcn x y r2 angle2 angle1)       (fill-and-stroke)       (save-png file))))  [Function] ellipse-arc cx cy radius-x radius-y rotation-angle angle1 angle2 => | Like ARC, but draws an arc from an ellipse. The arc is drawn counterclockwise. [Function] ellipse-arcn cx cy radius-x radius-y rotation-angle angle1 angle2 => | Like ELLIPSE-ARCN, but draws the arc clockwise. [Function] close-subpath => | Closes the current subpath. If the current point is not the same as the starting point for the subpath, appends a straight line from the current point to the starting point of the current subpath. Subpaths with start and end points that coincidentally overlap are not the same as closed subpaths. The distinction is important when stroking: Open subpath Closed subpath If the subpath is not closed, the start and points of the subpath will be drawn with the current line cap style. If the path is closed, the start and endpoints will be treated as joined and drawn with the line join style. [Function] stroke-to-paths => | Sets the current active paths to the paths that would result from outlining a STROKE operation. [Function] rectangle x y width height => | Creates a rectangular subpath with the given width and height that has its lower-left corner at (x,y). It is effectively the same as:  (move-to x y) (line-to (+ x width) y) (line-to (+ x width) (+ y height)) (line-to x (+ y height)) (close-subpath)  [Function] rounded-rectangle x y width height rx ry => | Like RECTANGLE, but rounds the corners of the rectangle paths by the x radius rx and the y radius ry. [Function] centered-ellipse-path x y rx ry Adds a closed subpath that outlines an ellipse centered at (x,y) with an X radius of rx and a Y radius of ry. [Function] centered-circle-path x y radius => | Adds a closed subpath that outlines a circle centered at (x,y) with a radius of radius. It is effectively the same as:  (centered-ellipse-path x y radius radius)  Painting After a path is defined, filling, stroking, or both will use the path to apply color to the canvas. After a path has been filled or stroked, it is no longer active; it effectively disappears. [Function] fill-path => | Fills the current path with the fill color or gradient. If the path has not been explicitly closed with CLOSE-SUBPATH, it is implicitly closed before filling. The non-zero winding rule is used to determine what areas are considered inside the path. [Function] even-odd-fill => | The same as FILL-PATH, but uses the even/odd rule to determine what areas are considered inside the path. [Function] stroke => | Strokes the current path. The line width, stroke color, line join style, line cap style, and dash pattern and phase determine how the stroked path will appear on the canvas. [Function] fill-and-stroke => | Fills the current path, then strokes it. [Function] even-odd-fill-and-stroke => | Fills the current path using the even/odd rule, then strokes it. [Function] end-path-no-op => | Ends the current path without painting anything. If a clipping path has been specified with CLIP-PATH or EVEN-ODD-CLIP-PATH, it will be created by end-path-no-op. Text Vecto can draw text to a canvas. It loads glyph shapes from TrueType font files with ZPB-TTF. [Function] get-font font-file => font-loader Creates and returns a ZPB-TTF font loader object from font-file. Any font loader created this way will automatically be closed at the end of its enclosing WITH-CANVAS form. [Function] set-font font-loader size => | Sets the active font to the font associated with font-loader, scaled to size units per line. The first argument can be any ZPB-TTF font loader; it need not be created via GET-FONT. However, only font loaders created via GET-FONT will be automatically closed at the end of WITH-CANVAS. [Function] set-character-spacing spacing => | Sets the scale of the spacing used between characters when drawing text with DRAW-STRING and related functions. Normally, the character spacing for drawing text is taken directly from a font's advance-width and kerning metrics. SET-CHARACTER-SPACING can be used to adjust this spacing; for example, a character spacing of 2.0d0 would double the normal space between characters, and 0.5d0 would halve it. [Special variable] *default-character-spacing* The default scale for character spacing when drawing text with DRAW-STRING and related functions. Initial value is 1.0d0. Changes to this variable affect the next WITH-CANVAS form. To affect the spacing within the current WITH-CANVAS form, use SET-CHARACTER-SPACING. [Function] draw-string x y string => | Draws string on the canvas with the active font. The glyph origin of the first character in the string is positioned at x and the baseline of the string is positioned at y. The text is filled with the current fill color. The string may be a specialized vector of characters (a true CL string) or a vector containing characters, Unicode code-points, or both. For example, #(#\L #\a #\m #\b #\d #\a #\= #x3BB) is a valid argument for DRAW-STRING. The horizontal space between characters is determined by the advance-width and kerning metrics of the font, then multiplied by the current character spacing. At the default character spacing of 1.0d0, the spacing is not adjusted at all. SET-CHARACTER-SPACING can be used to increase or decrease the character spacing. [Function] string-paths x y string => | Like DRAW-STRING, but instead of drawing the text, adds the subpaths that make up the string glyphs to the graphics state. This can be used to stroke, fill, or clip based on the outlines of a string. [Function] draw-centered-string x y string => | Draws string on the canvas with the active font. The horizontal center of the string is positioned at x and the baseline of the string is positioned at y. [Function] centered-string-paths x y string => | Like DRAW-CENTERED-STRING, but adds subpaths instead of painting. See also STRING-PATHS. [Function] string-bounding-box string size loader => #(xmin ymin xmax ymax) Calculates the bounding box of string for font-loader at size. Miscellaneous [Constant] +kappa+ => 0.5522847498307936d0. This constant is useful to draw portions of a circle. References Adobe Systems Inc., PDF Reference, Sixth Edition, Version 1.7 Lawrence Kesteloot, Alpha Premultiplication Dr. Thomas Sederberg, Bézier curves Alvy Ray Smith, Image Compositing Fundamentals G. Adam Stanislav, Drawing a circle with Bézier curves Alexander Thomas, The Inverse and Determinants of 2x2 and 3x3 Matrices Wikipedia, Bézier curve Acknowledgements Many thanks to Ben Deane for permission to adapt code from his curve library for drawing arcs. Ryan Davis helped fix my adaptation of the arc drawing. Feedback If you have any questions, comments, bug reports, or other feedback regarding Vecto, please email Zach Beane."	"null"	"null"	"Simple vector drawing library.."	"true"
"Graphics"	"zpng"	"http://www.xach.com/lisp/zpng/"	"A library for creating PNG files.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"null"	"null"	"null"	"ZPNG - Create PNG files from Common Lisp ZPNG - Create PNG files from Common Lisp Abstract ZPNG is a Common Lisp library for creating PNG files. It uses Salza2 for compression. The latest version is 1.2.2, released on March 12th, 2015. Download shortcut: http://www.xach.com/lisp/zpng.tgz Contents Overview and Limitations Examples Dictionary Common Functions samples-per-pixel width height rowstride color-type In-memory PNGs png image-data data-array copy-png png= write-png write-png-stream Streamed, row-at-a-time PNGs streamed-png row-data start-png write-row rows-written rows-left finish-png Streamed, pixel-at-a-time PNGs pixel-streamed-png write-pixel pixels-left-in-row Errors zpng-error invalid-size invalid-size-width invalid-size-height invalid-row-length insufficient-rows incomplete-row too-many-rows color-type-mismatch References Acknowledgements Feedback Overview and Limitations ZPNG provides three interfaces creating PNG files. The first is through a PNG object, which holds all image sample data and which may be written out to a file all at once. The second is through a STREAMED-PNG object, which writes a single output row of the image at a time. By working with only a single row at a time, images that are too big to fit in memory may still be written out incrementally as a PNG file. The third is through a PIXEL-STREAMED-PNG object which allows you to write a single pixel at a time. It still buffers a whole row at a time, but it manages all of the buffer handling for you. The PNG file format has many options, and ZPNG supports only a subset of them. does not load PNG files supports only 8 bits per sample does not support filtering does not support indexed color Examples (defun draw-mandelbrot (file)   (let* ((png (make-instance 'png                              :color-type :grayscale-alpha                              :width 200                              :height 200))          (image (data-array png))          (max 255))     (dotimes (y 200 (write-png png file))       (dotimes (x 200)         (let ((c (complex (- (/ x 100.0) 1.5) (- (/ y 100.0) 1.0)))               (z (complex 0.0 0.0))               (iteration 0))           (loop            (setf z (+ (* z z) c))            (incf iteration)            (cond ((< 4 (abs z))                   (setf (aref image y x 1) iteration)                   (return))                  ((= iteration max)                   (setf (aref image y x 1) 255)                   (return)))))))))  (defun draw-rgb (file)   (let ((png (make-instance 'pixel-streamed-png                              :color-type :truecolor-alpha                              :width 200                              :height 200)))     (with-open-file (stream file 			    :direction :output 			    :if-exists :supersede 			    :if-does-not-exist :create 			    :element-type '(unsigned-byte 8))       (start-png png stream)       (loop for a from 38 to 255 by 31 	do (loop for b from 10 to 255 by 10 	     do (loop for g from 38 to 255 by 31 		  do (loop for r from 10 to 255 by 10 			do (write-pixel (list r g b a) png)))))       (finish-png png))))  Dictionary The following symbols are exported from the ZPNG package. [Function] samples-per-pixel png => samples Returns the number of octet samples that make up a single pixel. Image Color Type Samples per Pixel Grayscale 1 Truecolor 3 Grayscale with Alpha 2 Truecolor with Alpha 4 [Functions] width png => width height png => height Returns the width or height of png. [Function] rowstride png => rowstride Returns the number of samples in a single row of png. It is equivalent to (* (width png) (samples-per-pixel png)). [Function] color-type png => color-type Returns the color type of png, one of of :grayscale, :truecolor, :grayscale-alpha, or :truecolor-alpha. [Class] png Instances of this class may be created directly. Supported initargs: :width - required, the width of the image :height - required, the height of the image :color-type - optional, the color type of the image, one of :grayscale, :truecolor (the default), :grayscale-alpha, or :truecolor-alpha :image-data - optional, the sample data of the image. If specified, this must be an octet vector with a length of width × height × samples-per-pixel. If not specified, an image data vector of the appropriate size will be created automatically. [Function] image-data png => octet-vector Returns the image data of png. Samples are laid out from left to right, top to bottom, so the first samples of data affect the upper-left of the image and the final samples affect the lower-right. Image Color Type Pixel Sample Layout Grayscale S|S|S... Truecolor RGB|RGB|RGB... Grayscale with Alpha SA|SA|SA... Truecolor with Alpha RGBA|RGBA|RGBA... Layout of the samples into pixels is done according to the image's color type and is fully documented in the Portable Network Graphics Specification. [Function] data-array png => data-array Returns a multidimensional array representing the pixels of png. The dimensions correspond to the height, width, and pixel components, respectively. For example, to access the red component at <53,100> of a truecolor PNG, you could use this:  (aref (data-array png) 100 53 0)  Note the reversed order of the coordinate arguments; this is a consequence of Common Lisp's row-major ordering of elements in a multidimensional array and PNG's specified sample layout. [Function] copy-png png => png-copy Create a copy of png. [Function] png= png1 png2 => boolean Returns true if png1 and png2 are equal. Equality is defined as having the same dimensions, color type, and image data. [Function] write-png png file &key (if-exists :supersede) => pathname Writes png to file and returns the truename of file. if-exists is passed to the underlying CL:OPEN call for opening the output file. [Function] write-png-stream png stream => | Writes png to stream, which should be an output stream that can accept octets. [Class] streamed-png Instances of this class may be created directly. Supports all the initargs of the PNG class except :IMAGE-DATA. In contrast to PNG instances, STREAMED-PNG instances do not keep all the image data in one large vector. Instead, instances are used to write out the image data of a PNG file one row at a time. The protocol for incrementally writing out via a STREAMED-PNG involves these generic functions: ROW-DATA START-PNG WRITE-ROW ROWS-WRITTEN ROWS-LEFT FINISH-PNG [Function] row-data streamed-png => octet-vector Returns a vector suitable for passing to WRITE-ROW for streamed-png; it has the appropriate number of entries for the image width and color type of the png. The initial contents are all zeroes. For a given streamed png, each call to row-data will return the same vector, not a fresh one. [Function] start-png png stream => png Writes PNG file header data to stream, which must be an output stream that supports writing (unsigned-byte 8) data. The header data is taken from png, which must be a STREAMED-PNG instance. [Function] write-row row png &key (start 0) end => | Writes row to the output stream of png. row must be an (unsigned-byte 8) vector with the appropriate number of entries for png. start defaults to 0 and end defaults to start + ROWSTRIDE. The difference between end and start should be equal to (rowstride png). png must be a STREAMED-PNG instance. If the row length, as defined by start and end, is not the right size, an error of type INVALID-ROW-LENGTH is signaled. If writing row would exceed the number of rows in the image (as defined by HEIGHT), an error of type TOO-MANY-ROWS is signaled. [Function] rows-written streamed-png => count Returns the number of rows written to streamed-png so far. [Function] rows-left streamed-png => count Returns the number of rows left to write to streamed-png. Equivalent to (- (height png) (rows-written png)). [Function] finish-png streamed-png => | Concludes writing PNG file data to the output stream of streamed-png. The internal state of streamed-png is reset in such a way that it can be re-used to write another PNG file, with the same dimensions and color type parameters, using another START-PNG/WRITE-ROW/FINISH-PNG sequence. This function must be called only after exactly HEIGHT rows have been written to streamed-png via WRITE-ROW. If too few rows have been written to streamed-png, an error of type INSUFFICIENT-ROWS is signaled. [Class] pixel-streamed-png Instances of this class may be created directly. Supports all the initargs of the STREAMED-PNG class. The PIXEL-STREAMED-PNG class extends the STREAMED-PNG class. Rather than preparing a row of pixels and caling the WRITE-ROW method, with PIXEL-STREAMED-PNG instances, you write a single pixel at a time with the WRITE-PIXEL method. The protocol for incrementally writing out via a PIXEL-STREAMED-PNG involves these generic functions: START-PNG WRITE-PIXEL ROWS-WRITTEN ROWS-LEFT PIXELS-LEFT-IN-ROW FINISH-PNG [Function] write-pixel pixel-samples pixel-streamed-png Writes the samples for a single pixel from the sequence pixel-samples to the next available spot in the ROW-DATA buffer. When the buffer is full, this method invokes the WRITE-ROW method. The length of the PIXEL-SAMPLES sequence must be equal to the SAMPLES-PER-PIXEL. [Function] pixels-left-in-row pixel-streamed-png Returns the number of pixels left to write to complete the current row of pixels. [Condition] zpng-error All errors signaled by ZPNG are a subtype of ZPNG-ERROR, which is a subtype of CL:ERROR. [Condition] invalid-size A condition of this type is signaled when a PNG with invalid size is created. Valid PNGs have positive width and height. [Accessors] invalid-size-width condition => width invalid-size-height condition => height These accessors provide the invalid size used for a PNG. [Condition] invalid-row-length A condition of this type is signaled when a row with an incorrect size is passed to WRITE-ROW. [Condition] insufficient-rows A condition of this type is signaled from FINISH-PNG when it is called before enough rows have been written via WRITE-ROW. [Condition] incomplete-row A condition of this type is signaled from FINISH-PNG when it is called on a PIXEL-STREAMED-PNG before the current row of pixels has been completed. [Condition] too-many-rows A condition of this type is signaled from WRITE-ROW if it is called more times than is necessary for the given PNG. [Condition] color-type-mismatch A condition of this type is signaled from WRITE-PIXEL if the number of samples in the pixel is not the expected SAMPLES-PER-PIXEL for the given PNG. References W3C, Portable Network Graphics Specification, Second Edition Wikipedia, Mandelbrot set Acknowledgements Thanks to Patrick Stein for implementing pixel-at-a-time streamed output. Feedback Please direct any questions, comments, bug reports, or other feedback to Zach Beane."	"null"	"null"	"A library for creating PNG files.."	"true"
"GUI"	"cl-cffi-gtk"	"http://www.crategus.com/books/cl-cffi-gtk/"	"Binding for GTK+3.."	"null"	"null"	"null"	"GNU LGPL2.1"	"http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html"	"null"	"null"	"null"	"null"	"null"	"cl-cffi-gtk API documentation    cl-cffi-gtk API documentation Index of packages: Package gtk This is the API documentation of a Lisp binding to GTK+. GTK+ is a library for creating graphical user interfaces. It works on many UNIX-like platforms, Windows, and OS X. GTK+ is released under the GNU Library General Public License (GNU LGPL), which allows for flexible licensing of client applications. GTK+ has a C-based object-oriented architecture that allows for maximum flexibility. Bindings for many other languages have been written, including C++, Objective-C, Guile/Scheme, Perl, Python, TOM, Ada95, Free Pascal, and Eiffel. About this package: Application support Interface builder Windows Layout Containers Display Widgets Buttons and Toggles Numeric and Text Data Entry GTK+ Core Reference Theming in GTK+ Multiline Text Editor Tree, List and Icon Grid Widgets Menus, Combo Box, Toolbar Action-based menus and toolbars Selectors (Color, File and Font) Ornaments Scrolling Printing Miscellaneous Abstract Base Classes Cross-process Embedding Recently Used Documents Choosing from installed applications Deprecated Package gdk GDK is an intermediate layer which isolates GTK+ from the details of the windowing system. This is the API documentation of a Lisp binding to GDK. About this package: General GdkDisplayManager GdkDisplay GdkScreen GdkDeviceManager GdkDevice Points and Rectangles Pixbufs RGBA Colors Visuals Cursors Windows Frame Clock Frame timings OpenGL context Events Event Structures Key Values Selections Drag And Drop Properties and Atoms Threads Pango Interaction Cairo Interaction X Window System Interaction Application launching Deprecated Package gdk-pixbuf GDK-Pixbuf is a library for image loading and manipulation. The GDK-Pixbuf documentation contains both the programmer's guide and the API reference. This is the API documentation of a Lisp binding to GDK-Pixbuf. About this package: Library version numbers The GdkPixbuf Structure File Loading File Saving Image Data in Memory Scaling Utilities Animations GdkPixbufLoader Module Interface Package gobject GObject provides the object system used for Pango and GTK+. This is the API documentation of a Lisp binding to GObject. About this package: Type Information GObject Enumeration and Flag Types Boxed Types Generic Values Parameters and Values GParamSpec Signals Closures Package glib GLib is a general-purpose utility library, which provides many useful data types, macros, type conversions, string utilities, file utilities, a mainloop abstraction, and so on. It works on many UNIX-like platforms, as well as Windows and OS X. GLib is released under the GNU Library General Public License (GNU LGPL). This is the API documentation of a Lisp binding to the library GLib. Only a small part of GLib is implemented in Lisp which is necessary to implement GTK+ in Lisp. About this package: Version Information Miscellaneous The Main Event Loop Quarks Error Reporting Utility Functions Commandline option parser GVariantType GVariant Package gio This is the API documentation of a Lisp binding to GIO. GIO is striving to provide a modern, easy-to-use VFS API that sits at the right level in the library stack, as well as other generally useful APIs for desktop applications (such as networking and D-Bus support). The goal is to overcome the shortcomings of GnomeVFS and provide an API that is so good that developers prefer it over raw POSIX calls. Among other things that means using GObject. It also means not cloning the POSIX API, but providing higher-level, document-centric interfaces. About this package: Files types and applications Icons Application support Package pango Pango is a text layout and shaping library. Pango facilitates the layout and shaping of multi-language text. Full-function rendering of text and cross-platform support is had when Pango is used with platform APIs or 3rd party libraries, such as Uniscribe and FreeType, as text rendering backends. Pango-processed text will appear similar under different operating systems. This is the API documentation of a Lisp binding to Pango. About this package: Basic Pango Interfaces Rendering with Pango Low Level Functionality Package cairo Cairo is a software library used to provide a vector graphics-based, device-independent API for software developers. It is designed to provide primitives for 2-dimensional drawing across a number of different backends. Cairo is designed to use hardware acceleration when available. This is the API documentation of a Lisp binding to Cairo. At this time only a few types and functions are implemented, which are needed to compile the Lisp bindung to GTK+. About this package: Drawing Fonts Surfaces Utilities Exported Symbol Index cairo: +cairo-version+, Constant cairo: +cairo-version-major+, Constant cairo: +cairo-version-micro+, Constant cairo: +cairo-version-minor+, Constant cairo: +cairo-version-string+, Constant gio: +g-menu-attribute-action+, Constant gio: +g-menu-attribute-label+, Constant gio: +g-menu-attribute-target+, Constant gio: +g-menu-link-section+, Constant gio: +g-menu-link-submenu+, Constant glib: +g-priority-default+, Constant glib: +g-priority-default-idle+, Constant glib: +g-priority-high+, Constant glib: +g-priority-high-idle+, Constant glib: +g-priority-low+, Constant glib: +g-source-continue+, Constant glib: +g-source-remove+, Constant gobject: +g-type-boolean+, Variable gobject: +g-type-boxed+, Variable gobject: +g-type-char+, Variable gobject: +g-type-double+, Variable gobject: +g-type-enum+, Variable gobject: +g-type-flags+, Variable gobject: +g-type-float+, Variable gobject: +g-type-fundamental-max+, Variable gobject: +g-type-int+, Variable gobject: +g-type-int64+, Variable gobject: +g-type-interface+, Variable gobject: +g-type-invalid+, Variable gobject: +g-type-long+, Variable gobject: +g-type-none+, Variable gobject: +g-type-object+, Variable gobject: +g-type-param+, Variable gobject: +g-type-pointer+, Variable gobject: +g-type-reserved-bse-first+, Variable gobject: +g-type-reserved-bse-last+, Variable gobject: +g-type-reserved-glib-first+, Variable gobject: +g-type-reserved-glib-last+, Variable gobject: +g-type-reserved-user-first+, Variable gobject: +g-type-string+, Variable gobject: +g-type-uchar+, Variable gobject: +g-type-uint+, Variable gobject: +g-type-uint64+, Variable gobject: +g-type-ulong+, Variable gobject: +g-type-variant+, Variable glib: +g-variant-type-any+, Constant glib: +g-variant-type-array+, Constant glib: +g-variant-type-basic+, Constant glib: +g-variant-type-boolean+, Constant glib: +g-variant-type-byte+, Constant glib: +g-variant-type-bytestring+, Constant glib: +g-variant-type-bytestring-array+, Constant glib: +g-variant-type-dict-entry+, Constant glib: +g-variant-type-dictionary+, Constant glib: +g-variant-type-double+, Constant glib: +g-variant-type-handle+, Constant glib: +g-variant-type-int16+, Constant glib: +g-variant-type-int32+, Constant glib: +g-variant-type-int64+, Constant glib: +g-variant-type-maybe+, Constant glib: +g-variant-type-object-path+, Constant glib: +g-variant-type-object-path-array+, Constant glib: +g-variant-type-signature+, Constant glib: +g-variant-type-string+, Constant glib: +g-variant-type-string-array+, Constant glib: +g-variant-type-tuple+, Constant glib: +g-variant-type-uint16+, Constant glib: +g-variant-type-uint32+, Constant glib: +g-variant-type-uint64+, Constant glib: +g-variant-type-unit+, Constant glib: +g-variant-type-vardict+, Constant glib: +g-variant-type-variant+, Constant gdk: +gdk-current-time+, Constant gdk: +gdk-event-propagate+, Constant gdk: +gdk-event-stop+, Constant gdk: +gdk-none+, Constant gdk: +gdk-parent-relative+, Variable gdk-pixbuf: +gdk-pixbuf-major-version+, Constant gdk-pixbuf: +gdk-pixbuf-micro-version+, Constant gdk-pixbuf: +gdk-pixbuf-minor-version+, Constant gdk-pixbuf: +gdk-pixbuf-version+, Constant gdk: +gdk-selection-clipboard+, Constant gdk: +gdk-selection-primary+, Constant gdk: +gdk-selection-secondary+, Constant gdk: +gdk-selection-type-atom+, Constant gdk: +gdk-selection-type-bitmap+, Constant gdk: +gdk-selection-type-colormap+, Constant gdk: +gdk-selection-type-drawable+, Constant gdk: +gdk-selection-type-integer+, Constant gdk: +gdk-selection-type-pixmap+, Variable gdk: +gdk-selection-type-string+, Constant gdk: +gdk-selection-type-window+, Constant gdk: +gdk-target-bitmap+, Constant gdk: +gdk-target-colormap+, Constant gdk: +gdk-target-drawable+, Constant gdk: +gdk-target-pixmap+, Constant gdk: +gdk-target-string+, Constant glib: +glib-binary-age+, Constant glib: +glib-interface-age+, Constant glib: +glib-major-version+, Constant glib: +glib-micro-version+, Constant glib: +glib-minor-version+, Constant gtk: +gtk-style-provider-priority-application+, Variable gtk: +gtk-style-provider-priority-fallback+, Variable gtk: +gtk-style-provider-priority-settings+, Variable gtk: +gtk-style-provider-priority-theme+, Variable gtk: +gtk-style-provider-priority-user+, Variable pango: +pango-scale+, Constant cairo: cairo-arc, Function cairo: cairo-arc-negative, Function cairo: cairo-clip, Function cairo: cairo-close-path, Function cairo: cairo-content-t, CEnum gtk: cairo-context, CStruct cairo: cairo-create, Function cairo: cairo-curve-to, Function cairo: cairo-destroy, Function cairo: cairo-device-acquire, Function cairo: cairo-device-destroy, Function cairo: cairo-device-get-reference-count, Function cairo: cairo-device-get-type, Function cairo: cairo-device-reference, Function cairo: cairo-device-release, Function cairo: cairo-device-t, CStruct cairo: cairo-device-to-user, Function cairo: cairo-device-to-user-distance, Function cairo: cairo-device-type-t, CEnum cairo: cairo-extend-t, CEnum cairo: cairo-fill, Function cairo: cairo-fill-preserve, Function cairo: cairo-fill-rule-t, CEnum cairo: cairo-font-extents, Function cairo: cairo-font-extents-t, CStruct cairo: cairo-font-face-t, CStruct cairo: cairo-font-options-t, CStruct cairo: cairo-font-slant-t, CEnum cairo: cairo-font-weight-t, CEnum cairo: cairo-format-t, CEnum cairo: cairo-get-dash, Function cairo: cairo-get-dash-count, Function cairo: cairo-get-fill-rule, Function cairo: cairo-get-font-options, Function cairo: cairo-get-line-cap, Function cairo: cairo-get-line-join, Function cairo: cairo-get-line-width, Function cairo: cairo-get-operator, Function cairo: cairo-get-reference-count, Function cairo: cairo-get-source, Function cairo: cairo-get-target, Function cairo: cairo-image-surface-create, Function cairo: cairo-image-surface-create-from-png, Function cairo: cairo-image-surface-get-width, Function cairo: cairo-line-cap-t, CEnum cairo: cairo-line-join-t, CEnum cairo: cairo-line-to, Function cairo: cairo-mask, Function cairo: cairo-mask-surface, Function cairo: cairo-matrix-t, CStruct cairo: cairo-mesh-patern-begin-patch, Symbol cairo: cairo-mesh-pattern-end-patch, Function cairo: cairo-mesh-pattern-line-to, Function cairo: cairo-move-to, Function cairo: cairo-new-sub-path, Function cairo: cairo-operator-t, CEnum cairo: cairo-paint, Function cairo: cairo-paint-with-alpha, Function cairo: cairo-pattern-add-color-stop-rgb, Function cairo: cairo-pattern-add-color-stop-rgba, Function cairo: cairo-pattern-create-for-surface, Function cairo: cairo-pattern-create-linear, Function cairo: cairo-pattern-create-radial, Function cairo: cairo-pattern-create-rgb, Function cairo: cairo-pattern-destroy, Function cairo: cairo-pattern-get-reference-count, Function cairo: cairo-pattern-reference, Function cairo: cairo-pattern-set-extend, Function cairo: cairo-pattern-set-matrix, Function cairo: cairo-pattern-status, Function cairo: cairo-pattern-t, CStruct cairo: cairo-pop-group, Function cairo: cairo-pop-group-to-source, Function cairo: cairo-push-group, Function cairo: cairo-push-group-with-content, Function cairo: cairo-rectangle, Function cairo: cairo-rectangle-int-t, CStruct cairo: cairo-reference, Function cairo: cairo-region-copy, Function cairo: cairo-region-create, Function cairo: cairo-region-create-rectangle, Function cairo: cairo-region-destroy, Function cairo: cairo-region-intersect, Function cairo: cairo-region-reference, Function cairo: cairo-region-status, Function cairo: cairo-region-t, CStruct cairo: cairo-region-union, Function cairo: cairo-rel-curve-to, Function cairo: cairo-rel-line-to, Function cairo: cairo-rel-move-to, Function cairo: cairo-reset-clip, Function cairo: cairo-restore, Function cairo: cairo-rotate, Function cairo: cairo-save, Function cairo: cairo-scale, Function cairo: cairo-scaled-font-create, Function cairo: cairo-scaled-font-t, CStruct cairo: cairo-scaled-font-text-extents, Function cairo: cairo-select-font-face, Function cairo: cairo-set-dash, Function cairo: cairo-set-fill-rule, Function cairo: cairo-set-font-face, Function cairo: cairo-set-font-options, Function cairo: cairo-set-font-size, Function cairo: cairo-set-line-cap, Function cairo: cairo-set-line-join, Function cairo: cairo-set-line-width, Function cairo: cairo-set-matrix, Function cairo: cairo-set-operator, Function cairo: cairo-set-scaled-font, Function cairo: cairo-set-source, Function cairo: cairo-set-source-rgb, Function cairo: cairo-set-source-rgba, Function cairo: cairo-set-source-surface, Function cairo: cairo-show-text, Function cairo: cairo-status, Function cairo: cairo-status-t, CEnum cairo: cairo-status-to-string, Function cairo: cairo-stroke, Function cairo: cairo-stroke-extents, Function cairo: cairo-stroke-preserve, Function cairo: cairo-surface-create-for-rectangle, Function cairo: cairo-surface-create-similar, Function cairo: cairo-surface-create-similar-image, Function cairo: cairo-surface-destroy, Function cairo: cairo-surface-flush, Function cairo: cairo-surface-get-reference-count, Function cairo: cairo-surface-get-type, Function cairo: cairo-surface-mark-dirty, Function cairo: cairo-surface-reference, Function cairo: cairo-surface-set-device-offset, Symbol cairo: cairo-surface-status, Function cairo: cairo-surface-t, CStruct cairo: cairo-surface-type-t, CEnum cairo: cairo-t, CStruct cairo: cairo-text-extents, Function cairo: cairo-text-extents-t, CStruct cairo: cairo-text-extents-t-height, Function  (undocumented) cairo: cairo-text-extents-t-width, Function  (undocumented) cairo: cairo-text-extents-t-x-advance, Function  (undocumented) cairo: cairo-text-extents-t-x-bearing, Function  (undocumented) cairo: cairo-text-extents-t-y-advance, Function  (undocumented) cairo: cairo-text-extents-t-y-bearing, Function  (undocumented) cairo: cairo-text-path, Function cairo: cairo-transform, Function cairo: cairo-translate, Function cairo: cairo-user-to-device, Function cairo: cairo-user-to-device-distance, Function cairo: cairo-version, Function cairo: cairo-version-encode, Function cairo: cairo-version-string, Function gtk: cl-cffi-gtk-build-info, Function gdk: copy-gdk-color, Function gdk: copy-gdk-event, Function gdk: copy-gdk-event-button, Function gdk: copy-gdk-event-configure, Function gdk: copy-gdk-event-crossing, Function gdk: copy-gdk-event-dnd, Function gdk: copy-gdk-event-expose, Function gdk: copy-gdk-event-focus, Function gdk: copy-gdk-event-grab-broken, Function gdk: copy-gdk-event-key, Function gdk: copy-gdk-event-motion, Function gdk: copy-gdk-event-owner-change, Function gdk: copy-gdk-event-property, Function gdk: copy-gdk-event-proximity, Function gdk: copy-gdk-event-scroll, Function gdk: copy-gdk-event-selection, Function gdk: copy-gdk-event-setting, Function gdk: copy-gdk-event-touch, Function gdk: copy-gdk-event-visibility, Function gdk: copy-gdk-event-window-state, Function gdk: copy-gdk-geometry, Function gdk: copy-gdk-keymap-key, Function gdk-pixbuf: copy-gdk-pixbuf-format, Function gdk: copy-gdk-point, Function gdk: copy-gdk-rectangle, Function gdk: copy-gdk-rgba, Function gdk: copy-gdk-time-coord, Function gdk: copy-gdk-window-attr, Function gtk: copy-gtk-border, Function gtk: copy-gtk-requested-size, Function gtk: copy-gtk-requisition, Function gtk: copy-gtk-selection-data, Function gtk: copy-gtk-target-entry, Function pango: copy-pango-matrix, Function gio: g-action, Interface gio: g-action-activate, Function gio: g-action-change-state, Function gio: g-action-enabled, Accessor gio: g-action-get-enabled, Function gio: g-action-get-name, Function gio: g-action-get-parameter-type, Function gio: g-action-get-state, Function gio: g-action-get-state-hint, Function gio: g-action-get-state-type, Function gio: g-action-group, Interface gio: g-action-group-action-added, Function gio: g-action-group-action-enabled-changed, Function gio: g-action-group-action-removed, Function gio: g-action-group-action-state-changed, Function gio: g-action-group-activate-action, Function gio: g-action-group-change-action-state, Function gio: g-action-group-get-action-enabled, Function gio: g-action-group-get-action-parameter-type, Function gio: g-action-group-get-action-state, Function gio: g-action-group-get-action-state-hint, Function gio: g-action-group-get-action-state-type, Function gio: g-action-group-has-action, Function gio: g-action-group-list-actions, Function gio: g-action-map, Interface gio: g-action-map-add-action, Function gio: g-action-map-add-action-entries, Function gio: g-action-map-lookup-action, Function gio: g-action-map-remove-action, Function gio: g-action-name, Accessor gio: g-action-parameter-type, Accessor gio: g-action-state, Accessor gio: g-action-state-type, Accessor gio: g-app-info, Interface gio: g-app-launch-context, Class gio: g-application, Class gio: g-application-action-group, Accessor gio: g-application-activate, Function gio: g-application-application-id, Accessor gio: g-application-flags, Accessor gio: g-application-flags, Enum gio: g-application-get-application-id, Function gio: g-application-get-default, Function gio: g-application-get-flags, Function gio: g-application-get-inactivity-timeout, Function gio: g-application-get-is-registered, Function gio: g-application-get-is-remote, Function gio: g-application-hold, Function gio: g-application-id-is-valid, Function gio: g-application-inactivity-timeout, Accessor gio: g-application-is-registered, Accessor gio: g-application-is-remote, Accessor gio: g-application-new, Function gio: g-application-quit, Function gio: g-application-register, Function gio: g-application-release, Function gio: g-application-run, Function gio: g-application-set-application-id, Function gio: g-application-set-default, Function gio: g-application-set-flags, Function gio: g-application-set-inactivity-timeout, Function gobject: g-boxed-copy, Function gobject: g-boxed-free, Function gobject: g-boxed-type-register-static, Function glib: g-build-filename, Function glib: g-build-path, Function gobject: g-closure, CStruct gobject: g-closure-add-finalize-notifier, Function gobject: g-closure-add-invalidate-notifier, Function gobject: g-closure-invalidate, Function gobject: g-closure-new-simple, Function gobject: g-closure-ref, Function gobject: g-closure-set-marshal, Function gobject: g-closure-sink, Function gobject: g-closure-unref, Function glib: g-cond, CStruct gio: g-content-type-get-description, Function gio: g-content-type-get-generic-icon-name, Function gio: g-content-type-get-icon, Function gio: g-content-type-get-mime-type, Function gio: g-content-type-get-symbolic-icon, Function gio: g-content-types-get-registered, Function gio: g-emblem, Class gio: g-emblem-icon, Accessor gio: g-emblem-origin, Accessor gio: g-emblem-origin, Enum gio: g-emblemed-icon, Class gio: g-emblemed-icon-add-emblem, Function gio: g-emblemed-icon-get-icon, Function gio: g-emblemed-icon-gicon, Accessor gobject: g-enum-class, CStruct gobject: g-enum-class-type, Function gobject: g-enum-class-type-name, Function gobject: g-enum-register-static, Function gobject: g-enum-value, CStruct glib: g-error, CStruct glib: g-filename-to-utf8, Function gobject: g-flags-class, CStruct gobject: g-flags-class-type, Function gobject: g-flags-class-type-name, Function gobject: g-flags-register-static, Function gobject: g-flags-value, CStruct glib: g-free, Function glib: g-get-application-name, Function glib: g-get-current-dir, Function glib: g-get-current-time, Function glib: g-get-environ, Function glib: g-get-home-dir, Function glib: g-get-host-name, Function glib: g-get-monotonic-time, Function glib: g-get-prgname, Function glib: g-get-real-name, Function glib: g-get-real-time, Function glib: g-get-system-config-dirs, Function glib: g-get-system-data-dirs, Function glib: g-get-tmp-dir, Function glib: g-get-user-cache-dir, Function glib: g-get-user-config-dir, Function glib: g-get-user-data-dir, Function glib: g-get-user-name, Function glib: g-get-user-special-dir, Function glib: g-getenv, Function gio: g-icon, Interface gio: g-icon-equal, Function gio: g-icon-hash, Function gio: g-icon-new-for-string, Function gio: g-icon-to-string, Function glib: g-idle-add, Function glib: g-idle-source-new, Function gobject: g-initially-unowned, Class gobject: g-interface-info, CStruct gobject: g-is-enum-class, Function gobject: g-is-object, Function gobject: g-is-object-class, Function gobject: g-is-param-spec, Function glib: g-key-file, CStruct glib: g-key-file-new, Function glib: g-list, Type glib: g-listenv, Function glib: g-main-context, CStruct glib: g-main-context-acquire, Function glib: g-main-context-add-poll, Function glib: g-main-context-check, Function glib: g-main-context-default, Function glib: g-main-context-dispatch, Function glib: g-main-context-find-source-by-id, Function glib: g-main-context-get-poll-func, Function glib: g-main-context-get-thread-default, Function glib: g-main-context-is-owner, Function glib: g-main-context-iteration, Function glib: g-main-context-new, Function glib: g-main-context-pending, Function glib: g-main-context-prepare, Function glib: g-main-context-query, Function glib: g-main-context-ref, Function glib: g-main-context-ref-thread-default, Function glib: g-main-context-release, Function glib: g-main-context-remove-poll, Function glib: g-main-context-set-poll-func, Function glib: g-main-context-unref, Function glib: g-main-context-wait, Function glib: g-main-context-wakeup, Function glib: g-main-current-source, Function glib: g-main-depth, Function glib: g-main-loop, CStruct glib: g-main-loop-get-context, Function glib: g-main-loop-is-running, Function glib: g-main-loop-new, Function glib: g-main-loop-quit, Function glib: g-main-loop-ref, Function glib: g-main-loop-run, Function glib: g-main-loop-unref, Function glib: g-malloc, Function gio: g-menu, Class gio: g-menu-insert-action, Symbol gio: g-menu-item, Class gio: g-menu-item-set-link, Function gio: g-menu-model, Class gio: g-menu-new, Function glib: g-mutex, CStruct gobject: g-object, Class gobject: g-object-add-toggle-ref, Function gobject: g-object-class, CStruct gobject: g-object-class-find-property, Function gobject: g-object-class-install-property, Function gobject: g-object-class-list-properties, Function gobject: g-object-class-name, Function gobject: g-object-class-override-property, Function gobject: g-object-class-type, Function gobject: g-object-construct-param, CStruct gobject: g-object-force-floating, Function gobject: g-object-freeze-notify, Function gobject: g-object-get-class, Function gobject: g-object-get-data, Function gobject: g-object-get-property, Function gobject: g-object-has-reference, Accessor gobject: g-object-interface-find-property, Function gobject: g-object-interface-install-property, Function gobject: g-object-interface-list-properties, Function gobject: g-object-is-floating, Function gobject: g-object-new, Function gobject: g-object-newv, Function gobject: g-object-notify, Function gobject: g-object-ref, Function gobject: g-object-ref-sink, Function gobject: g-object-remove-toggle-ref, Function gobject: g-object-set-data, Function gobject: g-object-set-data-full, Function gobject: g-object-set-property, Function gobject: g-object-signal-handlers, Accessor gobject: g-object-steal-data, Function gobject: g-object-thaw-notify, Function gobject: g-object-type, Function gobject: g-object-type-name, Function gobject: g-object-unref, Function gobject: g-object-weak-ref, Function gobject: g-object-weak-unref, Function glib: g-offset, Type glib: g-option-arg, CEnum glib: g-option-context, CStruct glib: g-option-context-add-group, Function glib: g-option-context-add-main-entries, Function glib: g-option-context-free, Function glib: g-option-context-get-description, Function glib: g-option-context-get-help, Function glib: g-option-context-get-summary, Function glib: g-option-context-new, Function glib: g-option-context-parse, Function glib: g-option-context-set-description, Function glib: g-option-context-set-help-enabled, Function glib: g-option-context-set-summary, Function glib: g-option-context-set-translate-func, Function glib: g-option-context-set-translation-domain, Function glib: g-option-entry, CStruct glib: g-option-flags, Bitfield glib: g-option-group, CStruct glib: g-option-group-add-entries, Function gobject: g-param-flags, Bitfield gobject: g-param-spec, CStruct gobject: g-param-spec-boolean, Function gobject: g-param-spec-boolean, CStruct gobject: g-param-spec-boxed, Function gobject: g-param-spec-boxed, CStruct gobject: g-param-spec-char, Function gobject: g-param-spec-char, CStruct gobject: g-param-spec-class, CStruct gobject: g-param-spec-double, Function gobject: g-param-spec-double, CStruct gobject: g-param-spec-enum, Function gobject: g-param-spec-enum, CStruct gobject: g-param-spec-flags, Function gobject: g-param-spec-flags, CStruct gobject: g-param-spec-float, Function gobject: g-param-spec-float, CStruct gobject: g-param-spec-g-type, Function gobject: g-param-spec-g-type, CStruct gobject: g-param-spec-get-blurb, Function gobject: g-param-spec-get-name, Function gobject: g-param-spec-get-nick, Function gobject: g-param-spec-get-redirect-target, Function gobject: g-param-spec-int, Function gobject: g-param-spec-int, CStruct gobject: g-param-spec-int64, Function gobject: g-param-spec-int64, CStruct gobject: g-param-spec-internal, Function gobject: g-param-spec-long, Function gobject: g-param-spec-long, CStruct gobject: g-param-spec-object, Function gobject: g-param-spec-object, CStruct gobject: g-param-spec-param, Function gobject: g-param-spec-param, CStruct gobject: g-param-spec-pointer, Function gobject: g-param-spec-pointer, CStruct gobject: g-param-spec-ref-sink, Function gobject: g-param-spec-string, Function gobject: g-param-spec-string, CStruct gobject: g-param-spec-type, Function gobject: g-param-spec-type-name, Function gobject: g-param-spec-uchar, Function gobject: g-param-spec-uchar, CStruct gobject: g-param-spec-uint, Function gobject: g-param-spec-uint, CStruct gobject: g-param-spec-uint64, Function gobject: g-param-spec-uint64, CStruct gobject: g-param-spec-ulong, Function gobject: g-param-spec-ulong, CStruct gobject: g-param-spec-unref, Function gobject: g-param-spec-value-array, Function gobject: g-param-spec-value-array, CStruct gobject: g-param-spec-value-type, Function gobject: g-param-value-defaults, Function gobject: g-param-value-set-default, Function gobject: g-param-value-validate, Function gobject: g-param-values-cmp, Function gobject: g-parameter, CStruct glib: g-path-is-absolute, Function gobject: g-pointer-type-register-static, Function glib: g-poll-fd, CStruct glib: g-quark, Type glib: g-quark-from-string, Function glib: g-quark-to-string, Function glib: g-random-int-range, Function glib: g-random-set-seed, Function glib: g-set-application-name, Function glib: g-set-prgname, Function glib: g-setenv, Function gobject: g-signal-connect, Function gobject: g-signal-connect-after, Function gobject: g-signal-connect-closure, Function gobject: g-signal-emit, Function gobject: g-signal-emitv, Function gobject: g-signal-flags, Bitfield gobject: g-signal-handler-block, Function gobject: g-signal-handler-disconnect, Function gobject: g-signal-handler-find, Function  (undocumented) gobject: g-signal-handler-is-connected, Function  (undocumented) gobject: g-signal-handler-unblock, Function gobject: g-signal-has-handler-pending, Function  (undocumented) gobject: g-signal-list-ids, Function gobject: g-signal-lookup, Function gobject: g-signal-match-type, Bitfield gobject: g-signal-name, Function gobject: g-signal-newv, Function gobject: g-signal-parse-name, Function  (undocumented) gobject: g-signal-query, Function gobject: g-signal-stop-emission, Function  (undocumented) gobject: g-signal-stop-emission-by-name, Function  (undocumented) gio: g-simple-action, Class gio: g-simple-action-enabled, Generic Function  (undocumented) gio: g-simple-action-group, Class gio: g-simple-action-group-add-entries, Function gio: g-simple-action-group-insert, Function gio: g-simple-action-group-lookup, Function gio: g-simple-action-group-new, Function gio: g-simple-action-group-remove, Function gio: g-simple-action-name, Generic Function  (undocumented) gio: g-simple-action-new, Function gio: g-simple-action-new-stateful, Function gio: g-simple-action-parameter-type, Generic Function  (undocumented) gio: g-simple-action-set-enabled, Function gio: g-simple-action-set-state, Function gio: g-simple-action-state, Generic Function  (undocumented) gio: g-simple-action-state-type, Generic Function  (undocumented) glib: g-size, Type glib: g-slist, Type glib: g-source, CStruct glib: g-source-add-poll, Function glib: g-source-attach, Function glib: g-source-destroy, Function glib: g-source-funcs, CStruct glib: g-source-get-can-recurse, Function glib: g-source-get-context, Function glib: g-source-get-current-time, Function glib: g-source-get-id, Function glib: g-source-get-name, Function glib: g-source-get-priority, Function glib: g-source-get-time, Function glib: g-source-is-destroyed, Function glib: g-source-new, Function glib: g-source-ref, Function glib: g-source-remove, Function glib: g-source-remove-by-funcs-user-data, Function glib: g-source-remove-by-user-data, Function glib: g-source-remove-poll, Function glib: g-source-set-callback, Function glib: g-source-set-can-recurse, Function glib: g-source-set-funcs, Function glib: g-source-set-name, Function glib: g-source-set-name-by-id, Function glib: g-source-set-priority, Function glib: g-source-unref, Function glib: g-ssize, Type gobject: g-strdup-value-contents, Function glib: g-string, Type glib: g-strv, Type gio: g-themed-icon, Class gio: g-themed-icon-append-name, Function gio: g-themed-icon-name, Accessor gio: g-themed-icon-names, Accessor gio: g-themed-icon-new, Function gio: g-themed-icon-new-from-names, Function gio: g-themed-icon-new-with-default-fallbacks, Function gio: g-themed-icon-prepend-name, Function gio: g-themed-icon-use-default-fallbacks, Accessor glib: g-time-val, CStruct glib: g-timeout-add, Function glib: g-timeout-add-seconds, Function glib: g-timeout-source-new, Function glib: g-timeout-source-new-seconds, Function gobject: g-type, Class gobject: g-type-add-interface-static, Function gobject: g-type-check-class-type, Function gobject: g-type-check-instance-type, Function gobject: g-type-children, Function gobject: g-type-class, CStruct gobject: g-type-class-add-private, Function gobject: g-type-class-peek, Function gobject: g-type-class-peek-parent, Function gobject: g-type-class-peek-static, Function gobject: g-type-class-ref, Function gobject: g-type-class-unref, Function gobject: g-type-closure, Function gobject: g-type-default-interface-peek, Function gobject: g-type-default-interface-ref, Function gobject: g-type-default-interface-unref, Function gobject: g-type-depth, Function gobject: g-type-ensure, Function gobject: g-type-flags, Bitfield gobject: g-type-from-class, Function gobject: g-type-from-instance, Function gobject: g-type-from-interface, Function gobject: g-type-from-name, Function gobject: g-type-fundamental, Function gobject: g-type-fundamental-flags, Bitfield gobject: g-type-fundamental-info, CStruct gobject: g-type-fundamental-next, Function gobject: g-type-get-qdata, Function gobject: g-type-gtype, Function gobject: g-type-has-value-table, Function gobject: g-type-info, CStruct gobject: g-type-instance, CStruct gobject: g-type-instance-get-class, Function gobject: g-type-interface, CStruct gobject: g-type-interface-add-prerequisite, Function gobject: g-type-interface-peek, Function gobject: g-type-interface-prerequisites, Function gobject: g-type-interfaces, Function gobject: g-type-is-a, Function gobject: g-type-is-abstract, Function gobject: g-type-is-classed, Function gobject: g-type-is-deep-derivable, Function gobject: g-type-is-derivable, Function gobject: g-type-is-derived, Function gobject: g-type-is-enum, Function gobject: g-type-is-flags, Function gobject: g-type-is-fundamental, Function gobject: g-type-is-instantiatable, Function gobject: g-type-is-interface, Function gobject: g-type-is-object, Function gobject: g-type-is-param, Function gobject: g-type-is-value, Function gobject: g-type-is-value-abstract, Function gobject: g-type-is-value-type, Function gobject: g-type-make-fundamental, Function gobject: g-type-name, Function gobject: g-type-next-base, Function gobject: g-type-param-boolean, Variable gobject: g-type-param-char, Variable gobject: g-type-param-int, Variable gobject: g-type-param-uchar, Variable gobject: g-type-parent, Function gobject: g-type-query, Function gobject: g-type-query, CStruct gobject: g-type-register-static, Function gobject: g-type-register-static-simple, Function gobject: g-type-set-qdata, Function gobject: g-type-strv, Function gobject: g-type-value, Function gobject: g-type-value-table, CStruct gobject: g-type-value-table-peek, Function glib: g-user-directory, Enum gobject: g-value, CStruct gobject: g-value-copy, Function gobject: g-value-get-boolean, Function gobject: g-value-get-boxed, Function gobject: g-value-get-char, Function gobject: g-value-get-double, Function gobject: g-value-get-enum, Function gobject: g-value-get-flags, Function gobject: g-value-get-float, Function gobject: g-value-get-g-type, Function gobject: g-value-get-int, Function gobject: g-value-get-int64, Function gobject: g-value-get-long, Function gobject: g-value-get-object, Function gobject: g-value-get-param, Function gobject: g-value-get-pointer, Function gobject: g-value-get-schar, Function gobject: g-value-get-string, Function gobject: g-value-get-uchar, Function gobject: g-value-get-uint, Function gobject: g-value-get-uint64, Function gobject: g-value-get-ulong, Function gobject: g-value-get-variant, Function gobject: g-value-holds, Function gobject: g-value-init, Function gobject: g-value-register-transform-func, Function gobject: g-value-reset, Function gobject: g-value-set-boolean, Function gobject: g-value-set-boxed, Function gobject: g-value-set-char, Function gobject: g-value-set-double, Function gobject: g-value-set-enum, Function gobject: g-value-set-flags, Function gobject: g-value-set-float, Function gobject: g-value-set-g-type, Function gobject: g-value-set-instance, Function gobject: g-value-set-int, Function gobject: g-value-set-int64, Function gobject: g-value-set-long, Function gobject: g-value-set-object, Function gobject: g-value-set-param, Function gobject: g-value-set-pointer, Function gobject: g-value-set-schar, Function gobject: g-value-set-string, Function gobject: g-value-set-uchar, Function gobject: g-value-set-uint, Function gobject: g-value-set-uint64, Function gobject: g-value-set-ulong, Function gobject: g-value-set-variant, Function gobject: g-value-take-boxed, Function gobject: g-value-transform, Function gobject: g-value-type, Function gobject: g-value-type-compatible, Function gobject: g-value-type-name, Function gobject: g-value-type-transformable, Function gobject: g-value-unset, Function gobject: g-value-zero, Function glib: g-variant, CStruct glib: g-variant-class, Enum glib: g-variant-classify, Function glib: g-variant-compare, Function glib: g-variant-equal, Function glib: g-variant-get-boolean, Function glib: g-variant-get-byte, Function glib: g-variant-get-double, Function glib: g-variant-get-handle, Function glib: g-variant-get-int16, Function glib: g-variant-get-int32, Function glib: g-variant-get-int64, Function glib: g-variant-get-string, Function glib: g-variant-get-type, Function glib: g-variant-get-type-string, Function glib: g-variant-get-uint16, Function glib: g-variant-get-uint32, Function glib: g-variant-get-uint64, Function glib: g-variant-is-container, Function glib: g-variant-is-floating, Function glib: g-variant-is-object-path, Function glib: g-variant-is-of-type, Function glib: g-variant-is-signature, Function glib: g-variant-new-boolean, Function glib: g-variant-new-byte, Function glib: g-variant-new-double, Function glib: g-variant-new-handle, Function glib: g-variant-new-int16, Function glib: g-variant-new-int32, Function glib: g-variant-new-int64, Function glib: g-variant-new-object-path, Function glib: g-variant-new-signature, Function glib: g-variant-new-string, Function glib: g-variant-new-uint16, Function glib: g-variant-new-uint32, Function glib: g-variant-new-uint64, Function glib: g-variant-new-variant, Function glib: g-variant-ref, Function glib: g-variant-ref-sink, Function glib: g-variant-take-ref, Function glib: g-variant-type, CStruct glib: g-variant-type-copy, Function glib: g-variant-type-dup-string, Function glib: g-variant-type-element, Function glib: g-variant-type-equal, Function glib: g-variant-type-first, Function glib: g-variant-type-free, Function glib: g-variant-type-get-string-length, Function glib: g-variant-type-hash, Function glib: g-variant-type-is-array, Function glib: g-variant-type-is-basic, Function glib: g-variant-type-is-container, Function glib: g-variant-type-is-definite, Function glib: g-variant-type-is-dict-entry, Function glib: g-variant-type-is-maybe, Function glib: g-variant-type-is-subtype-of, Function glib: g-variant-type-is-tuple, Function glib: g-variant-type-is-variant, Function glib: g-variant-type-key, Function glib: g-variant-type-n-items, Function glib: g-variant-type-new, Function glib: g-variant-type-new-array, Function glib: g-variant-type-new-dict-entry, Function glib: g-variant-type-new-maybe, Function glib: g-variant-type-new-tuple, Function glib: g-variant-type-next, Function glib: g-variant-type-peek-string, Function glib: g-variant-type-string-is-valid, Function glib: g-variant-type-string-scan, Function glib: g-variant-type-value, Function glib: g-variant-unref, Function gdk: gdk-app-launch-context, Class gdk: gdk-app-launch-context-display, Accessor gdk: gdk-app-launch-context-new, Function gdk: gdk-app-launch-context-set-desktop, Function gdk: gdk-app-launch-context-set-display, Function gdk: gdk-app-launch-context-set-icon, Function gdk: gdk-app-launch-context-set-icon-name, Function gdk: gdk-app-launch-context-set-screen, Function gdk: gdk-app-launch-context-set-timestamp, Function gdk: gdk-atom, Type gdk: gdk-atom-intern, Function gdk: gdk-atom-name, Function gdk: gdk-axis-use, Enum gdk: gdk-beep, Function gdk: gdk-byte-order, Enum gdk: gdk-cairo-create, Function gdk: gdk-cairo-region, Function gdk: gdk-cairo-set-source-pixbuf, Function gdk: gdk-cairo-set-source-rgba, Function gdk: gdk-cairo-set-source-window, Function gdk: gdk-color, Struct gdk: gdk-color-blue, Accessor gdk: gdk-color-copy, Function gdk: gdk-color-equal, Function gdk: gdk-color-green, Accessor gdk: gdk-color-hash, Function gdk: gdk-color-parse, Function gdk: gdk-color-pixel, Accessor gdk: gdk-color-red, Accessor gdk: gdk-color-to-string, Function gdk-pixbuf: gdk-colorspace, Enum gdk: gdk-crossing-mode, Enum gdk: gdk-cursor, Class gdk: gdk-cursor-cursor-type, Accessor gdk: gdk-cursor-display, Accessor gdk: gdk-cursor-get-image, Function gdk: gdk-cursor-new, Function gdk: gdk-cursor-new-for-display, Function gdk: gdk-cursor-new-from-name, Function gdk: gdk-cursor-new-from-pixbuf, Function gdk: gdk-cursor-ref, Function gdk: gdk-cursor-type, Enum gdk: gdk-cursor-unref, Function gdk: gdk-device, Class gdk: gdk-device-associated-device, Accessor gdk: gdk-device-device-manager, Accessor gdk: gdk-device-display, Accessor gdk: gdk-device-free-history, Function gdk: gdk-device-get-axis, Function gdk: gdk-device-get-axis-use, Function gdk: gdk-device-get-history, Function gdk: gdk-device-get-key, Function gdk: gdk-device-get-mode, Function gdk: gdk-device-get-n-keys, Function gdk: gdk-device-get-position, Function gdk: gdk-device-get-source, Function gdk: gdk-device-get-state, Function gdk: gdk-device-get-window-at-position, Function gdk: gdk-device-grab, Function gdk: gdk-device-has-cursor, Accessor gdk: gdk-device-input-mode, Accessor gdk: gdk-device-input-source, Accessor gdk: gdk-device-list-axes, Function gdk: gdk-device-list-slave-devices, Function gdk: gdk-device-manager, Class gdk: gdk-device-manager-display, Accessor gdk: gdk-device-manager-get-client-pointer, Function gdk: gdk-device-manager-list-devices, Function gdk: gdk-device-n-axes, Accessor gdk: gdk-device-name, Accessor gdk: gdk-device-product-id, Accessor gdk: gdk-device-set-axis-use, Function gdk: gdk-device-set-key, Function gdk: gdk-device-set-mode, Function gdk: gdk-device-type, Accessor gdk: gdk-device-type, Enum gdk: gdk-device-ungrab, Function gdk: gdk-device-vendor-id, Accessor gdk: gdk-device-warp, Function gdk: gdk-disable-multidevice, Function gdk: gdk-display, Class gdk: gdk-display-beep, Function gdk: gdk-display-close, Function gdk: gdk-display-device-is-grabbed, Function gdk: gdk-display-flush, Function gdk: gdk-display-get-app-launch-context, Function gdk: gdk-display-get-default, Function gdk: gdk-display-get-default-cursor-size, Function gdk: gdk-display-get-default-group, Function gdk: gdk-display-get-default-screen, Function gdk: gdk-display-get-device-manager, Function gdk: gdk-display-get-event, Function gdk: gdk-display-get-maximal-cursor-size, Function gdk: gdk-display-get-n-screens, Function gdk: gdk-display-get-name, Function gdk: gdk-display-get-screen, Function gdk: gdk-display-has-pending, Function gdk: gdk-display-is-closed, Function gdk: gdk-display-manager, Class gdk: gdk-display-manager-default-display, Accessor gdk: gdk-display-manager-get, Function gdk: gdk-display-manager-get-default-display, Function gdk: gdk-display-manager-list-displays, Function gdk: gdk-display-manager-open-display, Function gdk: gdk-display-manager-set-default-display, Function gdk: gdk-display-notify-startup-complete, Function gdk: gdk-display-open, Function gdk: gdk-display-peek-event, Function gdk: gdk-display-put-event, Function gdk: gdk-display-request-selection-notification, Function gdk: gdk-display-set-double-click-distance, Function gdk: gdk-display-set-double-click-time, Function gdk: gdk-display-store-clipboard, Function gdk: gdk-display-supports-clipboard-persistence, Function gdk: gdk-display-supports-composite, Function gdk: gdk-display-supports-cursor-alpha, Function gdk: gdk-display-supports-cursor-color, Function gdk: gdk-display-supports-input-shapes, Function gdk: gdk-display-supports-selection-notification, Function gdk: gdk-display-supports-shapes, Function gdk: gdk-display-sync, Function gdk: gdk-drag-abort, Function gdk: gdk-drag-action, Flags gdk: gdk-drag-begin, Function gdk: gdk-drag-begin-for-device, Function gdk: gdk-drag-context, Class gdk: gdk-drag-context-get-protocol, Function gdk: gdk-drag-drop, Function gdk: gdk-drag-drop-succeeded, Function gdk: gdk-drag-find-window-for-screen, Function gdk: gdk-drag-get-selection, Function gdk: gdk-drag-motion, Function gdk: gdk-drag-protocol, Enum gdk: gdk-drag-status, Function gdk: gdk-drop-finish, Function gdk: gdk-drop-reply, Function gdk: gdk-error-trap-pop, Function gdk: gdk-error-trap-pop-ignored, Function gdk: gdk-error-trap-push, Function gdk: gdk-event, Struct gdk: gdk-event-button, Struct gdk: gdk-event-button-axes, Accessor gdk: gdk-event-button-button, Accessor gdk: gdk-event-button-device, Accessor gdk: gdk-event-button-send-event, Accessor gdk: gdk-event-button-state, Accessor gdk: gdk-event-button-time, Accessor gdk: gdk-event-button-type, Accessor gdk: gdk-event-button-window, Accessor gdk: gdk-event-button-x, Accessor gdk: gdk-event-button-x-root, Accessor gdk: gdk-event-button-y, Accessor gdk: gdk-event-button-y-root, Accessor gdk: gdk-event-configure, Struct gdk: gdk-event-configure-height, Accessor gdk: gdk-event-configure-send-event, Accessor gdk: gdk-event-configure-type, Accessor gdk: gdk-event-configure-width, Accessor gdk: gdk-event-configure-window, Accessor gdk: gdk-event-configure-x, Accessor gdk: gdk-event-configure-y, Accessor gdk: gdk-event-copy, Function gdk: gdk-event-crossing, Struct gdk: gdk-event-crossing-detail, Accessor gdk: gdk-event-crossing-focus, Accessor gdk: gdk-event-crossing-mode, Accessor gdk: gdk-event-crossing-send-event, Accessor gdk: gdk-event-crossing-state, Accessor gdk: gdk-event-crossing-subwindow, Accessor gdk: gdk-event-crossing-time, Accessor gdk: gdk-event-crossing-type, Accessor gdk: gdk-event-crossing-window, Accessor gdk: gdk-event-crossing-x, Accessor gdk: gdk-event-crossing-x-root, Accessor gdk: gdk-event-crossing-y, Accessor gdk: gdk-event-crossing-y-root, Accessor gdk: gdk-event-dnd, Struct gdk: gdk-event-dnd-context, Accessor gdk: gdk-event-dnd-send-event, Accessor gdk: gdk-event-dnd-time, Accessor gdk: gdk-event-dnd-type, Accessor gdk: gdk-event-dnd-window, Accessor gdk: gdk-event-dnd-x-root, Accessor gdk: gdk-event-dnd-y-root, Accessor gdk: gdk-event-expose, Struct gdk: gdk-event-expose-area, Accessor gdk: gdk-event-expose-count, Accessor gdk: gdk-event-expose-region, Accessor gdk: gdk-event-expose-send-event, Accessor gdk: gdk-event-expose-type, Accessor gdk: gdk-event-expose-window, Accessor gdk: gdk-event-focus, Struct gdk: gdk-event-focus-in, Accessor gdk: gdk-event-focus-send-event, Accessor gdk: gdk-event-focus-type, Accessor gdk: gdk-event-focus-window, Accessor gdk: gdk-event-get, Function gdk: gdk-event-get-axis, Function gdk: gdk-event-get-button, Function gdk: gdk-event-get-click-count, Function gdk: gdk-event-get-coords, Function gdk: gdk-event-get-device, Function gdk: gdk-event-get-event-sequence, Function gdk: gdk-event-get-root-coords, Function gdk: gdk-event-get-screen, Function gdk: gdk-event-get-scroll-deltas, Function gdk: gdk-event-get-source-device, Function gdk: gdk-event-get-state, Function gdk: gdk-event-get-time, Function gdk: gdk-event-grab-broken, Struct gdk: gdk-event-grab-broken-grab-window, Accessor gdk: gdk-event-grab-broken-implicit, Accessor gdk: gdk-event-grab-broken-keyboard, Accessor gdk: gdk-event-grab-broken-send-event, Accessor gdk: gdk-event-grab-broken-type, Accessor gdk: gdk-event-grab-broken-window, Accessor gdk: gdk-event-handler-set, Function gdk: gdk-event-key, Struct gdk: gdk-event-key-group, Accessor gdk: gdk-event-key-hardware-keycode, Accessor gdk: gdk-event-key-is-modifier, Accessor gdk: gdk-event-key-keyval, Accessor gdk: gdk-event-key-length, Accessor gdk: gdk-event-key-send-event, Accessor gdk: gdk-event-key-state, Accessor gdk: gdk-event-key-string, Accessor gdk: gdk-event-key-time, Accessor gdk: gdk-event-key-type, Accessor gdk: gdk-event-key-window, Accessor gdk: gdk-event-mask, Flags gdk: gdk-event-motion, Struct gdk: gdk-event-motion-axes, Accessor gdk: gdk-event-motion-device, Accessor gdk: gdk-event-motion-is-hint, Accessor gdk: gdk-event-motion-send-event, Accessor gdk: gdk-event-motion-state, Accessor gdk: gdk-event-motion-time, Accessor gdk: gdk-event-motion-type, Accessor gdk: gdk-event-motion-window, Accessor gdk: gdk-event-motion-x, Accessor gdk: gdk-event-motion-x-root, Accessor gdk: gdk-event-motion-y, Accessor gdk: gdk-event-motion-y-root, Accessor gdk: gdk-event-new, Function gdk: gdk-event-owner-change, Struct gdk: gdk-event-owner-change-owner, Accessor gdk: gdk-event-owner-change-reason, Accessor gdk: gdk-event-owner-change-selection, Accessor gdk: gdk-event-owner-change-selection-time, Accessor gdk: gdk-event-owner-change-send-event, Accessor gdk: gdk-event-owner-change-time, Accessor gdk: gdk-event-owner-change-type, Accessor gdk: gdk-event-owner-change-window, Accessor gdk: gdk-event-peek, Function gdk: gdk-event-property, Struct gdk: gdk-event-property-atom, Accessor gdk: gdk-event-property-send-event, Accessor gdk: gdk-event-property-state, Accessor gdk: gdk-event-property-time, Accessor gdk: gdk-event-property-type, Accessor gdk: gdk-event-property-window, Accessor gdk: gdk-event-proximity, Struct gdk: gdk-event-proximity-device, Accessor gdk: gdk-event-proximity-send-event, Accessor gdk: gdk-event-proximity-time, Accessor gdk: gdk-event-proximity-type, Accessor gdk: gdk-event-proximity-window, Accessor gdk: gdk-event-put, Function gdk: gdk-event-request-motions, Function gdk: gdk-event-scroll, Struct gdk: gdk-event-scroll-delta-x, Accessor gdk: gdk-event-scroll-delta-y, Accessor gdk: gdk-event-scroll-device, Accessor gdk: gdk-event-scroll-direction, Accessor gdk: gdk-event-scroll-send-event, Accessor gdk: gdk-event-scroll-state, Accessor gdk: gdk-event-scroll-time, Accessor gdk: gdk-event-scroll-type, Accessor gdk: gdk-event-scroll-window, Accessor gdk: gdk-event-scroll-x, Accessor gdk: gdk-event-scroll-x-root, Accessor gdk: gdk-event-scroll-y, Accessor gdk: gdk-event-scroll-y-root, Accessor gdk: gdk-event-selection, Struct gdk: gdk-event-selection-property, Accessor gdk: gdk-event-selection-requestor, Accessor gdk: gdk-event-selection-selection, Accessor gdk: gdk-event-selection-send-event, Accessor gdk: gdk-event-selection-target, Accessor gdk: gdk-event-selection-time, Accessor gdk: gdk-event-selection-type, Accessor gdk: gdk-event-selection-window, Accessor gdk: gdk-event-send-event, Accessor gdk: gdk-event-sequence, Class gdk: gdk-event-set-device, Function gdk: gdk-event-set-screen, Function gdk: gdk-event-set-source-device, Function gdk: gdk-event-setting, Struct gdk: gdk-event-setting-action, Accessor gdk: gdk-event-setting-name, Accessor gdk: gdk-event-setting-send-event, Accessor gdk: gdk-event-setting-type, Accessor gdk: gdk-event-setting-window, Accessor gdk: gdk-event-touch, Struct gdk: gdk-event-touch-axes, Accessor gdk: gdk-event-touch-device, Accessor gdk: gdk-event-touch-emulating-pointer, Accessor gdk: gdk-event-touch-send-event, Accessor gdk: gdk-event-touch-sequence, Accessor gdk: gdk-event-touch-state, Accessor gdk: gdk-event-touch-time, Accessor gdk: gdk-event-touch-type, Accessor gdk: gdk-event-touch-window, Accessor gdk: gdk-event-touch-x, Accessor gdk: gdk-event-touch-x-root, Accessor gdk: gdk-event-touch-y, Accessor gdk: gdk-event-touch-y-root, Accessor gdk: gdk-event-type, Accessor gdk: gdk-event-type, Enum gdk: gdk-event-visibility, Struct gdk: gdk-event-visibility-send-event, Accessor gdk: gdk-event-visibility-state, Accessor gdk: gdk-event-visibility-type, Accessor gdk: gdk-event-visibility-window, Accessor gdk: gdk-event-window, Accessor gdk: gdk-event-window-state, Struct gdk: gdk-event-window-state-changed-mask, Accessor gdk: gdk-event-window-state-new-window-state, Accessor gdk: gdk-event-window-state-send-event, Accessor gdk: gdk-event-window-state-type, Accessor gdk: gdk-event-window-state-window, Accessor gdk: gdk-events-pending, Function gdk: gdk-filter-return, Enum gdk: gdk-flush, Function gdk: gdk-frame-clock, Class gdk: gdk-frame-clock-phase, Enum gdk: gdk-frame-timings, CStruct gdk: gdk-geometry, CStruct gdk: gdk-geometry-base-height, Accessor gdk: gdk-geometry-base-width, Accessor gdk: gdk-geometry-height-increment, Accessor gdk: gdk-geometry-max-aspect, Accessor gdk: gdk-geometry-max-height, Accessor gdk: gdk-geometry-max-width, Accessor gdk: gdk-geometry-min-aspect, Accessor gdk: gdk-geometry-min-height, Accessor gdk: gdk-geometry-min-width, Accessor gdk: gdk-geometry-width-increment, Accessor gdk: gdk-geometry-win-gravity, Accessor gdk: gdk-get-default-root-window, Function gdk: gdk-get-display, Function gdk: gdk-get-display-arg-name, Function gdk: gdk-get-program-class, Function gdk: gdk-get-setting, Function gdk: gdk-get-show-events, Function gdk: gdk-gl-context, Class gdk: gdk-gl-context-display, Accessor gdk: gdk-gl-context-shared-context, Accessor gdk: gdk-gl-context-window, Accessor gdk: gdk-grab-ownership, Enum gdk: gdk-grab-status, Enum gdk: gdk-gravity, Enum gdk: gdk-input-mode, Enum gdk: gdk-input-source, Enum gdk-pixbuf: gdk-interp-type, Enum gdk: gdk-keyboard-grab, Function gdk: gdk-keyboard-ungrab, Function gdk: gdk-keymap, Class gdk: gdk-keymap-add-virtual-modifiers, Function gdk: gdk-keymap-get-caps-lock-state, Function gdk: gdk-keymap-get-default, Function gdk: gdk-keymap-get-direction, Function gdk: gdk-keymap-get-entries-for-keycode, Function gdk: gdk-keymap-get-entries-for-keyval, Function gdk: gdk-keymap-get-for-display, Function gdk: gdk-keymap-get-modifier-mask, Function gdk: gdk-keymap-get-modifier-state, Function gdk: gdk-keymap-get-num-lock-state, Function gdk: gdk-keymap-have-bidi-layouts, Function gdk: gdk-keymap-key, Struct gdk: gdk-keymap-key-group, Accessor gdk: gdk-keymap-key-keycode, Accessor gdk: gdk-keymap-key-level, Accessor gdk: gdk-keymap-lookup-key, Function gdk: gdk-keymap-map-virtual-modifiers, Function gdk: gdk-keymap-translate-keyboard-state, Function gdk: gdk-keyval-convert-case, Function gdk: gdk-keyval-from-name, Function gdk: gdk-keyval-is-lower, Function gdk: gdk-keyval-is-upper, Function gdk: gdk-keyval-name, Function gdk: gdk-keyval-to-lower, Function gdk: gdk-keyval-to-unicode, Function gdk: gdk-keyval-to-upper, Function gdk: gdk-list-visuals, Function gdk: gdk-modifier-intent, Enum gdk: gdk-modifier-type, Flags gdk: gdk-notify-startup-complete, Function gdk: gdk-notify-startup-complete-with-id, Function gdk: gdk-notify-type, Enum gdk: gdk-offscreen-window-get-embedder, Function gdk: gdk-offscreen-window-get-surface, Function gdk: gdk-offscreen-window-set-embedder, Function gdk: gdk-owner-change, Enum gdk: gdk-pango-context-get, Function gdk: gdk-pango-context-get-for-screen, Function gdk: gdk-pango-layout-get-clip-region, Function gdk: gdk-pango-layout-line-get-clip-region, Function gdk-pixbuf: gdk-pixbuf, Class gdk-pixbuf: gdk-pixbuf-add-alpha, Function gdk-pixbuf: gdk-pixbuf-alpha-mode, Enum gdk-pixbuf: gdk-pixbuf-animation, Class gdk-pixbuf: gdk-pixbuf-animation-get-static-image, Function gdk-pixbuf: gdk-pixbuf-animation-loop, Accessor gdk-pixbuf: gdk-pixbuf-animation-new-from-file, Function gdk-pixbuf: gdk-pixbuf-bits-per-sample, Accessor gdk-pixbuf: gdk-pixbuf-colorspace, Accessor gdk-pixbuf: gdk-pixbuf-composite, Function gdk-pixbuf: gdk-pixbuf-composite-color, Function gdk-pixbuf: gdk-pixbuf-composite-color-simple, Function gdk-pixbuf: gdk-pixbuf-copy, Function gdk-pixbuf: gdk-pixbuf-copy-area, Function gdk-pixbuf: gdk-pixbuf-fill, Function gdk-pixbuf: gdk-pixbuf-format, CStruct gdk-pixbuf: gdk-pixbuf-format-description, Accessor gdk-pixbuf: gdk-pixbuf-format-disabled, Accessor gdk-pixbuf: gdk-pixbuf-format-domain, Accessor gdk-pixbuf: gdk-pixbuf-format-extensions, Accessor gdk-pixbuf: gdk-pixbuf-format-flags, Accessor gdk-pixbuf: gdk-pixbuf-format-flags, Bitfield gdk-pixbuf: gdk-pixbuf-format-license, Accessor gdk-pixbuf: gdk-pixbuf-format-mime-types, Accessor gdk-pixbuf: gdk-pixbuf-format-name, Accessor gdk-pixbuf: gdk-pixbuf-format-signature, Accessor gdk-pixbuf: gdk-pixbuf-get-bits-per-sample, Function gdk-pixbuf: gdk-pixbuf-get-byte-length, Function gdk-pixbuf: gdk-pixbuf-get-colorspace, Function gdk: gdk-pixbuf-get-from-surface, Function gdk: gdk-pixbuf-get-from-window, Function gdk-pixbuf: gdk-pixbuf-get-has-alpha, Function gdk-pixbuf: gdk-pixbuf-get-height, Function gdk-pixbuf: gdk-pixbuf-get-n-channels, Function gdk-pixbuf: gdk-pixbuf-get-option, Function gdk-pixbuf: gdk-pixbuf-get-pixels, Function gdk-pixbuf: gdk-pixbuf-get-rowstride, Function gdk-pixbuf: gdk-pixbuf-get-width, Function gdk-pixbuf: gdk-pixbuf-has-alpha, Accessor gdk-pixbuf: gdk-pixbuf-height, Accessor gdk-pixbuf: gdk-pixbuf-load-get-animation, Symbol gdk-pixbuf: gdk-pixbuf-loader, Class gdk-pixbuf: gdk-pixbuf-loader-close, Function gdk-pixbuf: gdk-pixbuf-loader-get-pixbuf, Function gdk-pixbuf: gdk-pixbuf-loader-new, Function gdk-pixbuf: gdk-pixbuf-loader-set-size, Function gdk-pixbuf: gdk-pixbuf-loader-write, Function gdk-pixbuf: gdk-pixbuf-module-pattern, CStruct gdk-pixbuf: gdk-pixbuf-n-channels, Accessor gdk-pixbuf: gdk-pixbuf-new, Function gdk-pixbuf: gdk-pixbuf-new-from-file, Function gdk-pixbuf: gdk-pixbuf-new-subpixbuf, Function gdk-pixbuf: gdk-pixbuf-pixels, Accessor gdk-pixbuf: gdk-pixbuf-rowstride, Accessor gdk-pixbuf: gdk-pixbuf-save, Function gdk-pixbuf: gdk-pixbuf-scale, Function gdk-pixbuf: gdk-pixbuf-scale-simple, Function gdk-pixbuf: gdk-pixbuf-width, Accessor gdk: gdk-point, CStruct gdk: gdk-point-x, Accessor gdk: gdk-point-y, Accessor gdk: gdk-pointer-grab, Function gdk: gdk-pointer-is-grabbed, Function gdk: gdk-pointer-ungrab, Function gdk: gdk-priority-redraw, Constant gdk: gdk-property-state, Enum gdk: gdk-query-depths, Function gdk: gdk-query-visual-types, Function gdk: gdk-rectangle, CStruct gdk: gdk-rectangle-height, Accessor gdk: gdk-rectangle-intersect, Function gdk: gdk-rectangle-union, Function gdk: gdk-rectangle-width, Accessor gdk: gdk-rectangle-x, Accessor gdk: gdk-rectangle-y, Accessor gdk: gdk-rgba, CStruct gdk: gdk-rgba-alpha, Accessor gdk: gdk-rgba-blue, Accessor gdk: gdk-rgba-copy, Function gdk: gdk-rgba-equal, Function gdk: gdk-rgba-green, Accessor gdk: gdk-rgba-hash, Function gdk: gdk-rgba-parse, Function gdk: gdk-rgba-red, Accessor gdk: gdk-rgba-to-string, Function gdk: gdk-screen, Class gdk: gdk-screen-font-options, Accessor gdk: gdk-screen-get-active-window, Function gdk: gdk-screen-get-default, Function gdk: gdk-screen-get-display, Function gdk: gdk-screen-get-height, Function gdk: gdk-screen-get-height-mm, Function gdk: gdk-screen-get-monitor-at-point, Function gdk: gdk-screen-get-monitor-at-window, Function gdk: gdk-screen-get-monitor-geometry, Function gdk: gdk-screen-get-monitor-height-mm, Function gdk: gdk-screen-get-monitor-plug-name, Function gdk: gdk-screen-get-monitor-width-mm, Function gdk: gdk-screen-get-monitor-workarea, Function gdk: gdk-screen-get-n-monitors, Function gdk: gdk-screen-get-number, Function gdk: gdk-screen-get-primary-monitor, Function gdk: gdk-screen-get-rgba-visual, Function gdk: gdk-screen-get-root-window, Function gdk: gdk-screen-get-setting, Function gdk: gdk-screen-get-system-visual, Function gdk: gdk-screen-get-toplevel-windows, Function gdk: gdk-screen-get-width, Function gdk: gdk-screen-get-width-mm, Function gdk: gdk-screen-get-window-stack, Function gdk: gdk-screen-height, Function gdk: gdk-screen-height-mm, Function gdk: gdk-screen-is-composited, Function gdk: gdk-screen-list-visuals, Function gdk: gdk-screen-make-display-name, Function gdk: gdk-screen-resolution, Accessor gdk: gdk-screen-width, Function gdk: gdk-screen-width-mm, Function gdk: gdk-scroll-direction, Enum gdk: gdk-selection-convert, Function gdk: gdk-selection-owner-get, Function gdk: gdk-selection-owner-get-for-display, Function gdk: gdk-selection-owner-set, Function gdk: gdk-selection-owner-set-for-display, Function gdk: gdk-selection-property-get, Function gdk: gdk-selection-send-notify, Function gdk: gdk-selection-send-notify-for-display, Function gdk: gdk-set-double-click-time, Function gdk: gdk-set-program-class, Function gdk: gdk-set-show-events, Function gdk: gdk-setting-action, Enum gdk: gdk-threads-add-idle, Function gdk: gdk-threads-add-idle-full, Function gdk: gdk-threads-add-timeout, Function gdk: gdk-threads-add-timeout-full, Function gdk: gdk-threads-add-timeout-seconds, Function gdk: gdk-threads-add-timeout-seconds-full, Function gdk: gdk-threads-enter, Function gdk: gdk-threads-init, Function gdk: gdk-threads-leave, Function gdk: gdk-time-coord, CStruct gdk: gdk-time-coord-axes, Accessor gdk: gdk-time-coord-time, Accessor gdk: gdk-unicode-to-keyval, Function gdk: gdk-visibility-state, Enum gdk: gdk-visual, Class gdk: gdk-visual-get-best, Function gdk: gdk-visual-get-best-depth, Function gdk: gdk-visual-get-best-type, Function gdk: gdk-visual-get-best-with-both, Function gdk: gdk-visual-get-best-with-depth, Function gdk: gdk-visual-get-best-with-type, Function gdk: gdk-visual-get-bits-per-rgb, Function gdk: gdk-visual-get-blue-pixel-details, Function gdk: gdk-visual-get-byte-order, Function gdk: gdk-visual-get-colormap-size, Function gdk: gdk-visual-get-depth, Function gdk: gdk-visual-get-green-pixel-details, Function gdk: gdk-visual-get-red-pixel-details, Function gdk: gdk-visual-get-screen, Function gdk: gdk-visual-get-system, Function gdk: gdk-visual-get-visual-type, Function gdk: gdk-visual-type, Enum gdk: gdk-window, Class gdk: gdk-window-at-pointer, Function gdk: gdk-window-attr, CStruct gdk: gdk-window-attr-cursor, Accessor gdk: gdk-window-attr-event-mask, Accessor gdk: gdk-window-attr-height, Accessor gdk: gdk-window-attr-override-redirect, Accessor gdk: gdk-window-attr-title, Accessor gdk: gdk-window-attr-type-hint, Accessor gdk: gdk-window-attr-visual, Accessor gdk: gdk-window-attr-width, Accessor gdk: gdk-window-attr-window-class, Accessor gdk: gdk-window-attr-window-type, Accessor gdk: gdk-window-attr-wmclass-class, Accessor gdk: gdk-window-attr-wmclass-name, Accessor gdk: gdk-window-attr-x, Accessor gdk: gdk-window-attr-y, Accessor gdk: gdk-window-attributes-type, Enum gdk: gdk-window-beep, Function gdk: gdk-window-begin-move-drag, Function gdk: gdk-window-begin-move-drag-for-device, Function gdk: gdk-window-begin-paint-rect, Function gdk: gdk-window-begin-paint-region, Function gdk: gdk-window-begin-resize-drag, Function gdk: gdk-window-begin-resize-drag-for-device, Function gdk: gdk-window-configure-finished, Function gdk: gdk-window-constrain-size, Function gdk: gdk-window-coords-from-parent, Function gdk: gdk-window-coords-to-parent, Function gdk: gdk-window-create-similar-surface, Function gdk: gdk-window-cursor, Accessor gdk: gdk-window-deiconify, Function gdk: gdk-window-destroy, Function gdk: gdk-window-edge, Enum gdk: gdk-window-enable-synchronized-configure, Function gdk: gdk-window-end-paint, Function gdk: gdk-window-ensure-native, Function gdk: gdk-window-flush, Function gdk: gdk-window-focus, Function gdk: gdk-window-freeze-updates, Function gdk: gdk-window-fullscreen, Function gdk: gdk-window-geometry-changed, Function gdk: gdk-window-get-accept-focus, Function gdk: gdk-window-get-children, Function gdk: gdk-window-get-clip-region, Function gdk: gdk-window-get-composited, Function gdk: gdk-window-get-decorations, Function gdk: gdk-window-get-device-cursor, Function gdk: gdk-window-get-device-events, Function gdk: gdk-window-get-device-position, Function gdk: gdk-window-get-display, Function gdk: gdk-window-get-effective-parent, Function gdk: gdk-window-get-effective-toplevel, Function gdk: gdk-window-get-events, Function gdk: gdk-window-get-focus-on-map, Function gdk: gdk-window-get-frame-extents, Function gdk: gdk-window-get-geometry, Function gdk: gdk-window-get-group, Function gdk: gdk-window-get-height, Function gdk: gdk-window-get-modal-hint, Function gdk: gdk-window-get-origin, Function gdk: gdk-window-get-parent, Function gdk: gdk-window-get-pointer, Function gdk: gdk-window-get-position, Function gdk: gdk-window-get-root-coords, Function gdk: gdk-window-get-root-origin, Function gdk: gdk-window-get-screen, Function gdk: gdk-window-get-source-events, Function gdk: gdk-window-get-state, Function gdk: gdk-window-get-support-multidevice, Function gdk: gdk-window-get-toplevel, Function gdk: gdk-window-get-type-hint, Function gdk: gdk-window-get-update-area, Function gdk: gdk-window-get-user-data, Function gdk: gdk-window-get-visible-region, Function gdk: gdk-window-get-visual, Function gdk: gdk-window-get-width, Function gdk: gdk-window-get-window-type, Function gdk: gdk-window-has-native, Function gdk: gdk-window-hide, Function gdk: gdk-window-hints, Flags gdk: gdk-window-iconify, Function gdk: gdk-window-input-shape-combine-region, Function gdk: gdk-window-invalidate-maybe-recurse, Function gdk: gdk-window-invalidate-rect, Function gdk: gdk-window-invalidate-region, Function gdk: gdk-window-is-destroyed, Function gdk: gdk-window-is-input-only, Function gdk: gdk-window-is-shaped, Function gdk: gdk-window-is-viewable, Function gdk: gdk-window-is-visible, Function gdk: gdk-window-lower, Function gdk: gdk-window-maximize, Function gdk: gdk-window-merge-child-input-shapes, Function gdk: gdk-window-merge-child-shapes, Function gdk: gdk-window-move, Function gdk: gdk-window-move-region, Function gdk: gdk-window-move-resize, Function gdk: gdk-window-new, Function gdk: gdk-window-peek-children, Function gdk: gdk-window-process-all-updates, Function gdk: gdk-window-process-updates, Function gdk: gdk-window-raise, Function gdk: gdk-window-register-dnd, Function gdk: gdk-window-reparent, Function gdk: gdk-window-resize, Function gdk: gdk-window-restack, Function gdk: gdk-window-scroll, Function gdk: gdk-window-set-accept-focus, Function gdk: gdk-window-set-background, Function gdk: gdk-window-set-background-pattern, Function gdk: gdk-window-set-background-rgba, Function gdk: gdk-window-set-child-input-shapes, Function gdk: gdk-window-set-child-shapes, Function gdk: gdk-window-set-composited, Function gdk: gdk-window-set-debug-updates, Function gdk: gdk-window-set-decorations, Function gdk: gdk-window-set-device-cursor, Function gdk: gdk-window-set-device-events, Function gdk: gdk-window-set-events, Function gdk: gdk-window-set-focus-on-map, Function gdk: gdk-window-set-functions, Function gdk: gdk-window-set-geometry-hints, Function gdk: gdk-window-set-group, Function gdk: gdk-window-set-icon-list, Function gdk: gdk-window-set-icon-name, Function gdk: gdk-window-set-keep-above, Function gdk: gdk-window-set-keep-below, Function gdk: gdk-window-set-modal-hint, Function gdk: gdk-window-set-opacity, Function gdk: gdk-window-set-override-redirect, Function gdk: gdk-window-set-role, Function gdk: gdk-window-set-skip-pager-hint, Function gdk: gdk-window-set-skip-taskbar-hint, Function gdk: gdk-window-set-source-events, Function gdk: gdk-window-set-startup-id, Function gdk: gdk-window-set-static-gravities, Function gdk: gdk-window-set-support-multidevice, Function gdk: gdk-window-set-title, Function gdk: gdk-window-set-transient-for, Function gdk: gdk-window-set-type-hint, Function gdk: gdk-window-set-urgency-hint, Function gdk: gdk-window-set-user-data, Function gdk: gdk-window-shape-combine-region, Function gdk: gdk-window-show, Function gdk: gdk-window-show-unraised, Function gdk: gdk-window-state, Flags gdk: gdk-window-stick, Function gdk: gdk-window-thaw-updates, Function gdk: gdk-window-type, Enum gdk: gdk-window-type-hint, Enum gdk: gdk-window-unfullscreen, Function gdk: gdk-window-unmaximize, Function gdk: gdk-window-unstick, Function gdk: gdk-window-window-class, Enum gdk: gdk-window-withdraw, Function gdk: gdk-wm-decoration, Flags gdk: gdk-wm-function, Flags glib: glib-check-version, Function gobject: gobject-class, Class gtk: gtk-about-dialog, Class gtk: gtk-about-dialog-add-credit-section, Function gtk: gtk-about-dialog-artists, Accessor gtk: gtk-about-dialog-authors, Accessor gtk: gtk-about-dialog-comments, Accessor gtk: gtk-about-dialog-copyright, Accessor gtk: gtk-about-dialog-documenters, Accessor gtk: gtk-about-dialog-license, Accessor gtk: gtk-about-dialog-license-type, Accessor gtk: gtk-about-dialog-logo, Accessor gtk: gtk-about-dialog-logo-icon-name, Accessor gtk: gtk-about-dialog-new, Function gtk: gtk-about-dialog-program-name, Accessor gtk: gtk-about-dialog-translator-credits, Accessor gtk: gtk-about-dialog-version, Accessor gtk: gtk-about-dialog-website, Accessor gtk: gtk-about-dialog-website-label, Accessor gtk: gtk-about-dialog-wrap-license, Accessor gtk: gtk-accel-flags, Flags gtk: gtk-accel-group, Class gtk: gtk-accel-group-activate, Function gtk: gtk-accel-group-is-locked, Accessor gtk: gtk-accel-group-lock, Function gtk: gtk-accel-group-modifier-mask, Accessor gtk: gtk-accel-group-new, Function gtk: gtk-accel-group-unlock, Function gtk: gtk-accel-key, CStruct gtk: gtk-accel-label, Class gtk: gtk-accel-label-accel-closure, Accessor gtk: gtk-accel-label-accel-widget, Accessor gtk: gtk-accel-label-get-accel-width, Function gtk: gtk-accel-label-new, Function gtk: gtk-accel-label-refetch, Function gtk: gtk-accel-label-set-accel, Function gtk: gtk-accel-map, Class gtk: gtk-accel-map-add-entry, Function gtk: gtk-accel-map-change-entry, Function gtk: gtk-accel-map-get, Function gtk: gtk-accel-map-load, Function gtk: gtk-accel-map-lock-path, Function gtk: gtk-accel-map-lookup-entry, Function gtk: gtk-accel-map-save, Function gtk: gtk-accel-map-unlock-path, Function gtk: gtk-accelerator-get-default-mod-mask, Function gtk: gtk-accelerator-get-label, Function  (undocumented) gtk: gtk-accelerator-name, Function  (undocumented) gtk: gtk-accelerator-parse, Function gtk: gtk-accelerator-set-default-mod-mask, Function gtk: gtk-accelerator-valid, Function gtk: gtk-action, Class gtk: gtk-action-action-group, Accessor gtk: gtk-action-activate, Function gtk: gtk-action-always-show-image, Accessor gtk: gtk-action-block-activate, Function gtk: gtk-action-connect-accelerator, Function gtk: gtk-action-create-icon, Function gtk: gtk-action-create-menu, Function gtk: gtk-action-create-menu-item, Function gtk: gtk-action-create-tool-item, Function gtk: gtk-action-disconnect-accelerator, Function gtk: gtk-action-get-accel-closure, Function gtk: gtk-action-get-accel-path, Function gtk: gtk-action-get-always-show-image, Function gtk: gtk-action-get-gicon, Function gtk: gtk-action-get-icon-name, Function gtk: gtk-action-get-is-important, Function gtk: gtk-action-get-label, Function gtk: gtk-action-get-name, Function gtk: gtk-action-get-proxies, Function gtk: gtk-action-get-sensitive, Function gtk: gtk-action-get-short-label, Function gtk: gtk-action-get-stock-id, Function gtk: gtk-action-get-tooltip, Function gtk: gtk-action-get-visible, Function gtk: gtk-action-get-visible-horizontal, Function gtk: gtk-action-get-visible-vertical, Function gtk: gtk-action-gicon, Accessor gtk: gtk-action-group, Class gtk: gtk-action-group-accel-group, Accessor gtk: gtk-action-group-add-action, Function gtk: gtk-action-group-add-actions, Function gtk: gtk-action-group-add-radio-actions, Function  (undocumented) gtk: gtk-action-group-add-toggle-actions, Function gtk: gtk-action-group-get-accel-group, Function gtk: gtk-action-group-get-action, Function gtk: gtk-action-group-get-name, Function gtk: gtk-action-group-get-sensitive, Function gtk: gtk-action-group-get-visible, Function gtk: gtk-action-group-list-actions, Function gtk: gtk-action-group-name, Accessor gtk: gtk-action-group-new, Function gtk: gtk-action-group-remove-action, Function gtk: gtk-action-group-sensitive, Accessor gtk: gtk-action-group-set-accel-group, Function gtk: gtk-action-group-set-sensitive, Function gtk: gtk-action-group-set-translate-func, Function gtk: gtk-action-group-set-translation-domain, Function gtk: gtk-action-group-set-visible, Function gtk: gtk-action-group-translate-string, Function gtk: gtk-action-group-visible, Accessor gtk: gtk-action-hide-if-empty, Accessor gtk: gtk-action-icon-name, Accessor gtk: gtk-action-is-important, Accessor gtk: gtk-action-is-sensitive, Function gtk: gtk-action-is-visible, Function gtk: gtk-action-label, Accessor gtk: gtk-action-name, Accessor gtk: gtk-action-new, Function gtk: gtk-action-sensitive, Accessor gtk: gtk-action-set-accel-group, Function gtk: gtk-action-set-accel-path, Function gtk: gtk-action-set-always-show-image, Function gtk: gtk-action-set-gicon, Function gtk: gtk-action-set-icon-name, Function gtk: gtk-action-set-is-important, Function gtk: gtk-action-set-label, Function gtk: gtk-action-set-sensitive, Function gtk: gtk-action-set-short-label, Function gtk: gtk-action-set-stock-id, Function gtk: gtk-action-set-tooltip, Function gtk: gtk-action-set-visible, Function gtk: gtk-action-set-visible-horizontal, Function gtk: gtk-action-set-visible-vertical, Function gtk: gtk-action-short-label, Accessor gtk: gtk-action-stock-id, Accessor gtk: gtk-action-tooltip, Accessor gtk: gtk-action-unblock-activate, Function gtk: gtk-action-visible, Accessor gtk: gtk-action-visible-horizontal, Accessor gtk: gtk-action-visible-overflown, Accessor gtk: gtk-action-visible-vertical, Accessor gtk: gtk-actionable, Interface gtk: gtk-actionable-action-name, Accessor gtk: gtk-actionable-action-target, Accessor gtk: gtk-actionable-set-detailed-action-name, Function gtk: gtk-activatable, Interface gtk: gtk-activatable-do-set-related-action, Function gtk: gtk-activatable-get-related-action, Function gtk: gtk-activatable-get-use-action-appearance, Function gtk: gtk-activatable-related-action, Accessor gtk: gtk-activatable-set-related-action, Function gtk: gtk-activatable-set-use-action-appearance, Function gtk: gtk-activatable-sync-action-properties, Function gtk: gtk-activatable-use-action-appearance, Accessor gtk: gtk-adjustment, Class gtk: gtk-adjustment-changed, Function gtk: gtk-adjustment-clamp-page, Function gtk: gtk-adjustment-configure, Function gtk: gtk-adjustment-get-lower, Function gtk: gtk-adjustment-get-minimum-increment, Function gtk: gtk-adjustment-get-page-increment, Function gtk: gtk-adjustment-get-page-size, Function gtk: gtk-adjustment-get-step-increment, Function gtk: gtk-adjustment-get-upper, Function gtk: gtk-adjustment-get-value, Function gtk: gtk-adjustment-lower, Accessor gtk: gtk-adjustment-new, Function gtk: gtk-adjustment-page-increment, Accessor gtk: gtk-adjustment-page-size, Accessor gtk: gtk-adjustment-set-lower, Function gtk: gtk-adjustment-set-page-increment, Function gtk: gtk-adjustment-set-page-size, Function gtk: gtk-adjustment-set-step-increment, Function gtk: gtk-adjustment-set-upper, Function gtk: gtk-adjustment-set-value, Function gtk: gtk-adjustment-step-increment, Accessor gtk: gtk-adjustment-upper, Accessor gtk: gtk-adjustment-value, Accessor gtk: gtk-adjustment-value-changed, Function gtk: gtk-align, Enum gtk: gtk-alignment, Class gtk: gtk-alignment-bottom-padding, Accessor gtk: gtk-alignment-get-padding, Function gtk: gtk-alignment-left-padding, Accessor gtk: gtk-alignment-new, Function gtk: gtk-alignment-right-padding, Accessor gtk: gtk-alignment-set, Function gtk: gtk-alignment-set-padding, Function gtk: gtk-alignment-top-padding, Accessor gtk: gtk-alignment-xalign, Accessor gtk: gtk-alignment-xscale, Accessor gtk: gtk-alignment-yalign, Accessor gtk: gtk-alignment-yscale, Accessor gtk: gtk-alternative-dialog-button-order, Function gtk: gtk-app-chooser, Interface gtk: gtk-app-chooser-button, Class gtk: gtk-app-chooser-button-append-custom-item, Function gtk: gtk-app-chooser-button-append-separator, Function gtk: gtk-app-chooser-button-get-heading, Function gtk: gtk-app-chooser-button-get-show-default-item, Function gtk: gtk-app-chooser-button-get-show-dialog-item, Function gtk: gtk-app-chooser-button-heading, Accessor gtk: gtk-app-chooser-button-new, Function gtk: gtk-app-chooser-button-set-active-custom-item, Function gtk: gtk-app-chooser-button-set-heading, Function gtk: gtk-app-chooser-button-set-show-default-item, Function gtk: gtk-app-chooser-button-set-show-dialog-item, Function gtk: gtk-app-chooser-button-show-default-item, Accessor gtk: gtk-app-chooser-button-show-dialog-item, Accessor gtk: gtk-app-chooser-content-type, Accessor gtk: gtk-app-chooser-dialog, Class gtk: gtk-app-chooser-dialog-get-heading, Function gtk: gtk-app-chooser-dialog-get-widget, Function gtk: gtk-app-chooser-dialog-gfile, Accessor gtk: gtk-app-chooser-dialog-heading, Accessor gtk: gtk-app-chooser-dialog-new, Function gtk: gtk-app-chooser-dialog-new-for-content-type, Function gtk: gtk-app-chooser-dialog-set-heading, Function gtk: gtk-app-chooser-get-app-info, Function gtk: gtk-app-chooser-get-content-type, Function gtk: gtk-app-chooser-refresh, Function gtk: gtk-app-chooser-widget, Class gtk: gtk-app-chooser-widget-default-text, Accessor gtk: gtk-app-chooser-widget-get-default-text, Function gtk: gtk-app-chooser-widget-get-show-all, Function gtk: gtk-app-chooser-widget-get-show-default, Function gtk: gtk-app-chooser-widget-get-show-fallback, Function gtk: gtk-app-chooser-widget-get-show-other, Function gtk: gtk-app-chooser-widget-get-show-recommended, Function gtk: gtk-app-chooser-widget-new, Function gtk: gtk-app-chooser-widget-set-default-text, Function gtk: gtk-app-chooser-widget-set-show-all, Function gtk: gtk-app-chooser-widget-set-show-default, Function gtk: gtk-app-chooser-widget-set-show-fallback, Function gtk: gtk-app-chooser-widget-set-show-other, Function gtk: gtk-app-chooser-widget-set-show-recommended, Function gtk: gtk-app-chooser-widget-show-all, Accessor gtk: gtk-app-chooser-widget-show-default, Accessor gtk: gtk-app-chooser-widget-show-fallback, Accessor gtk: gtk-app-chooser-widget-show-other, Accessor gtk: gtk-app-chooser-widget-show-recommended, Accessor gtk: gtk-application, Class gtk: gtk-application-active-window, Accessor gtk: gtk-application-add-accelerator, Function gtk: gtk-application-add-window, Function gtk: gtk-application-app-menu, Accessor gtk: gtk-application-get-window-by-id, Function gtk: gtk-application-get-windows, Function gtk: gtk-application-inhibit, Function gtk: gtk-application-inhibit-flags, Flags gtk: gtk-application-is-inhibited, Symbol gtk: gtk-application-menubar, Accessor gtk: gtk-application-new, Function gtk: gtk-application-register-session, Accessor gtk: gtk-application-remove-accelerator, Function gtk: gtk-application-remove-window, Function gtk: gtk-application-uninhibit, Function gtk: gtk-application-window, Class gtk: gtk-application-window-get-id, Function gtk: gtk-application-window-new, Function gtk: gtk-application-window-show-menubar, Accessor gtk: gtk-arrow, Class gtk: gtk-arrow-arrow-type, Accessor gtk: gtk-arrow-new, Function gtk: gtk-arrow-placement, Enum gtk: gtk-arrow-set, Function gtk: gtk-arrow-shadow-type, Accessor gtk: gtk-arrow-type, Enum gtk: gtk-aspect-frame, Class gtk: gtk-aspect-frame-new, Function gtk: gtk-aspect-frame-obey-child, Accessor gtk: gtk-aspect-frame-ratio, Accessor gtk: gtk-aspect-frame-set, Function gtk: gtk-aspect-frame-xalign, Accessor gtk: gtk-aspect-frame-yalign, Accessor gtk: gtk-assistant, Class gtk: gtk-assistant-add-action-widget, Function gtk: gtk-assistant-append-page, Function gtk: gtk-assistant-child-complete, Accessor gtk: gtk-assistant-child-header-image, Accessor gtk: gtk-assistant-child-page-type, Accessor gtk: gtk-assistant-child-sidebar-image, Accessor gtk: gtk-assistant-child-title, Accessor gtk: gtk-assistant-commit, Function gtk: gtk-assistant-get-current-page, Function gtk: gtk-assistant-get-n-pages, Function gtk: gtk-assistant-get-nth-page, Function gtk: gtk-assistant-get-page-complete, Function gtk: gtk-assistant-get-page-title, Function gtk: gtk-assistant-get-page-type, Function gtk: gtk-assistant-insert-page, Function gtk: gtk-assistant-new, Function gtk: gtk-assistant-next-page, Function gtk: gtk-assistant-page-type, Enum gtk: gtk-assistant-prepend-page, Function gtk: gtk-assistant-previous-page, Function gtk: gtk-assistant-remove-action-widget, Function gtk: gtk-assistant-remove-page, Function gtk: gtk-assistant-set-current-page, Function gtk: gtk-assistant-set-forward-page-func, Function gtk: gtk-assistant-set-page-complete, Function gtk: gtk-assistant-set-page-title, Function gtk: gtk-assistant-set-page-type, Function gtk: gtk-assistant-update-buttons-state, Function gtk: gtk-attach-options, Enum gtk: gtk-baseline-position, Enum gtk: gtk-bin, Class gtk: gtk-bin-get-child, Function gtk: gtk-border, CStruct gtk: gtk-border-bottom, Accessor gtk: gtk-border-copy, Function gtk: gtk-border-left, Accessor gtk: gtk-border-new, Function gtk: gtk-border-right, Accessor gtk: gtk-border-style, Enum gtk: gtk-border-top, Accessor gtk: gtk-box, Class gtk: gtk-box-baseline-position, Accessor gtk: gtk-box-child-expand, Accessor gtk: gtk-box-child-fill, Accessor gtk: gtk-box-child-pack-type, Accessor gtk: gtk-box-child-padding, Accessor gtk: gtk-box-child-position, Accessor gtk: gtk-box-get-center-widget, Function gtk: gtk-box-homogeneous, Accessor gtk: gtk-box-new, Function gtk: gtk-box-pack-end, Function gtk: gtk-box-pack-start, Function gtk: gtk-box-query-child-packing, Function gtk: gtk-box-reorder-child, Function gtk: gtk-box-set-center-widget, Function gtk: gtk-box-set-child-packing, Function gtk: gtk-box-spacing, Accessor gtk: gtk-buildable, Interface gtk: gtk-buildable-get-name, Function gtk: gtk-buildable-set-name, Function gtk: gtk-builder, Class gtk: gtk-builder-add-from-file, Function gtk: gtk-builder-add-from-string, Function gtk: gtk-builder-add-objects-from-file, Function gtk: gtk-builder-add-objects-from-string, Function gtk: gtk-builder-connect-signals, Function gtk: gtk-builder-connect-signals-full, Function gtk: gtk-builder-error, Enum gtk: gtk-builder-get-object, Function gtk: gtk-builder-get-objects, Function gtk: gtk-builder-new, Function gtk: gtk-builder-translation-domain, Accessor gtk: gtk-button, Class gtk: gtk-button-always-show-image, Accessor gtk: gtk-button-box, Class gtk: gtk-button-box-child-non-homogeneous, Accessor gtk: gtk-button-box-child-secondary, Accessor gtk: gtk-button-box-get-child-non-homogeneous, Function gtk: gtk-button-box-get-child-secondary, Function gtk: gtk-button-box-layout-style, Accessor gtk: gtk-button-box-new, Function gtk: gtk-button-box-set-child-non-homogeneous, Function gtk: gtk-button-box-set-child-secondary, Function gtk: gtk-button-box-style, Enum gtk: gtk-button-clicked, Function gtk: gtk-button-focus-on-click, Accessor gtk: gtk-button-get-alignment, Function gtk: gtk-button-get-event-window, Function gtk: gtk-button-image, Accessor gtk: gtk-button-image-position, Accessor gtk: gtk-button-label, Accessor gtk: gtk-button-new, Function gtk: gtk-button-new-from-stock, Function gtk: gtk-button-new-with-label, Function gtk: gtk-button-new-with-mnemonic, Function gtk: gtk-button-relief, Accessor gtk: gtk-button-set-alignment, Function gtk: gtk-button-use-stock, Accessor gtk: gtk-button-use-underline, Accessor gtk: gtk-button-xalign, Accessor gtk: gtk-button-yalign, Accessor gtk: gtk-buttons-type, Enum gtk: gtk-cairo-should-draw-window, Function gtk: gtk-cairo-transform-to-window, Function gtk: gtk-calendar, Class gtk: gtk-calendar-clear-marks, Function gtk: gtk-calendar-day, Accessor gtk: gtk-calendar-detail-height-rows, Accessor gtk: gtk-calendar-detail-width-chars, Accessor gtk: gtk-calendar-display-options, Enum gtk: gtk-calendar-get-date, Function gtk: gtk-calendar-get-day-is-marked, Function gtk: gtk-calendar-get-detail-height-rows, Function gtk: gtk-calendar-get-detail-width-chars, Function gtk: gtk-calendar-get-display-options, Function gtk: gtk-calendar-mark-day, Function gtk: gtk-calendar-month, Accessor gtk: gtk-calendar-new, Function gtk: gtk-calendar-no-month-change, Accessor gtk: gtk-calendar-select-day, Function gtk: gtk-calendar-select-month, Function gtk: gtk-calendar-set-detail-func, Function gtk: gtk-calendar-set-detail-height-rows, Function gtk: gtk-calendar-set-detail-width-chars, Function gtk: gtk-calendar-set-display-options, Function gtk: gtk-calendar-show-day-names, Accessor gtk: gtk-calendar-show-details, Accessor gtk: gtk-calendar-show-heading, Accessor gtk: gtk-calendar-show-week-numbers, Accessor gtk: gtk-calendar-unmark-day, Function gtk: gtk-calendar-year, Accessor gtk: gtk-cell-area, Class gtk: gtk-cell-area-activate, Function gtk: gtk-cell-area-add, Function gtk: gtk-cell-area-box, Class gtk: gtk-cell-area-box-child-align, Accessor gtk: gtk-cell-area-box-child-expand, Accessor gtk: gtk-cell-area-box-child-fixed-size, Accessor gtk: gtk-cell-area-box-child-pack-type, Accessor gtk: gtk-cell-area-box-get-spacing, Function gtk: gtk-cell-area-box-new, Function gtk: gtk-cell-area-box-pack-end, Function gtk: gtk-cell-area-box-pack-start, Function gtk: gtk-cell-area-box-set-spacing, Function gtk: gtk-cell-area-box-spacing, Accessor gtk: gtk-cell-area-context, Class gtk: gtk-cell-area-context-allocate, Function gtk: gtk-cell-area-context-area, Accessor gtk: gtk-cell-area-context-get-allocation, Function gtk: gtk-cell-area-context-get-area, Function gtk: gtk-cell-area-context-get-preferred-height, Function gtk: gtk-cell-area-context-get-preferred-height-for-width, Function gtk: gtk-cell-area-context-get-preferred-width, Function gtk: gtk-cell-area-context-get-preferred-width-for-height, Function gtk: gtk-cell-area-context-minimum-height, Accessor gtk: gtk-cell-area-context-minimum-width, Accessor gtk: gtk-cell-area-context-natural-height, Accessor gtk: gtk-cell-area-context-natural-width, Accessor gtk: gtk-cell-area-context-push-preferred-height, Function gtk: gtk-cell-area-context-push-preferred-width, Function gtk: gtk-cell-area-context-reset, Function gtk: gtk-cell-area-edit-widget, Accessor gtk: gtk-cell-area-edited-cell, Accessor gtk: gtk-cell-area-event, Function gtk: gtk-cell-area-focus-cell, Accessor gtk: gtk-cell-area-get-edit-widget, Function gtk: gtk-cell-area-get-edited-cell, Function gtk: gtk-cell-area-get-focus-cell, Function gtk: gtk-cell-area-get-preferred-height, Function gtk: gtk-cell-area-get-preferred-width, Function gtk: gtk-cell-area-has-renderer, Function gtk: gtk-cell-area-remove, Function gtk: gtk-cell-area-set-focus-cell, Function gtk: gtk-cell-editable, Interface gtk: gtk-cell-editable-editing-canceled, Accessor gtk: gtk-cell-editable-editing-done, Function gtk: gtk-cell-editable-remove-widget, Function gtk: gtk-cell-editable-start-editing, Function gtk: gtk-cell-layout, Class gtk: gtk-cell-layout-add-attribute, Function gtk: gtk-cell-layout-clear, Function gtk: gtk-cell-layout-clear-attributes, Function gtk: gtk-cell-layout-get-cells, Function gtk: gtk-cell-layout-pack-end, Function gtk: gtk-cell-layout-pack-start, Function gtk: gtk-cell-layout-reorder, Function gtk: gtk-cell-layout-set-cell-data-func, Function gtk: gtk-cell-renderer, Class gtk: gtk-cell-renderer-accel, Class gtk: gtk-cell-renderer-accel-accel-key, Accessor gtk: gtk-cell-renderer-accel-accel-mode, Accessor gtk: gtk-cell-renderer-accel-accel-mods, Accessor gtk: gtk-cell-renderer-accel-keycode, Accessor gtk: gtk-cell-renderer-accel-mode, Enum gtk: gtk-cell-renderer-accel-new, Function gtk: gtk-cell-renderer-activate-cell, Symbol gtk: gtk-cell-renderer-cell-background, Accessor gtk: gtk-cell-renderer-cell-background-gdk, Accessor gtk: gtk-cell-renderer-cell-background-rgba, Accessor gtk: gtk-cell-renderer-cell-background-set, Accessor gtk: gtk-cell-renderer-combo, Class gtk: gtk-cell-renderer-combo-has-entry, Accessor gtk: gtk-cell-renderer-combo-model, Accessor gtk: gtk-cell-renderer-combo-new, Function gtk: gtk-cell-renderer-combo-text-column, Accessor gtk: gtk-cell-renderer-editing, Accessor gtk: gtk-cell-renderer-get-fixed-size, Function gtk: gtk-cell-renderer-get-sensitive, Function gtk: gtk-cell-renderer-get-size, Function gtk: gtk-cell-renderer-get-visible, Function gtk: gtk-cell-renderer-height, Accessor gtk: gtk-cell-renderer-is-expanded, Accessor gtk: gtk-cell-renderer-is-expander, Accessor gtk: gtk-cell-renderer-mode, Accessor gtk: gtk-cell-renderer-mode, Enum gtk: gtk-cell-renderer-pixbuf, Class gtk: gtk-cell-renderer-pixbuf-follow-state, Accessor gtk: gtk-cell-renderer-pixbuf-gicon, Accessor gtk: gtk-cell-renderer-pixbuf-icon-name, Accessor gtk: gtk-cell-renderer-pixbuf-new, Function gtk: gtk-cell-renderer-pixbuf-pixbuf, Accessor gtk: gtk-cell-renderer-pixbuf-pixbuf-expander-closed, Accessor gtk: gtk-cell-renderer-pixbuf-pixbuf-expander-open, Accessor gtk: gtk-cell-renderer-pixbuf-stock-detail, Accessor gtk: gtk-cell-renderer-pixbuf-stock-id, Accessor gtk: gtk-cell-renderer-pixbuf-stock-size, Accessor gtk: gtk-cell-renderer-progress, Class gtk: gtk-cell-renderer-progress-inverted, Accessor gtk: gtk-cell-renderer-progress-new, Function gtk: gtk-cell-renderer-progress-pulse, Accessor gtk: gtk-cell-renderer-progress-text, Accessor gtk: gtk-cell-renderer-progress-text-xalign, Accessor gtk: gtk-cell-renderer-progress-text-yalign, Accessor gtk: gtk-cell-renderer-progress-value, Accessor gtk: gtk-cell-renderer-render, Function gtk: gtk-cell-renderer-sensitive, Accessor gtk: gtk-cell-renderer-set-fixed-size, Function gtk: gtk-cell-renderer-set-sensitive, Function gtk: gtk-cell-renderer-set-visible, Function gtk: gtk-cell-renderer-spin, Class gtk: gtk-cell-renderer-spin-adjustment, Accessor gtk: gtk-cell-renderer-spin-climb-rate, Accessor gtk: gtk-cell-renderer-spin-digits, Accessor gtk: gtk-cell-renderer-spin-new, Function gtk: gtk-cell-renderer-spinner, Class gtk: gtk-cell-renderer-spinner-active, Accessor gtk: gtk-cell-renderer-spinner-new, Function gtk: gtk-cell-renderer-spinner-pulse, Accessor gtk: gtk-cell-renderer-spinner-size, Accessor gtk: gtk-cell-renderer-state, Flags gtk: gtk-cell-renderer-stop-editing, Function gtk: gtk-cell-renderer-text, Class gtk: gtk-cell-renderer-text-align-set, Accessor gtk: gtk-cell-renderer-text-alignment, Accessor gtk: gtk-cell-renderer-text-attributes, Accessor gtk: gtk-cell-renderer-text-background, Accessor gtk: gtk-cell-renderer-text-background-gdk, Accessor gtk: gtk-cell-renderer-text-background-rgba, Accessor gtk: gtk-cell-renderer-text-background-set, Accessor gtk: gtk-cell-renderer-text-editable, Accessor gtk: gtk-cell-renderer-text-editable-set, Accessor gtk: gtk-cell-renderer-text-ellipsize, Accessor gtk: gtk-cell-renderer-text-ellipsize-set, Accessor gtk: gtk-cell-renderer-text-family, Accessor gtk: gtk-cell-renderer-text-family-set, Accessor gtk: gtk-cell-renderer-text-font, Accessor gtk: gtk-cell-renderer-text-font-desc, Accessor gtk: gtk-cell-renderer-text-foreground, Accessor gtk: gtk-cell-renderer-text-foreground-gdk, Accessor gtk: gtk-cell-renderer-text-foreground-rgba, Accessor gtk: gtk-cell-renderer-text-foreground-set, Accessor gtk: gtk-cell-renderer-text-language, Accessor gtk: gtk-cell-renderer-text-language-set, Accessor gtk: gtk-cell-renderer-text-markup, Accessor gtk: gtk-cell-renderer-text-max-width-chars, Accessor gtk: gtk-cell-renderer-text-new, Function gtk: gtk-cell-renderer-text-placeholder-text, Accessor gtk: gtk-cell-renderer-text-rise, Accessor gtk: gtk-cell-renderer-text-rise-set, Accessor gtk: gtk-cell-renderer-text-scale, Accessor gtk: gtk-cell-renderer-text-scale-set, Accessor gtk: gtk-cell-renderer-text-set-fixed-height-from-font, Function gtk: gtk-cell-renderer-text-single-paragraph-mode, Accessor gtk: gtk-cell-renderer-text-size, Accessor gtk: gtk-cell-renderer-text-size-points, Accessor gtk: gtk-cell-renderer-text-size-set, Accessor gtk: gtk-cell-renderer-text-stretch, Accessor gtk: gtk-cell-renderer-text-stretch-set, Accessor gtk: gtk-cell-renderer-text-strikethrough, Accessor gtk: gtk-cell-renderer-text-strikethrough-set, Accessor gtk: gtk-cell-renderer-text-style, Accessor gtk: gtk-cell-renderer-text-style-set, Accessor gtk: gtk-cell-renderer-text-text, Accessor gtk: gtk-cell-renderer-text-underline, Accessor gtk: gtk-cell-renderer-text-underline-set, Accessor gtk: gtk-cell-renderer-text-variant, Accessor gtk: gtk-cell-renderer-text-variant-set, Accessor gtk: gtk-cell-renderer-text-weight, Accessor gtk: gtk-cell-renderer-text-weight-set, Accessor gtk: gtk-cell-renderer-text-width-chars, Accessor gtk: gtk-cell-renderer-text-wrap-mode, Accessor gtk: gtk-cell-renderer-text-wrap-width, Accessor gtk: gtk-cell-renderer-toggle, Class gtk: gtk-cell-renderer-toggle-activatable, Accessor gtk: gtk-cell-renderer-toggle-active, Accessor gtk: gtk-cell-renderer-toggle-get-activatable, Function gtk: gtk-cell-renderer-toggle-get-active, Function gtk: gtk-cell-renderer-toggle-get-radio, Function gtk: gtk-cell-renderer-toggle-inconsistent, Accessor gtk: gtk-cell-renderer-toggle-indicator-size, Accessor gtk: gtk-cell-renderer-toggle-new, Function gtk: gtk-cell-renderer-toggle-radio, Accessor gtk: gtk-cell-renderer-toggle-set-activatable, Function gtk: gtk-cell-renderer-toggle-set-active, Function gtk: gtk-cell-renderer-toggle-set-radio, Function gtk: gtk-cell-renderer-visible, Accessor gtk: gtk-cell-renderer-width, Accessor gtk: gtk-cell-renderer-xalign, Accessor gtk: gtk-cell-renderer-xpad, Accessor gtk: gtk-cell-renderer-yalign, Accessor gtk: gtk-cell-renderer-ypad, Accessor gtk: gtk-cell-view, Class gtk: gtk-cell-view-background, Accessor gtk: gtk-cell-view-background-gdk, Accessor gtk: gtk-cell-view-background-rgba, Accessor gtk: gtk-cell-view-background-set, Accessor gtk: gtk-cell-view-cell-area, Accessor gtk: gtk-cell-view-cell-area-context, Accessor gtk: gtk-cell-view-draw-sensitive, Accessor gtk: gtk-cell-view-fit-model, Generic Function gtk: gtk-cell-view-get-size-of-row, Function gtk: gtk-cell-view-model, Accessor gtk: gtk-check-button, Class gtk: gtk-check-button-new, Function gtk: gtk-check-button-new-with-label, Function gtk: gtk-check-button-new-with-mnemonic, Function gtk: gtk-check-menu-item, Class gtk: gtk-check-menu-item-active, Accessor gtk: gtk-check-menu-item-draw-as-radio, Accessor gtk: gtk-check-menu-item-get-active, Function gtk: gtk-check-menu-item-get-draw-as-radio, Function gtk: gtk-check-menu-item-get-inconsistent, Function gtk: gtk-check-menu-item-inconsistent, Accessor gtk: gtk-check-menu-item-new, Function gtk: gtk-check-menu-item-new-with-label, Function gtk: gtk-check-menu-item-new-with-mnemonic, Function gtk: gtk-check-menu-item-set-active, Function gtk: gtk-check-menu-item-set-draw-as-radio, Function gtk: gtk-check-menu-item-set-inconsistent, Function gtk: gtk-check-menu-item-toggled, Function gtk: gtk-check-version, Function gtk: gtk-clipboard, Class gtk: gtk-clipboard-clear, Function gtk: gtk-clipboard-get, Function gtk: gtk-clipboard-get-for-display, Function gtk: gtk-clipboard-request-text, Function gtk: gtk-clipboard-set-text, Function gtk: gtk-color-button, Class gtk: gtk-color-button-alpha, Accessor gtk: gtk-color-button-color, Accessor gtk: gtk-color-button-get-alpha, Function gtk: gtk-color-button-get-color, Function gtk: gtk-color-button-get-rgba, Function gtk: gtk-color-button-get-title, Function gtk: gtk-color-button-get-use-alpha, Function gtk: gtk-color-button-new, Function gtk: gtk-color-button-new-with-color, Function gtk: gtk-color-button-new-with-rgba, Function gtk: gtk-color-button-rgba, Accessor gtk: gtk-color-button-set-alpha, Function gtk: gtk-color-button-set-color, Function gtk: gtk-color-button-set-rgba, Function gtk: gtk-color-button-set-title, Function gtk: gtk-color-button-set-use-alpha, Function gtk: gtk-color-button-title, Accessor gtk: gtk-color-button-use-alpha, Accessor gtk: gtk-color-chooser, Interface gtk: gtk-color-chooser-add-palette, Function gtk: gtk-color-chooser-dialog, Class gtk: gtk-color-chooser-dialog-new, Function gtk: gtk-color-chooser-dialog-show-editor, Accessor gtk: gtk-color-chooser-get-rgba, Function gtk: gtk-color-chooser-get-use-alpha, Function gtk: gtk-color-chooser-rgba, Accessor gtk: gtk-color-chooser-set-rgba, Function gtk: gtk-color-chooser-set-use-alpha, Function gtk: gtk-color-chooser-use-alpha, Accessor gtk: gtk-color-chooser-widget, Class gtk: gtk-color-chooser-widget-new, Function gtk: gtk-color-chooser-widget-show-editor, Accessor gtk: gtk-color-selection, Class gtk: gtk-color-selection-child-expand, Accessor gtk: gtk-color-selection-child-fill, Accessor gtk: gtk-color-selection-child-pack-type, Accessor gtk: gtk-color-selection-child-padding, Accessor gtk: gtk-color-selection-child-position, Accessor gtk: gtk-color-selection-current-alpha, Accessor gtk: gtk-color-selection-current-color, Accessor gtk: gtk-color-selection-current-rgba, Accessor gtk: gtk-color-selection-dialog, Class gtk: gtk-color-selection-dialog-cancel-button, Accessor gtk: gtk-color-selection-dialog-color-selection, Accessor gtk: gtk-color-selection-dialog-get-color-selection, Function gtk: gtk-color-selection-dialog-help-button, Accessor gtk: gtk-color-selection-dialog-new, Function gtk: gtk-color-selection-dialog-ok-button, Accessor gtk: gtk-color-selection-get-current-alpha, Function gtk: gtk-color-selection-get-current-color, Function gtk: gtk-color-selection-get-has-opacity-control, Function gtk: gtk-color-selection-get-has-palette, Function gtk: gtk-color-selection-get-previous-alpha, Function gtk: gtk-color-selection-get-previous-color, Function gtk: gtk-color-selection-has-opacity-control, Accessor gtk: gtk-color-selection-has-palette, Accessor gtk: gtk-color-selection-is-adjusting, Function gtk: gtk-color-selection-new, Function gtk: gtk-color-selection-palette-from-string, Function gtk: gtk-color-selection-palette-to-string, Function gtk: gtk-color-selection-set-current-alpha, Function gtk: gtk-color-selection-set-current-color, Function gtk: gtk-color-selection-set-has-opacity-control, Function gtk: gtk-color-selection-set-has-palette, Function gtk: gtk-color-selection-set-previous-alpha, Function gtk: gtk-color-selection-set-previous-color, Function gtk: gtk-combo-box, Class gtk: gtk-combo-box-active, Accessor gtk: gtk-combo-box-active-id, Accessor gtk: gtk-combo-box-add-tearoffs, Accessor gtk: gtk-combo-box-button-sensitivity, Accessor gtk: gtk-combo-box-cell-area, Accessor gtk: gtk-combo-box-column-span-column, Accessor gtk: gtk-combo-box-entry-text-column, Accessor gtk: gtk-combo-box-focus-on-click, Accessor gtk: gtk-combo-box-get-active, Function gtk: gtk-combo-box-get-active-id, Function gtk: gtk-combo-box-get-active-iter, Function gtk: gtk-combo-box-get-add-tearoffs, Function gtk: gtk-combo-box-get-button-sensitivity, Function gtk: gtk-combo-box-get-column-span-column, Function gtk: gtk-combo-box-get-entry-text-column, Function gtk: gtk-combo-box-get-focus-on-click, Function gtk: gtk-combo-box-get-has-entry, Function gtk: gtk-combo-box-get-id-column, Function gtk: gtk-combo-box-get-model, Function gtk: gtk-combo-box-get-popup-accessible, Function gtk: gtk-combo-box-get-popup-fixed-width, Function gtk: gtk-combo-box-get-row-separator-func, Function gtk: gtk-combo-box-get-row-span-column, Function gtk: gtk-combo-box-get-title, Function gtk: gtk-combo-box-get-wrap-width, Function gtk: gtk-combo-box-has-entry, Accessor gtk: gtk-combo-box-has-frame, Accessor gtk: gtk-combo-box-id-column, Accessor gtk: gtk-combo-box-model, Accessor gtk: gtk-combo-box-new, Function gtk: gtk-combo-box-new-with-area, Function gtk: gtk-combo-box-new-with-area-and-entry, Function gtk: gtk-combo-box-new-with-entry, Function gtk: gtk-combo-box-new-with-model, Function gtk: gtk-combo-box-new-with-model-and-entry, Function gtk: gtk-combo-box-popdown, Function gtk: gtk-combo-box-popup, Function gtk: gtk-combo-box-popup-fixed-width, Accessor gtk: gtk-combo-box-popup-for-device, Function gtk: gtk-combo-box-popup-shown, Accessor gtk: gtk-combo-box-row-span-column, Accessor gtk: gtk-combo-box-set-active, Function gtk: gtk-combo-box-set-active-id, Function gtk: gtk-combo-box-set-active-iter, Function gtk: gtk-combo-box-set-add-tearoffs, Function gtk: gtk-combo-box-set-button-sensitivity, Function gtk: gtk-combo-box-set-column-span-column, Function gtk: gtk-combo-box-set-entry-text-column, Function gtk: gtk-combo-box-set-focus-on-click, Function gtk: gtk-combo-box-set-id-column, Function gtk: gtk-combo-box-set-model, Function gtk: gtk-combo-box-set-popup-fixed-width, Function gtk: gtk-combo-box-set-row-separator-func, Function gtk: gtk-combo-box-set-row-span-column, Function gtk: gtk-combo-box-set-title, Function gtk: gtk-combo-box-set-wrap-width, Function gtk: gtk-combo-box-tearoff-title, Accessor gtk: gtk-combo-box-text, Class gtk: gtk-combo-box-text-append, Function gtk: gtk-combo-box-text-append-text, Function gtk: gtk-combo-box-text-get-active-text, Function gtk: gtk-combo-box-text-insert, Function gtk: gtk-combo-box-text-insert-text, Function gtk: gtk-combo-box-text-new, Function gtk: gtk-combo-box-text-new-with-entry, Function gtk: gtk-combo-box-text-prepend, Function gtk: gtk-combo-box-text-prepend-text, Function gtk: gtk-combo-box-text-remove, Function gtk: gtk-combo-box-text-remove-all, Function gtk: gtk-combo-box-wrap-width, Accessor gtk: gtk-container, Class gtk: gtk-container-add, Function gtk: gtk-container-border-width, Accessor gtk: gtk-container-check-resize, Function gtk: gtk-container-child, Accessor gtk: gtk-container-child-get, Function gtk: gtk-container-child-get-property, Function gtk: gtk-container-child-notify, Function gtk: gtk-container-child-set, Function gtk: gtk-container-child-set-property, Function gtk: gtk-container-child-type, Function gtk: gtk-container-class-find-child-property, Function gtk: gtk-container-class-list-child-properties, Function gtk: gtk-container-forall, Function gtk: gtk-container-foreach, Function gtk: gtk-container-get-children, Function gtk: gtk-container-get-focus-child, Function gtk: gtk-container-get-focus-hadjustment, Function gtk: gtk-container-get-focus-vadjustment, Function gtk: gtk-container-get-path-for-child, Function gtk: gtk-container-remove, Function gtk: gtk-container-resize-children, Function gtk: gtk-container-resize-mode, Accessor gtk: gtk-container-set-focus-chain, Function gtk: gtk-container-set-focus-child, Function gtk: gtk-container-set-focus-hadjustment, Function gtk: gtk-container-set-focus-vadjustment, Function gtk: gtk-container-set-reallocate-redraws, Function gtk: gtk-container-unset-focus-chain, Function gtk: gtk-corner-type, Enum gtk: gtk-css-provider, Class gtk: gtk-css-provider-get-default, Function gtk: gtk-css-provider-load-from-path, Function gtk: gtk-css-provider-new, Function gtk: gtk-css-provider-to-string, Function gtk: gtk-delete-type, Enum gtk: gtk-dest-defaults, Flags gtk: gtk-device-grab-add, Function gtk: gtk-device-grab-remove, Function gtk: gtk-dialog, Class gtk: gtk-dialog-add-action-widget, Function gtk: gtk-dialog-add-button, Function gtk: gtk-dialog-add-buttons, Function gtk: gtk-dialog-flags, Flags gtk: gtk-dialog-get-action-area, Function gtk: gtk-dialog-get-content-area, Function gtk: gtk-dialog-get-response-for-widget, Function gtk: gtk-dialog-get-widget-for-response, Function gtk: gtk-dialog-new, Function gtk: gtk-dialog-new-with-buttons, Function gtk: gtk-dialog-response, Function gtk: gtk-dialog-run, Function gtk: gtk-dialog-set-alternative-button-order, Function gtk: gtk-dialog-set-default-response, Function gtk: gtk-dialog-set-response-sensitive, Function gtk: gtk-dialog-use-header-bar, Accessor gtk: gtk-direction-type, Enum gtk: gtk-drag-begin, Function gtk: gtk-drag-check-threshold, Function gtk: gtk-drag-dest-add-image-targets, Function gtk: gtk-drag-dest-add-text-targets, Function gtk: gtk-drag-dest-add-uri-targets, Function gtk: gtk-drag-dest-find-target, Function gtk: gtk-drag-dest-get-target-list, Function gtk: gtk-drag-dest-get-track-motion, Function gtk: gtk-drag-dest-set, Function gtk: gtk-drag-dest-set-proxy, Function gtk: gtk-drag-dest-set-target-list, Function gtk: gtk-drag-dest-set-track-motion, Function gtk: gtk-drag-dest-unset, Function gtk: gtk-drag-finish, Function gtk: gtk-drag-get-data, Function gtk: gtk-drag-get-source-widget, Function gtk: gtk-drag-highlight, Function gtk: gtk-drag-result, Enum gtk: gtk-drag-set-icon-default, Function gtk: gtk-drag-set-icon-gicon, Function gtk: gtk-drag-set-icon-name, Function gtk: gtk-drag-set-icon-pixbuf, Function gtk: gtk-drag-set-icon-stock, Function gtk: gtk-drag-set-icon-surface, Function gtk: gtk-drag-set-icon-widget, Function gtk: gtk-drag-source-add-image-targets, Function gtk: gtk-drag-source-add-text-targets, Function gtk: gtk-drag-source-add-uri-targets, Function  (undocumented) gtk: gtk-drag-source-get-target-list, Function gtk: gtk-drag-source-set, Function gtk: gtk-drag-source-set-icon-gicon, Function gtk: gtk-drag-source-set-icon-name, Function gtk: gtk-drag-source-set-icon-pixbuf, Function gtk: gtk-drag-source-set-icon-stock, Function  (undocumented) gtk: gtk-drag-source-set-target-list, Function gtk: gtk-drag-source-unset, Function gtk: gtk-drag-unhighlight, Function gtk: gtk-drawing-area, Class gtk: gtk-drawing-area-new, Function gtk: gtk-editable, Interface gtk: gtk-editable-copy-clipboard, Function gtk: gtk-editable-cut-clipboard, Function gtk: gtk-editable-delete-selection, Function gtk: gtk-editable-delete-text, Function gtk: gtk-editable-get-chars, Function gtk: gtk-editable-get-editable, Function gtk: gtk-editable-get-position, Function gtk: gtk-editable-get-selection-bounds, Function gtk: gtk-editable-insert-text, Function gtk: gtk-editable-paste-clipboard, Function gtk: gtk-editable-select-region, Function gtk: gtk-editable-set-editable, Function gtk: gtk-editable-set-position, Function gtk: gtk-entry, Class gtk: gtk-entry-activates-default, Accessor gtk: gtk-entry-attributes, Accessor gtk: gtk-entry-buffer, Accessor gtk: gtk-entry-buffer, Class gtk: gtk-entry-buffer-delete-text, Function gtk: gtk-entry-buffer-emit-deleted-text, Function gtk: gtk-entry-buffer-emit-inserted-text, Function gtk: gtk-entry-buffer-get-bytes, Function gtk: gtk-entry-buffer-insert-text, Function gtk: gtk-entry-buffer-length, Accessor gtk: gtk-entry-buffer-max-length, Accessor gtk: gtk-entry-buffer-new, Function gtk: gtk-entry-buffer-text, Accessor gtk: gtk-entry-caps-lock-warning, Accessor gtk: gtk-entry-completion, Accessor gtk: gtk-entry-completion, Class gtk: gtk-entry-completion-cell-area, Accessor gtk: gtk-entry-completion-complete, Function gtk: gtk-entry-completion-compute-prefix, Function gtk: gtk-entry-completion-delete-action, Function gtk: gtk-entry-completion-get-completion-prefix, Function gtk: gtk-entry-completion-get-entry, Function gtk: gtk-entry-completion-inline-completion, Accessor gtk: gtk-entry-completion-inline-selection, Accessor gtk: gtk-entry-completion-insert-action-markup, Function gtk: gtk-entry-completion-insert-action-text, Function gtk: gtk-entry-completion-insert-prefix, Function gtk: gtk-entry-completion-minimum-key-length, Accessor gtk: gtk-entry-completion-model, Accessor gtk: gtk-entry-completion-new, Function gtk: gtk-entry-completion-new-with-area, Function gtk: gtk-entry-completion-popup-completion, Accessor gtk: gtk-entry-completion-popup-set-width, Accessor gtk: gtk-entry-completion-popup-single-match, Accessor gtk: gtk-entry-completion-set-match-func, Function gtk: gtk-entry-completion-text-column, Accessor gtk: gtk-entry-cursor-position, Accessor gtk: gtk-entry-editable, Accessor gtk: gtk-entry-get-alignment, Function gtk: gtk-entry-get-current-icon-drag-source, Function gtk: gtk-entry-get-cursor-hadjustment, Function gtk: gtk-entry-get-icon-activatable, Function gtk: gtk-entry-get-icon-area, Function gtk: gtk-entry-get-icon-at-pos, Function gtk: gtk-entry-get-icon-gicon, Function gtk: gtk-entry-get-icon-name, Function gtk: gtk-entry-get-icon-pixbuf, Function gtk: gtk-entry-get-icon-sensitive, Function gtk: gtk-entry-get-icon-stock, Function gtk: gtk-entry-get-icon-storage-type, Function gtk: gtk-entry-get-icon-tooltip-markup, Function gtk: gtk-entry-get-icon-tooltip-text, Function gtk: gtk-entry-get-layout, Function gtk: gtk-entry-get-layout-offsets, Function gtk: gtk-entry-get-text-area, Function gtk: gtk-entry-has-frame, Accessor gtk: gtk-entry-icon-position, Enum gtk: gtk-entry-im-context-filter-keypress, Function gtk: gtk-entry-im-module, Accessor gtk: gtk-entry-inner-border, Accessor gtk: gtk-entry-input-hints, Accessor gtk: gtk-entry-input-purpose, Accessor gtk: gtk-entry-invisible-char, Accessor gtk: gtk-entry-invisible-char-set, Accessor gtk: gtk-entry-layout-index-to-text-index, Function gtk: gtk-entry-max-length, Accessor gtk: gtk-entry-new, Function gtk: gtk-entry-new-with-buffer, Function gtk: gtk-entry-overwrite-mode, Accessor gtk: gtk-entry-placeholder-text, Accessor gtk: gtk-entry-populate-all, Accessor gtk: gtk-entry-primary-icon-activatable, Accessor gtk: gtk-entry-primary-icon-gicon, Accessor gtk: gtk-entry-primary-icon-name, Accessor gtk: gtk-entry-primary-icon-pixbuf, Accessor gtk: gtk-entry-primary-icon-sensitive, Accessor gtk: gtk-entry-primary-icon-stock, Accessor gtk: gtk-entry-primary-icon-storage-type, Accessor gtk: gtk-entry-primary-icon-tooltip-markup, Accessor gtk: gtk-entry-primary-icon-tooltip-text, Accessor gtk: gtk-entry-progress-fraction, Accessor gtk: gtk-entry-progress-pulse, Function gtk: gtk-entry-progress-pulse-step, Accessor gtk: gtk-entry-reset-im-context, Function gtk: gtk-entry-scroll-offset, Accessor gtk: gtk-entry-secondary-icon-activatable, Accessor gtk: gtk-entry-secondary-icon-gicon, Accessor gtk: gtk-entry-secondary-icon-name, Accessor gtk: gtk-entry-secondary-icon-pixbuf, Accessor gtk: gtk-entry-secondary-icon-sensitive, Accessor gtk: gtk-entry-secondary-icon-stock, Accessor gtk: gtk-entry-secondary-icon-storage-type, Accessor gtk: gtk-entry-secondary-icon-tooltip-markup, Accessor gtk: gtk-entry-secondary-icon-tooltip-text, Accessor gtk: gtk-entry-selection-bound, Accessor gtk: gtk-entry-set-alignment, Function gtk: gtk-entry-set-cursor-hadjustment, Function gtk: gtk-entry-set-icon-activatable, Function gtk: gtk-entry-set-icon-drag-source, Function gtk: gtk-entry-set-icon-from-gicon, Function gtk: gtk-entry-set-icon-from-icon-name, Function gtk: gtk-entry-set-icon-from-pixbuf, Function gtk: gtk-entry-set-icon-from-stock, Function gtk: gtk-entry-set-icon-sensitive, Function gtk: gtk-entry-set-icon-tooltip-markup, Function gtk: gtk-entry-set-icon-tooltip-text, Function gtk: gtk-entry-shadow-type, Accessor gtk: gtk-entry-tabs, Accessor gtk: gtk-entry-text, Accessor gtk: gtk-entry-text-index-to-layout-index, Function gtk: gtk-entry-text-length, Accessor gtk: gtk-entry-truncate-multiline, Accessor gtk: gtk-entry-unset-invisible-char, Function gtk: gtk-entry-visibility, Accessor gtk: gtk-entry-width-chars, Accessor gtk: gtk-entry-xalign, Accessor gtk: gtk-enumerate-printers, Function gtk: gtk-event-box, Class gtk: gtk-event-box-above-child, Accessor gtk: gtk-event-box-get-above-child, Function gtk: gtk-event-box-get-visible-window, Function gtk: gtk-event-box-new, Function gtk: gtk-event-box-set-above-child, Function gtk: gtk-event-box-set-visible-window, Function gtk: gtk-event-box-visible-window, Accessor gtk: gtk-events-pending, Function gtk: gtk-expander, Class gtk: gtk-expander-expanded, Accessor gtk: gtk-expander-label, Accessor gtk: gtk-expander-label-fill, Accessor gtk: gtk-expander-label-widget, Accessor gtk: gtk-expander-new, Function gtk: gtk-expander-new-with-mnemonic, Function gtk: gtk-expander-resize-toplevel, Accessor gtk: gtk-expander-spacing, Accessor gtk: gtk-expander-style, Enum gtk: gtk-expander-use-markup, Accessor gtk: gtk-expander-use-underline, Accessor gtk: gtk-file-chooser, Interface gtk: gtk-file-chooser-action, Accessor gtk: gtk-file-chooser-action, Enum gtk: gtk-file-chooser-add-filter, Function gtk: gtk-file-chooser-add-shortcut-folder, Function gtk: gtk-file-chooser-add-shortcut-folder-uri, Function gtk: gtk-file-chooser-button, Class gtk: gtk-file-chooser-button-child-expand, Accessor gtk: gtk-file-chooser-button-child-fill, Accessor gtk: gtk-file-chooser-button-child-pack-type, Function gtk: gtk-file-chooser-button-child-padding, Accessor gtk: gtk-file-chooser-button-child-position, Accessor gtk: gtk-file-chooser-button-dialog, Accessor gtk: gtk-file-chooser-button-focus-on-click, Accessor gtk: gtk-file-chooser-button-get-focus-on-click, Function gtk: gtk-file-chooser-button-get-title, Function gtk: gtk-file-chooser-button-get-width-chars, Function gtk: gtk-file-chooser-button-new, Function gtk: gtk-file-chooser-button-new-with-dialog, Function gtk: gtk-file-chooser-button-set-focus-on-click, Function gtk: gtk-file-chooser-button-set-title, Function gtk: gtk-file-chooser-button-set-width-chars, Function gtk: gtk-file-chooser-button-title, Accessor gtk: gtk-file-chooser-button-width-chars, Accessor gtk: gtk-file-chooser-confirmation, Enum gtk: gtk-file-chooser-create-folders, Accessor gtk: gtk-file-chooser-dialog, Class gtk: gtk-file-chooser-dialog-new, Function gtk: gtk-file-chooser-do-overwrite-confirmation, Accessor gtk: gtk-file-chooser-error, Enum gtk: gtk-file-chooser-extra-widget, Accessor gtk: gtk-file-chooser-filter, Accessor gtk: gtk-file-chooser-get-action, Function gtk: gtk-file-chooser-get-create-folders, Function gtk: gtk-file-chooser-get-current-folder, Function gtk: gtk-file-chooser-get-current-folder-uri, Function gtk: gtk-file-chooser-get-do-overwrite-confirmation, Function gtk: gtk-file-chooser-get-extra-widget, Function gtk: gtk-file-chooser-get-filename, Function gtk: gtk-file-chooser-get-filenames, Function gtk: gtk-file-chooser-get-filter, Function gtk: gtk-file-chooser-get-local-only, Function gtk: gtk-file-chooser-get-preview-filename, Function gtk: gtk-file-chooser-get-preview-uri, Function gtk: gtk-file-chooser-get-preview-widget, Function gtk: gtk-file-chooser-get-preview-widget-active, Function gtk: gtk-file-chooser-get-select-multiple, Function gtk: gtk-file-chooser-get-show-hidden, Function gtk: gtk-file-chooser-get-uri, Function gtk: gtk-file-chooser-get-uris, Function gtk: gtk-file-chooser-get-use-preview-label, Function gtk: gtk-file-chooser-list-filters, Function gtk: gtk-file-chooser-list-shortcut-folder-uris, Function gtk: gtk-file-chooser-list-shortcut-folders, Function gtk: gtk-file-chooser-local-only, Accessor gtk: gtk-file-chooser-preview-widget, Accessor gtk: gtk-file-chooser-preview-widget-active, Accessor gtk: gtk-file-chooser-remove-filter, Function gtk: gtk-file-chooser-remove-shortcut-folder, Function gtk: gtk-file-chooser-remove-shortcut-folder-uri, Function gtk: gtk-file-chooser-select-all, Function gtk: gtk-file-chooser-select-filename, Function gtk: gtk-file-chooser-select-multiple, Accessor gtk: gtk-file-chooser-select-uri, Function gtk: gtk-file-chooser-set-action, Function gtk: gtk-file-chooser-set-create-folders, Function gtk: gtk-file-chooser-set-current-folder, Function gtk: gtk-file-chooser-set-current-folder-uri, Function gtk: gtk-file-chooser-set-current-name, Function gtk: gtk-file-chooser-set-do-overwrite-confirmation, Function gtk: gtk-file-chooser-set-extra-widget, Function gtk: gtk-file-chooser-set-filename, Function gtk: gtk-file-chooser-set-filter, Function gtk: gtk-file-chooser-set-local-only, Function gtk: gtk-file-chooser-set-preview-widget, Function gtk: gtk-file-chooser-set-preview-widget-active, Function gtk: gtk-file-chooser-set-select-multiple, Function gtk: gtk-file-chooser-set-show-hidden, Function gtk: gtk-file-chooser-set-uri, Function gtk: gtk-file-chooser-set-use-preview-label, Function gtk: gtk-file-chooser-show-hidden, Accessor gtk: gtk-file-chooser-unselect-all, Function gtk: gtk-file-chooser-unselect-filename, Function gtk: gtk-file-chooser-unselect-uri, Function gtk: gtk-file-chooser-use-preview-label, Accessor gtk: gtk-file-chooser-widget, Class gtk: gtk-file-chooser-widget-child-expand, Accessor gtk: gtk-file-chooser-widget-child-fill, Accessor gtk: gtk-file-chooser-widget-child-pack-type, Accessor gtk: gtk-file-chooser-widget-child-padding, Accessor gtk: gtk-file-chooser-widget-child-position, Accessor gtk: gtk-file-chooser-widget-new, Function gtk: gtk-file-filter, Class gtk: gtk-file-filter-add-mime-type, Function gtk: gtk-file-filter-add-pattern, Function gtk: gtk-file-filter-add-pixbuf-formats, Function gtk: gtk-file-filter-flags, Flags gtk: gtk-file-filter-info, CStruct gtk: gtk-fixed, Class gtk: gtk-fixed-child-x, Accessor gtk: gtk-fixed-child-y, Accessor gtk: gtk-fixed-move, Function gtk: gtk-fixed-new, Function gtk: gtk-fixed-put, Function gtk: gtk-font-button, Class gtk: gtk-font-button-font-name, Accessor gtk: gtk-font-button-get-font-name, Function gtk: gtk-font-button-get-show-size, Function gtk: gtk-font-button-get-show-style, Function gtk: gtk-font-button-get-title, Function gtk: gtk-font-button-get-use-font, Function gtk: gtk-font-button-get-use-size, Function gtk: gtk-font-button-new, Function gtk: gtk-font-button-new-with-font, Function gtk: gtk-font-button-set-font-name, Function gtk: gtk-font-button-set-show-size, Function gtk: gtk-font-button-set-show-style, Function gtk: gtk-font-button-set-title, Function gtk: gtk-font-button-set-use-font, Function gtk: gtk-font-button-set-use-size, Function gtk: gtk-font-button-show-size, Accessor gtk: gtk-font-button-show-style, Accessor gtk: gtk-font-button-title, Accessor gtk: gtk-font-button-use-font, Accessor gtk: gtk-font-button-use-size, Accessor gtk: gtk-font-chooser, Interface gtk: gtk-font-chooser-dialog, Class gtk: gtk-font-chooser-dialog-new, Function gtk: gtk-font-chooser-font, Accessor gtk: gtk-font-chooser-font-desc, Accessor gtk: gtk-font-chooser-get-font, Function gtk: gtk-font-chooser-get-font-desc, Function gtk: gtk-font-chooser-get-font-face, Function gtk: gtk-font-chooser-get-font-family, Function gtk: gtk-font-chooser-get-font-size, Function gtk: gtk-font-chooser-get-preview-text, Function gtk: gtk-font-chooser-get-show-preview-entry, Function gtk: gtk-font-chooser-preview-text, Accessor gtk: gtk-font-chooser-set-filter-func, Function gtk: gtk-font-chooser-set-font, Function gtk: gtk-font-chooser-set-font-desc, Function gtk: gtk-font-chooser-set-preview-text, Function gtk: gtk-font-chooser-set-show-preview-entry, Function gtk: gtk-font-chooser-show-preview-entry, Accessor gtk: gtk-font-chooser-widget, Class gtk: gtk-font-chooser-widget-new, Function gtk: gtk-font-selection, Class gtk: gtk-font-selection-child-expand, Accessor gtk: gtk-font-selection-child-fill, Accessor gtk: gtk-font-selection-child-pack-type, Accessor gtk: gtk-font-selection-child-padding, Accessor gtk: gtk-font-selection-child-position, Accessor gtk: gtk-font-selection-dialog, Class gtk: gtk-font-selection-font-name, Accessor gtk: gtk-font-selection-get-face, Function gtk: gtk-font-selection-get-face-list, Function gtk: gtk-font-selection-get-family, Function gtk: gtk-font-selection-get-family-list, Function gtk: gtk-font-selection-get-font-name, Function gtk: gtk-font-selection-get-preview-entry, Function gtk: gtk-font-selection-get-preview-text, Function gtk: gtk-font-selection-get-size, Function gtk: gtk-font-selection-get-size-entry, Function gtk: gtk-font-selection-get-size-list, Function gtk: gtk-font-selection-new, Function gtk: gtk-font-selection-preview-text, Accessor gtk: gtk-font-selection-set-font-name, Function gtk: gtk-font-selection-set-preview-text, Function gtk: gtk-frame, Class gtk: gtk-frame-get-label, Function gtk: gtk-frame-get-label-align, Function gtk: gtk-frame-get-label-widget, Function gtk: gtk-frame-get-shadow-type, Function gtk: gtk-frame-label, Accessor gtk: gtk-frame-label-widget, Accessor gtk: gtk-frame-label-xalign, Accessor gtk: gtk-frame-label-yalign, Accessor gtk: gtk-frame-new, Function gtk: gtk-frame-set-label, Function gtk: gtk-frame-set-label-align, Function gtk: gtk-frame-set-label-widget, Function gtk: gtk-frame-set-shadow-type, Function gtk: gtk-frame-shadow-type, Accessor gtk: gtk-get-binary-age, Function gtk: gtk-get-current-event, Function gtk: gtk-get-current-event-device, Function gtk: gtk-get-current-event-state, Function gtk: gtk-get-current-event-time, Function gtk: gtk-get-default-language, Function gtk: gtk-get-event-widget, Function gtk: gtk-get-interface-age, Function gtk: gtk-get-major-version, Function gtk: gtk-get-micro-version, Function gtk: gtk-get-minor-version, Function gtk: gtk-get-option-group, Function gtk: gtk-grab-add, Function gtk: gtk-grab-get-current, Function gtk: gtk-grab-remove, Function gtk: gtk-grid, Class gtk: gtk-grid-attach, Function gtk: gtk-grid-attach-next-to, Function gtk: gtk-grid-baseline-row, Accessor gtk: gtk-grid-child-height, Accessor gtk: gtk-grid-child-left-attach, Accessor gtk: gtk-grid-child-top-attach, Accessor gtk: gtk-grid-child-width, Accessor gtk: gtk-grid-column-homogeneous, Accessor gtk: gtk-grid-column-spacing, Accessor gtk: gtk-grid-get-child-at, Function gtk: gtk-grid-insert-column, Function gtk: gtk-grid-insert-next-to, Function gtk: gtk-grid-insert-row, Function gtk: gtk-grid-new, Function gtk: gtk-grid-row-homogeneous, Accessor gtk: gtk-grid-row-spacing, Accessor gtk: gtk-handle-box, Class gtk: gtk-handle-box-child-detached, Accessor gtk: gtk-handle-box-handle-position, Accessor gtk: gtk-handle-box-shadow-type, Accessor gtk: gtk-handle-box-snap-edge, Accessor gtk: gtk-handle-box-snap-edge-set, Accessor gtk: gtk-hbox, Class gtk: gtk-hbox-child-expand, Accessor gtk: gtk-hbox-child-fill, Accessor gtk: gtk-hbox-child-pack-type, Accessor gtk: gtk-hbox-child-padding, Accessor gtk: gtk-hbox-child-position, Accessor gtk: gtk-hbox-new, Function gtk: gtk-hbutton-box, Class gtk: gtk-hbutton-box-child-expand, Accessor gtk: gtk-hbutton-box-child-fill, Accessor gtk: gtk-hbutton-box-child-pack-type, Accessor gtk: gtk-hbutton-box-child-padding, Accessor gtk: gtk-hbutton-box-child-position, Accessor gtk: gtk-hbutton-box-child-secondary, Accessor gtk: gtk-hbutton-box-new, Function gtk: gtk-header-bar, Class gtk: gtk-header-bar-custom-title, Accessor gtk: gtk-header-bar-decoration-layout, Accessor gtk: gtk-header-bar-decoration-layout-set, Accessor gtk: gtk-header-bar-has-subtitle, Generic Function  (undocumented) gtk: gtk-header-bar-show-close-button, Accessor gtk: gtk-header-bar-spacing, Accessor gtk: gtk-header-bar-subtitle, Accessor gtk: gtk-header-bar-title, Accessor gtk: gtk-hpaned, Class gtk: gtk-hpaned-child-resize, Accessor gtk: gtk-hpaned-child-shrink, Accessor gtk: gtk-hpaned-new, Function gtk: gtk-hscale, Class gtk: gtk-hscale-new, Function gtk: gtk-hscale-new-with-range, Function gtk: gtk-hscrollbar, Class gtk: gtk-hscrollbar-new, Function gtk: gtk-hseparator, Class gtk: gtk-hseparator-new, Function gtk: gtk-hsv, Class gtk: gtk-hsv-get-color, Function gtk: gtk-hsv-get-metrics, Function gtk: gtk-hsv-is-adjusting, Function gtk: gtk-hsv-new, Function gtk: gtk-hsv-set-color, Function gtk: gtk-hsv-set-metrics, Function gtk: gtk-hsv-to-rgb, Function gtk: gtk-icon-factory, Class gtk: gtk-icon-factory-add, Function gtk: gtk-icon-factory-add-default, Function gtk: gtk-icon-factory-lookup, Function gtk: gtk-icon-factory-lookup-default, Function gtk: gtk-icon-factory-remove-default, Function gtk: gtk-icon-info, CStruct gtk: gtk-icon-info-get-builtin-pixbuf, Function gtk: gtk-icon-info-get-filename, Function gtk: gtk-icon-info-load-icon, Function gtk: gtk-icon-lookup-flags, Flags gtk: gtk-icon-set, CStruct gtk: gtk-icon-set-add-source, Function gtk: gtk-icon-set-new, Function gtk: gtk-icon-set-new-from-pixbuf, Function gtk: gtk-icon-set-render-icon, Function gtk: gtk-icon-set-render-icon-pixbuf, Function gtk: gtk-icon-size, Enum gtk: gtk-icon-source, CStruct gtk: gtk-icon-source-get-filename, Function gtk: gtk-icon-source-get-icon-name, Function gtk: gtk-icon-source-new, Function gtk: gtk-icon-source-set-filename, Function gtk: gtk-icon-source-set-icon-name, Function gtk: gtk-icon-theme, Class gtk: gtk-icon-theme-choose-icon, Function gtk: gtk-icon-theme-error, Enum gtk: gtk-icon-theme-get-default, Function gtk: gtk-icon-theme-get-example-icon-name, Function gtk: gtk-icon-theme-get-for-screen, Function gtk: gtk-icon-theme-has-icon, Function gtk: gtk-icon-theme-list-contexts, Function gtk: gtk-icon-theme-list-icons, Function gtk: gtk-icon-theme-load-icon, Function gtk: gtk-icon-theme-lookup-icon, Function gtk: gtk-icon-theme-new, Function gtk: gtk-icon-view, Class gtk: gtk-icon-view-cell-area, Accessor gtk: gtk-icon-view-column-spacing, Accessor gtk: gtk-icon-view-columns, Accessor gtk: gtk-icon-view-convert-widget-to-bin-window-coords, Function gtk: gtk-icon-view-create-drag-icon, Function gtk: gtk-icon-view-drop-position, Enum gtk: gtk-icon-view-enable-model-drag-dest, Function gtk: gtk-icon-view-enable-model-drag-source, Function gtk: gtk-icon-view-get-cell-rect, Function gtk: gtk-icon-view-get-column-spacing, Function gtk: gtk-icon-view-get-columns, Function gtk: gtk-icon-view-get-cursor, Function gtk: gtk-icon-view-get-dest-item-at-pos, Function gtk: gtk-icon-view-get-drag-dest-item, Function gtk: gtk-icon-view-get-item-at-pos, Function gtk: gtk-icon-view-get-item-column, Function gtk: gtk-icon-view-get-item-orientation, Function gtk: gtk-icon-view-get-item-padding, Function gtk: gtk-icon-view-get-item-row, Function gtk: gtk-icon-view-get-item-width, Function gtk: gtk-icon-view-get-margin, Function gtk: gtk-icon-view-get-markup-column, Function gtk: gtk-icon-view-get-model, Function gtk: gtk-icon-view-get-path-at-pos, Function gtk: gtk-icon-view-get-pixbuf-column, Function gtk: gtk-icon-view-get-reorderable, Function gtk: gtk-icon-view-get-row-spacing, Function gtk: gtk-icon-view-get-selected-items, Function gtk: gtk-icon-view-get-selection-mode, Function gtk: gtk-icon-view-get-spacing, Function gtk: gtk-icon-view-get-text-column, Function gtk: gtk-icon-view-get-tooltip-column, Function gtk: gtk-icon-view-get-tooltip-context, Function gtk: gtk-icon-view-get-visible-range, Function gtk: gtk-icon-view-item-activated, Function gtk: gtk-icon-view-item-orientation, Accessor gtk: gtk-icon-view-item-padding, Accessor gtk: gtk-icon-view-item-width, Accessor gtk: gtk-icon-view-margin, Accessor gtk: gtk-icon-view-markup-column, Accessor gtk: gtk-icon-view-model, Accessor gtk: gtk-icon-view-new, Function gtk: gtk-icon-view-new-with-area, Function gtk: gtk-icon-view-path-is-selected, Function gtk: gtk-icon-view-pixbuf-column, Accessor gtk: gtk-icon-view-reorderable, Accessor gtk: gtk-icon-view-row-spacing, Accessor gtk: gtk-icon-view-scroll-to-path, Function gtk: gtk-icon-view-select-all, Function gtk: gtk-icon-view-select-path, Function gtk: gtk-icon-view-selected-foreach, Function gtk: gtk-icon-view-selection-mode, Accessor gtk: gtk-icon-view-set-column-spacing, Function gtk: gtk-icon-view-set-columns, Function gtk: gtk-icon-view-set-cursor, Function gtk: gtk-icon-view-set-drag-dest-item, Function gtk: gtk-icon-view-set-item-orientation, Function gtk: gtk-icon-view-set-item-padding, Function gtk: gtk-icon-view-set-item-width, Function gtk: gtk-icon-view-set-margin, Function gtk: gtk-icon-view-set-markup-column, Function gtk: gtk-icon-view-set-model, Function gtk: gtk-icon-view-set-pixbuf-column, Function gtk: gtk-icon-view-set-reorderable, Function gtk: gtk-icon-view-set-row-spacing, Function gtk: gtk-icon-view-set-selection-mode, Function gtk: gtk-icon-view-set-spacing, Function gtk: gtk-icon-view-set-text-column, Function gtk: gtk-icon-view-set-tooltip-cell, Function gtk: gtk-icon-view-set-tooltip-column, Function gtk: gtk-icon-view-set-tooltip-item, Function gtk: gtk-icon-view-spacing, Accessor gtk: gtk-icon-view-text-column, Accessor gtk: gtk-icon-view-tooltip-column, Accessor gtk: gtk-icon-view-unselect-all, Function gtk: gtk-icon-view-unselect-path, Function gtk: gtk-icon-view-unset-model-drag-dest, Function gtk: gtk-icon-view-unset-model-drag-source, Function gtk: gtk-im-context, Class gtk: gtk-im-context-input-hints, Accessor gtk: gtk-im-context-input-purpose, Accessor gtk: gtk-im-context-simple, Class gtk: gtk-im-multicontext, Class gtk: gtk-im-preedit-style, Enum gtk: gtk-im-status-style, Enum gtk: gtk-image, Class gtk: gtk-image-clear, Function gtk: gtk-image-file, Accessor gtk: gtk-image-get-animation, Function gtk: gtk-image-get-gicon, Function gtk: gtk-image-get-icon-name, Function gtk: gtk-image-get-icon-set, Function gtk: gtk-image-get-stock, Function gtk: gtk-image-gicon, Accessor gtk: gtk-image-icon-name, Accessor gtk: gtk-image-icon-set, Accessor gtk: gtk-image-icon-size, Accessor gtk: gtk-image-menu-item, Class gtk: gtk-image-menu-item-accel-group, Accessor gtk: gtk-image-menu-item-always-show-image, Accessor gtk: gtk-image-menu-item-get-always-show-image, Function  (undocumented) gtk: gtk-image-menu-item-get-image, Function  (undocumented) gtk: gtk-image-menu-item-get-use-stock, Function  (undocumented) gtk: gtk-image-menu-item-image, Accessor gtk: gtk-image-menu-item-new, Function  (undocumented) gtk: gtk-image-menu-item-new-from-stock, Function  (undocumented) gtk: gtk-image-menu-item-new-with-label, Function  (undocumented) gtk: gtk-image-menu-item-new-with-mnemonic, Function  (undocumented) gtk: gtk-image-menu-item-set-accel-group, Function  (undocumented) gtk: gtk-image-menu-item-set-always-show-image, Function  (undocumented) gtk: gtk-image-menu-item-set-image, Function  (undocumented) gtk: gtk-image-menu-item-set-use-stock, Function  (undocumented) gtk: gtk-image-menu-item-use-stock, Accessor gtk: gtk-image-new, Function gtk: gtk-image-new-from-animation, Function gtk: gtk-image-new-from-file, Function gtk: gtk-image-new-from-gicon, Function gtk: gtk-image-new-from-icon-name, Function gtk: gtk-image-new-from-icon-set, Function gtk: gtk-image-new-from-pixbuf, Function gtk: gtk-image-new-from-resource, Function gtk: gtk-image-new-from-stock, Function gtk: gtk-image-pixbuf, Accessor gtk: gtk-image-pixbuf-animation, Accessor gtk: gtk-image-pixel-size, Accessor gtk: gtk-image-resource, Generic Function gtk: gtk-image-set-from-animation, Function gtk: gtk-image-set-from-file, Function gtk: gtk-image-set-from-gicon, Function gtk: gtk-image-set-from-icon-name, Function gtk: gtk-image-set-from-icon-set, Function gtk: gtk-image-set-from-pixbuf, Function gtk: gtk-image-set-from-resource, Function gtk: gtk-image-set-from-stock, Function gtk: gtk-image-stock, Accessor gtk: gtk-image-storage-type, Accessor gtk: gtk-image-surface, Accessor gtk: gtk-image-type, Enum gtk: gtk-image-use-fallback, Accessor gtk: gtk-info-bar, Class gtk: gtk-info-bar-add-action-widget, Function gtk: gtk-info-bar-add-button, Function gtk: gtk-info-bar-add-buttons, Function gtk: gtk-info-bar-get-action-area, Function gtk: gtk-info-bar-get-content-area, Function gtk: gtk-info-bar-message-type, Accessor gtk: gtk-info-bar-new, Function gtk: gtk-info-bar-new-with-buttons, Function gtk: gtk-info-bar-response, Function gtk: gtk-info-bar-set-default-response, Function gtk: gtk-info-bar-set-response-sensitive, Function gtk: gtk-info-bar-show-close-button, Accessor gtk: gtk-input-hints, Flags gtk: gtk-input-purpose, Enum gtk: gtk-invisible, Class gtk: gtk-invisible-new, Function gtk: gtk-invisible-new-for-screen, Function gtk: gtk-invisible-screen, Accessor gtk: gtk-junction-sides, Enum gtk: gtk-justification, Enum gtk: gtk-label, Class gtk: gtk-label-angle, Accessor gtk: gtk-label-attributes, Accessor gtk: gtk-label-cursor-position, Accessor gtk: gtk-label-ellipsize, Accessor gtk: gtk-label-get-current-uri, Function gtk: gtk-label-get-layout, Function gtk: gtk-label-get-layout-offsets, Function gtk: gtk-label-get-line-wrap, Function gtk: gtk-label-get-line-wrap-mode, Function gtk: gtk-label-get-selection-bounds, Function gtk: gtk-label-get-text, Function gtk: gtk-label-justify, Accessor gtk: gtk-label-label, Accessor gtk: gtk-label-lines, Accessor gtk: gtk-label-max-width-chars, Accessor gtk: gtk-label-mnemonic-keyval, Accessor gtk: gtk-label-mnemonic-widget, Accessor gtk: gtk-label-new, Function gtk: gtk-label-new-with-mnemonic, Function gtk: gtk-label-pattern, Accessor gtk: gtk-label-select-region, Function gtk: gtk-label-selectable, Accessor gtk: gtk-label-selection-bound, Accessor gtk: gtk-label-set-line-wrap, Function gtk: gtk-label-set-line-wrap-mode, Function gtk: gtk-label-set-markup, Function gtk: gtk-label-set-markup-with-mnemonic, Function gtk: gtk-label-set-text, Function gtk: gtk-label-set-text-with-mnemonic, Function gtk: gtk-label-single-line-mode, Accessor gtk: gtk-label-track-visited-links, Accessor gtk: gtk-label-use-markup, Accessor gtk: gtk-label-use-underline, Accessor gtk: gtk-label-width-chars, Accessor gtk: gtk-label-wrap, Accessor gtk: gtk-label-wrap-mode, Accessor gtk: gtk-layout, Class gtk: gtk-layout-child-x, Accessor gtk: gtk-layout-child-y, Accessor gtk: gtk-layout-get-bin-window, Function gtk: gtk-layout-get-size, Function gtk: gtk-layout-height, Accessor gtk: gtk-layout-move, Function gtk: gtk-layout-new, Function gtk: gtk-layout-put, Function gtk: gtk-layout-set-size, Function gtk: gtk-layout-width, Accessor gtk: gtk-level-bar, Class gtk: gtk-level-bar-add-offset-value, Function gtk: gtk-level-bar-get-offset-value, Function gtk: gtk-level-bar-inverted, Accessor gtk: gtk-level-bar-max-value, Accessor gtk: gtk-level-bar-min-value, Accessor gtk: gtk-level-bar-mode, Accessor gtk: gtk-level-bar-mode, Enum gtk: gtk-level-bar-new, Function gtk: gtk-level-bar-new-for-interval, Function gtk: gtk-level-bar-remove-offset-value, Function gtk: gtk-level-bar-value, Accessor gtk: gtk-license, Enum gtk: gtk-link-button, Class gtk: gtk-link-button-new, Function gtk: gtk-link-button-new-with-label, Function gtk: gtk-link-button-uri, Accessor gtk: gtk-link-button-visited, Accessor gtk: gtk-list-store, Class gtk: gtk-list-store-append, Function gtk: gtk-list-store-clear, Function gtk: gtk-list-store-insert, Function gtk: gtk-list-store-insert-after, Function gtk: gtk-list-store-insert-before, Function gtk: gtk-list-store-insert-with-values, Function gtk: gtk-list-store-iter-is-valid, Function gtk: gtk-list-store-move-after, Function gtk: gtk-list-store-move-before, Function gtk: gtk-list-store-new, Function gtk: gtk-list-store-prepend, Function gtk: gtk-list-store-remove, Function gtk: gtk-list-store-set, Function gtk: gtk-list-store-set-column-types, Function gtk: gtk-list-store-set-value, Function gtk: gtk-list-store-swap, Function gtk: gtk-main, Function gtk: gtk-main-do-event, Function gtk: gtk-main-iteration, Function gtk: gtk-main-iteration-do, Function gtk: gtk-main-level, Function gtk: gtk-main-quit, Function gtk: gtk-menu, Class gtk: gtk-menu-accel-group, Accessor gtk: gtk-menu-accel-path, Accessor gtk: gtk-menu-active, Accessor gtk: gtk-menu-attach, Function gtk: gtk-menu-attach-to-widget, Function gtk: gtk-menu-attach-widget, Accessor gtk: gtk-menu-bar, Class gtk: gtk-menu-bar-child-pack-direction, Accessor gtk: gtk-menu-bar-get-child-pack-direction, Function gtk: gtk-menu-bar-get-pack-direction, Function gtk: gtk-menu-bar-new, Function gtk: gtk-menu-bar-new-from-model, Function gtk: gtk-menu-bar-pack-direction, Accessor gtk: gtk-menu-bar-set-child-pack-direction, Function gtk: gtk-menu-bar-set-pack-direction, Function gtk: gtk-menu-child-bottom-attach, Accessor gtk: gtk-menu-child-left-attach, Accessor gtk: gtk-menu-child-right-attach, Accessor gtk: gtk-menu-child-top-attach, Accessor gtk: gtk-menu-detach, Function gtk: gtk-menu-direction-type, Enum gtk: gtk-menu-get-accel-group, Function gtk: gtk-menu-get-accel-path, Function gtk: gtk-menu-get-active, Function gtk: gtk-menu-get-attach-widget, Function gtk: gtk-menu-get-for-attach-widget, Function gtk: gtk-menu-get-monitor, Function gtk: gtk-menu-get-reserve-toggle-size, Function gtk: gtk-menu-get-tearoff-state, Function gtk: gtk-menu-get-title, Function gtk: gtk-menu-item, Class gtk: gtk-menu-item-accel-path, Accessor gtk: gtk-menu-item-activate, Function gtk: gtk-menu-item-deselect, Function gtk: gtk-menu-item-get-accel-path, Function gtk: gtk-menu-item-get-reserve-indicator, Function gtk: gtk-menu-item-get-right-justified, Function gtk: gtk-menu-item-get-use-underline, Function gtk: gtk-menu-item-label, Accessor gtk: gtk-menu-item-new, Function gtk: gtk-menu-item-new-with-label, Function gtk: gtk-menu-item-new-with-mnemonic, Function gtk: gtk-menu-item-right-justified, Accessor gtk: gtk-menu-item-select, Function gtk: gtk-menu-item-set-accel-path, Function gtk: gtk-menu-item-set-reserve-indicator, Function gtk: gtk-menu-item-set-right-justified, Function gtk: gtk-menu-item-set-use-underline, Function gtk: gtk-menu-item-submenu, Accessor gtk: gtk-menu-item-toggle-size-allocate, Function gtk: gtk-menu-item-toggle-size-request, Function gtk: gtk-menu-item-use-underline, Accessor gtk: gtk-menu-monitor, Accessor gtk: gtk-menu-new, Function gtk: gtk-menu-new-from-model, Function gtk: gtk-menu-popdown, Function gtk: gtk-menu-popup, Function gtk: gtk-menu-popup-for-device, Function gtk: gtk-menu-reorder-child, Function gtk: gtk-menu-reposition, Function gtk: gtk-menu-reserve-toggle-size, Accessor gtk: gtk-menu-set-accel-group, Function gtk: gtk-menu-set-accel-path, Function gtk: gtk-menu-set-active, Function gtk: gtk-menu-set-monitor, Function gtk: gtk-menu-set-reserve-toggle-size, Function gtk: gtk-menu-set-screen, Function gtk: gtk-menu-set-tearoff-state, Function gtk: gtk-menu-set-title, Function gtk: gtk-menu-shell, Class gtk: gtk-menu-shell-activate-item, Function gtk: gtk-menu-shell-append, Function gtk: gtk-menu-shell-cancel, Function gtk: gtk-menu-shell-deactivate, Function gtk: gtk-menu-shell-deselect, Function gtk: gtk-menu-shell-insert, Function gtk: gtk-menu-shell-prepend, Function gtk: gtk-menu-shell-select-first, Function gtk: gtk-menu-shell-select-item, Function gtk: gtk-menu-shell-take-focus, Accessor gtk: gtk-menu-tearoff-state, Accessor gtk: gtk-menu-tearoff-title, Accessor gtk: gtk-menu-tool-button, Class gtk: gtk-menu-tool-button-get-menu, Function gtk: gtk-menu-tool-button-menu, Accessor gtk: gtk-menu-tool-button-new, Function gtk: gtk-menu-tool-button-new-from-stock, Function gtk: gtk-menu-tool-button-set-arrow-tooltip-markup, Function gtk: gtk-menu-tool-button-set-arrow-tooltip-text, Function gtk: gtk-menu-tool-button-set-menu, Function gtk: gtk-message-dialog, Class gtk: gtk-message-dialog-buttons, Accessor gtk: gtk-message-dialog-format-secondary-markup, Function gtk: gtk-message-dialog-format-secondary-text, Function gtk: gtk-message-dialog-image, Accessor gtk: gtk-message-dialog-message-area, Accessor gtk: gtk-message-dialog-message-type, Accessor gtk: gtk-message-dialog-new, Function gtk: gtk-message-dialog-new-with-markup, Function gtk: gtk-message-dialog-secondary-text, Accessor gtk: gtk-message-dialog-secondary-use-markup, Accessor gtk: gtk-message-dialog-set-markup, Function gtk: gtk-message-dialog-text, Accessor gtk: gtk-message-dialog-use-markup, Accessor gtk: gtk-message-type, Enum gtk: gtk-misc, Class gtk: gtk-misc-get-alignment, Function gtk: gtk-misc-get-padding, Function gtk: gtk-misc-set-alignment, Function gtk: gtk-misc-set-padding, Function gtk: gtk-misc-xalign, Accessor gtk: gtk-misc-xpad, Accessor gtk: gtk-misc-yalign, Accessor gtk: gtk-misc-ypad, Accessor gtk: gtk-movement-step, Enum gtk: gtk-notebook, Class gtk: gtk-notebook-append-page, Function gtk: gtk-notebook-append-page-menu, Function gtk: gtk-notebook-child-detachable, Accessor gtk: gtk-notebook-child-menu-label, Accessor gtk: gtk-notebook-child-position, Accessor gtk: gtk-notebook-child-reorderable, Accessor gtk: gtk-notebook-child-tab-expand, Accessor gtk: gtk-notebook-child-tab-fill, Accessor gtk: gtk-notebook-child-tab-label, Accessor gtk: gtk-notebook-enable-popup, Accessor gtk: gtk-notebook-get-action-widget, Function gtk: gtk-notebook-get-current-page, Function gtk: gtk-notebook-get-menu-label, Function gtk: gtk-notebook-get-menu-label-text, Function gtk: gtk-notebook-get-n-pages, Function gtk: gtk-notebook-get-nth-page, Function gtk: gtk-notebook-get-tab-detachable, Function gtk: gtk-notebook-get-tab-label, Function gtk: gtk-notebook-get-tab-label-text, Function gtk: gtk-notebook-get-tab-reorderable, Function gtk: gtk-notebook-group-name, Accessor gtk: gtk-notebook-insert-page, Function gtk: gtk-notebook-insert-page-menu, Function gtk: gtk-notebook-new, Function gtk: gtk-notebook-next-page, Function gtk: gtk-notebook-page, Accessor gtk: gtk-notebook-page-num, Function gtk: gtk-notebook-popup-disable, Function gtk: gtk-notebook-popup-enable, Function gtk: gtk-notebook-prepend-page, Function gtk: gtk-notebook-prepend-page-menu, Function gtk: gtk-notebook-prev-page, Function gtk: gtk-notebook-remove-page, Function gtk: gtk-notebook-reorder-child, Function gtk: gtk-notebook-scrollable, Accessor gtk: gtk-notebook-set-action-widget, Function gtk: gtk-notebook-set-current-page, Function gtk: gtk-notebook-set-menu-label, Function gtk: gtk-notebook-set-menu-label-text, Function gtk: gtk-notebook-set-tab-detachable, Function gtk: gtk-notebook-set-tab-label, Function gtk: gtk-notebook-set-tab-label-text, Function gtk: gtk-notebook-set-tab-reorderable, Function gtk: gtk-notebook-show-border, Accessor gtk: gtk-notebook-show-tabs, Accessor gtk: gtk-notebook-tab-pos, Accessor gtk: gtk-number-up-layout, Enum gtk: gtk-numerable-icon, Class gtk: gtk-numerable-icon-background-icon, Accessor gtk: gtk-numerable-icon-background-icon-name, Accessor gtk: gtk-numerable-icon-count, Accessor gtk: gtk-numerable-icon-get-background-gicon, Function gtk: gtk-numerable-icon-get-background-icon-name, Function gtk: gtk-numerable-icon-get-count, Function gtk: gtk-numerable-icon-get-label, Function gtk: gtk-numerable-icon-get-style-context, Function gtk: gtk-numerable-icon-label, Accessor gtk: gtk-numerable-icon-new, Function gtk: gtk-numerable-icon-new-with-style-context, Function gtk: gtk-numerable-icon-set-background-gicon, Function gtk: gtk-numerable-icon-set-background-icon-name, Function gtk: gtk-numerable-icon-set-count, Function gtk: gtk-numerable-icon-set-label, Function gtk: gtk-numerable-icon-set-style-context, Function gtk: gtk-numerable-icon-style-context, Accessor gtk: gtk-offscreen-window, Class gtk: gtk-offscreen-window-get-pixbuf, Function gtk: gtk-offscreen-window-get-surface, Function gtk: gtk-offscreen-window-new, Function gtk: gtk-orientable, Interface gtk: gtk-orientable-orientation, Accessor gtk: gtk-orientation, Enum gtk: gtk-overlay, Class gtk: gtk-overlay-add-overlay, Function gtk: gtk-overlay-new, Function gtk: gtk-pack-direction, Enum gtk: gtk-pack-type, Enum gtk: gtk-page-orientation, Enum gtk: gtk-page-set, Enum gtk: gtk-page-setup, Class gtk: gtk-page-setup-copy, Function gtk: gtk-page-setup-get-orientation, Function gtk: gtk-page-setup-new, Function gtk: gtk-page-setup-unix-dialog, Class gtk: gtk-page-setup-unix-dialog-get-page-setup, Function gtk: gtk-page-setup-unix-dialog-get-print-settings, Function gtk: gtk-page-setup-unix-dialog-new, Function gtk: gtk-page-setup-unix-dialog-set-page-setup, Function gtk: gtk-page-setup-unix-dialog-set-print-settings, Function gtk: gtk-paned, Class gtk: gtk-paned-add1, Function gtk: gtk-paned-add2, Function gtk: gtk-paned-child-resize, Accessor gtk: gtk-paned-child-shrink, Accessor gtk: gtk-paned-get-child1, Function gtk: gtk-paned-get-child2, Function gtk: gtk-paned-get-handle-window, Function gtk: gtk-paned-max-position, Accessor gtk: gtk-paned-min-position, Accessor gtk: gtk-paned-new, Function gtk: gtk-paned-pack1, Function gtk: gtk-paned-pack2, Function gtk: gtk-paned-position, Accessor gtk: gtk-paned-position-set, Accessor gtk: gtk-paper-size, CStruct gtk: gtk-paper-size-copy, Function gtk: gtk-paper-size-free, Function gtk: gtk-paper-size-get-default, Function gtk: gtk-paper-size-get-default-bottom-margin, Function gtk: gtk-paper-size-get-default-left-margin, Function gtk: gtk-paper-size-get-default-right-margin, Function gtk: gtk-paper-size-get-default-top-margin, Function gtk: gtk-paper-size-get-display-name, Function gtk: gtk-paper-size-get-height, Function gtk: gtk-paper-size-get-name, Function gtk: gtk-paper-size-get-paper-sizes, Function gtk: gtk-paper-size-get-ppd-name, Function gtk: gtk-paper-size-get-width, Function gtk: gtk-paper-size-is-custom, Function gtk: gtk-paper-size-is-equal, Function gtk: gtk-paper-size-new, Function gtk: gtk-paper-size-new-custom, Function gtk: gtk-paper-size-new-from-key-file, Function gtk: gtk-paper-size-new-from-ppd, Function gtk: gtk-paper-size-set-size, Function gtk: gtk-paper-size-to-key-file, Function gtk: gtk-path-priority-type, Enum gtk: gtk-path-type, Enum gtk: gtk-plug, Class gtk: gtk-plug-embedded, Accessor gtk: gtk-plug-get-id, Function gtk: gtk-plug-new, Function gtk: gtk-plug-socket-window, Accessor gtk: gtk-policy-type, Enum gtk: gtk-position-type, Enum gtk: gtk-print-backend, Class gtk: gtk-print-capabilities, Enum gtk: gtk-print-context, Class gtk: gtk-print-context-create-pango-context, Function gtk: gtk-print-context-create-pango-layout, Function gtk: gtk-print-context-get-cairo-context, Function gtk: gtk-print-context-get-dpi-x, Function gtk: gtk-print-context-get-dpi-y, Function gtk: gtk-print-context-get-hard-margins, Function gtk: gtk-print-context-get-height, Function gtk: gtk-print-context-get-page-setup, Function gtk: gtk-print-context-get-pango-fontmap, Function gtk: gtk-print-context-get-width, Function gtk: gtk-print-context-set-cairo-context, Function gtk: gtk-print-duplex, Enum gtk: gtk-print-error, Enum gtk: gtk-print-job, Class gtk: gtk-print-job-get-collate, Function gtk: gtk-print-job-get-n-up, Function gtk: gtk-print-job-get-n-up-layout, Function gtk: gtk-print-job-get-num-copies, Function gtk: gtk-print-job-get-page-set, Function gtk: gtk-print-job-get-pages, Function gtk: gtk-print-job-get-printer, Function gtk: gtk-print-job-get-reverse, Function gtk: gtk-print-job-get-rotate, Function gtk: gtk-print-job-get-scale, Function gtk: gtk-print-job-get-settings, Function gtk: gtk-print-job-get-status, Function gtk: gtk-print-job-get-surface, Function gtk: gtk-print-job-get-title, Function gtk: gtk-print-job-get-track-print-status, Function gtk: gtk-print-job-new, Function gtk: gtk-print-job-page-setup, Accessor gtk: gtk-print-job-printer, Accessor gtk: gtk-print-job-send, Function gtk: gtk-print-job-set-collate, Function gtk: gtk-print-job-set-n-up, Function gtk: gtk-print-job-set-n-up-layout, Symbol gtk: gtk-print-job-set-num-copies, Function gtk: gtk-print-job-set-page-set, Function gtk: gtk-print-job-set-pages, Function gtk: gtk-print-job-set-reverse, Function gtk: gtk-print-job-set-rotate, Function gtk: gtk-print-job-set-scale, Function gtk: gtk-print-job-set-source-file, Function gtk: gtk-print-job-set-track-print-status, Function gtk: gtk-print-job-settings, Accessor gtk: gtk-print-job-title, Accessor gtk: gtk-print-job-track-print-status, Accessor gtk: gtk-print-operation, Class gtk: gtk-print-operation-action, Enum gtk: gtk-print-operation-allow-async, Accessor gtk: gtk-print-operation-cancel, Function gtk: gtk-print-operation-current-page, Accessor gtk: gtk-print-operation-custom-tab-label, Accessor gtk: gtk-print-operation-default-page-setup, Accessor gtk: gtk-print-operation-embed-page-setup, Accessor gtk: gtk-print-operation-export-filename, Accessor gtk: gtk-print-operation-get-default-page-setup, Function gtk: gtk-print-operation-get-embed-page-setup, Function gtk: gtk-print-operation-get-has-selection, Function gtk: gtk-print-operation-get-n-pages-to-print, Function gtk: gtk-print-operation-get-print-settings, Function gtk: gtk-print-operation-get-status, Symbol gtk: gtk-print-operation-get-status-string, Function gtk: gtk-print-operation-get-support-selection, Function gtk: gtk-print-operation-has-selection, Accessor gtk: gtk-print-operation-job-name, Accessor gtk: gtk-print-operation-n-pages, Accessor gtk: gtk-print-operation-n-pages-to-print, Accessor gtk: gtk-print-operation-new, Function gtk: gtk-print-operation-preview, Class gtk: gtk-print-operation-preview-end-preview, Function gtk: gtk-print-operation-preview-is-selected, Function gtk: gtk-print-operation-preview-render-page, Function gtk: gtk-print-operation-print-settings, Accessor gtk: gtk-print-operation-result, Enum gtk: gtk-print-operation-run, Function gtk: gtk-print-operation-set-allow-async, Function gtk: gtk-print-operation-set-current-page, Function gtk: gtk-print-operation-set-custom-tab-label, Function gtk: gtk-print-operation-set-default-page-setup, Function gtk: gtk-print-operation-set-defer-drawing, Function gtk: gtk-print-operation-set-embed-page-setup, Function gtk: gtk-print-operation-set-export-filename, Function gtk: gtk-print-operation-set-has-selection, Function gtk: gtk-print-operation-set-job-name, Function gtk: gtk-print-operation-set-n-pages, Function gtk: gtk-print-operation-set-print-settings, Function gtk: gtk-print-operation-set-show-progress, Function gtk: gtk-print-operation-set-support-selection, Function gtk: gtk-print-operation-set-track-print-status, Function gtk: gtk-print-operation-set-unit, Function gtk: gtk-print-operation-set-use-full-page, Function gtk: gtk-print-operation-show-progress, Accessor gtk: gtk-print-operation-status, Accessor gtk: gtk-print-operation-status-string, Accessor gtk: gtk-print-operation-support-selection, Accessor gtk: gtk-print-operation-track-print-status, Accessor gtk: gtk-print-operation-unit, Accessor gtk: gtk-print-operation-use-full-page, Accessor gtk: gtk-print-pages, Enum gtk: gtk-print-quality, Enum gtk: gtk-print-run-page-setup-dialag-async, Symbol gtk: gtk-print-run-page-setup-dialog, Function gtk: gtk-print-settings, Class gtk: gtk-print-settings-copy, Function gtk: gtk-print-settings-get, Function gtk: gtk-print-settings-get-bool, Function gtk: gtk-print-settings-get-collate, Function gtk: gtk-print-settings-get-default-source, Function  (undocumented) gtk: gtk-print-settings-get-double, Function gtk: gtk-print-settings-get-double-with-default, Function gtk: gtk-print-settings-get-duplex, Function gtk: gtk-print-settings-get-int, Function gtk: gtk-print-settings-get-int-with-default, Function gtk: gtk-print-settings-get-length, Function gtk: gtk-print-settings-get-media-type, Function  (undocumented) gtk: gtk-print-settings-get-number-up, Function gtk: gtk-print-settings-get-number-up-layout, Function  (undocumented) gtk: gtk-print-settings-get-orientation, Function gtk: gtk-print-settings-get-page-set, Function  (undocumented) gtk: gtk-print-settings-get-paper-height, Function gtk: gtk-print-settings-get-paper-size, Function gtk: gtk-print-settings-get-paper-width, Function gtk: gtk-print-settings-get-print-pages, Function  (undocumented) gtk: gtk-print-settings-get-printer, Function gtk: gtk-print-settings-get-printer-lpi, Function  (undocumented) gtk: gtk-print-settings-get-quality, Function gtk: gtk-print-settings-get-resolution, Function  (undocumented) gtk: gtk-print-settings-get-resolution-x, Function  (undocumented) gtk: gtk-print-settings-get-resolution-y, Function  (undocumented) gtk: gtk-print-settings-get-reverse, Function gtk: gtk-print-settings-get-scale, Function  (undocumented) gtk: gtk-print-settings-get-use-color, Function gtk: gtk-print-settings-has-key, Function gtk: gtk-print-settings-n-copies, Symbol gtk: gtk-print-settings-new, Function gtk: gtk-print-settings-set, Function gtk: gtk-print-settings-set-bool, Function gtk: gtk-print-settings-set-collate, Function gtk: gtk-print-settings-set-default-source, Function  (undocumented) gtk: gtk-print-settings-set-double, Function gtk: gtk-print-settings-set-duplex, Function gtk: gtk-print-settings-set-int, Function gtk: gtk-print-settings-set-length, Function gtk: gtk-print-settings-set-media-type, Function  (undocumented) gtk: gtk-print-settings-set-n-copies, Function gtk: gtk-print-settings-set-number-up, Function gtk: gtk-print-settings-set-number-up-layout, Function  (undocumented) gtk: gtk-print-settings-set-orientation, Function gtk: gtk-print-settings-set-page-set, Function  (undocumented) gtk: gtk-print-settings-set-paper-height, Function gtk: gtk-print-settings-set-paper-size, Function gtk: gtk-print-settings-set-paper-width, Function gtk: gtk-print-settings-set-print-pages, Function  (undocumented) gtk: gtk-print-settings-set-printer, Function gtk: gtk-print-settings-set-printer-lpi, Function  (undocumented) gtk: gtk-print-settings-set-quality, Function gtk: gtk-print-settings-set-resolution, Function  (undocumented) gtk: gtk-print-settings-set-resolution-xy, Function  (undocumented) gtk: gtk-print-settings-set-reverse, Function gtk: gtk-print-settings-set-scale, Function  (undocumented) gtk: gtk-print-settings-set-use-color, Function gtk: gtk-print-settings-unset, Function gtk: gtk-print-status, Enum gtk: gtk-print-unix-dialog, Class gtk: gtk-print-unix-dialog-add-custom-tab, Function gtk: gtk-print-unix-dialog-current-page, Accessor gtk: gtk-print-unix-dialog-embed-page-setup, Accessor gtk: gtk-print-unix-dialog-get-current-page, Function gtk: gtk-print-unix-dialog-get-embed-page-setup, Function gtk: gtk-print-unix-dialog-get-has-selection, Function gtk: gtk-print-unix-dialog-get-manual-capabilities, Function gtk: gtk-print-unix-dialog-get-page-setup, Function gtk: gtk-print-unix-dialog-get-page-setup-set, Function gtk: gtk-print-unix-dialog-get-selected-printer, Function gtk: gtk-print-unix-dialog-get-settings, Function gtk: gtk-print-unix-dialog-get-support-selection, Function gtk: gtk-print-unix-dialog-has-selection, Accessor gtk: gtk-print-unix-dialog-manual-capabilities, Accessor gtk: gtk-print-unix-dialog-new, Function gtk: gtk-print-unix-dialog-page-setup, Accessor gtk: gtk-print-unix-dialog-print-settings, Accessor gtk: gtk-print-unix-dialog-selected-printer, Accessor gtk: gtk-print-unix-dialog-set-current-page, Function gtk: gtk-print-unix-dialog-set-embed-page-setup, Function gtk: gtk-print-unix-dialog-set-has-selection, Function gtk: gtk-print-unix-dialog-set-manual-capabilities, Function gtk: gtk-print-unix-dialog-set-page-setup, Function gtk: gtk-print-unix-dialog-set-settings, Function gtk: gtk-print-unix-dialog-set-support-selection, Function gtk: gtk-print-unix-dialog-support-selection, Accessor gtk: gtk-printer, Class gtk: gtk-printer-accepting-jobs, Accessor gtk: gtk-printer-accepts-pdf, Accessor gtk: gtk-printer-accepts-ps, Accessor gtk: gtk-printer-backend, Accessor gtk: gtk-printer-compare, Function gtk: gtk-printer-get-backend, Function gtk: gtk-printer-get-capabilities, Function gtk: gtk-printer-get-default-page-size, Function gtk: gtk-printer-get-description, Function gtk: gtk-printer-get-hard-margins, Function gtk: gtk-printer-get-icon-name, Function gtk: gtk-printer-get-job-count, Function gtk: gtk-printer-get-location, Function gtk: gtk-printer-get-name, Function gtk: gtk-printer-get-state-message, Function gtk: gtk-printer-has-details, Function gtk: gtk-printer-icon-name, Accessor gtk: gtk-printer-is-accepting-jobs, Function gtk: gtk-printer-is-active, Function gtk: gtk-printer-is-default, Function gtk: gtk-printer-is-paused, Function gtk: gtk-printer-is-virtual, Accessor gtk: gtk-printer-job-count, Accessor gtk: gtk-printer-list-papers, Function gtk: gtk-printer-location, Accessor gtk: gtk-printer-name, Accessor gtk: gtk-printer-new, Function gtk: gtk-printer-paused, Accessor gtk: gtk-printer-request-details, Function gtk: gtk-printer-state-message, Accessor gtk: gtk-progress-bar, Class gtk: gtk-progress-bar-ellipsize, Accessor gtk: gtk-progress-bar-fraction, Accessor gtk: gtk-progress-bar-inverted, Accessor gtk: gtk-progress-bar-new, Function gtk: gtk-progress-bar-pulse, Function gtk: gtk-progress-bar-pulse-step, Accessor gtk: gtk-progress-bar-show-text, Accessor gtk: gtk-progress-bar-text, Accessor gtk: gtk-propagate-event, Function gtk: gtk-radio-action, Class gtk: gtk-radio-action-current-value, Accessor gtk: gtk-radio-action-get-current-value, Function gtk: gtk-radio-action-get-group, Function gtk: gtk-radio-action-group, Accessor gtk: gtk-radio-action-join-group, Function gtk: gtk-radio-action-new, Function gtk: gtk-radio-action-set-current-value, Function gtk: gtk-radio-action-set-group, Function gtk: gtk-radio-action-value, Accessor gtk: gtk-radio-button, Class gtk: gtk-radio-button-get-group, Function gtk: gtk-radio-button-group, Accessor gtk: gtk-radio-button-join-group, Function gtk: gtk-radio-button-new, Function gtk: gtk-radio-button-new-from-widget, Function gtk: gtk-radio-button-new-with-label, Function gtk: gtk-radio-button-new-with-label-from-widget, Function gtk: gtk-radio-button-new-with-mnemonic, Function gtk: gtk-radio-button-new-with-mnemonic-from-widget, Function gtk: gtk-radio-button-set-group, Function gtk: gtk-radio-menu-item, Class gtk: gtk-radio-menu-item-get-group, Function  (undocumented) gtk: gtk-radio-menu-item-group, Accessor gtk: gtk-radio-menu-item-new, Function  (undocumented) gtk: gtk-radio-menu-item-new-from-widget, Function  (undocumented) gtk: gtk-radio-menu-item-new-with-label, Function  (undocumented) gtk: gtk-radio-menu-item-new-with-label-from-widget, Function  (undocumented) gtk: gtk-radio-menu-item-new-with-mnemonic, Function  (undocumented) gtk: gtk-radio-menu-item-new-with-mnemonic-from-widget, Function  (undocumented) gtk: gtk-radio-menu-item-set-group, Function  (undocumented) gtk: gtk-radio-tool-button, Class gtk: gtk-radio-tool-button-get-group, Function gtk: gtk-radio-tool-button-group, Accessor gtk: gtk-radio-tool-button-new, Function gtk: gtk-radio-tool-button-new-from-stock, Function gtk: gtk-radio-tool-button-new-from-widget, Function gtk: gtk-radio-tool-button-new-with-stock-from-widget, Function gtk: gtk-radio-tool-button-set-group, Function gtk: gtk-range, Class gtk: gtk-range-adjustment, Accessor gtk: gtk-range-fill-level, Accessor gtk: gtk-range-get-flippable, Function gtk: gtk-range-get-min-slider-size, Function gtk: gtk-range-get-range-rect, Function gtk: gtk-range-get-slider-range, Function gtk: gtk-range-get-slider-size-fixed, Function gtk: gtk-range-get-value, Function gtk: gtk-range-inverted, Accessor gtk: gtk-range-lower-stepper-sensitivity, Accessor gtk: gtk-range-restrict-to-fill-level, Accessor gtk: gtk-range-round-digits, Accessor gtk: gtk-range-set-flippable, Function gtk: gtk-range-set-increments, Function gtk: gtk-range-set-min-slider-size, Function gtk: gtk-range-set-range, Function gtk: gtk-range-set-slider-size-fixed, Function gtk: gtk-range-set-value, Function gtk: gtk-range-show-fill-level, Accessor gtk: gtk-range-upper-stepper-sensitivity, Accessor gtk: gtk-rc-flags, Flags gtk: gtk-rc-style, Class gtk: gtk-rc-token-type, Enum gtk: gtk-recent-action, Class gtk: gtk-recent-action-get-show-numbers, Function  (undocumented) gtk: gtk-recent-action-new, Function  (undocumented) gtk: gtk-recent-action-new-for-manager, Function  (undocumented) gtk: gtk-recent-action-set-show-numbers, Function  (undocumented) gtk: gtk-recent-action-show-numbers, Accessor gtk: gtk-recent-chooser, Class gtk: gtk-recent-chooser-add-filter, Function gtk: gtk-recent-chooser-dialog, Class gtk: gtk-recent-chooser-dialog-new, Function gtk: gtk-recent-chooser-dialog-new-for-manager, Function gtk: gtk-recent-chooser-error, Enum gtk: gtk-recent-chooser-filter, Accessor gtk: gtk-recent-chooser-get-current-item, Function gtk: gtk-recent-chooser-get-current-uri, Function gtk: gtk-recent-chooser-get-filter, Function gtk: gtk-recent-chooser-get-items, Function gtk: gtk-recent-chooser-get-limit, Function gtk: gtk-recent-chooser-get-local-only, Function gtk: gtk-recent-chooser-get-select-multiple, Function gtk: gtk-recent-chooser-get-show-icons, Function gtk: gtk-recent-chooser-get-show-not-found, Function gtk: gtk-recent-chooser-get-show-private, Function gtk: gtk-recent-chooser-get-show-tips, Function gtk: gtk-recent-chooser-get-sort-type, Function gtk: gtk-recent-chooser-get-uris, Function gtk: gtk-recent-chooser-limit, Accessor gtk: gtk-recent-chooser-list-filters, Function gtk: gtk-recent-chooser-local-only, Accessor gtk: gtk-recent-chooser-menu, Class gtk: gtk-recent-chooser-menu-get-show-numbers, Function gtk: gtk-recent-chooser-menu-new, Function gtk: gtk-recent-chooser-menu-new-for-manager, Function gtk: gtk-recent-chooser-menu-set-show-numbers, Function gtk: gtk-recent-chooser-menu-show-numbers, Generic Function gtk: gtk-recent-chooser-recent-manager, Accessor gtk: gtk-recent-chooser-remove-filter, Function gtk: gtk-recent-chooser-select-all, Function gtk: gtk-recent-chooser-select-multiple, Accessor gtk: gtk-recent-chooser-select-uri, Function gtk: gtk-recent-chooser-set-current-uri, Function gtk: gtk-recent-chooser-set-filter, Function gtk: gtk-recent-chooser-set-limit, Function gtk: gtk-recent-chooser-set-local-only, Function gtk: gtk-recent-chooser-set-select-multiple, Function gtk: gtk-recent-chooser-set-show-icons, Function gtk: gtk-recent-chooser-set-show-not-found, Function gtk: gtk-recent-chooser-set-show-private, Function gtk: gtk-recent-chooser-set-show-tips, Function gtk: gtk-recent-chooser-set-sort-func, Function gtk: gtk-recent-chooser-set-sort-type, Function gtk: gtk-recent-chooser-show-icons, Accessor gtk: gtk-recent-chooser-show-not-found, Accessor gtk: gtk-recent-chooser-show-private, Accessor gtk: gtk-recent-chooser-show-tips, Accessor gtk: gtk-recent-chooser-sort-type, Accessor gtk: gtk-recent-chooser-unselect-all, Function gtk: gtk-recent-chooser-unselect-uri, Function gtk: gtk-recent-chooser-widget, Class gtk: gtk-recent-chooser-widget-new, Function gtk: gtk-recent-chooser-widget-new-for-manager, Function gtk: gtk-recent-filter, Class gtk: gtk-recent-filter-add-application, Function gtk: gtk-recent-filter-add-custom, Function gtk: gtk-recent-filter-add-mime-type, Function gtk: gtk-recent-filter-add-pattern, Function gtk: gtk-recent-filter-filter, Function gtk: gtk-recent-filter-flags, Flags gtk: gtk-recent-filter-info, CStruct gtk: gtk-recent-info, CStruct gtk:"	"null"	"null"	"Binding for GTK+3.."	"true"
"GUI"	"cl-gtk2"	"https://github.com/dmitryvk/cl-gtk2"	"A binding for GTK+2.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"38"	"13"	"25"	"GitHub - dmitryvk/cl-gtk2: Common Lisp binding for Gtk+ Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 13 Star 38 Fork 25 dmitryvk/cl-gtk2 Code Issues 7 Pull requests 4 Pulse Graphs Common Lisp binding for Gtk+ http://common-lisp.net/project/cl-gtk2/ 572 commits 1 branch 1 release Fetching contributors Common Lisp 99.9% Shell 0.1% Common Lisp Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show 0.1.1 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. bugs cairo doc gdk glib gtk-glext gtk pango .ditz-config .gitignore generating.lisp Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/dmitryvk/cl-gtk2"	"A binding for GTK+2.."	"true"
"GUI"	"cl-xul"	"https://github.com/mmontone/cl-xul"	"Mozilla XUL bindings.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"27"	"5"	"2"	"GitHub - mmontone/cl-xul: Mozilla XUL bindings for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 27 Fork 2 mmontone/cl-xul Code Issues 0 Pull requests 0 Pulse Graphs Mozilla XUL bindings for Common Lisp http://mmontone.github.io/cl-xul 150 commits 2 branches 0 releases Fetching contributors Common Lisp 88.4% HTML 6.2% JavaScript 5.2% Shell 0.2% Common Lisp HTML JavaScript Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Latest commit 049c866 Mar 1, 2016 mmontone Update README.md Permalink Failed to load latest commit information. doc/images Screenshots Dec 7, 2013 resources/icons Inform and prompt standard dialogs Dec 3, 2013 src Type fix Nov 29, 2015 test Update project homepage Dec 7, 2013 .gitignore First commit Nov 21, 2013 LICENSE Year update Nov 22, 2013 README.md Update README.md Mar 1, 2016 cl-xul-test.asd Tabs showcase Dec 7, 2013 cl-xul.asd No cl-who Dec 7, 2013 README.md CL-XUL CL-XUL is a library that helps to create Mozilla XUL user interfaces in Common Lisp. It uses IOlib based clws library for the communication between the Mozilla XULRunner and Common Lisp via web sockets. Because of the IOlib limitation, it works only on Linux at the moment, until a platform independent implementation of websockets is found. Also, I've only tried it from SBCL so far. CL-XUL implements a component-based architecture, standard widgets support, easy communication between client and server and automatic view updates and a readable description of GUI directly in Common Lisp, with no need of external XML files. Its implementation can be considered similar to that of the Phobos Smalltalk framework, and to the javascript implementation XULJet, although it is not quite the same. This is still work in progress, and there's no documentation at the moment (it is coming soon, though) but a demo can be tried. As of December 26 of 2013, CL-XUL can be obtained from Quicklisp. Evaluate (ql:quickload :cl-xul) to download and install the system, and (ql:quickload :cl-xul-test) followed by (xul-test:showcase) to run the demo. Alternatively, download the source code from here and point cl-xul.asd and cl-xul-test.asd system definition files from ./sbcl/system (ln -s <system definition file path>) and then evaluate: (require :cl-xul-test) and (xul-test:showcase) from your lisp listener. You will also need to satisfy the system dependencies: alexandria log5 parenscript cxml cl-fad closer-mop clws cl-json md5 The easiest way of installing those packages is via Quicklisp. This library is under the MIT licence. Screenshots Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/mmontone/cl-xul"	"Mozilla XUL bindings.."	"true"
"GUI"	"CommonQt"	"https://github.com/commonqt/commonqt"	"A Common Lisp binding for Qt4 via QtSmoke.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"60"	"17"	"11"	"GitHub - commonqt/commonqt: Official commonqt repository Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 17 Star 60 Fork 11 commonqt/commonqt Code Issues 4 Pull requests 1 Pulse Graphs Official commonqt repository http://common-lisp.net/project/commonqt/ 318 commits 5 branches 0 releases Fetching contributors Common Lisp 94.8% C++ 5.1% QMake 0.1% Common Lisp C++ QMake Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags asd child-callback defstruct master testing Nothing to show Nothing to show New pull request Latest commit 6ceee90 Mar 22, 2016 stassats Remove unused defcvars. Permalink Failed to load latest commit information. doc Documentation typo fixes. Oct 29, 2015 test Change the way applications should be started. Sep 11, 2013 tutorial Tutorial: use the new style of connecting signals. Sep 11, 2013 .gitignore .gitignore: *.so => *.so*, add Makefile. Aug 11, 2010 .travis.yml Fix .travis.yml Mar 22, 2016 LICENSE initial commit Mar 18, 2009 call.lisp Properly check that ptr types can be marshalled. Aug 24, 2015 classes.lisp Add enum-equal. Nov 10, 2014 commonqt.cpp Added support for arguments of type QVector<unsigned int>. May 3, 2014 commonqt.h Added support for arguments of type QVector<unsigned int>. May 3, 2014 commonqt.pro commonqt.pro: Add -lsmokebase needed by newer versions of smoke. Feb 19, 2012 connect.lisp Make CFFI happy with structs. Mar 25, 2013 ffi.lisp Remove unused defcvars. Mar 22, 2016 info.lisp Fix a paste typo. Jan 14, 2014 marshal.lisp Add GLint/GLuint marshalling. Mar 22, 2016 meta-classes.lisp Clean up: dynamic-object no longer needs to have qt-class metaclass. Mar 24, 2013 meta.lisp Search for override methods in the native module of a class. Fixes #13. Jan 14, 2014 package.lisp Add enum-equal. Nov 10, 2014 primitive-call.lisp Better casting across modules. Oct 29, 2015 property.lisp property.lisp: Remove manual QVariant unmarshalling, since QVariant a… Jan 18, 2013 qapp.lisp Remove enable-syntax macro for (named-readtables:in-readtable :qt). Sep 11, 2013 qlist.lisp Add more QList types marshalling. Jan 17, 2014 qt-repl.asd Added REPL integration. Mar 29, 2009 qt-test.asd Add Microbenchmarks as tests/microbench.lisp Dec 26, 2010 qt-tutorial.asd Make qt-tutorial.asd asdf2 friendly. Dec 6, 2010 qt.asd Try running qmake-qt4 if it exists. Apr 3, 2015 qvariant.lisp Do not always delete automatically created QVariants, #9. Jan 1, 2014 reader.lisp #_: Exit earlier when *read-suppress* is T. Feb 27, 2013 repl-integration.lisp qt-repl:start-gui-thread reuses the initial thread on OSX. Mar 2, 2012 unmarshal.lisp Add GLint/GLuint marshalling. Mar 22, 2016 utils.lisp cached-values-bind: Use svref instead of aref. Mar 24, 2013 Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/commonqt/commonqt"	"A Common Lisp binding for Qt4 via QtSmoke.."	"true"
"GUI"	"ltk"	"http://www.peter-herth.de/ltk/"	"A binding for the Tk toolkit. or."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"LTK - The Lisp Toolkit Home screenshots LTK - The Lisp Toolkit ""The easy way to do Lisp GUI programming"" LTK is a Common Lisp binding for the Tk graphics toolkit. It does not require any Tk knowledge for its usage. As it is written in pure Lisp, it is highly portable. Screenshots of the test program using Linux and OS X. The LTK documentation can be read online or is available as a PDF here. The latest version of Ltk is ltk-0.981.tgz. Visit the Ltk user mailinglist at http://common-lisp.net/cgi-bin/mailman/listinfo/ltk-user Comments and suggestions for further development are very welcome. Peter Herth Last modified: Tue July 12 22:11:00 CEST 2011"	"null"	"null"	"A binding for the Tk toolkit. or."	"true"
"GUI"	"ceramic"	"https://ceramic.github.io/"	"Desktop web apps with Common Lisp.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"null"	"null"	"null"	"Ceramic Documentation Source Ceramic Bring the web to the desktop. Turn web applications into native desktop apps. app.lisp ;; Load Ceramic and our app (ql:quickload '(:ceramic :lucerne-utweet))  ;; Ensure Ceramic is set up (ceramic:setup) (ceramic:interactive)  ;; Start our app (lucerne:start utweet.views:app :port 8000)  ;; Open a browser window to it (defvar window (ceramic:make-window :url ""http://localhost:8000/""))  (ceramic:show-window window) utweet Get Started Ship everywhere. Ceramic is built on top of Electron, the same library that powers the Atom text editor, and this enables it to run on the three major platforms: Windows, Mac and Linux. Compile to native executables. Don't worry about having to minify your JS: Ceramic applications are compiled down to native code, ensuring both performance and enabling you to deliver closed-source, commercial applications. *slime-repl sbcl* CL-USER> (ceramic.bundler:bundle :ceramic-hello-world                                  :bundle-pathname #p""/home/eudoxia/app.tar"") Copying resources... Compiling app... Compressing... Done! #P""/home/eudoxia/app.tar"" Example: MarkEdit Tutorial API Reference Example App Repository Organization Submit a Bug © 2015 — Fernando Borretti"	"null"	"null"	"Desktop web apps with Common Lisp.."	"true"
"Implementations"	"ABCL"	"https://common-lisp.net/project/armedbear/"	"Armed Bear Common Lisp; targets the JVM, compiles to bytecode.. with."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Armed Bear Common Lisp (ABCL) - Common Lisp on the JVM Armed Bear Common Lisp (ABCL) Project page User Manual[pdf] FAQ Testimonials 1.3.3 Release notes Paid support J - the editor Downloads Binary abcl-bin-1.3.3.tar.gz (pgp) abcl-bin-1.3.3.zip (pgp) abcl-contrib-1.3.2.jar (pgp) Source abcl-src-1.3.3.tar.gz (pgp) abcl-src-1.3.3.zip (pgp) abcl-contrib source ABCL — Common Lisp on the JVM Armed Bear Common Lisp (ABCL) is a full implementation of the Common Lisp language featuring both an interpreter and a compiler, running in the JVM. Originally started to be a scripting language for the J editor, it now supports JSR-223 (Java scripting API): it can be a scripting engine in any Java application. Additionally, it can be used to implement (parts of) the application using Java to Lisp integration APIs. Users (development with ABCL) Developers (development of ABCL) FAQ Blog Introduction: building & running Documentation Examples Testimonials Bug reporting Mailing list Source repository Technical wiki Bug tracker Contributing System requirements (Users) System requirements (Developers) One of the following JRE 1.5.0 JRE 1.6.0 (patch level 10 or higher) JRE 1.7.0 JRE 1.8.0 Running on one of the explictly supported platforms: Windows, Linux, MacOS X, OpenBSD, NetBSD, FreeBSD, Solaris or Google App Engine One of the following JDK 1.5.0 JDK 1.6.0 (patch level 10 or higher) JDK 1.7.0 JDK 1.8.0 And either Ant version 1.7.1 or higher, or A Lisp to run the lisp-based build system Licensing ABCL is covered by the GNU General Public License with Classpath exception, meaning that you can use ABCL in your application without the requirement to open the sources to your application. Hosted as part of common-lisp.net. Valid XHTML 1.0 Strict $Id: index.shtml 14834 2015-09-18 19:07:05Z mevenson $"	"null"	"null"	"Armed Bear Common Lisp; targets the JVM, compiles to bytecode.. with."	"true"
"Implementations"	"Standard conformance"	"https://common-lisp.net/project/armedbear/faq.shtml#qa"	"Armed Bear Common Lisp; targets the JVM, compiles to bytecode.. with."	"null"	"null"	"null"	"Classpath exception"	"http://www.gnu.org/software/classpath/license.html"	"null"	"null"	"null"	"null"	"null"	"FAQ: ABCL - Common Lisp on the JVM FAQ: ABCL - Common Lisp on the JVM Project page User Manual[pdf] FAQ Testimonials 1.3.3 Release notes Paid support J - the editor Frequently Asked Questions about Armed Bear Common Lisp General Questions about ABCL What is ABCL? What license is used for ABCL? How/Where should I report bugs? Is ABCL faster or slower than implementation XYZ? What is the quality of the implementation? How can you tell? Where is ABCL's source code repository? Where is ABCL's documentation? Questions about Building ABCL The Ant build process seems to recompile from scratch each time. How do I avoid this? Questions about Running ABCL Java is running out of memory with an error reporting something about ""java.lang.OutOfMemoryError: PermGen space"". What can I do? What's the name of the startup configuration file? General What is ABCL? ABCL stands for Armed Bear Common Lisp. ABCL is an implementation of Common Lisp hosted on the Java Virtual Machine. With the release of abcl-1.0, Armed Bear Common Lisp is a conforming implementation of the ANSI Common Lisp specification. The required statement of conformance is included in the User Manual. With the release of version 1.1.0, ABCL now contains a complete implementation of AMOP. What license is used for ABCL? ABCL is distributed under the GNU General Public License with Classpath exception. This is the same license as used for JAVA SE and GNU Classpath. Basically this means you can use ABCL from your application without the need to make your own application open source. In general, such usage means that whenever you keep ABCL as a separate jar file, you won't have licensing problems. The combining in the Classpath exception means that you can Extend ABCL java classes in your program Use ABCL java classes in your program Invoke ABCL lisp functions in your program without having to worry about the licensing. You do have to distribute the source code of ABCL (including modifications) if you distribute ABCL, but otherwise the license of ABCL is not viral. How/Where should I report bugs? The current state of issues can be found in the ABCL issue tracker. Individuals with an OpenID such as a Google ID may enter information directly in the bug tracker after authenticating by your provider. Alternatively, to report a bug, please mail a description of the problem, the version of ABCL you are using, and if possible a set of steps to reproduce the problem to the armedbear-devel mailing list. We endeavor to respond within a day to messages. Developers can also usually be found on the #abcl irc channel. Is ABCL faster or slower than implementation XYZ? General comparisons are hard to make, the relative speeds depend on a lot of factors. For example timing outcomes of specific bits of Java may have different timings depending on the settings of the HotSpot JIT compiler (if the tests are run on Sun). Some statements can be made in general though. Due to the fact that ABCL has been implemented in Java, it inherits some of the aspects of Java itself as well as the fact that it can't directly manipulate CPU content. Implementations such as SBCL and Closure CL can do that and take that to their advantage: for example in SBCL a boxed fixnum is a direct register value, while in ABCL it's encapsulated in an object. On the other hand, ABCL - like SBCL - supports unboxed fixnums. ABCL's fixnums support the full 32 bit range of integer values, while SBCL due to its boxing strategy can only use 29 bit integers (on 32bit platforms). Given ABCL's age - a young project by Lisp standards - there is also plenty of room for improvement in the area of execution speed and optimization. The project welcomes initiatives to improve performance. What is the quality of the implementation? How can you tell? The project recognizes there are several dimensions to quality: The level of compliance to the standard The level of 'usability': whether (or not) the application is able to run existing Lisp code The plan is to ensure that ABCL runs with the software provided by Quicklisp. For many packages available from Quicklisp, this is already the case. The first item is being measured by running the ANSI test suite compliance tests. The second item is measured by compiling and running the test suite in the Maxima application. Additionally, compilation of AP5 is used to improve this measure too. ABCL 1.1.1 fails roughly 12 out of 21702 tests in the ANSI test suite in interpreted and compiled modes, a constant number over the past releases. As a measure of 'improvement achieved', the development team refers to the number of failing tests in the Maxima test suite too. ABCL 0.23.0 is able to run the test suite without failures, coming from 'only' ca 75 failing tests at the time of 0.15.0, and even 1400 failures around October 2008. Where is ABCL's source code repository? The source code may be viewed with a web browser by visiting http://abcl.org/trac/browser/trunk/abcl/. If you want to build the source, ABCL trunk, can be checked out via Subversion (aka ""svn"") from the URI http://abcl.org/svn/trunk/abcl/. Where is ABCL's documentation? Documentation on ABCL can be found in several places, depending on the kind of documentation you're looking for. Users of the system are invited to start with the Armed Bear Common Lisp User Manual Our wiki The source code (JavaDoc and general comments) Specific examples Building The Ant build process seems to recompile from scratch each time. How do I avoid this? If the JVM system property abcl.build.incremental is set, the Ant build process will attempt to build ABCL incrementally by not removing any intermediate results. The easiest way to enable this property is to copy the 'abcl.properties.in' file to 'abcl.properties', then uncomment the line referencing the setting of the abcl.build.incremental property. Running Java is running out of memory with an error reporting something about ""java.lang.OutOfMemoryError: PermGen space"". What can I do? You need to increase the memory which the Java allocates for permanent generation (""PermGen)"" objects by using the appropriate switch on command line which invokes the JVM hosting ABCL. When the implementation compiles or loads Lisp code, it creates a separate JVM class for each top-level form. With large workloads, this can overrun the part of memory which Java reserves for storing the class definition which results in the error you are seeing. The exact manner of configuring this option unfortunately varies by Java implementation. For the Oracle HotSpot 64bit JVM, something like ""-d64 -Xmx4g -XX:MaxPermSize=1g -XX:+CMSClassUnloadingEnabled"" will not only increase the PermGen space, but will ensure you always invoke the 64bit JVM, increase the maximum memory space available to the Java to 4GiB, and allow the garbage collection of class definitions which are deemed to be unused. If you are compiling ABCL from source, a handy way to have the build process incorporate such runtime flags in the JVM invocation would be to copy the 'abcl.properties.in' file to 'abcl.properties', and then ensure that the 'java.options' variable is set to the desired options. Is there a file that customizes the startup of the ABCL process? The file ~/.abclrc is loaded by the implementation if the --noinit flag is not specified. Hosted as part of common-lisp.net. Valid XHTML 1.0 Strict $Id: faq.shtml 14741 2015-01-05 16:44:38Z mevenson $"	"null"	"null"	"Armed Bear Common Lisp; targets the JVM, compiles to bytecode.. with."	"true"
"Implementations"	"CCL"	"http://ccl.clozure.com/"	"Clozure Common Lisp; compiler-only implementation, generates native code.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Clozure CL Clozure Common Lisp Download Wiki Report Bug Documentation About Clozure CL Clozure CL (often called CCL for short) is a free Common Lisp implementation with a long history. Some distinguishing features of the implementation include fast compilation speed, native threads, a precise, generational, compacting garbage collector, and a convenient foreign-function interface. Starting with version 1.11, Clozure CL is distributed under the terms of the Apache License, version 2.0. Getting Clozure CL Clozure CL is available for the following platforms: Mac OS X 10.6 and later (x86, x86-64) Linux (x86, x86-64, ppc32, ppc64, armv7l/armv6) FreeBSD (x86, x86-64) Solaris (x86, x86-64) Microsoft Windows XP and later (x86, x86-64) See the download page to learn how to download and install Clozure CL. Documentation The documentation page has links to pre-formatted versions of the manaul. The Clozure CL wiki often contains information that hasn't yet made it into the manual. Documentation for CCL is written in a notation called CCLDoc. Please see http://trac.clozure.com/ccldoc/ for information about this format and for the source code of the manual. Support Mailing lists The mailing list openmcl-devel@clozure.com is for general and technical discussion of Clozure CL. Note that you must be a subscriber in order to post. IRC Everyone interested in Clozure CL is welcome to participate in #ccl on irc.freenode.net. The channel logs are available. We also keep logs for #lisp and logs for #scheme. Reporting bugs To report a bug or request a feature, please create a ticket. You must register before you can create a ticket. (Thanks, spammers.) Paid support Fee-based support for Clozure CL is available from Clozure Associates on a per-incident or contract basis. Please send mail to business@clozure.com for more information."	"null"	"null"	"Clozure Common Lisp; compiler-only implementation, generates native code.."	"true"
"Implementations"	"CMUCL"	"https://www.cons.org/cmucl/"	"An implementation from Carnegie Mellon University. Public domain."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"CMUCL Home Page -----   FAQ Benchmarks Credits Documentation Download Hemlock Home Install News Platforms Ports Projects Search Support  Home: a high-performance, free Common Lisp implementation CMUCL is a free implementation of the Common Lisp programming language which runs on most major Unix platforms. It mainly conforms to the ANSI Common Lisp standard. Here is a summary of its main features: Support for static arrays that are never moved by GC but are properly removed when no longer referenced. Unicode support, including many of the most common external formats such as UTF-8 and support for handling Unix, DOS, and Mac end-of-line schemes. native double-double floats including complex double-double floats and specialized arrays for double-double floats and and complex double-double floats that give approximately 106 bits (32 digits) of precision. a sophisticated native-code compiler which is capable of powerful type inferences, and generates code competitive in speed with C compilers. generational garbage collection and multiprocessing capability on the x86 ports. a foreign function interface which allows interfacing with C code and system libraries, including shared libraries on most platforms, and direct access to Unix system calls. support for interprocess communication and remote procedure calls. an implementation of CLOS, the Common Lisp Object System, which includes multimethods and a metaobject protocol. a graphical source-level debugger using a Motif interface, and a code profiler. an interface to the X11 Window System (CLX), and a sophisticated graphical widget library (Garnet). programmer-extensible input and output streams. an Emacs-like editor implemented in Common Lisp. freely redistributable: free, with full source code (most of which is in the public domain) and no strings attached (and no warranty). Like the GNU/Linux and *BSD operating systems, CMUCL is maintained and improved by a team of volunteers collaborating over the Internet. Latest News For the most up-to-date info and news, see CMUCL Gitlab Wiki. For older news see News. The old Trac wiki is still available but is deprecated in favor of the Gitlab wiki. CMUCL 21a released CMUCL 21f has been released, For information on the changes between 21a and 20f, we refer the reader to the 21a release notes. Because of the release, there will not be a 2014-10 snapshot. . CMUCL 20f released CMUCL 20f has been released, For information on the changes between 20f and 20e, we refer the reader to the 20f release notes. Because of the release, there will not be a 2014-10 snapshot. . CMUCL moves to Gitlab from Trac common-lisp.net announced that Gitlab would replace the current Trac system. The pages from Trac are slowing being migrated to CMUCL's gitlab page. CMUCL 20e released CMUCL 20e has been released, For information on the changes between 20e and 20d, we refer the reader to the 20e release notes. Because of the release, there will not be a 2013-10 snapshot. . What is Common Lisp? Common Lisp is well suited to large programming projects and explorative programming. The language has a dynamic semantics which distinguishes it from languages such as C and Ada. It features automatic memory management, an interactive incremental development environment, a module system, a large number of powerful data structures, a large standard library of useful functions, a sophisticated object system supporting multiple inheritance and generic functions, an exception system, user-defined types and a macro system which allows programmers to extend the language. Pascal is for building pyramids -- imposing, breathtaking structures built by armies pushing heavy blocks into place. Lisp is for building organisms ... Alan Perlis Printable version of this page CMUCLon Last modified 2015-10-17 by <webmaster@cmucl.cons.org> Copyright © 1999-2010 CMUCL Project Validate links, HTML, stylesheet."	"null"	"null"	"An implementation from Carnegie Mellon University. Public domain."	"true"
"Implementations"	"ECL"	"https://common-lisp.net/project/ecl/"	"Embeddable Common Lisp; compiles to C.."	"null"	"null"	"null"	"GNU LGPL2.1"	"http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html"	"null"	"null"	"null"	"null"	"null"	"Embeddable Common-Lisp Embeddable Common-Lisp News About Files Code Recent Content ECL Quarterly Volume IV posted on 2016-06-15 Table of Contents 1. Preface 2. ECL's ""what's going on"" 3. Porting Lisp Games to Android with Embeddable Common Lisp, Part 1 4. Common Lisp implementations 5. Building various implementations 6. Portability libraries 1 Preface Hello, I've managed to assemble the fourth volume of the ECL Quarterly. As always a bit off schedule but I hope you'll find it interesting. This issue will revovle around ECL news, some current undertakings and plans. Additionally we'll talk about Common Lisp implementations in general and the portability layers. I believe it is important to keep things portable. Why? Keep reading! Lately we're working with David O'Toole on making support for ECL on Android better. He wants to distribute his games on this platform and was kind enough to write an article for ECL Quarterly. Thanks to his work we've discovered various rough edges and bugs in ECL and gained some invaluable insight into the cross compilation problems of Common Lisp applications. As the final remark – I've found some time to establish a proper RSS subscription feed for ECL and ECL Quarterly. I hope that this issue will finally land on the Planet Lisp – a well known Lisp-related blog posts aggregator maintained by Zach Beane. I want to thank for the valuable feedback and proofreading to many people, especially Antoni Grzymała, Javier Olaechea, Michał Posta, Ilya Khaprov and David O'Toole. Have a nice lecture, – Daniel Kochmański ;; aka jackdaniel | TurtleWare Poznań, Poland June 2016 2 ECL's ""what's going on"" I've added a milestone with a deadline for the ECL 16.1.3 release with the bugs I want to fix. You may find it here. I'm very happy to receive a lot of positive feedback, merge requests and awesome bug reports. Thank you for that! :-) Backporting CLOS changes from CLASP was successful but we won't incorporate them in the main branch. The recently resurrected cl-bench has shown that these changes impact performance and consing negatively (check benchmarks). If you are curious about the changes, you may checkout the branch feature-improve-clos in the repository. I'm slowly working on the new documentation. This is very mundane task which I'm not sure I'll be able to finish. Rewriting DocBook to TexInfo and filling the missing parts is hard. I'm considering giving up and improving the DocBook instead. In the near future I plan to make a crowdfunding campaign to improve support for cross-compilation, Android and Java interoperability in order to boost development. More details will be probably covered in the next Quarterly issue. 3 Porting Lisp Games to Android with Embeddable Common Lisp, Part 1 3.1 Introduction Recently I ported my Common Lisp game engine ""Xelf"" to the Android operating system using Embeddable Common Lisp. Some work remains to be done before I can do a proper beta test release, but ECL Quarterly provides a good opportunity to pause and share the results thus far. This is the first part of a two-part article. The focus of Part 2 will be on performance optimization, testing, and user interface concerns. Special thanks to Daniel Kochmański, 3-B, oGMo, and the rest of the Lisp Games crew for their inspiration and assistance. 3.1.1 About the software Xelf is a simple 2-D game engine written in Common Lisp. It is the basis of all the games I have released since 2008, and can currently be used with SBCL to deliver optimized standalone game executables for GNU/Linux, MS Windows, and Mac OSX. Xelf home page: http://xelf.me/ Xelf documentation: http://xelf.me/reference.html I've also published a Git repository with all the work-in-progress scripts, patches, and libraries needed to compile Xelf for Android with Embeddable Common Lisp, OpenGL, and SDL. Android build setup: https://gitlab.com/dto/ecl-android-games-src Please note that this is a pre-alpha release and is mainly intended for Common Lisp developers looking to get a head start in building an Android game. Use with caution. Xelf is not required; you can substitute your own Lisp libraries and applications and just use the repo as a springboard. I would like to add support for CL-SDL2 as well, both as a prelude to porting Xelf to SDL 2.0, and as a way to help the majority who use SDL 2.0 for current projects. 3.2 Problems 3.2.1 Choosing an implementation As I use only Free Software for my projects, I did not consider any proprietary Lisps. Steel Bank Common Lisp now runs on Android, but SBCL as a whole cannot yet be loaded as a dynamic shared library. This is a show-stopper because Android requires the entry point of a native application to be in a shared library specially embedded in the app. Xelf works very well with Clozure Common Lisp, but CCL's Android support is not fully functional at present. So I've been quite happy to discover Embeddable Common Lisp. Its technique of translating Common Lisp into plain C has made integration with the Android NDK toolchain relatively simple. 3.2.2 Cross-compilation For performance reasons the Lisp stack (meaning LISPBUILDER-SDL, CL-OPENGL, CFFI, Xelf, the game, and all their dependencies) must be compiled to native ARM machine code and loaded as shared libraries. There is a complication in this task as regards ECL. The latter produces native code by translating Common Lisp into plain C, and then invoking the C compiler. But the C compiler toolchain is not typically present on Android, and building one that is properly configured for this task has proved difficult so far. Therefore we must cross-compile the entire Lisp stack. ECL's Android build procedure already cross-compiles the Lisp contained in ECL, but there were additional difficulties in compiling Lisp libraries which I'll cover below in the ""Solutions"" section. 3.2.3 Legacy code Xelf has improved a lot over time and gained new features, but is now outdated in some respects. When I first wrote Xelf in the 2006-2007 period SDL 1.2 was current and OpenGL Immediate mode had not yet been officially deprecated. This hasn't been a terrible problem in practical terms, given that both are still widely supported on PC platforms. But porting to Android would mean I could not procrastinate any longer on updating Xelf's SDL and OpenGL support. 3.3 Solutions 3.3.1 CommanderGenius to the rescue Help arrived for my SDL woes in the form of Sergii Pylypenko's ""CommanderGenius"", a fancy port of SDL 1.2/2.0 to Android. I can utilize the existing LISPBUILDER-SDL bindings for SDL, SDL-MIXER, SDL-TTF, SDL-IMAGE, and SDL-GFX. Not only that, there are extra features such as gamepad support, floating virtual joysticks, access to touchscreen gesture data and Android system events, support for the Android TV standard, and much more. CommanderGenius is actually designed from the start to rebuild existing SDL 1.2 / 2.0 / OpenGL projects as Android applications, and includes dozens of examples to work with. So in mid-May this year I set about splicing together Daniel Kochmański's ECL-ANDROID Java wrapper and startup code (which together load ECL as a shared object from within the app) into the CommanderGenius SDL application code and build procedures. The result is a fullscreen SDL/OpenGL application with Embeddable Common Lisp, optionally running Swank. There's even a configurable splash screen! 3.3.2 Do a little dance with ASDF ECL can compile an entire system into one FASL file, but I ran into a snag with the ASDF-based build procedure. The typical way is to compile each Lisp file and then load the resulting compiled file. But on the cross-compiler,  (load (compile-file ""myfile.lisp""))  fails because the output of COMPILE-FILE is a binary for the wrong architecture. Likewise, alien shared libraries cannot be loaded during Lisp compilation, which broke CL-OPENGL and LISPBUILDER-SDL. My temporary solution was to redefine the function ASDF:PERFORM-LISP-LOAD-FASL in my build script. My modified version does something like this instead:  (compile-file ""myfile.lisp"") (load ""myfile.lisp"")  I then invoke ECL's system builder, which spits out a big binary FASB file containing the whole system. But thanks to the LOAD statements, each Lisp file has had access to the macros and other definitions that preceded it in compilation. I'm sure this is really wrong, but it works, and the resulting FASBs load very quickly. (App startup time went from over 30 seconds when loading byte-compiled FASCs, to about 3.5 seconds.) In the end, it was simple to deal with CL-OPENGL and LISPBUILDER-SDL wanting to open shared libraries during compilation. I used Grep to find and then comment out calls to CFFI:USE-FOREIGN-LIBRARY, leaving the DEFINE-FOREIGN-LIBRARY definitions intact. This allows cross-compilation to proceed normally. Then on Android, after the FASBs are loaded I invoke USE-FOREIGN-LIBRARY on each of the required definitions. So tricking ASDF works. But aside from being a hack, it's not enough for some of the things I'd like to do. The INLINED-GENERIC-FUNCTION technique looks like a highly promising way to increase performance, but my cross-compilation trick led in this case to invalid FASB's with embedded FASC bytecodes. Indeed, to work with ECL in this situation would require actually loading the ARM-architecture compiled INLINED-GENERIC-FUNCTION binary before compiling systems that use inlining—which as mentioned above cannot be done during cross-compilation. I'm exploring other potential solutions, such as installing a GNU/Linux container on my Android development unit in order to give ECL access to a native C compiler toolchain (see below). I may even attempt to write a custom cross-compilation procedure using Clang and LLVM. But this is less urgent for now, because tweaking ASDF is sufficient to produce a working application. 3.3.3 Use OpenGL ESv1 with CL-OPENGL Luckily the the path of least resistance could prevail here. OpenGL ES version 1 is widely supported on Android devices, and is easier to port to from Immediate mode than is GLESv2. CL-OPENGL supports it right out of the box. (I'd like to thank 3-B and oGMo for their help in bridging the gap with my own code.) Some tasks remain to be done here but most of Xelf's drawing functions are now working, including TrueType fonts and vertex coloring. I've also written some code to partially emulate vertex coloring as a way of increasing render performance, and this will be covered in the forthcoming Part 2 of this article. 3.3.4 ProTip: Use the byte-compiler One issue has gone unmentioned. How do I interactively redefine functions and set variables in order to develop the running game via SLIME/Swank, if everything must be cross-compiled on an X86 system? The answer is that ECL's built-in bytecode compiler is used in these cases, and the bytecoded definitions replace the originals. I can freely use COMPILE-FILE, LOAD, and even ASDF:LOAD-SYSTEM during ""live"" development; under normal circumstances the only real difference is execution speed of the resulting code. The final game app will ship without Swank, of course, and with a fully native Lisp stack. Now you have a new problem, which is how to edit the Lisp files on your Android device so that Swank can compile and load them. 3.3.5 ProTip: Use Emacs TRAMP with ADB To make this useful you need a rooted android device.  (add-to-list 'tramp-default-user-alist '(""adb"" nil ""root"")) (find-file ""/adb::/"")  This can integrate with Emacs' ""bookmarks"" and ""desktop"" features for even more convenience. 3.3.6 ProTip: Use Emacs to inspect your APK package They're just zip files. Missing libraries or assets? Check the APK by opening it as a file in GNU Emacs. 3.3.7 ProTip: Use a GNU/Linux container for SSH and native Emacs with X11! You can actually install a GNU/Linux ""container"" with Debian, Ubuntu, or some other distribution on your Android development system in order run the Secure Shell daemon and many other applications. I use it to run a graphical Emacs on the Android box, with Emacs' X11 connection forwarded through SSH so that its windows open on my desktop GNU/Linux PC's X server—right alongside my native Emacs. I use different color themes to avoid mixing them up. This gives me full access to everything on both systems from a single mouse/keyboard/monitor, and I can cut and paste text freely between applications. Setting up such a container is beyond the scope of this article, but I highly recommend it. It was pretty easy on a rooted device, and works very well. 3.4 Conclusion In less than a month we went from ""let's do it"" to ""wow, it works!"" What more can you ask for? This concludes Part 1 of my article on building Lisp games for Android with Embeddable Common Lisp. To read my running commentary and see news and test results as they are posted, you can visit the project README: https://gitlab.com/dto/ecl-android-games-src/blob/master/README.org More details and all scripts and configurations can be found in that repository. Thanks for reading, – David O'Toole (dto@xelf.me) 11 June, 2016 4 Common Lisp implementations Some time ago I've created with the help of many kind people (most notably from Rainer Joswig and Fare Rideau) a graph presenting Common Lisp implementations and the relations between them. This version is improved over drafts presented on twitter and linkedin. If you find any errors, please contact me. It is worth noting that LispWorks and VAX share the code with Spice Lisp which later evolved into Common Lisp implementation CMUCL. Striped lines lead to CMUCL, because I didn't want to add pre-CL implementations. There is also suspicion that Lucid shares code with Spice Lisp and/or VAX, but I couldn't confirm that, so I'm leaving it as is. ""JavaScript Lisp Implementations"" classifies some lisps as CL, but I've added only Acheron and parenscript to the list, because rest is just CL-ish, not even being a subset. Resources I've found on the internet: CMU FAQ, ALU list, CLiki overview, Wikipedia article, JavaScript Lisp Implementations. 5 Building various implementations I've built various lisps to perform some benchmarks and to have some material for comparison. Ultimately I've decided to polish it a little and publish. I had some problems with Clasp and Mezzano so I've decided to not include them and leave building these as an exercise for the reader ;-). Also, if you feel adventurous, you may try to build Poplog, which has Common Lisp as one of the supported languages. If you want to read about various implementations, please consult Daniel's Weinreb Common Lisp Implementations: A Survey (material from 2010, definitely worth reading). First we create a directory for the lisp implementations (we'll build as an ordinary user) and download the sources. Each implementation has a list of building prerequisites, but it may be not comprehensive. export LISPS_DIR=${HOME}/lisps mkdir -p ${LISPS_DIR}/{src,bin} pushd ${LISPS_DIR}/src  # Obtain sources svn co http://abcl.org/svn/trunk/abcl/ abcl # git clone git@github.com:drmeister/clasp.git svn co http://svn.clozure.com/publicsvn/openmcl/trunk/linuxx86/ccl ccl hg clone http://hg.code.sf.net/p/clisp/clisp clisp git clone git@common-lisp.net:cmucl/cmucl.git cmucl git clone https://gitlab.com/embeddable-common-lisp/ecl.git ecl git clone git://git.sv.gnu.org/gcl.git gcl git clone git@github.com:davazp/jscl.git jscl # git clone https://github.com/froggey/Mezzano.git git clone https://gitlab.common-lisp.net/mkcl/mkcl.git mkcl git clone git://git.code.sf.net/p/sbcl/sbcl sbcl git clone git@github.com:wadehennessey/wcl.git wcl git clone https://github.com/gnooth/xcl.git  5.0.1 ABCL (Armed Bear Common Lisp) Requires jdk, ant pushd abcl ant cp abcl ${LISPS_DIR}/bin/abcl-dev popd  5.0.2 CCL (Clozure Common Lisp) Requires gcc, m4, gnumake pushd ccl echo '(ccl:rebuild-ccl :full t)' | ./lx86cl64 -n -Q -b  # installation script is inspired by the AUR's PKGBUILD mkdir -p ${LISPS_DIR}/ccl-dev cp -a compiler contrib level-* lib* lisp-kernel objc-bridge \    tools x86-headers64 xdump lx86cl64* examples doc \    ${LISPS_DIR}/ccl-dev  find ${LISPS_DIR}/ccl-dev -type d -name .svn -exec rm -rf '{}' + find ${LISPS_DIR}/ccl-dev -name '*.o' -exec rm -f '{}' + find ${LISPS_DIR}/ccl-dev -name '*.*fsl' -exec rm -f '{}' +  cat <<EOF > ${LISPS_DIR}/bin/ccl-dev #!/bin/sh exec ${LISPS_DIR}/ccl-dev/lx86cl64 ""\$@"" EOF chmod +x ${LISPS_DIR}/bin/ccl-dev popd  5.0.3 CLISP Requires gcc, make Notes don't build with ASDF (it's old and broken) pushd clisp ./configure --prefix=${LISPS_DIR}/clisp-dev/ \             --with-threads=POSIX_THREADS \             build/ cd build make && make install ln -s ${LISPS_DIR}/clisp-dev/bin/clisp ${LISPS_DIR}/bin/clisp-dev popd  5.0.4 CMUCL (CMU Common Lisp) Requires cmucl binary, gcc, make, openmotif Notes it needs another CMUCL to bootstrap (release 21a) pushd cmucl mkdir -p prebuilt pushd prebuilt wget https://common-lisp.net/project/cmucl/downloads/release/21a/cmucl-21a-x86-linux.tar.bz2 \      https://common-lisp.net/project/cmucl/downloads/release/21a/cmucl-21a-x86-linux.extra.tar.bz2 mkdir ${LISPS_DIR}/cmucl-21a tar -xf cmucl-21a-x86-linux.tar.bz2 -C ${LISPS_DIR}/cmucl-21a/ tar -xf cmucl-21a-x86-linux.extra.tar.bz2 -C ${LISPS_DIR}/cmucl-21a/ cat <<EOF > ${LISPS_DIR}/bin/cmucl-21a #!/bin/sh exec ${LISPS_DIR}/cmucl-21a/bin/lisp ""\$@"" EOF chmod +x ${LISPS_DIR}/bin/cmucl-21a # Note, that this is already a fully functional lisp now popd bin/build.sh -C """" -o ""cmucl-21a"" bin/make-dist.sh -I ${LISPS_DIR}/cmucl-dev/ linux-4/ cat <<EOF > ${LISPS_DIR}/bin/cmucl-dev #!/bin/sh exec ${LISPS_DIR}/cmucl-dev/bin/lisp ""\$@"" EOF chmod +x ${LISPS_DIR}/bin/cmucl-dev popd  5.0.5 ECL (Embeddable Common Lisp) Requires gcc, make ./configure --prefix=${LISPS_DIR}/ecl-dev/ make && make install ln -s $LISPS_DIR/ecl-dev/bin/ecl ${LISPS_DIR}/bin/ecl-dev  5.0.6 JSCL (Java Script Common Lisp) Requires Conforming CL implementation, web browser, nodejs Notes Doesn't provide LOAD yet (no filesystem), but author confirmed that this will be implemented (virtual filesystem on the browser and the physical one on the nodejs). mkdir ${LISPS_DIR}/jscl-dev pushd jscl ./make.sh  # Run in the console (node-repl) cp jscl.js repl-node.js ${LISPS_DIR}/bin/jscl-dev cat <<EOF > ${LISPS_DIR}/bin/jscl-dev #!/bin/sh exec node ${LISPS_DIR}/jscl-dev/repl-node.js EOF chmod +x ${LISPS_DIR}/bin/jscl-dev  # Run in the web browser (optional) cp jscl.js repl-web.js jquery.js jqconsole.min.js jscl.html style.css \    ${LISPS_DIR}/jscl-dev/ # replace surf with your favourite browser supporting JS cat <<EOF > ${LISPS_DIR}/bin/jscl-dev-browser #!/bin/sh exec surf ${LISPS_DIR}/jscl-dev/jscl.html EOF chmod +x ${LISPS_DIR}/bin/jscl-dev-browser  popd  5.0.7 GCL (GNU Common Lisp) Requires gcc, make # Doesn't work both with head and the release, luckily it works with # the next pre-release branch git checkout Version_2_6_13pre ./configure --prefix=${LISPS_DIR}/gcl-2.6.13-pre make && make install ln -s ${LISPS_DIR}/gcl-2.6.13-pre/bin/gcl ${LISPS_DIR}/bin/gcl-2.6.13-pre  5.0.8 MKCL (Man-Kai Common Lisp) Requires gcc, make pushd mkcl ./configure --prefix=${LISPS_DIR}/mkcl-dev make && make install ln -s ${LISPS_DIR}/mkcl-dev/bin/mkcl ${LISPS_DIR}/bin/mkcl-dev popd  5.0.9 SBCL (Steel Bank Common Lisp) Requires ANSI-compliant CL implementation Notes Lisp has to close on EOF in top-level (CMUCL doesn't do that), ECL has some bug regarding Lisp-to-C compiler apparently triggered by the SBCL compilation – don't use it here, we could use precompiled SBCL like with the CMUCL, but let's exploit the fact, that we can compile from the C-bootstrapped implementation (we'll use already built clisp-dev), it is advised to run the script in fast terminal (like xterm) or in the terminal multiplexer and to detach it – SBCL compilation process is very verbose, if you build SBCL on Windows, consider using MinGW to preserve POSIX compatibility. pushd sbcl export GNUMAKE=make ./make.sh ""clisp"" INSTALL_ROOT=${LISPS_DIR}/sbcl-dev ./install.sh cat <<EOF > ${LISPS_DIR}/bin/sbcl-dev #!/bin/sh SBCL_HOME=${LISPS_DIR}/sbcl-dev/lib/sbcl exec ${LISPS_DIR}/sbcl-dev/bin/sbcl ""\$@"" EOF chmod +x ${LISPS_DIR}/bin/sbcl-dev popd  5.0.10 WCL Requires tcsh, gcc, git Notes very incomplete implementation pushd wcl REV=`git rev-parse HEAD` sed -i -e ""s/WCL_VERSION = \""3.0.*$/WCL_VERSION = \""3.0-dev (git-${REV})\""/"" CONFIGURATION LD_LIBRARY_PATH=`pwd`/lib make rebuild mkdir ${LISPS_DIR}/wcl-dev cp -a bin/ lib/ doc/ ${LISPS_DIR}/wcl-dev/ cat <<EOF > ${LISPS_DIR}/bin/wcl-dev #!/bin/sh LD_LIBRARY_PATH=${LISPS_DIR}/wcl-dev/lib exec ${LISPS_DIR}/wcl-dev/bin/wcl ""\$@"" EOF chmod +x ${LISPS_DIR}/bin/wcl-dev popd  5.0.11 XCL Requires gcc Notes last commit in 2011 pushd xcl mkdir ${LISPS_DIR}/xcl-dev XCL_HOME=${LISPS_DIR}/xcl-dev make cp -a clos compiler lisp COPYING README xcl ${LISPS_DIR}/xcl-dev # This will build in XCL_HOME, even if run in source directory ./xcl <<EOF (rebuild-lisp) EOF  ln -s ${LISPS_DIR}/xcl-dev/xcl ${LISPS_DIR}/bin/xcl-dev popd  6 Portability libraries It is important to know the difference between the language standard, implementation-specific extensions and the portability libraries. The language standard is something you can depend on in any conforming implementation. Sometimes it's just not enough. You may want to do ** serializethreading*, or to *data, which is very hard to express (or even impossible) in the language provided by the standard. That's where the implementation-specific extensions kick in. Why are they called ""implementation-specific""? Because the API may be different between implementations – reaching consensus is a hard thing1. The most straightforward approach I can imagine is to reach for the documentation of the Common Lisp implementation you are currently using and to use the API provided by this implementation. I dare you not to do that! It's definitely the easiest thing to do at first, but mind the consequences. You lock yourself, and your users in the implementation you prefer. What if you want to run it on the JVM or to make it a shared library? Nope, you're locked-in. ""What can I do then?"" – you may ask. Before I answer this question, I'll tell you how many people do it (or did it in the past) – they used read-time conditionals directly in the code. Something like the following: (defun my-baz ()   #+sbcl                        (sb-foo:do-baz-thing 'quux)   #+ccl                         (ccl:baz-thing       'quux)   #+(and ecl :baz-thing)        (ext:baz             'quux)   #+abcl                        (ext:baz             'quux)   #+(and clisp :built-with-baz) (ext:baz-thingie     'quux)   #-(or sbcl ccl ecl abcl clisp)   (error ""Your implementation isn't supported. Fix me!""))  If the creator felt more fancy and had some extra time, they put it in the package my-app-compat. It's all great, now your application works on all supported implementations. If somebody wants theirs implementation to work, send the creator a patch, who incorporates it into the code and voila, everything works as desired. We have one problem however. Libraries tend to depend on one another. There is also a lot of software which uses features beyond the ANSI specification (it's all good, programmers need these!). Do you see code duplication everywhere? How many times does a snippet above have to be copy-pasted, or rewritten from scratch? It's not black magic after all. APIs between ad-hoc implementations don't exactly match, covered CL implementations differ… So you quickload your favorite library which depends on 10 other libraries which implement BAZ functionality in theirs own unique way, with a slightly different API on the unsupported implementation – that's why we have my-baz abstraction after all, right? Now, to make it work, a user has to: Find which of the ten libraries don't work (not trivial!), find and clone the repositories (we want to use git for patches), fix each one of them (grep helps!) and commit the changes, push the changes to your own forked repository and create a pull request (or send a diff to the mailing list) – *ten times*, voila, you're done, profit, get rich, grab a beer. It's a lot of work which the user probably won't bothered to do. They will just drop the task, choose another implementation or hack their own code creating the Yet Another Baz Library for the implementations he cares for reinventing the wheel once more. It's a hacker's mortal sin. I'm going to tell you now what is the Right Thing™ here. Of course you are free to disagree. When you feel that there is a functionality you need which isn't covered by the standard you should Look if there is a library which provides it. You may ask on IRC, the project's mailing list, check out the CLiki, do some research on the web. Names sometimes start with trivial-*, but it's not a rule. In other words: do your homework. If you can't find such a library, create one. And by creating such a library I mean comparing the API proposed by at least two CL implementations (three would be optimal IMHO), carefully designing your own API which covers the functionality (if it's trivial, this should be easy) and implementing it in your library. Preferably (if possible) add a fallback implementation for implementations not covered (with the appropriate warning, that it may be inefficient or not complete in one way or another). It may be worth reading the Maintaining Portable Lisp Programs paper written by Christophe Rhodes. Write beautiful documentation. A CL implementation docs may be very rough. It takes time to write them and programmers tend to prioritize code over the documentation. It's really bad, but it's very common for the documentation to be incomplete or outdated. Document your library, describe what it does, how to use it. Don't be afraid of the greatness! People will praise you, success will come, world will be a better place. And most importantly, your library will be useful to others. Publish the library. Make that library your project's dependency. I know it's not easy, but in the long term it's beneficial. I guarantee you that. That's how the ecosystem grows. Less duplication, more cooperation – pure benefit. Some people don't follow this path. They didn't think it through, or maybe they did and decided that keeping the dependency list minimal is essential to their project, or were simply lazy and hacked their own solution. There are also some old projects which exported a number of features being a very big portability library and an application at the same time (ACL-compat, McCLIM and others). What to do then? If it's a conscious decision of the developer (who doesn't want to depend on /anything/), you can do nothing but provide a patch adding your own implementation to the supported list. It's their project, their choice, we have to respect that. But before doing that you may simply ask if they have something against plugging these hacks with the proper portability library. If they don't – do it, everybody will benefit. There are a few additional benefits of the presented portability library approach for the implementations itself. Having these internal details in one place makes it more probable that your implementation is already supported. If the library has a bug it's easier to fix it in one place. Also, if the CL implementation changes it's API, it's easy to propagate changes to the corresponding portability libraries. New CL implementation creators have a simplified task of making their work usable with existing libraries. It is worth noting, that creating such library paves the way to the new quasi-standard functionalities. For instance Bordeaux Threads has added recently CONDITION-WAIT function, which isn't implemented on all implementations. It is a very good stimulus to add it. This is how library creators may have real impact on the implementation creators decisions about what to implement next. 6.1 Portability layer highlights Here are some great projects helping CL implementations be part of a more usable ecosystem. Many of these are considered being part of the de-facto standard: bordeaux-threads Provides thread primitives, locks and conditionals cl-store Serializing and deserializing CL objects from streams cffi Foreign function interface (accessing foreign libraries) closer-mop Meta-object protocol – provides it's own closer-common-lisp-user package (redefines for instance defmethod) usocket TCP/IP and UDP/IP socket interface. osicat Osicat is a lightweight operating system interface for Common Lisp on POSIX-like systems, including Windows cl-fad Portable pathname library trivial-garbage trivial-garbage provides a portable API to finalizers, weak hash-tables and weak pointers trivial-features trivial-features ensures consistent *FEATURES* across multiple Common Lisp implementations trivial-gray-streams trivial-gray-streams system provides an extremely thin compatibility layer for gray streams external-program external-program enables running programs outside the Lisp process There are many other very good libraries which span multiple implementations. Some of them have some drawbacks though. For instance IOlib is a great library, but piggy-backs heavily on UN*X – if you develop for many platforms you may want to consider other alternatives.. UIOP is also a very nice set of utilities, but isn't documented well, does too many things at once and tries to deprecate other actively maintained projects – that is counterproductive and socially wrong. I'd discourage using it. There are a few arguments supporting UIOP's state – it is a direct dependency of ASDF, so it can't (or doesn't want to) depend on other libraries, but many utilities are needed by this commonly used system definition library. My reasoning here is as follows: UIOP goes beyond ASDF's requirements and tries to make actively maintained projects obsolete. Additionally it works only on supported implementations even for features which may be implemented portably. 6.2 UIOP discussion I'm aware that my opinion regarding UIOP may be a bit controversial. I've asked the library author and a few other people for feedback which I'm very grateful for. I'm publishing it here to keep opinions balanced. 6.2.1 Fare Rideau Dear Daniel, while there is a variety of valid opinions based on different interests and preferences, I believe your judgment of UIOP is based on incorrect premises. First, I object to calling UIOP ""not well documented"". While UIOP isn't the best documented project around, all its exported functions and variables have pretty decent DOCSTRINGs, and there is at least one automatic document extractor, HEΛP, that can deal with the fact that UIOP is made of many packages, and extract the docstrings into a set of web pages, with a public heλp site listed in the UIOP README.md. The fact that some popular docstring extractors such as quickdocs can't deal with the many packages that UIOP creates with its own uiop:define-package doesn't mean that UIOP is less documented than other projects on which these extractors work well, it's a bug in these extractors. Second, regarding the deprecation of other projects: yes, UIOP does try to deprecate other projects, but (a) it's a good thing, and (b) I don't know that any of the projects being deprecated is ""actively maintained"". It's a good thing to try to deprecate other lesser libraries, as I've argued in my article Consolidating Common Lisp libraries: whoever writes any library should work hard so it will deprecate all its rivals, or so that a better library will deprecate his and all rivals (such as optima deprecating my fare-matcher). That's what being serious about a library is all about. As for the quality of the libraries I'm deprecating, one widely-used project the functionality of which is completely covered by UIOP is cl-fad. cl-fad was a great improvement in its day, but some of its API is plain broken (e.g. the :directories argument to its walk-directory function has values with bogus names, while its many pathname manipulation functions get things subtly wrong in corner cases), and its implementation not quite as portable as UIOP (that works on all known actively used implementations). There is no reason whatsoever to ever choose cl-fad over UIOP for a new project. Another project is trivial-backtrace. I reproduced most of its functionality, except in a more stable, more portable way (to every single CL implementation). The only interface I didn't reproduce from it is map-backtrace, which is actually not portable in trivial-backtrace (only for SBCL and CCL), whereas serious portable backtrace users will want to use SLIME's or SLY's API, anyway. As for external-program, a good thing it has for it is some support for asynchronous execution of subprocesses; but it fails to abstract much over the discrepancies between implementations and operating systems, and is much less portable than uiop:run-program (as for trivial-shell, it just doesn't compete). UIOP is also ubiquitous in a way that other libraries aren't: all implementations will let you (require ""asdf"") out of the box at which point you have UIOP available (exception: mostly dead implementations like Corman Lisp, GCL, Genera, SCL, XCL, may require you to install ASDF 3 on top of their code; still they are all supported by UIOP, whereas most portability libraries don't even bother with any of them). This ubiquity is important when writing scripts. Indeed, all the functionality in UIOP is so basic that ASDF needed it at some point — there is nothing in UIOP that wasn't itself required by some of ASDF's functionality, contrary to your claim that ""UIOP goes beyond ASDF's requirements"" (exception: I added one function or two to match the functionality in cl-fad, such as delete-directory-tree which BTW has an important safeguard argument :validate; but even those functions are used if not by ASDF itself, at least by the scripts used to release ASDF itself). I never decided ""hey, let's make a better portability library, for the heck of it"". Instead, I started making ASDF portable and robust, and at some point the portability code became a large chunk of ASDF and I made it into its own library, and because ASDF is targetting 16 different implementations and has to actually work on them, this library soon became much more portable, much more complete and much more robust than any other portability library, and I worked hard to achieve feature parity with all the libraries I was thereby deprecating. Finally, a lot of the functionality that UIOP offers is just not offered by any other library, much less with any pretense of universal portability. 6.2.2 David Gu For the documentation thing, I really think Quickdocs could do a better job. The bug #24 stated that problem, however, it's remain to be solved. I will check this out if I have free time recently. I use UIOP a lot in my previous company, the reason is simple and maybe a little naive: my manager didn't want to involve too many add-ons in the software. UIOP is shipped together with ASDF, it's really ""convenient"", and its robustness is the final reason why I will stick to it. If people understand how UIOP came out in the history from ASDF2 to ASDF3, I think people will understand why it's acting like deprecating several other projects – that's not the original idea of it. But anyway, I really learned a lot from this post and also the comments. In my opinion, avoid reinventing the wheels is the right idea and directions for this community. So from that perspective, I support @fare's idea ""It's a good thing to try to deprecate other lesser libraries"". Including this article and along with Maintaining Portable Lisp Programs and @fare's Consolidating Common Lisp Libraries, we should let more people involved in this topic. Footnotes: 1 If you are Common Lisp implementer and plan to add a feature beyond ANSI specification, please consider writing a proposal and submitting it to Common Lisp Document Repository. It will make everybody's life easier. New website look posted on 2016-04-22 I've imported the old archives and genearated ECL website with help of the coleslaw and the sclp. Now we have a proper RSS feed and posting news is less annoying then before. For posterity, here is the ugly hack I've used to import archives from JSON: (defparameter *archives-template* "";;;;; title: ~A tags: date: ~A author: ~A format: md ;;;;; ~A"") (setf *json-posts* (with-open-file (f #P""/home/jack/linki/repo/ecl-website/static/files/misc/news-ecl-backup-2015-08-25.json"" :direction :input :external-format '(:line-termination :cr :character-encoding :utf-8)) (cl-json:decode-json f))) (mapcar (let ((cnt 0)) #'(lambda (post) (with-open-file (f (format nil ""/tmp/archives/archive-~A.post"" (incf cnt)) :direction :output :if-exists :supersede :external-format (make-external-format :line-termination :unix)) (format f *archives-template* (cdr (assoc :title post)) ;; (cdr (assoc :labels post)) (substitute #\- #\/ (subseq (cdr (assoc :url post)) 40 47)) (let ((author (cdr (assoc :author post)))) (if (string-equal author ""dkochmanski"") ""jackdaniel"" author)) (remove #\Return (cdr (assoc :text post))))))) (cdar *json-posts*)) You may find a guide how to use the Sample Common Lisp Project template for your own project here. The clnet theme is inspired by the css in most of the common-lisp.net projects. Best regards, Daniel Bountysource Salt account posted on 2016-03-04 We have set up an account on the bountysource to simplify the financial contributions to the project. Additionally you may send money contributions with a PayPal account: ECL 16.1.2 release posted on 2016-02-29 We are happy to inform that the official ECL 16.1.2 release is available for download: Source archive Windows binary installer (x86) ECL Quarterly Volume III posted on 2016-02-06 Table of Contents 1. Preface 2. Stupid ECL tricks 3. ADIO project with ECL and a bunch of electronic devices 4. ECL Android port 1 Preface Dear all, I'm proud to publish the third ECL Quarterly volume. I'm aware that it's a bit late, but very happy that delay didn't extend any further. Some exciting stuff is going on. First of all Embeddable Common-Lisp has been successfully ported to the Android platform. Additionally we have untested ports to NaCL and PNaCL (any volunteer?) and an alpha quality Android application - ecl-android (fully fledged swank-accessible Common Lisp running in Dalvik via JNI with all the goodies ECL provides). I'm very happy to open this volume with a great guide written and contributed by Earl Ducaine – Stupid ECL tricks. This is set of a very useful hints for the development with ECL. We invite everyone to contribute to the repository located at Earl's GitHub repository. Moreover Angelo Rossi has finished his project embodying ECL on the embedded board SBC MIPS Creator CI20 and written very nice summary to share with us. Third chapter will resolve around the Android port and how to build the ecl-android application. I want to apology for this delay everyone, who waited for this volume. I'm quite busy lately and despite having some unfinished material I couldn't find time to polish it, so I've decided to skip it for the next volume. I'm very grateful to both Earl and Angelo for providing good material for a readers. I hope the next volume will be published very soon, or at least on schedule :-). Thank you for waiting. We're testing now a new release of ECL (version number 16.1.2) and if everything goes fine it will be released on February 29th. If you are curious about the changes, you may skim the ""Pending changes"" section here. *Please* send all the feedback to the mailing list or directly to me. It is really ensuring to know, that someone reads this. Also if you want to be published here please let me know. Thank you! – Daniel Kochmański ;; aka jackdaniel | TurtleWare Poznań, Poland February 2016 2 Stupid ECL tricks Mostly these are half baked hacks. But hopefully they stimulate the imagination of real programmers by providing a glims of what ELC is cabable of. 2.1 Running ECL in gdb. I've always had a total mental block when it comes to C pointers. It makes no sense to my brain that * indicates a variable is a pointer when used in a declaration, but retrieves a value when used as an operator. And an array of pointers to a character string makes total sense to me in words but char** str[] causes my mind to go blank. As a consequence any C code I write, or even look at too intently immediately blows up when compiled and run. A big inconvenience when embedding Lisp. Replacing the usual, (setq inferior-lisp-program ""ecl"")  with, (setq inferior-lisp-program       ""gdb --eval-command=run --eval-command=quit --args ecl"")  Will run ecl under gdb, which will provide you the normal gdb environment with c runtime errors, while throwing you into the lisp debugger for Lisp errors. Note that gdb by default breaks on SIGPWR and SIGXCPU which ecl uses for internal processing. So, you'll also want to add the following to your .gdbinit file. handle SIGPWR nostop noprint handle SIGXCPU nostop noprint  2.2 Embedding Swank in a c application. Swank is a Lisp program that provides remote access to a Lisp instance. It started as client/server application layer in CMUCL and the Hemlock editor it ran. It's since been ported to most Lisps. Slime is the Emacs front-end client to Swank. Together the two tools provide a powerful Lisp development environment in Emacs. The easiest way to install Swank and Slime is simply to get it from quicklisp. See: https://www.quicklisp.org/beta/ Swank and slime work in following way: +----------+     launch ecl in                +--------------------+  | emacs    |---- process buffer, tell ------> | ecl process buffer | +----------+     ecl to start swank           +-----+--------------+                             |                                                       |    |                                         start swank server: create slime                                 (swank-loader:init) buffer                                       (swank:start-server)    |                                                |    |                                                |   \/                                              \/ +--------------+      integrated      +--------------------------------+ | repl:        +<---- lisp repl   --->| swank server listening         | | slime buffer |      interaction     | on some arbitrary              | +--------------+                      | TCP/IP port e.g.               |                                       | ""Swank started at port: 46493"" |                                       +--------------------------------+                                                       /\ +--------------------------+                           | | edit:                    +<--------------------------+ | buffer with Lisp source  | +--------------------------+  To embed swank in a C application we need the application to launch Swank and then for Emacs to establish the connection to the swank server using slime-connect. Below is the C code that launches Swank. Note, the following example is for a GNU/Linux type system. ecl needs to explicitly load load a shared library in order to access binary symbols such as C functions or C variables in the process, this is a hackish way of handling it since the library was already loaded when the applicaiton started, and could cause problems on platforms that put different constraints on loading shared libraries. /* -*- mode: c;  -*-    file: main.c */  #include ""app_main.h"" /* a.out wrapper for call into a shared library. */ int main() {   return app_main(); }  /* -*- mode: c;  -*-    file: app_main.h */  #ifndef __APP_MAIN_H__ #define __APP_MAIN_H__  #include <ecl/ecl.h>  int app_main();  #endif /* APP_MAIN_H */  The following creates the shared library app_main used by both the C program and ECL for symbols. The embedded ECL code initializes the ECL environment and calls the Common Lisp load function to load a local Lisp file with the code to run swank. /* -*- mode: c;  -*-    file: app_main.c */  #include <stdlib.h> #include <math.h> #include ""app_main.h""  void run_swank();  /* TODO: Are embedded quotes really needed? */ char start_swank[] =   ""\""/mnt/pixel-512/dev/stupid-ecl-tricks-1/start-swank-server.lisp\"""";  char* argv; char** pargv;  int app_main() {   argv = ""app"";   pargv = &argv;    cl_boot(1, pargv);   atexit(cl_shutdown);    /* Set up handler for Lisp errors to prevent buggy Lisp (an */   /* imposibility, I know!) from killing the app. */   const cl_env_ptr l_env = ecl_process_env();   CL_CATCH_ALL_BEGIN(l_env) {     CL_UNWIND_PROTECT_BEGIN(l_env) {       run_swank();     }     CL_UNWIND_PROTECT_EXIT {}     CL_UNWIND_PROTECT_END;   }   CL_CATCH_ALL_END;    return 0;  }  void run_swank() {   cl_object cl_start_swank_path = c_string_to_object(start_swank);   cl_object cl_load =  ecl_make_symbol(""LOAD"",""CL"");   cl_funcall(2, cl_load, cl_start_swank_path);   return; }  The following Lisp file, loaded by appmain, contains a couple of snippets of code I copied from the Emacs Slime client that launches the Swank server. When Swank launches it will print out the socket you can use to connect to it, e.g. ;; Swank started at port: 58252. you can then connect to it in Emacs using Slime: M-x slime-connect ;;; -*- mode: lisp ; syntax: ansi-common-lisp -*-  ;; standard quicklisp init file, since with be launching ecl without ~/.eclrc (let ((quicklisp-init (merge-pathnames ""quicklisp/setup.lisp""                                        (user-homedir-pathname))))   (when (probe-file quicklisp-init)     (load quicklisp-init)))  (when (probe-file  ""/tmp/slime.2565"")   (delete-file ""/tmp/slime.2565""))  (load  ""~/quicklisp/dists/quicklisp/software/slime-2.14/swank-loader.lisp""  :verbose t)  (funcall (read-from-string ""swank-loader:init"")) (funcall (read-from-string ""swank:start-server"")          ""/tmp/slime.2565""))  A quick and dirty script file to build a shared library. # -*- mode: bash;  -*-   rm -f *.o *.so app  export libs=""-lm""  # Note, the -Wl,-R flags will make our shared library available to the # executable app from the location that it was compiled, rather than # having to be installed globably or adding the build path to # LD_LIBRARY_PATH.  export ldflags=""-L. -Wl,-R -Wl,."" export cflags=""-DGC_LINUX_THREADS -D_REENTRANT -fPIC  -g -pipe -Wall""  gcc $cflags -c app_main.c gcc -shared -Wl,-soname,libapp_main.so $ldflags -lecl -o libapp_main.so *o $libs gcc main.c $cflags $ldflags -lapp_main -lecl -o app  To build and run $ ./build_app.sh $ ./app  2.3 Troubleshooting compilation problems with ffi:c-inline ECL provide a facility for embedding C code directly in Lisp code like the following: (defun c-sin (x)   (ffi:clines ""#include \""ecl/ecl.h\"""")   ;; Whoops!  mathh.h should be math.h   (ffi:clines ""#include <mathh.h>"")   (ffi:clines  ""#include \""app_main.h\"""")   (ffi:c-inline (x) (:double) :double ""{ @(return 0)= sin(#0); }"" :one-liner nil))  To use this function you need to compile the defun. When you issue the explicit compile, (compile 'c-sin) ECL will invoke your underlying C compiler. However, C syntax and header include errors, like we included in the above example, will cause compilation to fail. Unfortunately, ECL doesn't pass along the compilers output. You'll get something like the following: ;;; OPTIMIZE levels: Safety=2, Space=0, Speed=3, Debug=3 ;;; ;;; End of Pass 1. ;;; Internal error: ;;;   ** Error code 1 when executing ;;; (RUN-PROGRAM ""gcc"" (""-I."" ""-I/usr/local/include/"" ""-D_GNU_SOURCE"" ""-D_FILE_OFFSET_BITS=64"" ""-g"" ""-O2"" ""-fPIC"" ""-D_THREAD_SAFE"" ""-Dlinux"" ""-O2"" ""-c"" ""/tmp/ecl001QoKf80.c"" ""-o"" ""/tmp/ecl001QoKf80.o""))  if you try to recreate the error by invoking the implied shell command: $ gcc -I. -I/usr/local/include/ -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 \     -g -O2 -fPIC -D_THREAD_SAFE -Dlinux -O2 -c /tmp/ecl001QoKf8.c \     -o /tmp/ecl001QoKf80.o  You'll get the error: gcc: error: /tmp/ecl001QoKf80.c: No such file or directory gcc: fatal error: no input files compilation terminated.  Because ECL has already cleaned it from /tmp. But, ECL has a special variable, compiler::*delete-files* that controls cleaning up c output files. By setting it to nil, (setf compiler::*delete-files* nil) you can troubleshoot compilation errors. Re-running above gcc command on from the Unix shell gives us the following: In file included from /tmp/ecl001QoKf80.c:6:0: /tmp/ecl001QoKf80.eclh:8:19: fatal error: mathh.h: No such file or directory #include <mathh.h>                 ^ compilation terminated.  2.4 Cache Files Swank and ECL's embedded C in Lisp facility seem to have some issues with caching where compiled C snippets and a Swank images don't get refreshed when they should (at least on GNU/Linux). If you start noticing strange issues with changes to ffi:c-inline not taking effect or Swank having the wrong image, try deleting the following cache files: rm -rf ~/.cache/common-lisp/ecl-15.2.21-ee989b97-linux-x64 rm -rf ~/.slime  /Earl Ducaine/ 3 ADIO project with ECL and a bunch of electronic devices 3.1 Synopsis This document describe my experience with the SBC MIPS Creator CI20 from Imagination and ecl (Embeddable Common Lisp) interpreter/compiler. The goal is to program a distributed diagnostic/supervision system for DVB transmitter equipment's. 3.2 The experience The Creator CI20 comes with a linux Debian Jessie distro preinstalled on its 8 GB internal flash drive. After upgrading it and install some packages I was ready to deploy ECL. The version choosen for the prototype was the 16.1.0, compilation was really straightforward (I modified a bash script written for SBCL to download, compile and install the git version of ECL) and after 20/30 minutes of code crunching I've got a shiny working ECL. I must say that problems didn't come from ECL itself, but from other packages. As I installed quicklisp soon came troubles, for example: slime does not add the correct architecture to the *features* variable and some other minor problems with iolib too. The Lisp community is the most active and helpful among those living on irc and with their help I've got fixed and ready in short time. The project I'm currently working on is divided in two main areas: the hardware design and test phase and the software one. The first, at this stage, contemplates the design and production of a limited number of ADIO boards (designed by me). More basic an ADIO board is an insulated analog and digital i/o board, it is interfaced with the Creator CI20 via the i2c bus and externally powered. The software part is the more vast part of the project. The idea is to provide a system that is able to interface to external users and feed them with sensors data regarding the state of the DVB apparatuses plus every ADIO + Creator CI20 hold the configuration for the apparatus they're going to monitor/supervise. In addition to that the system should be responsible to warn about anomalies and take some pre-emptive actions just to not make the whole thing blow up. So the Customer was facing a dilemma: Arduino + RS485 and a lot of amulets or rely on a modern and saner idea? My advice for the landing party was: ""why do not use a cheap sbc (80 Eur) with an embedded OS powered by a Lisp interpreter?"" here are the benefits: ethernet based communication hardware layer is proven to be cost effective and reliable, plus every oses and cheap sbcs support it; an embedded os, in most cases, is better than start a baremetal application: e.g. tcp/ip connections and standard network services like http, ftp, ssh, samba and snmp require a lot time to program, debug and test even if you use on the shelf solutions. on the contrary with an embedded os you've got these things already coded and ready to use, shortening the deployment time of about one order of magnitude (in man hours); using lisp is useful for almost three aspects: portability, remote debugging and last but not least the possibility to create compiled code for mips; possibility to expand hardware and software via external modules. So lisp at last, the first prototype is now running a test code which provide basic functionalities like: a general i2c library to access the linux i2c device via /dev/i2c-*, a simple i2c gpio expander library for the mcp23017 and another library to cope with hitachi compatible 16x2 lcd and a simple looping program which displays some random characters on it. next improvements are ready to be tested too, like a machine learning algorithm to detect anomalies and so on. 3.3 Last words At this stage, ECL was truly the right choice: first of all the time to develop this small set of libraries was incredibly short compared to c/c++ due to that now I've got a test prototype running on my desk happily showing on a 16x2 display some test patterns in just about one month circa from Lisp environment setup. I must thank the friend PJB for his invaluable help and patience and jackdaniel for his work on ECL and the patience too. /Angelo Rossi/ 4 ECL Android port I'm happy to announce, that the android port has been merged to the develop branch of the main ECL repository. This work is mainly based on Sylvain Ageneau's work. I've also adjusted and incorporated NaCL and pNaCL patches but these are not tested (yet). To use ECL fully on the android, user want's to have an application which may be started from within the phone, not in the terminal. That's why I've created a separate project ECL Android which is based on Sylvain's integration example code (further adjusted by Evrim Ulu). For now it is in alpha state and it's discouraged to use it in applications meant for the end user. The following sections will explain current compilation process of the ECL and how to build ECL Android application and deploy it to the computer. 4.1 Building ECL ECL may be built as a library. This great feature allows us to dynamically link ECL with arbitrary applications capable of using shared objects. We take advantage of this and the fact, that the android platform allows us to embed shared objects with the .apk and use it with the Java Native Interface (JNI). To use libecl we first need to cross compile it for the target platform. There is some work pending to simplify the cross compilation process, but for a time being you have to build a host ECL compiler and after that the target library. Before that, however, you have to build a proper android toolchain. If you don't have a prebuilt one you may use android NDK scripts. Both Android SDK and NDK are a prerequisites and installing them is an exercise for the reader. export PLATFORM_PREFIX=/opt/toolchains/android-ndk9/ export NDK_PATH=/opt/android-ndk/ export NDK_PLATFORM=android-12  mkdir ${PLATFORM_PREFIX} /opt/android-ndk/build/tools/make-standalone-toolchain.sh \     --platform=${NDK_PLATFORM} \     --install-dir=${PLATFORM_PREFIX} \     --arch=arm  export PATH=${PLATFORM_PREFIX}/bin:${PATH}  Now you have to build the host compiler1 and the final library for the android. Note, that using the preexisting ECL binary could work if you it is a 32 bit installation with disabled longdouble. ./configure ABI=32 CFLAGS=""-m32 -g -O2"" LDFLAGS=""-m32 -g -O2"" \             --disable-longdouble \             --prefix=`pwd`/ecl-android-host \             --enable-libatomic=included  make && make install export ECL_TO_RUN=`pwd`/ecl-android-host/bin/ecl rm -r build  ./configure --host=arm-linux-androideabi \             --prefix=`pwd`/ecl-android-target \             --with-cross-config=`pwd`/src/util/android.cross_config \             --disable-soname  # You have to adjust build/cross_config to your settings (especially # set ECL_TO_RUN to your host ecl) make && make install  You should have libecl.so and the other necessary files in the ecl-android/ directory. Some pre-compiled modules are located in the ecl-android/lib/ecl-16.1.0 directory. You will want them on the target system. 4.2 ECL Android (application/service) This application isn't stable yet and documentation is still rather scarce. API isn't stable and it is discouraged to base any work on it for now. It is provided on terms of AGPL-3.0+ license, however alternative licensing is possible. First thing to do is to clone the repository and adjust the project configuration to your local setup. git clone https://gitlab.common-lisp.net/ecl/ecl-android.git cd ecl-android # update the project (sets sdk path and the other android ""magic"") android update project -t android-10 -p . # create symlinks (sets ECL directories). For instance: ln -s ../ecl-android-target ecl-android ln -s ecl-android/lib/ecl-*.*.* ecl-libdir  Now it's worth to explain how the application works on the target platform. We put the library libecl.so in the apk file, but rest of the module and other ECL-related files are packed as a resource in the assets/lisp/ directory at which *default-pathname-defaults* points to. Initialization is performed by assets/lisp/etc/init.lisp file, which loads the user.lisp. The latter contains some sample code loading swank (if it's put in the home/slime-2.14/ directory – swank is not bundled with the repository) and defines auxiliary functions: #'get-quicklisp, #'start-swank and #'stop-swank. Function #'get-quicklisp will download and install the Quicklisp. It will also replace it's bundled compression tools with a prebuilt one (it is essential for performance – GCC produces faster code then the byte compiler). Before you build the ecl-android you may want to copy some files for further use and edit the initialization script: mkdir assets/lisp/home cp -rf ~/things/slime-2.14 assets/lisp/home cp ~/things/my-awesome-lisp-app/awesome.lisp assets/lisp/ emacs assets/etc/user.lisp  When you are ready you may build and deploy the application on the phone: ndk-build ant debug install  ECL Android launcher should appear on your phone. Footnotes: 1 If your host platform is darwin, then the host compiler should be built with the Apple's GCC (not the GCC from Macports). Using the MacPort command: sudo port select --set gcc none  Hint provided by Pascal J. Bourguignon. ECL Android 0.0.1 posted on 2015-11-07 ECL Android 0.0.1 has been released. Keep in mind that this is an alpha quality software for the preview purposes. Prebuilt apk is based on the ECL repository, not the 16.0.0 release. More in-depth information will be provided in the upcoming ECL Quarterly. Please send a feedback to the mailing list or directly to me. EclAndroid-0.0.1.apk ECL Android repository Enjoy :-). ECL 16.0.0 release posted on 2015-09-28 We are happy to inform that the official ECL 16.0.0 release is available for download: Source archive Windows binary installer (x86) ECL Quarterly Volume II posted on 2015-09-16 Table of Contents 1. Preface 2. Sourceforge migration 3. Embeddable Common-Lisp 16.0.0 (new release) 4. ECL future 5. On Lisp (not a book!) 6. Advertisement 1 Preface Hello! Three months has passed (plus a few days - 25 actually) and a new volume of ECL Quarterly arises — as promised. Highlights of this volume: Embeddable Common-Lisp 16.0.0 (new release) A few words about new ECL release ECL future Things we consider implementing in the future On Lisp (not a book!) Three short essays about unique ECL C/C++ inlining feature (in the form of a tutorial), the ANSI CL specification in the context of LET, FLET and LABELS block, and non ANSI compliant extensions of the reader syntax I've recently started my own company – TurtleWare. There is a shameless plug at the end of the volume with information that I'm open for consultancy work. Everyone is free to skip the last section. I also want to remind everyone that the main project site (containing all further resource pointers) is located at: https://www.common-lisp.net/project/ecl If you have any suggestions regarding the Quarterly – you like it? or maybe you hate it? – please tell me either by writing to the mailing list or by writing an e-mail directly to me. If you want your own article or tutorial to be published in this e-zin – please drop me an e-mail (daniel[at]turtleware.eu). Thank you! – Daniel Kochmański ;; aka jackdaniel Poznań, Poland August 2015 2 Sourceforge migration Until now we had a few remaining resources kept on Sourceforge: Mailing lists Release source archive Announcements / blog channel All these have now been moved to the common-lisp.net servers (https://www.common-lisp.net/project/ecl). All members of the mailing list did get an invitation e-mail to the new one. The obsolete list will be shut down at September 1st. Mailing list archives are already imported, so we won't lost any accumulated threads. I owe a big thanks to Erik Huelsmann for help with the migration and for his constant work on the common-lisp.net platform. Without him, such migration would be somewhere between a nightmare and the impossible. Thanks! 3 Embeddable Common-Lisp 16.0.0 (new release) 3.1 Announcement We are happy to announce that the new ECL release has been published. Version 16.0.0 has various improvements over the previous one mostly focused on the interoperability with the existing CL libraries ecosystem, pushing forward ANSI compliance and increasing portability across various platforms. Significant (ongoing) efforts have been made to improve general code quality – removing dead blocks and interfaces, untabifying sources and refactoring parts of the code base. Also we've refreshed the testing framework. Documentation has been verified and updated. We owe big ""thank you"" to many people who helped us with understanding the ANSI spec and pointing us in the right direction when in doubt, and to those who bothered to report issues and provide test cases. These discussions took place mostly on IRC and via the ""Issues"" tab on the GitLab platform. Unfortunately I don't remember all the nicks and names, so it would be unfair to list only a few I remember. People who have contributed to this release are (alphabetically): Daniel Kochmański, Philipp Mark, Roger Sen and Evrim Ulu. Without further ado – the changes: 3.1.1 Known issues In Windows, ECL comes with the bytecode compiler by default, because C compilers are normally not available. Unfortunately several libraries out there are not prepared for this. If you plan to use quicklisp and have a C compiler accessible to ECL, you may use (ext:install-c-compiler) to switch back to the Lisp-to-C compiler. In order to test a package, programmer has to install ECL on a desired destination (specified with ""–prefix"" parameter given to the configure script). 3.1.2 API changes There is no UFFI nickname for the FFI package - we piggyback on cffi-uffi-compat for UFFI dependent systems (our UFFI wasn't version 2.0 compatible and there were problems with ADSF dependencies on UFFI - it wasn't a system) CLOS has the new nickname ""MOP"" The new ext:run-program :error argument can automatically create a separate stream if provided with the :stream keyword. The external-process structure also has a new field to hold that stream. ext:run-program accepts new arguments - :if-input-does-not-exist, :if-error-exists and :external-format ext:system no longer binds ** standard-outputstandard-input* and *and now ignores input and output (use ext:run-program for more control) methods can be specialized on both single-float and double-float (built-in classes were added for them) LET/FLET/LABELS will signal an error if the parameter of the same name appears multiple times lambda lists with repeated required parameters name are considered invalid deprecated configure options ""–with-system-boehm=x"" and ""–enable-slow-config"" removed 3.1.3 Enhancements Verification if manual is up-to-date, providing corrections for outdated parts Documentation is now included in the main repository under the top-level directory `doc' Update libffi to version 3.2.1 Update asdf to version 3.1.5.4 Update Boehm-Demers-Weiser garbage collector to version 7.4.2 Pathname string-parts internal representation is now character, not base-char Dead code removal, tabulators were replaced by spaces Better quality of generated code (explicit casting when necessary) 3.1.4 Issues fixed Various fixes of bogus declarations Remove deprecated GC calls ROTATEF, SHIFTF, PSETF reworked to conform to the ANSI standard. Places were handled improperly in regard of multiple values. Improved Unicode support in character handling Format handles floats and exponentials correctly (major format rework) Stack limits refinements and cleanup, inconsistency and bug fixes Duplicate large block deallocation with GMP 6.0.0a fixed ECL builds on OpenBSD with threads enabled Closures put in mapcar work as expected in both compiled and interpreted code Improved readtable-case handling (:invert and character literals now conform) Library initialization functions have unique names - no risk of clashing symbol names in object files Format float bug fixed, when width and fdigits were not set, but k was `logical-pathname-translations' now signals an error if logical pathname wasn't defined yet, to conform with ANSI (it used to return NIL) Wildcards in logical pathname translations are replaced correctly Regression testing framework and unit tests cleanup deftype ANSI conformity fix (deftype accepts macro labda-lists) ECL built with MSVC doesn't crash when Control-C is pressed Other minor tweaks 3.2 New version numbering scheme The data-based version numbering scheme is ceased from this release. From now on all the releases will follow the rules described in https://autotools.io/libtool/version.html. Basically release numbers will follow the scheme X.Y.Z, where X increases when the API changes, Y if interfaces are added (but not removed) or changed in mostly backward compatible and Z is the ""patch level"" part, which changes for fixes not affecting API. All new releases are considered ABI incompatible, so the sources have to be recompiled with each new release (this is the default when using ASDF). 4 ECL future There is plenty of work to be done and many ideas to realize. We can't do it all at the same time and all the further points are rather loose ideas than plans for the next release. Just a food for thought. Dynamic Foreign Function Interface ECL has a decent DFFI for a small set of platforms (x86, x8664 and PPC32) hand coded with assembly. ECL on other platforms doesn't support DFFI with the bytecode compiler and requires the C backend (function calls are inlined in the generated C code). On the other hand, we already depend on libffi with regard to closures. We can use it for DFFI as well – it has a really impressive list of supported platforms and using it for that will be a big win. Cross-compilation framework We are able to cross-compile applications with host the ECL and GCC toolchain, but this is somewhat painful and we have no convenient interface for doing that at run-time from the REPL user perspective. Compilation flags and parameters are stored as global variables and API for cross compilation is documented. Juan Jose Garcia Ripoll started to make the target machine description separate from the host implementation. On the other hand Sylvain Ageneau created the cross-cmp compiler package. I haven't investigated either work in great detail, but I see an opportunity to combine both these works for greater support for the cross comilation. Sylvain's repository (https://github.com/ageneau/ecl-android) seems to be a place full of real treasures worth merging back to the main repository. Cross-compiling applications for Android to native code is definitely something I could put to good use ;-) Documentation improvements Many exported functions and interfaces are undocumented or existing documentation is scarce. More usage examples and verification of ""examples/"" src directory would be a good thing too. The official manual layout could be refined to allow html ""one-page"" builds (source is in DocBook). C compiler on-board Providing an optional C compiler package to be bundled as fallback with ECL would be a nice thing to have. Both GCC and TCC can be built as libraries. Didn't investigate it much yet. More platforms The repository mentioned above (""ecl-android"") isn't only about Android support. It has iOS and NaCL ports too. Creating a Minix port would be rather easy – only the bdwgc port is missing, and porting it would be as easy as adding two defines since it's advertised as ""API compatible"" with NetBSD which is already supported. Introspection facilities ECL has a few problems when it comes to introspection. While it works nicely with SLIME when it comes to the user-defined functions, many functions defined at ECL build time don't have any hints. It's even worse when it comes to macros – no hints at all. This issues have to be addressed and fixed by fixing ECL interfaces and improving SLIME integration. It will also create a good background for writing simplified (not emacs-dependant) IDE (read below). Graphical integrated development environment This should work via Swank backend and must be easy to grasp for a programming beginners. I truly believe that Emacs (while being editor of my choice) doesn't have to be the only solution for CL programmers who use free implementations. It's a big entrance barrier which people often fail to conquer. I imagine it being written in EQL and supporting Swank, so any implementation can be attached. Some ideas from Bret Victor's ""Learnable Programming"" might be incorporated, especially contextual information in the case when documentation is in a specific format (for instance providing description for each parameter). Decent support from line-edit would also be nice for quick hacking from the console – auto-completion and hints are a killer feature here. Imagine BPython (it's ncurses). Improving existing interfaces Gray streams and MOP has a few remaining issues (implementation isn't fully conforming). For instance: Gray Streams #'close isn't a method but function, MOP's complex methods are terribly slow or even non-functional. This issues has to be addressed. Compiler thread-safety ECL compiler isn't thread safe (at least that's what I've been told). Verifying and fixing it is one of the things to be done. Central Document Repository We plan to incorporate suitable extensions into ECL. Starting from CDR-14 (we already have CDR-5). It's a nice place for quasi-standard proposals and we think it's a good way to achieve consensus among various CL implementations about a common API for future extensions to allow portability. We know many facilities are practically standardized by portability libraries (ASDF, Bordeaux Threads, CFFI etc.), but future extensions might have an actual specification – we all know warts of ""reference implementation"" standards *cough-python-cough*. I would love to see ""Extensible Sequences"" in the Central Document Repository. 5 On Lisp (not a book!) 5.1 Inlining C/C++ code in Common-Lisp with ECL Like many compilers ECL offers a facility to inline it's assembly in the source code for a convenience and performance reasons. ECL's assembler is C/C++°. To achieve inlining, ECL offers three constructs. (ffi:clines                           &body strings) (ffi:c-inline args arg-types ret-type &body others) (ffi:c-progn  args                    &body forms-and-strings)  The most basic is ffi:clines, which allows you to just drop in some C/C++ code (for instance include a header you need for further use). ffi:c-inline is much more useful, allowing you to pass values from Lisp to the block and receive output in return. This construct allows returning multiple values declared in the third clause. You may also declare whenever it has side effects and if it is one-liner°° (more details in ECL manual). Short example: (defun ctrunc (number divisor)   (ffi:c-inline (number divisor) (:int :int) (values :int :int) ""{     int num = #0, div = #1;     @(return 0) = num/div;     @(return 1) = num%div; }""))  It's worth mentioning that the number and divisor types are checked when the function #'ctrunc is called and if incorrect – proper lisp condition is signaled. ffi:c-progn is the last construct. It allows you to intermix both C and lisp code – it doesn't return any value so it is called purely for it's side-effects (assigning variable with computed result for instance). Don't forget to declare variable types! If you don't, results might be surprising. To illustrate potential gain of using inlined C language we'll take the trivial Fibbonachi algorithm and benchmark ECL against itself. It's not a proper benchmark, nor a good implementation, but both implementations are comparable and this should prove a point, that ECL might be quite fast when we want it to be°°°. (defun fib-1 (n)   ""Borrowed from http://www.cliki.net/fibonacci""   (loop for f1 = 0 then f2      and f2 = 1 then (+ f1 f2)      repeat n finally (return f1)))  (defun fib-2 (n)   (let ((f1 0) (f2 1) (n n))     (declare (:int f1 f2 n))     (ffi:c-progn (n f1 f2) ""      int aux = 0;      for( ; #0>0; #0--, aux=#1) {          #1 = #2;          #2 = aux + #2;      }"")     f1))  (defun bench ()   (compile 'fib-1)   (compile 'fib-2)   (prog1 nil     (print ""Common Lisp:"")     (time (dotimes (x 10000000) (fib-1 20)))     (print ""Common Lisp with inlined C:"")     (time (dotimes (x 10000000) (fib-2 20)))))  On my computer This yields: ""Common Lisp:"" real time : 9.583 secs run time : 9.596 secs gc count : 1 times consed : 271531840 bytes ""Common Lisp with inlined C:"" real time : 0.657 secs run time : 0.656 secs gc count : 1 times consed : 271567088 bytes So, as we can see, the speed improvement is pretty decent. Proper declarations would speed up #'fib-1 a little, but the C version will still be faster (note the fact that we are comparing ECL with ECL, other implementations might theoretically outperform ECL's C version using provided #'fib-1 definition). For more information please consult manual: https://common-lisp.net/project/ecl/static/manual/ch28.html – ° None of these constructs will work with the bytecode compiler (it will signal an error). °° C doesn't treat each statement as a valid R-value. By ""one-liner"" we mean something, what might be used as such. °°° We can't say it's fast Common Lisp, since it's no longer Common Lisp – if we use this technique we're using ECL and it's not portable by any means. 5.2 Case on LET / FLET / LABELS (aka Nasal Demons Reborn) Consider an example (let ((x 'foo)       (x 'bar))   x)  what symbol does this form evaluate to: **BARFOO* or *? Well, it's not defined – in CCL and CLISP it is **FOOBAR*, ECL and ABCL make it *, while SBCL signals an error. It isn't clear what should happen because it's not specified in the spec. I think that the SBCL approach is the most sane. I can hardly imagine a programmer doing that, not as a typo, but as a conscious decision°. The same argument applies to **FLET* FLET*FLET* (except the side-effect thingy – all but one definition of the same name can be optimized out) – which function definition is the valid one? It isn't specified – note that the operator name isn't *but *. The last case – the most dangerous and the least comprehensible. *LABELS* allows mutual recursion and it's far less obvious what would happen even from an implementation point of view. If we write a code: (labels ((function1 ()            (im-dangerous 2))          (im-dangerous (x)            (format t ""FIRST X=~A~%"" x)            (if (zerop x)                'first                (im-dangerous (1- x))))          (function2 ()            (im-dangerous 2))          (im-dangerous (x)            (format t ""SECOND X=~A~%"" x)            (if (zerop x)                'second                (im-dangerous (1- x))))          (function3 ()            (im-dangerous 2)))   (list (function1)         (function2)         (function3)         (im-dangerous 1)))  CLISP take the first definition of ** IM-DANGEROUSIM-DANGEROUS*, while others the second one. SBCL on the other hand behaves inconsistently – inside function definitions references to *are bound to the first definition, while references from inner block are bound to the second one. It is important to say that the behavior in these situations is undefined by the spec and each implementation is free to do what it considers most reasonable, easiest to implement, or best to optimize – and none of these is wrong (CCL allows all constructs, but issues a style warning for each – it is the only implementation which does that – bravo). Curious minds may find the following article amusing (warning, C code involved): http://blogs.msdn.com/b/oldnewthing/archive/2014/06/27/10537746.aspx. My conclusion is as follows: you can't rely on ** LABELS* FLETLET*, *and *constructs if multiple definitions of the same name exist – they are ambiguous and should be considered being an error. The new release of ECL treats them that way°°. – ° Multiple variables can't be optimized out, because the initialization form might have side effects (let ((x (side-effects1))       (x (side-effects2)))   x)  ;; More deterministic form: (let ((x (progn (side-effects1)                 (side-effects2))))   x)  °° ANSI defines LAMBDA-LIST in terms of LET*, so repeating the parameters of the same name is theoretically correct. There is no valid use-case for two required parameters of the same name (there is no initialization form) though, so ECL signals an error on such situation. 5.3 Case for portability and against unusual reader syntax Why we shouldn't use all these implementation-specific niceties Lately, Zach Bane posted a nifty trick for accessing symbols from packages you're not in, literally: foo::(list 'these 'symbols 'are 'from ""foo"" 'package)  It's nice, intuitive, practical… and not compliant. It would be a minor problem, if it weren't a syntax hack, which is hard to implement portably as a library (at least I don't see any elegant solution). In my opinion it requires digging into implementation innards and tweaking the reader to support it. Manipulating strings before they are actually read is an option too. Also – unlike the metaobject protocol, gray streams or extensible sequences – it doesn't bring anything new to the table. ""But hey! It's just syntactic sugar for REPL interaction! Don't be such a grumpy guy!"" OK, fine, if you promise me that this ""syntactic sugar"" won't land in any library *ever* – it's advertised after all. Nobody knows who will pick up this hint. And if critical mass will prevail, then this dubious syntactic sugar will become de-facto standard, so other implementations will be forced to implement it, or fail to load libraries using it. Such a situation happened once. CLtL had an example of the ** UNTIL* FORLOOP* usage, where a *clause landed after an *clause, which isn't ANSI compliant. The fact that it was supported by a few implementations lead to the situation imagined above. If you really want some syntactic sugar for using other packages locally – I propose a little uglier, yet portable, solution: (defun sharp-l (stream char subchar)   (declare (ignore char subchar))   (let ((*package* (find-package (read stream))))     (read stream nil nil t)))  (set-dispatch-macro-character #\# #\l #'sharp-l)  #l foo (list 'these 'symbols 'are 'from ""foo"" 'package)  It's only five lines of code and works everywhere (unless someone binds #l to his own reader macro). If someone wants to be a little fancier, then he may mimic the SLIME prompt in his syntax: (defun sharp-x (stream char subchar)   (declare (ignore char subchar))   (let ((*readtable* (copy-readtable))         (right #\))         (rpar #\>))     (set-macro-character rpar (get-macro-character right))     (let ((*package* (find-package (read stream))))       (peek-char #\> stream)       (read-char stream)       (read stream nil nil t))))  (set-dispatch-macro-character #\# #\[ #'sharp-x)  #[foo> (list 'these 'symbols 'are 'from ""foo"" 'package)  And, honestly I really like proposed syntax, but for my taste it's totally unportable and harmful for reasons I've mentioned above. 6 Advertisement Here comes the shameless plug – I've recently (officially) launched the company named TurtleWare. I am open for consultancy. If anyone: wants to pay for a dreamed ECL feature, prioritizes his own issues with implementation, likes to pay for support or system maintenance, has some Lisp and/or embedded systems work to do then reach me with further details at: hello[at]turtleware.eu. ECL Quarterly Volume I posted on 2015-05-01 Table of Contents 1. Preface 2. Changes and development status 3. Contributing to ECL 1 Preface Hello everyone! From time to time there are misleading signals, that ECL is ""floating dead"". This FUD is mostly spread by IRC newcomers with little orientation, but it's good! This is a signal, that this particular implementation of Common Lisp needs to make little more noise, instead of silently fixing ** stuffstuff* (however it obviously needs a bit of work on *as well ;-)) . Some projects make new release each month to prevent such disinformation. It solves this particular problem, but introduces a new one - it's a bit fuzzy, if a new release introduces any significant improvements, or if it's just a release number bump. Yet, updating it requires recompilation of personal projects, which depending on machine might take a while and is surely a bit annoying. This is where ECL Quarterly idea has born. To show a bit activity from time to time - post will be published every three months. I want to make it an e-zine containing info about development, tutorials, comparisons, benchmarks and anything, what is at least slightly related to ECL. Everyone is welcome to contribute - such materials will be also published on wiki, added to git tree, and if appropriate - incorporated in documentation. If you have such material, don't hesitate to contact me at dkochmanski[at]turtle-solutions[dot]eu. This chapter highlights: Changes, development status etc. Contributing to ECL If you have any suggestions regarding ECL Quarterly, you like it, or maybe hate it - please tell me either by commenting this post, or writing an e-mail. Thank you! – Daniel Kochmański Poznań, Poland May 2015 2 Changes and development status After 15.3.7 release there are a few changes going on. We are now hosted at gitlab.com (however it would be nice to move to gitlab.common-lisp.net, just /not now/), a few wiki entries are added, official site is https://common-lisp.net/project/ecl/. Domain embeddable-common-lisp.net is already bought (not configured properly yet). Until now we have updated libraries, which we depend on. Namely: libffi to version 3.2.1, asdf to version 3.1.4, bdwgc to version 7.4.2. There was also update of GMP to more recent version, but we won't include it - yes, we are staying LGPLv2, to remain GPLv2 compatible. All changes were tested on Windows with MSVC2012. For now we have also reworked ROTATEF, SHIFTF and PSETF macros, to conform ANSI standard in regard to places (multiple values weren't held properly). Experimental branch contains Android (as name suggests - experimental) port, which is preview only for now (this branch is LGPLv3, because included GMP enforces it, and doesn't build on Windows). Loads of things are to be done, and we're slowly making progress. After all we won't change release versioning scheme. No ETA for next release, but I assure you - if you contribute, it will be sooner ;-). What leads us to the next part. 3 Contributing to ECL 3.1 Documentation, tutorials, wiki, others You can contribute in numerous ways. One way is to code and fix bugs - and it's very important part. But equally important is to find bugs and report them, so developers can improve codebase. Feature requests are also welcome (however we are focused now on fixing stuff rather than adding functionality, so even good proposition might wait in queue behind something maybe less exciting). Testing on various platform and architectures is essential. Thanks to Anton Vodonosov and cl-test-grid it is as easy as setting environment, tweaking two configuration files and invoking ./run-agent.sh. Run may take a while (depending on computer) and is limited to operating systems and architectures supported by Clozure Common Lisp. If ECL doesn't build, crashes, or works non-conforming to specification, please do report at https://gitlab.com/embeddable-common-lisp/ecl/issues. It requires account on GitLab, but setting it up is free. I'm still struggling to produce some time and move all tickets from https://sourceforge.net/p/ecls/_list/tickets to above mentioned issue tracking site - volunteers are more then welcome to do it. If you encounter problem, please write to mailing list. There are many kind souls there more then willing to help - and usually they do. On the other hand, if someone asks for help and you know the answer - act! :-) Wiki is a place, where many resources are gathered. It is incomplete and barely usable, because I don't have time to improve it. If you successfully build ECL on Android - great! Please add page to wiki, so others may reproduce your work! Do you have some nifty idea, and you believe it is worth to keep it there - do it. See a typo? Bug? Outdated information? You know what to do! You spot some nice blog post about ECL? Please share with others - wiki is best place to do so. You did successful project using ECL? Share this information! All this, and so much more, may be done here: https://gitlab.com/embeddable-common-lisp/ecl/wikis/home. You can also write something for ECL Quarterly (my e-mail is mentioned in preface). 3.2 Source code contributions Development takes place on git repository located at git@gitlab.com:embeddable-common-lisp/ecl.git. If you want your code in Embeddable Common-Lisp project, please send a patch to mailing list with additional tag [PATCH] in subject. Generally we want to follow convention used by U-Boot development team (http://www.denx.de/wiki/U-Boot/Patches), which borrows a lot from Linux policy. Please read this guide, it's really worthwhile reading. If you submit a significant change, please report it in CHANGELOG located in top directory. Basically, if you want to contribute to code, you have at least two choices. You may improve C code (which is probably less interesting for lispers). Most of the sources are written in lisp however, and require no knowledge about C. Problems vary from fairly easy even for seasoned developer to hard conceptual riddles, so everyone can find something interesting for himself.. Please consult appropriate directories under src/ sub-directory (i.e. src/lsp, src/clos etc.) - it's pure lisp! And it's fun to hack. Improving both C and Lisp sources might be a great learning experience. To figure what's wrong requires often getting your hands dirty, and then cleaning proposed solution. This, connected with peer review, might be a next step to become a better programmer. There is also a third part, which is tiresome (for me at least) - improving build system - it is buggy and inconsistent. First person who will fix this has granted a free dinner when we meet in person. Remember however, that we support many operating systems, so it might be tricky to do it properly without introducing *new* problems. If you are a library or application developer, _please_ test against as many implementations as possible - it's hard, it takes time, but in my humble opinion it is essential for CL ecosystem. Each implementation has it's weak and strong sides, and you never know, when you'll need one, or who and in what purpose is using your code :-). ECL Quarterly - Volume I posted on 2015-05 Table of Contents 1. ECL Quarterly - Volume I 1.1. Preface 1.2. Changes and development status 1.3. Contributing to ECL 1.3.1. Documentation, tutorials, wiki, others 1.3.2. Source code contributions ECL Quarterly - Volume I Preface Hello everyone! From time to time there are misleading signals, that ECL is ""floating dead"". This FUD is mostly spread by IRC newcomers with little orientation, but it's good! This is a signal, that this particular implementation of Common Lisp needs to make a bit more noise, instead of silently fixing stuff (however it obviously needs a bit of work on stuff as well ;-)). Some projects make new release each month to prevent such disinformation. It solves this particular problem, but introduces a new one - it's a bit fuzzy, if a new release introduces any significant improvements, or if it's just a release number bump. Yet, updating it requires recompilation of personal projects, which depending on machine might take a while and is surely a bit annoying. This is how the ECL Quarterly idea was born. To show a bit activity from time to time - post will be published every three months. I want to make it an e-zine containing info about development, tutorials, comparisons, benchmarks and anything what is at least slightly related to ECL. Everyone is welcome to contribute - such material will also be published on wiki, added to git tree, and if appropriate - incorporated in documentation. If you have such material, don't hesitate to contact me at dkochmanski[at]turtle-solutions[dot]eu. This chapter highlights: Changes, development status etc. Contributing to ECL If you have any suggestions regarding ECL Quarterly, you like it, or maybe hate it - please tell me either by commenting this post, or writing an e-mail. Thank you! – Daniel Kochmaski Pozna, Poland May 2015 Changes and development status After the 15.3.7 release there are a few changes going on. We are now hosted at gitlab.com (however it would be nice to move to gitlab.common-lisp.net, just not now), a few wiki entries are added, official site is https://common-lisp.net/project/ecl/. Domain embeddable-common-lisp.net is already bought (not configured properly yet). Until now we have updated libraries that we depend on. Namely: libffi to version 3.2.1, asdf to version 3.1.4, bdwgc to version 7.4.2. There was also an update of GMP to more recent version, but we won't include it - yes, we are staying LGPLv2, to remain GPLv2 compatible. All changes were tested on Windows with MSVC2012. For now we have also reworked the ROTATEF, SHIFTF and PSETF macros, to conform ANSI standard in regard to places (multiple values weren't held properly). The experimental branch contains Android (as name suggests - experimental) port, which is preview only for now (this branch is LGPLv3, because included GMP enforces it, and doesn't build on Windows). Loads of things are to be done, and we're slowly making progress. After all we won't change release versioning scheme. No ETA for next release, but I assure you - if you contribute, it will be sooner ;-). What leads us to the next part. Contributing to ECL Documentation, tutorials, wiki, others You can contribute in numerous ways. One way is to code and fix bugs - and it's very important part. But equally important is to find bugs and report them, so developers can improve codebase. Feature requests are also welcome (however we are focused now on fixing stuff rather than adding functionality, so even good proposition might wait in queue behind something maybe less exciting). Testing on various platform and architectures is essential. Thanks to Anton Vodonosov and cl-test-grid it is as easy as setting environment, tweaking two configuration files and invoking ./run-agent.sh. Run may take a while (depending on computer) and is limited to operating systems and architectures supported by Clozure Common Lisp. If ECL doesn't build, crashes, or works non-conforming to specification, please do report at https://gitlab.com/embeddable-common-lisp/ecl/issues. It requires account on GitLab, but setting it up is free. I'm still struggling to produce some time and move all tickets from https://sourceforge.net/p/ecls/_list/tickets to above mentioned issue tracking site - volunteers are more then welcome to do it. If you encounter problem, please write to mailing list. There are many kind souls there more then willing to help - and usually they do. On the other hand, if someone asks for help and you know the answer - act! :-) Wiki is a place, where many resources are gathered. It is incomplete and barely usable, because I don't have time to improve it. If you successfully build ECL on Android - great! Please add page to wiki, so others may reproduce your work! Do you have some nifty idea, and you believe it is worth to keep it there - do it. See a typo? Bug? Outdated information? You know what to do! You spot some nice blog post about ECL? Please share with others - wiki is best place to do so. You did successful project using ECL? Share this information! All this, and so much more, may be done here: https://gitlab.com/embeddable-common-lisp/ecl/wikis/home. You can also write something for ECL Quarterly (e-mail me at dkochmanski[at]turtle-solutions[dot]eu). Source code contributions Development takes place on git repository located at git@gitlab.com:embeddable-common-lisp/ecl.git. If you want your code in Embeddable Common-Lisp project, please send a patch to mailing list with additional tag [PATCH] in subject. Generally we want to follow convention used by U-Boot development team (http://www.denx.de/wiki/U-Boot/Patches), which borrows a lot from Linux policy. Please read this guide, it's really worthwhile reading. If you submit a significant change, please report it in CHANGELOG located in top directory. Basically, if you want to contribute to code, you have at least two choices. You may improve C code (which is probably less interesting for lispers). Most of the sources are written in lisp however, and require no knowledge about C. Problems vary from fairly easy even for seasoned developer to hard conceptual riddles, so everyone can find something interesting for himself.. Please consult appropriate directories under src/ sub-directory (i.e. src/lsp, src/clos etc.) - it's pure lisp! And it's fun to hack. Improving both C and Lisp sources might be a great learning experience. To figure what's wrong requires often getting your hands dirty, and then cleaning proposed solution. This, connected with peer review, might be a next step to become a better programmer. There is also a third part, which is tiresome (for me at least) - improving build system - it is buggy and inconsistent. First person who will fix this has granted a free dinner when we meet in person. Remember however, that we support many operating systems, so it might be tricky to do it properly without introducing new problems. If you are a library or application developer, please test against as many implementations as possible - its hard, it takes time, but in my humble opinion it is essential for CL ecosystem. Each implementation has it's weak and strong sides, and you never know, when you'll need one, or who and in what purpose is using your code :-). Previous   This blog covers android, content, contributing, news, quarterly, release View content from 2016-06, 2016-04, 2016-03, 2016-02, 2015-11, 2015-09, 2015-05, 2015-03, 2015-02, 2013-10, 2013-05, 2013-01, 2012-12, 2012-11, 2012-08, 2012-07, 2012-06, 2012-05, 2011-05, 2011-01, 2010-07, 2010-06, 2010-03, 2009-10, 2009-07, 2009-06, 2009-04, 2008-12, 2008-10, 2008-08, 2008-04, 2007-12, 2007-05, 2007-01, 2006-09, 2006-06, 2006-04, 2006-03, 2006-01, 2005-12, 2005-11, 2005-10, 2005-08, 2005-07, 2005-06, 2005-05 Last modification: Wed, 15 Jun 2016 07:42:14 +0000. Back to Common-lisp.net."	"null"	"null"	"Embeddable Common Lisp; compiles to C.."	"true"
"Implementations"	"GCL"	"https://www.gnu.org/software/gcl/"	"Another GNU implementation; not yet fully ANSI-compliant.."	"null"	"null"	"null"	"GNU LGPL2.1"	"http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html"	"null"	"null"	"null"	"null"	"null"	"GCL - GNU Common Lisp GCL - GNU Common Lisp About Development Download Mailing Lists Menu » Get Latest Release » Debian package page » Browse GIT » Devel Mailing List » Archives » Bugs Links » Maxima » ACL2 » Axiom » Cliki » Lisp.org Hosting » Homepage » Savannah GCL - an implementation of Common Lisp NEW! (20141028) GCL 2.6.12 is released. The release notes can be found here. NEW! (20140906) GCL 2.6.11 is released. The release notes can be found here. NEW! (20131113) GCL 2.6.10 is released. The release notes can be found here. NEW! (20130823) GCL will use the git version control system henceforth. 2.6.8 and 2.6.9 are the last tagged releases in cvs. All cvs tags and branches have been converted into git. In addition, the cvs experimental branch has been merged into master, and several git-only commits on this branch have already been made. Eventually, the master branch will be released as 2.7.0. NEW! (20130823) GCL 2.6.8 and 2.6.9 are released. The release notes can be found here and here. NEW! (20050810) GCL 2.6.7 is released. The release notes can be found here. NEW! (20050427) Patch added to the errata page to reenable support for si::run-process on linux. NEW! (20050402) Support for new texinfo format and precompiled regexp searching posted to errata page. NEW! (20050330) ERRATA page for 2.6.6 updated. Control-D on a fresh line was not exiting GCL when readline was on. Also, libreadline5-dev support in debian/control. NEW! (20050225) ERRATA page for 2.6.6 started here.. So far just one entry, supplying a patch to enable (listen) to work when readline is enabled. One can also workaround the bug with (si::readline-off). NEW! (20050119) GCL 2.6.6 is released. The release notes can be found here. NEW! (20041124) Newer binutils don't define _raw_size in their section structure. A patch is included on the errata page fixing this. The patch works with the older versions too. NEW! (20050113) Patches added to the errata page allowing compile-file to process pathnames with whitespace on Windows, and explicitly ensuring brk added pages are executable on all x86 Linux, the latter in response to the policy change regarding same in Fedora Core 3. NEW! (20041029) Additions to the 2.6.5 errata page: fixes for older gcc processing gmp_wrappers.h; fix for (+ most-negative-fixnum -1) on 64bit machines. NEW! (20040823) An errata page to 2.6.5 on Sun Solaris has been added here . This fixes a problem which may arise in the loader with certain gcc/ld combinations when C optimization is in force. NEW! (20040817) Version 2.6.5 is released. Please read the release notes together with some new timing results here . GCL is the official Common Lisp for the GNU project. Its design makes use of the system's C compiler to compile to native object code, providing for both good performance and facile portability. GCL currently compiles itself and the primary free software Lisp applications, Maxima , ACL2 and Axiom, on eleven GNU/Linux architectures (x86 powerpc s390 sparc arm alpha ia64 hppa m68k mips mipsel), Windows, Sparc Solaris, and FreeBSD. On most platforms, GCL can load native object code modules directly into its lisp core, where they are preserved in any custom lisp images produced via the save-system call. GCL has been packaged for the Debian GNU/Linux operating system. While GCL was originally designed to meet the CLtL1 standard, recent development has brought GCL much of the way toward its current goal -- full ANSI compliance. An ANSI regression test suite is being developed as part of this effort. As of the time of this writing, the new ANSI behavior is enabled optionally at compile time with the configure switch --enable-ansi. Several GCL extensions exist, and are in various stages of incorporation. xgcl, providing a Lisp interface to the X Windows system, is included in the main source tree. pargcl, an MPI extension enabling lisp programs to run in parallel across computing clusters, will be incorporated soon. These efforts are good examples of GCL's foreign function interface, which is rather flexible due to its close relationship with C. Other Features: Very efficient. A function call is basically the same speed as a C function call, in fact identical to a C function call via a pointer. A source level Lisp debugger (dbl) for interpreted code, letting you step a line at a time, while displaying the your position in an Emacs window. This is invaluable when trying to understand large systems. Pioneered conservative Garbage Collection schemes. Has a garbage collection scheme, for only recent allocations, based on native page fault handling. This is the stratified garbage collection (SGC). Very reliable. Built in interface to Tk widget system. Allows a mixture of tcl and common lisp to be used in a user interface--your choice which you use. History GCL is the product of many hands over many years. The original effort was known as the Kyoto Common Lisp system, written by Taiichi Yuasa and Masami Hagiya in 1984. In 1987 new work was begun by William Schelter, and that version of the system was called AKCL (Austin Kyoto Common Lisp). In 1994 AKCL was released as GCL (GNU Common Lisp) under the GNU public library license. The primary purpose of GCL during that phase of it's existence was to support the Maxima computer algebra system, also maintained by Dr. Schelter. It existed largely as a subproject of Maxima. After the passing of Dr. Schelter in 2001, it was decided that GCL should be actively maintained and improved. GCL is currently maintained by a team of 12 developers across the world coordinated via the gcl-devel mailing list."	"null"	"null"	"Another GNU implementation; not yet fully ANSI-compliant.."	"true"
"Implementations"	"GNU CLISP"	"http://www.clisp.org/"	"A GNU implementation; contains a compiler and an interpreter..."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"CLISP - an ANSI Common Lisp Implementation Welcome to CLISP This is GNU CLISP - an ANSI Common Lisp Implementation Current version: 2.49 (2010-07-07) NEWS About CLISP Get CLISP What is CLISP? a feature-loaded implementation of a great language! The benefits of Common Lisp and CLISP why is ANSI Common Lisp such a great programming environment? CLISP manual page for UN*X command line options for other platforms are very similar (see clisp.html in your build directory or binary distribution) CLISP Implementation Notes [TOC] How CLISP implements and extends the ANSI standard INCITS 226-1994 (R1999) ""Information Technology - Programming Language - Common Lisp"", available as the Common Lisp HyperSpec. CLISP as a login shell You can use CLISP instead of bash or tcsh! Common Lisp on the Web information and software CLISP FAQ list Frequently Asked Questions about CLISP, with answers, including How do I ask for help? How do I report bugs? SourceForge Project Home bug reports developers help wanted RFEs donate - recent donors CLISP elsewhere GNU Free Software Directory - CLISP and Lisp CMU Artificial Intelligence Repository (very old but still valuable) - CLISP and Lisp SWiK Launchpad Ohloh Help translate CLISP messages into your language! Rate CLISP! FreshMeat --10 98 76 54 32 1 OSDir --10 98 76 54 32 1 How are you using CLISP? Tell us your story! Review CLISP on Ohloh! Home http://clisp.org/ http://clisp.sourceforge.net/ http://www.gnu.org/software/clisp/ Our official distribution sites http/SF (sources and win32) ftp://ftp.gnu.org/pub/gnu/clisp/ http://ftp.gnu.org/pub/gnu/clisp/ Linux packages Debian Fedora SuSE Gentoo ALT Arch Mandriva Slackware Ubuntu *BSD ports FreeBSD pkgsrc (NetBSD and DragonFly BSD) OpenBSD Fink: Unix software for Darwin and Mac OS X CLISP Package MacPorts: Open-Source software for the Mac OS X CLISP Package Homebrew: The missing package manager for OS X CLISP Formula Cygwin: Linux-like environment for Windows CLISP Package CSW: Open Source Software for Sun Solaris CLISP Package Mercurial: when you cannot wait for the next release Development NEWS Implementation Notes - updated nightly from the Mercurial repository Check out CLISP source tree from the Mercurial repository Browse CLISP Mercurial repository General SourceForge Mercurial documentation (rsync, permissions, notification etc) Search CLISP Implementation Notes Common Lisp HyperSpec clisp.org gnu.org sourceforge.net the whole web mailing list archives (more options) clisp-list clisp-devel clisp-announce clisp-announce clisp-list clisp-devel clisp-list clisp-devel clisp-announce Sort by Date Relevance Political issues we promote Hosting and support This project is hosted by SourceForge, which is, in turn, owned and operated by Geeknet. This project is not supported by these or any other company or organization. This project is supported by your generous donations as well as advertising revenue from ads displayed on the beta pages. Copyright and licensing All contents here is copyright by the developers and is released under the GNU Free Documentation License or, at your option, GNU General Public License. Contact the Webmaster: please report all problems with these pages (dead links, inaccuracies, additions) using the bug tracker (category doc)."	"null"	"null"	"A GNU implementation; contains a compiler and an interpreter..."	"true"
"Implementations"	"Standard conformance"	"http://www.gnu.org/software/clisp/impnotes.html"	"A GNU implementation; contains a compiler and an interpreter..."	"null"	"null"	"null"	"GNU GPL3"	"http://www.gnu.org/copyleft/gpl.html"	"null"	"null"	"null"	"null"	"null"	"Implementation Notes for GNU CLISP Implementation Notes for GNU CLISP These notes document CLISP version 2.49 Bruno HaibleThe original author and long-time maintainer.  Michael StollThe original author.  Sam SteingoldCo-maintainer since 1998.  OthersSee COPYRIGHT for the list of other contributors and the license.   Copyright © 1992-2010 Bruno Haible Copyright © 1998-2010 Sam Steingold Legal Status of the CLISP Implementation Notes These notes are dually licensed under GNU FDL and GNU GPL. This means that you can redistribute this document under either of these two licenses, at your choice. These notes are covered by the GNU FDL. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License (FDL), either version 1.2 of the License, or (at your option) any later version published by the Free Software Foundation (FSF); with no Invariant Sections, with no Front-Cover Text, and with no Back-Cover Texts. A copy of the license is included in Appendix B, GNU Free Documentation License. These notes are covered by the GNU GPL. This document documents free software; you can redistribute it and/or modify it under the terms of the GNU General Public License (GPL), either version 2 of the License, or (at your option) any later version published by the Free Software Foundation (FSF). A copy of the license is included in Appendix C, GNU General Public License. CLISP Release History Release 1 April 1987 - July 1992 bruno The project was started when both original authors, Bruno Haible and Michael Stoll, were students in Germany. The original version was for Atari ST only, written in 68000 assembly language and Common Lisp. Release 2.0 1992-10-09 bruno comp.os.linux announcement (Linux binaries only) Release 2.1 1993-01-01 bruno The first portable release, with source, released under GNU GPL. Supported platforms: Atari ST, Amiga 500-2000, DOS (emx, djgpp), OS/2 (emx), Unix (Linux, Sun4, Sun386, HP9000/800). Release 2.1.1 1993-01-11 bruno Release 2.1.2 1993-02-01 bruno Release 2.1.3 1993-02-03 bruno Release 2.2 1993-02-21 bruno Add test suite. Release 2.2.1 1993-03-04 bruno Release 2.2.2 1993-03-19 bruno CUSTOM:*EDITOR* Release 2.3 1993-03-30 bruno LOAD-TIME-VALUE EXT:DEFAULT-DIRECTORY Release 2.3.1 1993-04-05 bruno Release 2.4 1993-05-24 bruno DEFPACKAGE FUNCTION-LAMBDA-EXPRESSION Section 32.1, “Random Screen Access” Release 2.5 1993-06-29 bruno SETF function names. PRINT-UNREADABLE-OBJECT SYMBOL-MACROLET Release 2.5.1 1993-07-17 bruno immutable objects Release 2.6 1993-08-22 bruno “CLOS” package: DEFCLASS, DEFMETHOD, DEFGENERIC, GENERIC-FUNCTION, CLOS:GENERIC-FLET, CLOS:GENERIC-LABELS, WITH-SLOTS, WITH-ACCESSORS, FIND-CLASS, (SETF FIND-CLASS), CLASS-OF, CLASS-NAME, (SETF CLASS-NAME), SLOT-VALUE, SLOT-BOUNDP, SLOT-MAKUNBOUND, SLOT-EXISTS-P, CALL-NEXT-METHOD, NEXT-METHOD-P, NO-APPLICABLE-METHOD, CLOS:NO-PRIMARY-METHOD, NO-NEXT-METHOD, FIND-METHOD, ADD-METHOD, REMOVE-METHOD, COMPUTE-APPLICABLE-METHODS, METHOD-QUALIFIERS, FUNCTION-KEYWORDS, SLOT-MISSING, SLOT-UNBOUND, PRINT-OBJECT, DESCRIBE-OBJECT, MAKE-INSTANCE, INITIALIZE-INSTANCE, REINITIALIZE-INSTANCE, SHARED-INITIALIZE Release 2.6.1 1993-09-01 bruno Release 2.7 1993-09-27 bruno top-level forms DECLAIM Release 2.8 1993-11-08 bruno “COMMON-LISP”, “COMMON-LISP-USER” New module: STDWIN Release 2.9 1994-01-08 bruno DEFINE-CONDITION, IGNORE-ERRORS, HANDLER-CASE, HANDLER-BIND, RESTART-CASE, EXT:WITH-RESTARTS, WITH-SIMPLE-RESTART, RESTART-BIND, WITH-CONDITION-RESTARTS, RESTART, CONDITION, SERIOUS-CONDITION, ERROR, PROGRAM-ERROR, CONTROL-ERROR, ARITHMETIC-ERROR, DIVISION-BY-ZERO, FLOATING-POINT-OVERFLOW, FLOATING-POINT-UNDERFLOW, CELL-ERROR, UNBOUND-VARIABLE, UNDEFINED-FUNCTION, TYPE-ERROR, PACKAGE-ERROR, STREAM-ERROR, END-OF-FILE, FILE-ERROR, STORAGE-CONDITION, WARNING, SIMPLE-CONDITION, SIMPLE-ERROR, SIMPLE-TYPE-ERROR, SIMPLE-WARNING, MAKE-CONDITION, SIGNAL, COMPUTE-RESTARTS, FIND-RESTART, INVOKE-RESTART, INVOKE-RESTART-INTERACTIVELY, ABORT, CONTINUE, MUFFLE-WARNING, STORE-VALUE, USE-VALUE, INVOKE-DEBUGGER, RESTART-NAME, ARITHMETIC-ERROR-OPERATION, ARITHMETIC-ERROR-OPERANDS, CELL-ERROR-NAME, TYPE-ERROR-DATUM, TYPE-ERROR-EXPECTED-TYPE, PACKAGE-ERROR-PACKAGE, STREAM-ERROR-STREAM, FILE-ERROR-PATHNAME, EXT:SIMPLE-CONDITION-FORMAT-STRING, SIMPLE-CONDITION-FORMAT-ARGUMENTS, *BREAK-ON-SIGNALS*, *DEBUGGER-HOOK*, *PRINT-READABLY* Release 2.10 1994-06-22 bruno EXT:READ-CHAR-SEQUENCE, EXT:WRITE-CHAR-SEQUENCE, EXT:READ-BYTE-SEQUENCE, EXT:WRITE-BYTE-SEQUENCE Section 31.6, “Generic streams” Release 2.11 1994-07-04 bruno LOOP, LOOP-FINISH, MAP-INTO LEAST-POSITIVE-NORMALIZED-SHORT-FLOAT, LEAST-NEGATIVE-NORMALIZED-SHORT-FLOAT, LEAST-POSITIVE-NORMALIZED-SINGLE-FLOAT, LEAST-NEGATIVE-NORMALIZED-SINGLE-FLOAT, LEAST-POSITIVE-NORMALIZED-DOUBLE-FLOAT, LEAST-NEGATIVE-NORMALIZED-DOUBLE-FLOAT, LEAST-POSITIVE-NORMALIZED-LONG-FLOAT, LEAST-NEGATIVE-NORMALIZED-LONG-FLOAT Release 2.12 1994-08-23 bruno generational garbage-collection DESTRUCTURING-BIND EXT:UNCOMPILE Release 2.12.1 1994-09-01 bruno Release 2.13 1994-10-26 bruno WILD-PATHNAME-P, PATHNAME-MATCH-P, TRANSLATE-PATHNAME, LOGICAL-PATHNAME, LOGICAL-PATHNAME-TRANSLATIONS, TRANSLATE-LOGICAL-PATHNAME, LOAD-LOGICAL-PATHNAME-TRANSLATIONS, COMPILE-FILE-PATHNAME Release 2.13.1 1995-01-01 bruno Release 2.14 1995-04-04 bruno “FFI” ROW-MAJOR-AREF, DELETE-PACKAGE, EXT:MUFFLE-CERRORS, EXT:APPEASE-CERRORS, EXT:EXIT-ON-ERROR Release 2.15 1995-04-25 bruno New modules: wildcard, regexp FORMATTER, EXT:FINALIZE FILE-STREAM, SYNONYM-STREAM, BROADCAST-STREAM, CONCATENATED-STREAM, TWO-WAY-STREAM, ECHO-STREAM, STRING-STREAM, OPEN-STREAM-P, SYNONYM-STREAM-SYMBOL, BROADCAST-STREAM-STREAMS, CONCATENATED-STREAM-STREAMS, TWO-WAY-STREAM-INPUT-STREAM, TWO-WAY-STREAM-OUTPUT-STREAM, ECHO-STREAM-INPUT-STREAM, ECHO-STREAM-OUTPUT-STREAM, PRINT-NOT-READABLE, PRINT-NOT-READABLE-OBJECT Release 2.16 1995-06-23 bruno COMPLEMENT, WITH-STANDARD-IO-SYNTAX, DYNAMIC-EXTENT, LAMBDA, IGNORABLE, CONSTANTLY WITH-HASH-TABLE-ITERATOR, HASH-TABLE-REHASH-SIZE, HASH-TABLE-REHASH-THRESHOLD, HASH-TABLE-SIZE, HASH-TABLE-TEST Release 2.17 1996-07-21 bruno SOCKET:SOCKET-SERVER, SOCKET:SOCKET-SERVER-CLOSE, SOCKET:SOCKET-SERVER-PORT, SOCKET:SOCKET-WAIT, SOCKET:SOCKET-ACCEPT, SOCKET:SOCKET-CONNECT, SOCKET:SOCKET-STREAM-HOST, SOCKET:SOCKET-STREAM-PORT, SOCKET:SOCKET-SERVICE-PORT, SOCKET:SOCKET-STREAM-PEER Release 2.17 1996-07-22 bruno Release 2.18 1997-05-03 bruno I18N:DEFLANGUAGE, I18N:DEFINTERNATIONAL, I18N:DEFLOCALIZED CUSTOM:*LOAD-COMPILING* Release 2.19 1997-08-07 bruno CLX Release 2.20 1997-09-25 bruno *READ-EVAL* EXT:TIMES Release 2.20.1 1997-12-06 bruno Release 2.21 1998-09-09 bruno Removed module STDWIN. CUSTOM:*WARN-ON-FLOATING-POINT-CONTAGION*, CUSTOM:*FLOATING-POINT-CONTAGION-ANSI*, FLOATING-POINT-INEXACT, FLOATING-POINT-INVALID-OPERATION EXT:PROBE-DIRECTORY, ENSURE-DIRECTORIES-EXIST *PRINT-RIGHT-MARGIN*, ARRAY-DISPLACEMENT BOOLEAN, COPY-STRUCTURE, GENERIC-FUNCTION, STRUCTURE-OBJECT, CLASS, METHOD, SPECIAL-OPERATOR-P Release 2.22 1999-01-08 bruno BASE-CHAR, EXTENDED-CHAR, BASE-STRING, SIMPLE-BASE-STRING GET-SETF-EXPANSION, DEFINE-SETF-EXPANDER PARSE-ERROR, READER-ERROR UNBOUND-SLOT-INSTANCE SOCKET:SOCKET-STREAM-LOCAL, SOCKET:SOCKET-SERVER-HOST Release 2.23 1999-07-22 bruno New module: postgresql UNICODE, “CHARSET”, CUSTOM:*DEFAULT-FILE-ENCODING*, CUSTOM:*PATHNAME-ENCODING*, CUSTOM:*TERMINAL-ENCODING*, CUSTOM:*MISC-ENCODING* CUSTOM:*FOREIGN-ENCODING*, AFFI:*FOREIGN-ENCODING* Chapter 30, Gray streams STREAM-EXTERNAL-FORMAT WITH-PACKAGE-ITERATOR ALLOCATE-INSTANCE Section 31.7.1, “Weak Pointers” EXT:READ-INTEGER, EXT:WRITE-INTEGER SIMPLE-CONDITION-FORMAT-CONTROL Release 2.24 2000-03-06 bruno EXT:READ-FLOAT, EXT:WRITE-FLOAT EXT:CHAR-WIDTH, EXT:STRING-WIDTH WITH-COMPILATION-UNIT Release 2.25 2001-03-15 sds INSPECT, EXT:CLHS EXT:CONVERT-STRING-FROM-BYTES, EXT:CONVERT-STRING-TO-BYTES EXT:READ-BYTE-LOOKAHEAD, GRAY:STREAM-READ-BYTE-LOOKAHEAD, EXT:READ-BYTE-WILL-HANG-P, GRAY:STREAM-READ-BYTE-WILL-HANG-P, EXT:READ-BYTE-NO-HANG, GRAY:STREAM-READ-BYTE-NO-HANG Win32 improvements (UNC pathnames, registry, screen) Release 2.25.1 2001-04-06 sds Release 2.26 2001-05-23 sds dropped CLtL1, added :LISP=CL to *FEATURES* DEFINE-COMPILER-MACRO UPGRADED-COMPLEX-PART-TYPE EXT:RUN-SHELL-COMMAND, EXT:RUN-PROGRAM accept :WAIT compiler checks function call signatures Release 2.27 2001-07-17 sds (SETF EXT:GETENV) src/install.bat Release 2.28 2002-03-03 sds [ANSI CL standard] Pretty-Printer MAKE-LOAD-FORM, MAKE-LOAD-FORM-SAVING-SLOTS Section 31.7.9, “Weak Hash Tables” EXT:FCASE I18N:GETTEXT Release 2.29 2002-07-25 bruno Bug-fix/portability: gcc 3.1 etc Release 2.30 2002-09-15 sds Do not bundle GNU libiconv, GNU gettext, GNU readline, GNU libsigsegv. CHARSET:UCS-4 CUSTOM:*PARSE-NAMESTRING-DOT-FILE* SOCKET:SOCKET-STREAM-SHUTDOWN POSIX:STREAM-LOCK, POSIX:COPY-FILE, POSIX:DUPLICATE-HANDLE New module: oracle Release 2.31 2003-09-01 sds New modules: fastcgi, dirkey, bindings/win32, syscalls, netica Support modules on Win32. UNICODE 3.2 New backquote implementation. Many [ANSI CL standard] compliance fixes. More “FFI” functionality. Release 2.32 2003-12-29 sds support LFS New modules: berkeley-db, pcre Release 2.33 2004-03-17 sds CUSTOM:*APROPOS-MATCHER*, EXT:MOD-EXPT, EXT:ARGV, GRAY:STREAM-POSITION DEFINE-METHOD-COMBINATION Portability: removed Acorn and Amiga support, fixed UNIXes. Release 2.33.1 2004-05-22 sds Bug-fixes, portability: gcc 3.4 Release 2.33.2 2004-06-02 sds Portability: RedHat Fedora Linux/x86 Release 2.34 2005-07-20 sds Chapter 29, Meta-Object Protocol Section 31.7, “Weak Objects” Section 11.5, “Package Case-Sensitivity” EXT:SET-GLOBAL-HANDLER, EXT:WITHOUT-GLOBAL-HANDLERS Portability: removed DOS and OS/2 support. New modules: matlab, rawsock, zlib, i18n, pari. Release 2.35 2005-08-29 sds EXT:COMPILED-FILE-P EXT:CHAR-INVERTCASE, EXT:STRING-INVERTCASE, EXT:NSTRING-INVERTCASE POSIX:STREAM-OPTIONS Close all file descriptors before exec. Release 2.36 2005-12-04 sds EXT:OPEN-HTTP, EXT:NOTSPECIAL, FFI:DEF-C-CONST, BASE64 modules/clx/new-clx/demos/koch.lisp src/spvw_sigterm.d Release 2.37 2006-01-02 sds SOCKET:SOCKET-SERVER accepts :INTERFACE and :BACKLOG. Fixed (SETF EXT:GETENV). Release 2.38 2006-01-24 sds EXT:SAVEINITMEM creates standalone executables. Release 2.39 2006-07-16 sds Reliable stack overflow detection and recovery. Release 2.40 2006-09-23 sds Keep doc string and lambda list in the closure object. Release 2.41 2006-10-13 sds FFI:DEFAULT-FOREIGN-LIBRARY New module: libsvm Release 2.42 2007-10-16 sds Section 8.2, “The structure Meta-Object Protocol” EXT:RENAME-DIRECTORY Many additions to modules/clx/new-clx/demos/ New modules: gtk2, gdbm Release 2.43 2007-11-18 sds The CLISP build process is now in compliance with the GNU standards. Use gnulib-tool to sync with GNU Portability Library. Release 2.43.1 2008-02-24 bruno Portability: work around gcc bug 34300 present in gcc 4.2 and 4.3. Release 2.44 2008-02-02 sds Do not bundle GNU libffcall. Release 2.44.1 2008-02-24 bruno Portability: work around gcc bug 34300 present in gcc 4.2 and 4.3. Release 2.45 2008-05-15 sds Just-In-Time compilation via GNU lightning. FFI:DEF-CALL-OUT and FFI:DEF-C-VAR accept :VERSION. read-eval-print loop commands accept arguments. Section 33.1.13, “Standard file input and output”. Fixed cross-compilation. Release 2.46 2008-07-02 sds :WORD-SIZE=64 in *FEATURES* on 64-bit platforms. Section 33.1.14, “Error handling”. Macro XLIB:WITH-OPEN-DISPLAY. Fixed the remaining bugs in SPECIAL bindings in evaluated code on TYPECODES platforms. Release 2.47 2008-10-23 sds New module: dbus EXT:PROBE-PATHNAME EXT:CANONICALIZE CUSTOM:*REOPEN-OPEN-FILE* POSIX:FILE-SIZE Release 2.48 2009-07-28 sds Experimental thread support, see Section 32.5, “Multiple Threads of Execution” POSIX:WAIT EXT:TRIM-IF src/m4/clisp.m4 Release 2.49 2010-07-07 sds CUSTOM:*USER-LIB-DIRECTORY*; dynamic modules are now the default build option -disable-readline COMPILER-DIAGNOSTICS:USE-HANDLER Abstract This document describes the GNU CLISP - an implementation of the [ANSI CL standard]. See the section called “Bugs” for instructions on how to report bugs (both in the software and the documentaion). See Q: A.1.1.5 for information on CLISP support. Table of Contents Overview Conventions I. Chapters or the Common Lisp HyperSpec 1. Introduction 1.1. Special Symbols 1.2. Error Terminology 1.3. Symbols in the Package “COMMON-LISP” 2. Syntax 2.1. Standard Characters 2.2. Reader Algorithm 2.3. Symbols as Tokens 2.4. Valid Patterns for Tokens 2.5. Backquote 2.6. Sharpsign 3. Evaluation and Compilation 3.1. Evaluation 3.2. Compilation 3.3. Declarations 3.4. Lambda Lists 4. Types and Classes 4.1. Types 4.2. Classes 4.3. Deviations from ANSI CL standard 4.4. Standard Metaclasses 4.5. Defining Classes 4.6. Redefining Classes 5. Data and Control Flow 5.1. Generalized Reference 5.2. Setf Expansions 5.3. Kinds of Places 5.4. Miscellaneous 5.5. Macro DEFCONSTANT 5.6. Macro EXT:FCASE 5.7. Function EXT:XOR 5.8. Function EQ 5.9. Special Operator FUNCTION 6. Iteration 6.1. The LOOP Facility 6.2. Miscellaneous 7. Objects 7.1. Standard Method Combination 8. Structures 8.1. The options for DEFSTRUCT 8.2. The structure Meta-Object Protocol 9. Conditions 9.1. Embedded Newlines in Condition Reports 9.2. Mentioning Containing Function in Condition Reports 9.3. Interfaces to Restarts 9.4. Assertions 10. Symbols 11. Packages 11.1. Introduction to Packages 11.2. Constraints on the “COMMON-LISP” Package for Conforming Programs - package locking 11.3. The “COMMON-LISP-USER” Package 11.4. Implementation-Defined Packages 11.5. Package Case-Sensitivity 12. Numbers 12.1. Numeric Types 12.2. Number Concepts 13. Characters 13.1. Introduction to Characters 13.2. Character sets 13.3. Character Scripts 13.4. Character Attributes 13.5. Graphic Characters 13.6. Alphabetic Characters 13.7. Characters With Case 13.8. Numeric Characters 13.9. Ordering of Characters 13.10. Treatment of Newline during Input and Output 13.11. Character Encodings 13.12. Documentation of Implementation-Defined Scripts 13.13. Platform-Dependent Characters 13.14. Obsolete Constants 14. Conses 14.1. Conses as Lists 15. Arrays 15.1. Array Elements 16. Strings 16.1. Miscellaneous 17. Sequences 17.1. Additional Functions 17.2. Additional Macros 17.3. Functions NREVERSE & NRECONC 17.4. Functions REMOVE & DELETE 17.5. Functions SORT & STABLE-SORT 18. Hash Tables 18.1. Modifying Hash Table Keys 18.2. Function MAKE-HASH-TABLE 18.3. Macro EXT:DEFINE-HASH-TABLE-TEST 18.4. Function HASH-TABLE-TEST 18.5. Macro EXT:DOHASH 19. Filenames 19.1. Pathname Components 19.2. :UNSPECIFIC as a Component Value 19.3. External notation 19.4. Logical Pathnames 19.5. Miscellaneous 20. Files 20.1. Directory is not a file 20.2. File functions 20.3. Directory functions 21. Streams 21.1. Interactive Streams 21.2. Terminal interaction 21.3. Binary Input and Output 21.4. Bulk Input and Output 21.5. Non-Blocking Input and Output 21.6. Newline Convention 21.7. Function STREAM-EXTERNAL-FORMAT 21.8. Function STREAM-ELEMENT-TYPE 21.9. Function EXT:MAKE-STREAM 21.10. Function FILE-POSITION 21.11. Function EXT:ELASTIC-NEWLINE 21.12. Function OPEN 21.13. Function CLEAR-INPUT 21.14. Function CLOSE 21.15. Function OPEN-STREAM-P 21.16. Class BROADCAST-STREAM 21.17. Functions EXT:MAKE-BUFFERED-INPUT-STREAM and EXT:MAKE-BUFFERED-OUTPUT-STREAM 22. Printer 22.1. Multiple Possible Textual Representations 22.2. Printing Floats 22.3. Printing Characters 22.4. Package Prefixes for Symbols 22.5. Printing Other Vectors 22.6. Printing Other Arrays 22.7. The Lisp Pretty Printer 22.8. Formatted Output 22.9. Functions WRITE & WRITE-TO-STRING 22.10. Macro PRINT-UNREADABLE-OBJECT 22.11. Miscellaneous Issues 23. Reader 23.1. Effect of Readtable Case on the Lisp Reader 23.2. The recursive-p argument 24. System Construction 24.1. Function COMPILE-FILE 24.2. Function COMPILE-FILE-PATHNAME 24.3. Function REQUIRE 24.4. Function LOAD 24.5. Variable *FEATURES* 24.6. Function EXT:FEATUREP [CLRFI-1] 24.7. Function EXT:COMPILED-FILE-P [CLRFI-2] 25. Environment 25.1. Top Level Loop 25.2. Debugging Utilities 25.3. Environment Inquiry 25.4. Time 26. Glossary 27. Appendix 28. X3J13 Issue Index [CLHS-ic] II. Common Portable Extensions 29. Meta-Object Protocol 29.1. Introduction 29.2. Overview 29.3. Classes 29.4. Slot Definitions 29.5. Generic Functions 29.6. Methods 29.7. Accessor Methods 29.8. Specializers 29.9. Method Combinations 29.10. Slot Access 29.11. Dependent Maintenance 29.12. Deviations from AMOP 30. Gray streams 30.1. Overview 30.2. Defined classes 30.3. General generic functions 30.4. Generic functions for character input 30.5. Generic functions for character output 30.6. Generic functions for binary input 30.7. Generic functions for binary output 30.8. Class EXT:FILL-STREAM III. Extensions Specific to CLISP 31. Platform Independent Extensions 31.1. Customizing CLISP Process Initialization and Termination 31.2. Saving an Image 31.3. Quitting CLISP 31.4. Internationalization of CLISP 31.5. Encodings 31.6. Generic streams 31.7. Weak Objects 31.8. Finalization 31.9. The Prompt 31.10. Maximum ANSI CL compliance 31.11. Additional Fancy Macros and Functions 31.12. Customizing CLISP behavior 31.13. Code Walker 32. Platform Specific Extensions 32.1. Random Screen Access 32.2. External Modules 32.3. The Foreign Function Call Facility 32.4. Socket Streams 32.5. Multiple Threads of Execution 32.6. Quickstarting delivery with CLISP 32.7. Shell, Pipes and Printing 32.8. Operating System Environment 33. Extensions Implemented as Modules 33.1. System Calls 33.2. Internationalization of User Programs 33.3. POSIX Regular Expressions 33.4. Advanced Readline and History Functionality 33.5. GDBM - The GNU database manager 33.6. Berkeley DB access 33.7. Directory Access 33.8. PostgreSQL Database Access 33.9. Oracle Interface 33.10. LibSVM Interface 33.11. Computer Algebra System PARI 33.12. Matlab Interface 33.13. Netica Interface 33.14. Perl Compatible Regular Expressions 33.15. The Wildcard Module 33.16. Interface to zlib 33.17. Raw Socket Access 33.18. The FastCGI Interface 33.19. Interface to D-Bus 33.20. GTK Interface IV. Internals of the CLISP Implementation 34. The source files of CLISP 34.1. File Types 34.2. Source Pre-Processing 34.3. Files 35. Overview of CLISP's Garbage Collection 35.1. Introduction 35.2. Lisp objects in CLISP 35.3. Object Pointer Representations 35.4. Memory Models 35.5. The burden of garbage-collection upon the rest of CLISP 35.6. Foreign Pointers 35.7. Garbage Collection and Multithreading 36. Extending CLISP Core 36.1. Adding a built-in function 36.2. Adding a built-in variable 36.3. Recompilation 37. The CLISP bytecode specification 37.1. Introduction 37.2. The virtual machine 37.3. The structure of compiled functions 37.4. The general structure of the instructions 37.5. The instruction set 37.6. Examining compiled closures 37.7. Bytecode Design V. Appendices A. Frequently Asked Questions (With Answers) about CLISP B. GNU Free Documentation License C. GNU General Public License C.1. Preamble C.2. TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION C.3. How to Apply These Terms to Your New Programs Index References List of Figures 29.1. Inheritance structure of metaobject classes 29.2. Inheritance structure of class metaobject classes 29.3. Inheritance structure of slot definition metaobject classes 29.4. Inheritance structure of generic function metaobject classes 29.5. Inheritance structure of method metaobject classes 29.6. Inheritance structure of specializer metaobject classes 29.7. Inheritance structure of method combination metaobject classes List of Tables 1. Mark-up conventions 3.1. Function call limits 12.1. Boolean operations 12.2. Fixnum limits 13.1. Number of characters 13.2. Standard characters 13.3. Semi-standard characters 13.4. Additional Named Characters 13.5. Additional syntax for characters with code from #x00 to #x1F: 13.6. Additional characters (Win32 platform only.) 13.7. Additional characters (UNIX platform only.) 13.8. Character bit constants (obsolete) 15.1. Array limits 19.1. The minimum filename syntax that may be used portably 25.1. Commands common to the main loop, the debugger and the stepper 25.2. Commands common to the debugger and the stepper 25.3. Commands common to the debugger and the stepper 25.4. Commands specific to EVAL/APPLY 25.5. Commands specific to the debugger 25.6. Commands specific to the stepper 25.7. Time granularity 29.1. Direct Superclass Relationships Among The Specified Metaobject Classes 29.2. Initialization arguments and accessors for class metaobjects 29.3. Initialization arguments and accessors for slot definition metaobjects 29.4. Initialization arguments and accessors for generic function metaobjects 29.5. Initialization arguments and accessors for method metaobjects 29.6. The correspondence between slot access function and underlying slot access generic function 35.1. Memory models with TYPECODES 35.2. Memory models with HEAPCODES List of Examples 25.1. Identifying Individual Calls in TRACE 30.1. Example of EXT:FILL-STREAM usage 32.1. Create a module set with GNU libc bindings 32.2. Simple declarations and access 32.3. External C variable and some accesses 32.4. Calling an external function 32.5. Another example for calling an external function 32.6. Accessing cpp macros 32.7. Calling Lisp from C 32.8. Calling Lisp from C dynamically 32.9. Variable size arguments: calling gethostname from CLISP 32.10. Accessing variables in shared libraries 32.11. Controlling validity of resources 32.12. Floating point arrays 32.13. Lisp read-eval-print loop server 32.14. Lisp HTTP client 33.1. REGEXP:MATCH 33.2. REGEXP:REGEXP-QUOTE 33.3. Count unix shell users Overview These notes discuss the CLISP implementation of Common Lisp by Bruno Haible and Michael Stoll. The current maintainers are Bruno Haible and Sam Steingold. This implementation is mostly conforming to the [ANSI CL standard] available on-line as the [Common Lisp HyperSpec] (but the printed ANSI document remains the authoritative source of information). [ANSI CL standard] supersedes the earlier specifications [CLtL1] and [CLtL2]. The first part of these notes, Part I, “Chapters or the Common Lisp HyperSpec”, is indexed in parallel to the [Common Lisp HyperSpec] and documents how CLISP implements the [ANSI CL standard]. The second part, Part II, “Common Portable Extensions”, documents the common extensions to the [ANSI CL standard], specifically Meta-Object Protocol and “GRAY” STREAMs. The third part, Part III, “Extensions Specific to CLISP”, documents the CLISP-specific extensions, e.g., Section 32.4, “Socket Streams”. The fourth part, Part IV, “Internals of the CLISP Implementation”, is intended mostly for developers as it documents the CLISP internals, e.g., garbage-collection, adding new built-ins, and the bytecodes generated by the compiler (i.e., what is printed by DISASSEMBLE). Conventions The following is the mark-up notations used in this document: Table 1. Mark-up conventions Object Kind Example Function CAR Variable CUSTOM:*LOAD-PATHS* Formal Argument x Keyword :EOF Number 0 Character #\Newline Class, type REGEXP:MATCH FORMAT instruction ~A Standard lambda list keyword &KEY Declaration FTYPE Package “COMMON-LISP-USER” Real file config.lisp Abstract file #P"".c"" Code (you are likely to type it) (CONS 1 2) Data (CLISP is likely to print it) #(1 2 3) Program listing  (DEFUN cycle-length (n &OPTIONAL (len 1) (top 0))   (COND ((= n 1) (VALUES len top))         ((EVENP n) (cycle-length (ASH n -1) (1+ len) (MAX top n)))         (T (LET ((next (1+ (* 3 n))))              (cycle-length next (1+ len) (MAX top next)))))) Bytecode instruction (STOREV k m) First mention of an entity firstterm External module libsvm, bindings/glibc Command line argument -x Interaction Computer output Prompt: user input Part I. Chapters or the [Common Lisp HyperSpec] Table of Contents 1. Introduction 1.1. Special Symbols 1.2. Error Terminology 1.3. Symbols in the Package “COMMON-LISP” 2. Syntax 2.1. Standard Characters 2.2. Reader Algorithm 2.3. Symbols as Tokens 2.4. Valid Patterns for Tokens 2.5. Backquote 2.6. Sharpsign 2.6.1. Sharpsign Backslash 2.6.2. Sharpsign Less-Than-Sign 3. Evaluation and Compilation 3.1. Evaluation 3.1.1. Introduction to Environments 3.1.2. Symbols as Forms 3.1.3. Conses as Forms 3.1.4. Special Forms 3.1.5. Function Forms 3.1.6. Macros DEFUN & DEFMACRO 3.2. Compilation 3.2.1. Compiler Terminology 3.2.2. Compilation Semantics 3.2.3. Definition of Similarity 3.2.4. Exceptional Situations in the Compiler 3.3. Declarations 3.3.1. Declaration SPECIAL 3.3.2. Declaration EXT:CONSTANT-NOTINLINE 3.3.3. Function CONSTANTP 3.3.4. Declaration SAFETY 3.3.5. Declaration (COMPILE) 3.3.6. Declaration SPACE 3.4. Lambda Lists 3.4.1. Boa Lambda Lists 4. Types and Classes 4.1. Types 4.1.1. Type Specifiers 4.2. Classes 4.3. Deviations from ANSI CL standard 4.4. Standard Metaclasses 4.5. Defining Classes 4.6. Redefining Classes 5. Data and Control Flow 5.1. Generalized Reference 5.2. Setf Expansions 5.3. Kinds of Places 5.4. Miscellaneous 5.5. Macro DEFCONSTANT 5.5.1. Variable CUSTOM:*SUPPRESS-SIMILAR-CONSTANT-REDEFINITION-WARNING* 5.6. Macro EXT:FCASE 5.7. Function EXT:XOR 5.8. Function EQ 5.9. Special Operator FUNCTION 6. Iteration 6.1. The LOOP Facility 6.1.1. Mixing Termination Test Clauses 6.1.2. Iteration variables in the loop epilogue 6.1.3. Backward Compatibility 6.2. Miscellaneous 7. Objects 7.1. Standard Method Combination 8. Structures 8.1. The options for DEFSTRUCT 8.1.1. The :PRINT-FUNCTION option 8.1.2. The :INHERIT option 8.2. The structure Meta-Object Protocol 9. Conditions 9.1. Embedded Newlines in Condition Reports 9.2. Mentioning Containing Function in Condition Reports 9.3. Interfaces to Restarts 9.4. Assertions 10. Symbols 11. Packages 11.1. Introduction to Packages 11.1.1. Function MAKE-PACKAGE 11.1.2. Macro DEFPACKAGE 11.1.3. Function EXT:RE-EXPORT 11.1.4. Function EXT:PACKAGE-CASE-INVERTED-P 11.1.5. Function EXT:PACKAGE-CASE-SENSITIVE-P 11.2. Constraints on the “COMMON-LISP” Package for Conforming Programs - package locking 11.3. The “COMMON-LISP-USER” Package 11.4. Implementation-Defined Packages 11.5. Package Case-Sensitivity 11.5.1. User Package for the Case-sensitive World 11.5.2. Package Names 11.5.3. Gensyms and Keywords 11.5.4. Migration Tips 11.5.5. Using case-sensitive packages by default 12. Numbers 12.1. Numeric Types 12.2. Number Concepts 12.2.1. Numeric Operations 12.2.2. Implementation-Dependent Numeric Constants 12.2.3. Rule of Float Substitutability 12.2.4. Floating-point Computations 12.2.5. Complex Computations 12.2.6. Rule of Canonical Representation for Complex Rationals 12.2.7. Random-State Operations 13. Characters 13.1. Introduction to Characters 13.1.1. Function CHAR-CODE 13.1.2. Type BASE-CHAR 13.1.3. Function EXT:CHAR-WIDTH 13.2. Character sets 13.3. Character Scripts 13.4. Character Attributes 13.4.1. Input Characters 13.5. Graphic Characters 13.6. Alphabetic Characters 13.7. Characters With Case 13.7.1. Function EXT:CHAR-INVERTCASE 13.7.2. Case of Implementation-Defined Characters 13.8. Numeric Characters 13.9. Ordering of Characters 13.10. Treatment of Newline during Input and Output 13.11. Character Encodings 13.12. Documentation of Implementation-Defined Scripts 13.13. Platform-Dependent Characters 13.14. Obsolete Constants 14. Conses 14.1. Conses as Lists 14.1.1. Mapping Functions 15. Arrays 15.1. Array Elements 16. Strings 16.1. Miscellaneous 16.1.1. String Comparison 16.1.2. Function EXT:STRING-WIDTH 16.1.3. Functions EXT:STRING-INVERTCASE and EXT:NSTRING-INVERTCASE 17. Sequences 17.1. Additional Functions 17.1.1. Function EXT:TRIM-IF 17.2. Additional Macros 17.2.1. Macro EXT:DOSEQ 17.3. Functions NREVERSE & NRECONC 17.4. Functions REMOVE & DELETE 17.5. Functions SORT & STABLE-SORT 18. Hash Tables 18.1. Modifying Hash Table Keys 18.2. Function MAKE-HASH-TABLE 18.2.1. Interaction between HASH-TABLEs and garbage-collection 18.3. Macro EXT:DEFINE-HASH-TABLE-TEST 18.4. Function HASH-TABLE-TEST 18.5. Macro EXT:DOHASH 19. Filenames 19.1. Pathname Components 19.1.1. Directory canonicalization 19.1.2. Platform-specific issues 19.2. :UNSPECIFIC as a Component Value 19.3. External notation 19.4. Logical Pathnames 19.5. Miscellaneous 19.5.1. Function TRANSLATE-PATHNAME 19.5.2. Function TRANSLATE-LOGICAL-PATHNAME 19.5.3. Function PARSE-NAMESTRING 19.5.4. Function MERGE-PATHNAMES 19.5.5. Function LOAD-LOGICAL-PATHNAME-TRANSLATIONS 19.5.6. Function EXT:ABSOLUTE-PATHNAME 20. Files 20.1. Directory is not a file 20.1.1. Function EXT:PROBE-PATHNAME 20.2. File functions 20.2.1. Function PROBE-FILE 20.2.2. Function FILE-AUTHOR 20.2.3. Function DELETE-FILE 20.2.4. Function RENAME-FILE 20.3. Directory functions 20.3.1. Function EXT:PROBE-DIRECTORY 20.3.2. Function DIRECTORY 20.3.3. Function EXT:DIR 20.3.4. Function EXT:CD 20.3.5. Function EXT:DEFAULT-DIRECTORY 20.3.6. Function EXT:MAKE-DIRECTORY 20.3.7. Function EXT:DELETE-DIRECTORY 20.3.8. Function EXT:RENAME-DIRECTORY 21. Streams 21.1. Interactive Streams 21.1.1. Initialization of Standard Streams 21.2. Terminal interaction 21.2.1. Command line editing with GNU readline 21.2.2. Macro EXT:WITH-KEYBOARD 21.3. Binary Input and Output 21.3.1. Binary input, READ-BYTE, EXT:READ-INTEGER & EXT:READ-FLOAT 21.3.2. Binary output, WRITE-BYTE, EXT:WRITE-INTEGER & EXT:WRITE-FLOAT 21.4. Bulk Input and Output 21.4.1. Bulk Input 21.4.2. Bulk Output 21.4.3. Rationale 21.5. Non-Blocking Input and Output 21.6. Newline Convention 21.6.1. Should programs output a newline before or after each line of output? 21.6.2. Analysis 21.6.3. Conclusion 21.6.4. Solution 21.6.5. Elastic Newline Analysis 21.7. Function STREAM-EXTERNAL-FORMAT 21.8. Function STREAM-ELEMENT-TYPE 21.8.1. Binary input from *STANDARD-INPUT* 21.9. Function EXT:MAKE-STREAM 21.10. Function FILE-POSITION 21.11. Function EXT:ELASTIC-NEWLINE 21.12. Function OPEN 21.13. Function CLEAR-INPUT 21.14. Function CLOSE 21.15. Function OPEN-STREAM-P 21.16. Class BROADCAST-STREAM 21.17. Functions EXT:MAKE-BUFFERED-INPUT-STREAM and EXT:MAKE-BUFFERED-OUTPUT-STREAM 22. Printer 22.1. Multiple Possible Textual Representations 22.2. Printing Floats 22.3. Printing Characters 22.4. Package Prefixes for Symbols 22.5. Printing Other Vectors 22.6. Printing Other Arrays 22.6.1. Printing Pathnames 22.7. The Lisp Pretty Printer 22.7.1. Pretty Print Dispatch Table 22.8. Formatted Output 22.9. Functions WRITE & WRITE-TO-STRING 22.10. Macro PRINT-UNREADABLE-OBJECT 22.11. Miscellaneous Issues 23. Reader 23.1. Effect of Readtable Case on the Lisp Reader 23.2. The recursive-p argument 24. System Construction 24.1. Function COMPILE-FILE 24.2. Function COMPILE-FILE-PATHNAME 24.3. Function REQUIRE 24.3.1. Additional LOAD locations 24.3.2. Interaction with COMPILE-FILE 24.4. Function LOAD 24.5. Variable *FEATURES* 24.6. Function EXT:FEATUREP [CLRFI-1] 24.7. Function EXT:COMPILED-FILE-P [CLRFI-2] 25. Environment 25.1. Top Level Loop 25.1.1. User-defined Commands 25.2. Debugging Utilities 25.2.1. Function DISASSEMBLE 25.2.2. Function EXT:UNCOMPILE 25.2.3. Function DOCUMENTATION 25.2.4. Function DESCRIBE 25.2.5. Macro TRACE 25.2.6. Function INSPECT 25.2.7. Macro TIME 25.2.8. Function ED 25.2.9. Functions APROPOS & APROPOS-LIST 25.2.10. Function DRIBBLE 25.3. Environment Inquiry 25.3.1. Function ROOM 25.3.2. Function EXT:GC 25.3.3. Machine 25.3.4. Function LISP-IMPLEMENTATION-VERSION 25.3.5. Function EXT:ARGV 25.4. Time 26. Glossary 27. Appendix 28. X3J13 Issue Index [CLHS-ic] Chapter 1. Introduction [chap-1] Table of Contents 1.1. Special Symbols 1.2. Error Terminology 1.3. Symbols in the Package “COMMON-LISP” 1.1. Special Symbols [sec_1-4-1-3] The final delimiter of an interactive stream: UNIX type Control+D at the beginning of a line Win32 type Control+Z, followed by Enter This final delimiter is never actually seen by programs; no need to test for #\^D or #\^Z - use READ-CHAR-NO-HANG to check for end-of-stream. A newline character can be entered by the user by pressing the Enter key. See also Section 21.13, “Function CLEAR-INPUT”. 1.2. Error Terminology [sec_1-4-2] Safety settings are ignored by the interpreted code; therefore where the standard uses the phrase “should signal an error”, an ERROR is SIGNALed. See Section 3.3.4, “Declaration SAFETY” for the safety of compiled code. 1.3. Symbols in the Package “COMMON-LISP” [sec_1-9] All 978 symbols in the “COMMON-LISP” package specified by the [ANSI CL standard] are implemented. Chapter 2. Syntax [chap-2] Table of Contents 2.1. Standard Characters 2.2. Reader Algorithm 2.3. Symbols as Tokens 2.4. Valid Patterns for Tokens 2.5. Backquote 2.6. Sharpsign 2.6.1. Sharpsign Backslash 2.6.2. Sharpsign Less-Than-Sign 2.1. Standard Characters [sec_2-1-3] The standard characters are #\Newline and the graphic characters with a CODE-CHAR between 32 and 126 (inclusive). 2.2. Reader Algorithm [sec_2-2] The requirement of step 4 that a “reader macro function may return zero values or one value” is enforced. You can use the function VALUES to control the number of values returned. 2.3. Symbols as Tokens [sec_2-3-4] A reserved token , i.e., a token that has potential number syntax but cannot be interpreted as a NUMBER, is interpreted as SYMBOL when being read. 2.4. Valid Patterns for Tokens [sec_2-3-5] When a token with package markers is read, then no checking is done whether the SYMBOL-PACKAGE part and the SYMBOL-NAME part do not have number syntax. (What would the purpose of this check be?) So we consider tokens like USER:: or :1 or LISP::4711 or 21:3 as symbols. 2.5. Backquote [sec_2-4-6] The backquote read macro also works when nested. Example:     (EVAL ``(,#'(LAMBDA () ',a) ,#'(LAMBDA () ',b)))  ≡ (EVAL `(list #'(LAMBDA () ',a) #'(LAMBDA () ',b)))  ≡ (EVAL (list 'list (list 'function (list 'lambda nil (list 'quote a)))                      (list 'function (list 'lambda nil (list 'quote b)))))  2.6. Sharpsign [sec_2-4-8] 2.6.1. Sharpsign Backslash 2.6.2. Sharpsign Less-Than-Sign Reader macros are also defined for the following: Additional reader macros #, load-time evaluation, kept despite the [ANSI CL standard] issue SHARP-COMMA-CONFUSION:REMOVE. #Y compiled FUNCTION objects and input STREAM's EXT:ENCODINGs #"""" PATHNAME: #""test.lisp"" is the value of (PATHNAME ""test.lisp"") 2.6.1. Sharpsign Backslash [sec_2-4-8-1] #\Code allows input of characters of arbitrary code: e.g., #\Code231 reads as the character (CODE-CHAR 231). 2.6.2. Sharpsign Less-Than-Sign [sec_2-4-8-20] This is the list of objects whose external representation cannot be meaningfully read in: Unreadable objects #<type ...> all STRUCTURE-OBJECTs lacking a keyword constructor #<ARRAY type dimensions> all ARRAYs except STRINGs, if *PRINT-ARRAY* is NIL #<SYSTEM-FUNCTION name> built-in function written in C #<ADD-ON-SYSTEM-FUNCTION name> module function written in C #<SPECIAL-OPERATOR name> special operator handler #<COMPILED-FUNCTION name> compiled function, if CUSTOM:*PRINT-CLOSURE* is NIL #<FUNCTION name ...> interpreted function, , if CUSTOM:*PRINT-CLOSURE* is NIL #<FRAME-POINTER #x...> pointer to a stack frame #<DISABLED POINTER> frame pointer which has become invalid on exit from the corresponding BLOCK or TAGBODY #<...STREAM...> STREAM #<PACKAGE name> PACKAGE #<HASH-TABLE #x...> HASH-TABLE, if *PRINT-ARRAY* is NIL #<READTABLE #x...> READTABLE #<SYMBOL-MACRO form> SYMBOL-MACRO handler #<MACRO function> macro expander (defined by DEFMACRO and friends) #<FFI:FOREIGN-POINTER #x...> foreign pointer (Platform Dependent: UNIX, Win32 platforms only.) #<FFI:FOREIGN-ADDRESS #x...> foreign address (Platform Dependent: UNIX, Win32 platforms only.) #<FFI:FOREIGN-VARIABLE name #x...> foreign variable (Platform Dependent: UNIX, Win32 platforms only.) #<FFI:FOREIGN-FUNCTION name #x...> foreign function (Platform Dependent: UNIX, Win32 platforms only.) #<UNBOUND> “value” of an unbound symbol, an unsupplied optional or keyword argument #<SPECIAL REFERENCE> environment marker for variables declared SPECIAL #<DOT> internal READ result for “.” #<END OF FILE> internal READ result, when the end-of-stream is reached #<READ-LABEL ...> intermediate READ result for #n# #<ADDRESS #x...> machine address, should not occur #<SYSTEM-POINTER #x...> should not occur Chapter 3. Evaluation and Compilation [chap-3] Table of Contents 3.1. Evaluation 3.1.1. Introduction to Environments 3.1.2. Symbols as Forms 3.1.2.1. Macro DEFINE-SYMBOL-MACRO 3.1.2.2. Dynamic Variables 3.1.3. Conses as Forms 3.1.4. Special Forms 3.1.4.1. Special operator EVAL-WHEN 3.1.4.2. Special operator THE 3.1.5. Function Forms 3.1.5.1. Function SYMBOL-FUNCTION 3.1.6. Macros DEFUN & DEFMACRO 3.2. Compilation 3.2.1. Compiler Terminology 3.2.1.1. Just-In-Time Native Compilation 3.2.2. Compilation Semantics 3.2.2.1. Compiler Macros 3.2.2.2. Minimal Compilation 3.2.2.3. Semantic Constraints 3.2.3. Definition of Similarity 3.2.4. Exceptional Situations in the Compiler 3.3. Declarations 3.3.1. Declaration SPECIAL 3.3.2. Declaration EXT:CONSTANT-NOTINLINE 3.3.3. Function CONSTANTP 3.3.4. Declaration SAFETY 3.3.5. Declaration (COMPILE) 3.3.6. Declaration SPACE 3.4. Lambda Lists 3.4.1. Boa Lambda Lists All the functions built by FUNCTION, COMPILE and the like are atoms. There are built-in functions written in C, compiled functions (both of type COMPILED-FUNCTION) and interpreted functions (of type FUNCTION). Table 3.1. Function call limits CALL-ARGUMENTS-LIMIT 212=4096 MULTIPLE-VALUES-LIMIT 27=128 LAMBDA-PARAMETERS-LIMIT 212=4096 3.1. Evaluation [sec_3-1] 3.1.1. Introduction to Environments 3.1.2. Symbols as Forms 3.1.2.1. Macro DEFINE-SYMBOL-MACRO 3.1.2.2. Dynamic Variables 3.1.3. Conses as Forms 3.1.4. Special Forms 3.1.4.1. Special operator EVAL-WHEN 3.1.4.2. Special operator THE 3.1.5. Function Forms 3.1.5.1. Function SYMBOL-FUNCTION 3.1.6. Macros DEFUN & DEFMACRO 3.1.1. Introduction to Environments [sec_3-1-1] Macro EXT:THE-ENVIRONMENT. As in Scheme, the macro (EXT:THE-ENVIRONMENT) returns the current lexical environment. This works only in interpreted code and is not compilable! Function (EXT:EVAL-ENV form &OPTIONAL environment). evaluates a form in a given lexical environment, just as if the form had been a part of the program that the environment came from. 3.1.2. Symbols as Forms [sec_3-1-2-1-1] 3.1.2.1. Macro DEFINE-SYMBOL-MACRO 3.1.2.2. Dynamic Variables 3.1.2.1. Macro DEFINE-SYMBOL-MACRO The macro DEFINE-SYMBOL-MACRO establishes SYMBOL-MACROs with global scope (as opposed to SYMBOL-MACROs defined with SYMBOL-MACROLET, which have local scope). The function EXT:SYMBOL-MACRO-EXPAND tests for a SYMBOL-MACRO: If symbol is defined as a SYMBOL-MACRO in the global environment, (EXT:SYMBOL-MACRO-EXPAND symbol) returns two values, T and the expansion; otherwise it returns NIL. EXT:SYMBOL-MACRO-EXPAND is a special case of MACROEXPAND-1. MACROEXPAND-1 can also test whether a symbol is defined as a SYMBOL-MACRO in lexical environments other than the global environment. 3.1.2.2. Dynamic Variables [sec_3-1-2-1-1-2] “Undefined variables”, i.e. variables which are referenced outside any lexical binding for a variable of the same name and which are not declared SPECIAL, are treated like dynamic variables in the global environment. The compiler SIGNALs a WARNING when it encounters an undefined variable. 3.1.3. Conses as Forms [sec_3-1-2-1-2] Lists of the form ((SETF symbol) ...) are also treated as function forms. This makes the syntax (function-name arguments ...) consistent with the syntax (FUNCALL #'function-name arguments ...). It implements the item 7 of the [ANSI CL standard] issue FUNCTION-NAME:LARGE and the definition of function forms, and is consistent with the use of function names elsewhere in Common Lisp. 3.1.4. Special Forms [sec_3-1-2-1-2-1] 3.1.4.1. Special operator EVAL-WHEN 3.1.4.2. Special operator THE 3.1.4.1. Special operator EVAL-WHEN EVAL-WHEN also accepts the situations (NOT EVAL) and (NOT COMPILE). Warning The situations EVAL, LOAD and COMPILE are deprecated by the [ANSI CL standard], and they are not equivalent to the new standard situations :EXECUTE, :LOAD-TOPLEVEL and :COMPILE-TOPLEVEL in that they ignore the top-level form versus non-top-level form distinction. 3.1.4.2. Special operator THE The special form (THE value-type form) is similar to CHECK-TYPE but does a type check only in interpreted code (no type check is done in compiled code - but see the EXT:ETHE macro) and does not allow interactive error correction by the user. 3.1.5. Function Forms [sec_3-1-2-1-2-3] 3.1.5.1. Function SYMBOL-FUNCTION Constant LAMBDA-LIST-KEYWORDS. (&OPTIONAL &REST &KEY &ALLOW-OTHER-KEYS &AUX &BODY &WHOLE &ENVIRONMENT) 3.1.5.1. Function SYMBOL-FUNCTION (SETF (SYMBOL-FUNCTION symbol) object) requires object to be either a FUNCTION, a SYMBOL-FUNCTION return value, or a lambda expression. The lambda expression is thereby immediately converted to a FUNCTION. 3.1.6. Macros DEFUN & DEFMACRO DEFUN and DEFMACRO are allowed in non-toplevel positions. As an example, consider the old ([CLtL1]) definition of GENSYM:  (let ((gensym-prefix ""G"")       (gensym-count 1))   (defun gensym (&optional (x nil s))     (when s       (cond ((stringp x) (setq gensym-prefix x))             ((integerp x)              (if (minusp x)                (error ""~S: index ~S is negative"" 'gensym x)                (setq gensym-count x)))             (t (error ""~S: argument ~S of wrong type"" 'gensym x))))     (prog1       (make-symbol         (concatenate 'string           gensym-prefix           (write-to-string gensym-count :base 10 :radix nil)))       (incf gensym-count))))  See also Section 3.2.2.2, “Minimal Compilation ”. Function EXT:ARGLIST. Function (EXT:ARGLIST name) returns the lambda list of the function or macro that name names and SIGNALs an ERROR if name is not FBOUNDP. It also SIGNALs an ERROR when the macro lambda list is not available due to the compiler optimization settings (see Section 3.3.6, “Declaration SPACE”). Variable CUSTOM:*SUPPRESS-CHECK-REDEFINITION*. When CUSTOM:*SUPPRESS-CHECK-REDEFINITION* is NIL, CLISP issues a WARNING when a function (macro, variable, class, etc) is redefined in a different file than its original definition. It is not a good idea to set this variable to T. Variable CUSTOM:*DEFUN-ACCEPT-SPECIALIZED-LAMBDA-LIST*. When CUSTOM:*DEFUN-ACCEPT-SPECIALIZED-LAMBDA-LIST* is non-NIL, DEFUN accepts specialized lambda lists, converting type-parameter associations to type declarations: (defun f ((x list) (y integer)) ...) is equivalent to (defun f (x y) (declare (type list x) (type integer y)) ...) This extension is disabled by -ansi and by setting CUSTOM:*ANSI* to T, but can be re-enabled by setting CUSTOM:*DEFUN-ACCEPT-SPECIALIZED-LAMBDA-LIST* explicitly. 3.2. Compilation [sec_3-2] 3.2.1. Compiler Terminology 3.2.1.1. Just-In-Time Native Compilation 3.2.2. Compilation Semantics 3.2.2.1. Compiler Macros 3.2.2.2. Minimal Compilation 3.2.2.3. Semantic Constraints 3.2.3. Definition of Similarity 3.2.4. Exceptional Situations in the Compiler 3.2.1. Compiler Terminology [sec_3-2-1] 3.2.1.1. Just-In-Time Native Compilation CLISP compiles to platform-independent bytecode. 3.2.1.1. Just-In-Time Native Compilation Platform Dependent: only in CLISP built with GNU lightning The code compiled to bytecodes with optimization levels  (OR (>= 0 SPACE) (<= 1 SPEED)) (by COMPILE, COMPILE-FILE, or (COMPILE)) will be just-in-time (i.e., on the first execution) compiled to native code using GNU lightning. 3.2.2. Compilation Semantics [sec_3-2-2] 3.2.2.1. Compiler Macros 3.2.2.2. Minimal Compilation 3.2.2.3. Semantic Constraints 3.2.2.1. Compiler Macros [sec_3-2-2-1] Compiler macros are expanded in the compiled code only, and ignored by the interpreter. 3.2.2.2. Minimal Compilation [sec_3-2-2-2] When a DEFUN form is EVALuated, the macros used there are expanded, so they must be already defined, and their (re)definition does not affect functions which are already defined. This means that even the interpreted code is minimally compiled in CLISP. 3.2.2.3. Semantic Constraints [sec_3-2-2-3] Non-conforming code that does not follow the rule “Special proclamations for dynamic variables must be made in the compilation environment.” can produce quite unexpected results, e.g., observable differences between compiled and interpreted programs:  (defun adder-c (value) (declare (COMPILE)) (lambda (x) (+ x value))) ⇒ ADDER-C	; compiled function; value is lexical (defun adder-i (value) (lambda (x) (+ x value))) ⇒ ADDER-I	; interpreted function; value is lexical (defparameter add-c-10 (adder-c 10)) ⇒ ADD-C-10	; compiled function (defparameter add-i-10 (adder-i 10)) ⇒ ADD-I-10	; interpreted function (funcall add-c-10 32) ⇒ 42	; as expected (funcall add-i-10 32) ⇒ 42	; as expected (defvar value 12) ⇒ VALUE	; affects ADDER-I and ADD-I-10 but not ADDER-C and ADD-C-10 (funcall add-c-10 32) ⇒ 42	; as before (funcall add-i-10 32) ⇒ 44	; value is now dynamic!  Non-conformance. The code shown above has a SPECIAL proclamation (by DEFVAR) for the variable value in the execution environment (before the last two FUNCALLs) but not in the compilation environment: at the moment the ADDER-I function is defined, value is not known to be a SPECIAL variable. Therefore the code is not conforming. Rationale The function ADD-C-10 was compiled before value was declared SPECIAL, so the symbol value was eliminated from its code and the SPECIAL declaration did not affect the return value (i.e., (funcall add-c-10 32) always returned 42). On the opposite, function ADDER-I was not compiled, so ADD-I-10 was interpreted. Whenever ADD-I-10 is executed, its definition is interpreted all over again. Before DEFVAR, value is evaluated as a lexical (because is is not declared SPECIAL yet), but after DEFVAR, we see a globally SPECIAL symbol value which can have only a global SYMBOL-VALUE (not a local binding), and thus we are compelled to evaluate it to 12. This behavior was implemented intentionally to ease interactive development, because usually the ADDER-I above would be followed by a (forgotten) DEFVAR. When a user compiles a program, the compiler is allowed to remember the information whether a variable was SPECIAL or not, because that allows the compiler to generate more efficient code, but in interpreted code, when the user changes the state of a variable, he does not want to re-evaluate all DEFUNs that use the variable. [ANSI CL standard] gives the implementation freedom regarding interpreted evaluation, how much it wants to remember / cache, and how much it wants to re-evaluate according the current environment, if it has changed. CLISP implements ad-hoc look-up for variables (but not for macros, see Section 3.2.2.2, “Minimal Compilation ”). 3.2.3. Definition of Similarity [sec_3-2-4-2-2] Hash tables are externalizable objects. 3.2.4. Exceptional Situations in the Compiler [sec_3-2-5] Both COMPILE and EVAL may SIGNAL the EXT:SOURCE-PROGRAM-ERROR CONDITION which derives from PROGRAM-ERROR and which contains additional slots with accessors EXT:SOURCE-PROGRAM-ERROR-FORM Returns the whole form in which the ERROR was SIGNALed EXT:SOURCE-PROGRAM-ERROR-DETAIL Returns the specific (usually small) part of the above which triggered the ERROR 3.3. Declarations [sec_3-3] 3.3.1. Declaration SPECIAL 3.3.2. Declaration EXT:CONSTANT-NOTINLINE 3.3.3. Function CONSTANTP 3.3.4. Declaration SAFETY 3.3.5. Declaration (COMPILE) 3.3.6. Declaration SPACE The declarations (TYPE type variable ...), (FTYPE type function ...), are ignored by both the interpreter and the compiler. 3.3.1. Declaration SPECIAL Declaration EXT:NOTSPECIAL. Declarations (PROCLAIM '(SPECIAL variable)) and DEFCONSTANT are undone by the (PROCLAIM '(EXT:NOTSPECIAL variable)) declaration. This declaration can be used only in global PROCLAIM and DECLAIM forms, not in local DECLARE forms. Warning You cannot expect miracles: functions compiled before the EXT:NOTSPECIAL proclamation was issued will still be treating variable as special even after the EXT:NOTSPECIAL proclamation. See also Section 3.2.2.3, “Semantic Constraints ”. Function EXT:SPECIAL-VARIABLE-P. You can use the function (EXT:SPECIAL-VARIABLE-P symbol &OPTIONAL environment) to check whether the symbol is a dynamic variable. environment of NIL or omitted means use the global environment. You can also obtain the current lexical environment using the macro EXT:THE-ENVIRONMENT (interpreted code only). This function will always return T for global special variables and constant variables. 3.3.2. Declaration EXT:CONSTANT-NOTINLINE Constants defined by DEFCONSTANT but proclaimed EXT:CONSTANT-NOTINLINE will not be inlined by the compiler. This is useful for variables which remain constant within an a single Lisp process but may vary between processes and machines (such as endianness or word size) thus they should be written to #P"".fas""s as symbols, not values. 3.3.3. Function CONSTANTP Function CONSTANTP fully complies with [ANSI CL standard]. Additionally, some non-trivial forms are identified as constants, e.g., (CONSTANTP '(+ 1 2 3)) returns T. Warning Since DEFCONSTANT initial value forms are not evaluated at compile time, CONSTANTP will not report T of their name within the same compilation unit for the null lexical environment. This is consistent and matches questionable code using the pattern (IF (CONSTANTP form) (EVAL form)). Use EVAL-WHEN if you need recognition and the value during compile-time. See also Section 31.11.5, “Macro EXT:COMPILE-TIME-VALUE”. 3.3.4. Declaration SAFETY Declaration (OPTIMIZE (SAFETY 3)) results in “safe” compiled code: function calls are never eliminated. This guarantees the semantics described in [sec_3-5]. 3.3.5. Declaration (COMPILE) The declaration (COMPILE) has the effect that the current form is compiled prior to execution. Examples:  (LOCALLY (DECLARE (compile)) form) executes the compiled version of form.  (LET ((x 0))   (FLET ((inc () (DECLARE (compile)) (INCF x))          (dec () (DECF x)))     (VALUES #'inc #'dec))) returns two functions. The first is compiled and increments x, the second is interpreted (slower) and decrements the same x. This declaration can also be used to name the resulting compiled closure:  (LAMBDA (x) (DECLARE (compile ident)) x) ⇒ #<COMPILED-FUNCTION IDENT> (FUNCTION-LAMBDA-EXPRESSION *) ⇒ NIL	; source is not preserved ⇒ T ⇒ IDENT (FBOUNDP 'ident) ⇒ NIL	; sic!  Note The declaration (COMPILE) is ignored by the following special operators: LABELS FLET MACROLET 3.3.6. Declaration SPACE The declaration determines what metadata is recorded in the function object: SPACE >= 2 documentation string is discarded SPACE >= 3 the original lambda list is also discarded (most information is still available, see DESCRIBE, but the names of the positional arguments are not). 3.4. Lambda Lists [sec_3-4] 3.4.1. Boa Lambda Lists 3.4.1. Boa Lambda Lists [sec_3-4-6] The initial value of an &AUX variable in a boa lambda list is the value of the corresponding slot's initial form. Chapter 4. Types and Classes [chap-4] Table of Contents 4.1. Types 4.1.1. Type Specifiers 4.2. Classes 4.3. Deviations from ANSI CL standard 4.4. Standard Metaclasses 4.5. Defining Classes 4.6. Redefining Classes 4.1. Types [sec_4-2] 4.1.1. Type Specifiers 4.1.1. Type Specifiers [sec_4-2-3] The general form of the COMPLEX type specifier is (COMPLEX type-of-real-part type-of-imaginary-part). The type specifier (COMPLEX type) is equivalent to (COMPLEX type type). DEFTYPE lambda lists are subject to destructuring (nested lambda lists are allowed, as in DEFMACRO) and may contain a &WHOLE marker, but not an &ENVIRONMENT marker. Function (EXT:TYPE-EXPAND type &OPTIONAL once-p). If type is a user-defined type specifier this will expand it recursively until it is no longer a user-defined type (unless once-p is supplied and non-NIL). Two values are returned - the expansion and an indicator (T or NIL) of whether the original type was a user-defined type specifier. The possible results of TYPE-OF CONS SYMBOL, NULL, BOOLEAN, KEYWORD BIT, (INTEGER 0 #.MOST-POSITIVE-FIXNUM), (INTEGER #.MOST-NEGATIVE-FIXNUM (0)), (INTEGER (#.MOST-POSITIVE-FIXNUM)), (INTEGER * (#.MOST-NEGATIVE-FIXNUM)) RATIONAL, SHORT-FLOAT, SINGLE-FLOAT, DOUBLE-FLOAT, LONG-FLOAT, COMPLEX CHARACTER, BASE-CHAR, STANDARD-CHAR (ARRAY element-type dimensions), (SIMPLE-ARRAY element-type dimensions) (VECTOR T size), (SIMPLE-VECTOR size) (STRING size), (SIMPLE-STRING size) (BASE-STRING size), (SIMPLE-BASE-STRING size) (BIT-VECTOR size), (SIMPLE-BIT-VECTOR size) FUNCTION, COMPILED-FUNCTION, STANDARD-GENERIC-FUNCTION STREAM, FILE-STREAM, SYNONYM-STREAM, BROADCAST-STREAM, CONCATENATED-STREAM, TWO-WAY-STREAM, ECHO-STREAM, STRING-STREAM PACKAGE, HASH-TABLE, READTABLE, PATHNAME, LOGICAL-PATHNAME, RANDOM-STATE, BYTE SPECIAL-OPERATOR, LOAD-TIME-EVAL, SYMBOL-MACRO, GLOBAL-SYMBOL-MACRO, EXT:ENCODING, FFI:FOREIGN-POINTER, FFI:FOREIGN-ADDRESS, FFI:FOREIGN-VARIABLE, FFI:FOREIGN-FUNCTION EXT:WEAK-POINTER, EXT:WEAK-LIST, EXT:WEAK-AND-RELATION, EXT:WEAK-OR-RELATION, EXT:WEAK-MAPPING, EXT:WEAK-AND-MAPPING, EXT:WEAK-OR-MAPPING, EXT:WEAK-ALIST, READ-LABEL, FRAME-POINTER, SYSTEM-INTERNAL ADDRESS (should not occur) any other SYMBOL (structure types or CLOS classes) a class object (CLOS classes without a proper name) Function COERCE. FIXNUM is not a character designator in [ANSI CL standard], although CODE-CHAR provides an obvious venue to COERCE a FIXNUM to a CHARACTER. When CUSTOM:*COERCE-FIXNUM-CHAR-ANSI* is NIL, CLISP COERCEs FIXNUMs to CHARACTERs via CODE-CHAR. When CUSTOM:*COERCE-FIXNUM-CHAR-ANSI* is non-NIL, FIXNUMs cannot be COERCEd to CHARACTERs. 4.2. Classes [sec_4-3] The CLOS symbols are EXPORTed from the package “CLOS”. “COMMON-LISP” uses (as in USE-PACKAGE) “CLOS” and EXT:RE-EXPORTs the [ANSI CL standard] standard exported symbols (the CLISP extensions, e.g., those described in Chapter 29, Meta-Object Protocol, are not EXT:RE-EXPORTed). Since the default :USE argument to MAKE-PACKAGE is “COMMON-LISP”, the standard CLOS symbols are normally visible in all user-defined packages. If you do not want them (for example, if you want to use the PCL implementation of CLOS instead of the native one), do the following:  (DEFPACKAGE ""CL-NO-CLOS"" (:use ""CL"")) (DO-EXTERNAL-SYMBOLS (symbol “COMMON-LISP”)   (SHADOW symbol ""CL-NO-CLOS"")) (DO-SYMBOLS (symbol ""CL-NO-CLOS"")   (EXPORT symbol ""CL-NO-CLOS"")) (IN-PACKAGE ""CL-NO-CLOS"") (LOAD ""pcl"")	; or whatever (DEFPACKAGE ""MY-USER"" (:use ""CL-NO-CLOS"")) (IN-PACKAGE ""MY-USER"") ;; your code which uses PCL goes here  4.3. Deviations from [ANSI CL standard] DEFCLASS supports the option :METACLASS STRUCTURE-CLASS. This option is necessary in order to define a subclass of a DEFSTRUCT-defined structure type using DEFCLASS instead of DEFSTRUCT. When CALL-NEXT-METHOD is called with arguments, the rule that the ordered set of applicable methods must be the same as for the original arguments is enforced by the implementation only in interpreted code. CLOS:GENERIC-FLET and CLOS:GENERIC-LABELS are implemented as macros, not as special operators (as permitted by [sec_3-1-2-1-2-2]). They are not imported into the packages “COMMON-LISP-USER” and “COMMON-LISP” because of the [ANSI CL standard] issue GENERIC-FLET-POORLY-DESIGNED:DELETE. PRINT-OBJECT is only called on objects of type STANDARD-OBJECT and STRUCTURE-OBJECT. It is not called on other objects, like CONSes and NUMBERs, due to the performance concerns. 4.4. Standard Metaclasses [sec_4-3-1-1] Among those classes listed in Figure 4-8, only the following are instances of BUILT-IN-CLASS: T CHARACTER NUMBER, COMPLEX, REAL, FLOAT, RATIONAL, RATIO, INTEGER SEQUENCE ARRAY, VECTOR, BIT-VECTOR, STRING LIST, CONS SYMBOL, NULL FUNCTION HASH-TABLE PACKAGE PATHNAME, LOGICAL-PATHNAME RANDOM-STATE READTABLE STREAM, BROADCAST-STREAM, CONCATENATED-STREAM, ECHO-STREAM, STRING-STREAM, FILE-STREAM, SYNONYM-STREAM, TWO-WAY-STREAM 4.5. Defining Classes [sec_4-3-2] DEFCLASS supports the :METACLASS option. Possible values are STANDARD-CLASS (the default), STRUCTURE-CLASS (which creates structure classes, like DEFSTRUCT does), and user-defined meta-classes (see Section 29.3.6.7, “Generic Function CLOS:VALIDATE-SUPERCLASS”). It is not required that the superclasses of a class are defined before the DEFCLASS form for the class is evaluated. Use Meta-Object Protocol generic functions CLOS:CLASS-FINALIZED-P to check whether the class has been finalized and thus its instances can be created, and CLOS:FINALIZE-INHERITANCE to force class finalization. See also Section 29.3.1, “Macro DEFCLASS”. 4.6. Redefining Classes [sec_4-3-6] Trivial changes, e.g., those that can occur when doubly loading the same code, do not require updating the instances. These are the changes that do not modify the set of local slots accessible in instances, e.g., changes to slot options :INITFORM, :DOCUMENTATION, and changes to class options :DEFAULT-INITARGS, :DOCUMENTATION. The instances are updated when they are first accessed, not at the time when the class is redefined or MAKE-INSTANCES-OBSOLETE is called. When the class has been redefined several times since the instance was last accessed, UPDATE-INSTANCE-FOR-REDEFINED-CLASS is still called just once. Chapter 5. Data and Control Flow [chap-5] Table of Contents 5.1. Generalized Reference 5.2. Setf Expansions 5.3. Kinds of Places 5.4. Miscellaneous 5.5. Macro DEFCONSTANT 5.5.1. Variable CUSTOM:*SUPPRESS-SIMILAR-CONSTANT-REDEFINITION-WARNING* 5.6. Macro EXT:FCASE 5.7. Function EXT:XOR 5.8. Function EQ 5.9. Special Operator FUNCTION 5.1. Generalized Reference [sec_5-1] &KEY markers in DEFSETF lambda lists are supported, but the corresponding keywords must appear literally in the program text. An attempt to modify read-only data SIGNALs an ERROR. Program text and quoted constants loaded from files are considered read-only data. This check is only performed for strings, not for conses, other kinds of arrays, and user-defined data types. See also Section 31.11.2, “Macros EXT:LETF & EXT:LETF*”. 5.2. Setf Expansions [sec_5-1-1-2] (GET-SETF-EXPANSION form &OPTIONAL environment), (EXT:GET-SETF-METHOD form &OPTIONAL environment), and (EXT:GET-SETF-METHOD-MULTIPLE-VALUE form &OPTIONAL environment) receive as optional argument environment the environment necessary for macro expansions. In DEFINE-SETF-EXPANDER and EXT:DEFINE-SETF-METHOD lambda lists, one can specify &ENVIRONMENT and a variable, which will be bound to the environment. This environment should be passed to all calls of GET-SETF-EXPANSION, EXT:GET-SETF-METHOD and EXT:GET-SETF-METHOD-MULTIPLE-VALUE. If this is done, even local macros will be interpreted as places correctly. 5.3. Kinds of Places [sec_5-1-2] Additional places: FUNCALL (SETF (FUNCALL #'symbol ...) object) and (SETF (FUNCALL 'symbol ...) object) are equivalent to (SETF (symbol ...) object). PROGN (SETF (PROGN form ... place) object) LOCALLY (SETF (LOCALLY declaration ... form ... place) object) IF (SETF (IF condition place1 place2) object) GET-DISPATCH-MACRO-CHARACTER (SETF (GET-DISPATCH-MACRO-CHARACTER ...) ...) calls SET-DISPATCH-MACRO-CHARACTER. EXT:LONG-FLOAT-DIGITS: (SETF (EXT:LONG-FLOAT-DIGITS) digits) sets the default mantissa length of LONG-FLOATs to digits bits. VALUES-LIST (SETF (VALUES-LIST list) form) is equivalent to (VALUES-LIST (SETF list (MULTIPLE-VALUE-LIST form))). Note Note that this place is restricted: it can only be used in SETF, EXT:LETF, EXT:LETF*, not in other positions. 5.4. Miscellaneous Function FUNCTION-LAMBDA-EXPRESSION The name of a FFI:FOREIGN-FUNCTION is a string (the name of the underlying C function), not a lisp function name. Macro DESTRUCTURING-BIND This macro does not perform full error checking. Macros PROG1, PROG2, AND, OR, PSETQ, WHEN, UNLESS, COND, CASE, MULTIPLE-VALUE-LIST, MULTIPLE-VALUE-BIND, MULTIPLE-VALUE-SETQ These macros are implemented as special operators (as permitted by [sec_3-1-2-1-2-2]) and, as such, are rather efficient. 5.5. Macro DEFCONSTANT 5.5.1. Variable CUSTOM:*SUPPRESS-SIMILAR-CONSTANT-REDEFINITION-WARNING* The initial value is not evaluated at compile time, just like with DEFVAR and DEFPARAMETER. Use EVAL-WHEN if you need the value at compile time. constant variables may not be bound dynamically or lexically. See also Section 3.3.2, “Declaration EXT:CONSTANT-NOTINLINE”. If you need to undo the effects of a DEFCONSTANT form, PROCLAIM the symbol SPECIAL (to turn the constant variable into a dynamic variable), and then PROCLAIM it EXT:NOTSPECIAL (to turn the dynamic variable into a lexical variable). Note If you follow the usual variable naming convention (*FOO* for DEFVAR and DEFPARAMETER, +BAR+ for DEFCONSTANT, ZOT for LET/LET*), you will save yourself a lot of trouble. See also Q: A.4.14. 5.5.1. Variable CUSTOM:*SUPPRESS-SIMILAR-CONSTANT-REDEFINITION-WARNING* If the variable being defined by DEFCONSTANT is already bound to a value which is not EQL to the new value, a WARNING is issued. If, however, the new value is visually similar (prints to the same string, as is commonly the case when re-loading files) to the old one, the warning can be suppressed by setting CUSTOM:*SUPPRESS-SIMILAR-CONSTANT-REDEFINITION-WARNING* to a non-NIL value. The initial value of CUSTOM:*SUPPRESS-SIMILAR-CONSTANT-REDEFINITION-WARNING* is NIL. 5.6. Macro EXT:FCASE This macro allows specifying the test for CASE, e.g.,  (fcase string= (subseq foo 0 (position #\Space foo))   (""first"" 1)   ((""second"" ""two"") 2)   ((""true"" ""yes"") t)   (otherwise nil))  is the same as  (let ((var (subseq foo 0 (position #\Space foo))))   (cond ((string= var ""first"") 1)         ((or (string= var ""second"") (string= var ""two"")) 2)         ((or (string= var ""true"") (string= var ""yes"")) t)         (t nil)))  If you use a built-in HASH-TABLE test (see Section 18.4, “Function HASH-TABLE-TEST”) as the test (e.g., EQUAL instead of STRING= above, but not a test defined using EXT:DEFINE-HASH-TABLE-TEST), the compiler will be able to optimize the EXT:FCASE form better than the corresponding COND form. 5.7. Function EXT:XOR This function checks that exactly one of its arguments is non-NIL and, if this is the case, returns its value and index in the argument list as multiple values, otherwise returns NIL. 5.8. Function EQ EQ compares CHARACTERs and FIXNUMs as EQL does. No unnecessary copies are made of CHARACTERs and NUMBERs. Nevertheless, one should use EQL as it is more portable across Common Lisp implementations. (LET ((x y)) (EQ x x)) always returns T for any Lisp object y. See also Equality of foreign values. 5.9. Special Operator FUNCTION (FUNCTION symbol) returns the local function definition established by FLET or LABELS, if it exists, otherwise the global function definition. (SPECIAL-OPERATOR-P symbol) returns NIL or T. If it returns T, then (SYMBOL-FUNCTION symbol) returns the (useless) special operator handler. Chapter 6. Iteration [chap-6] Table of Contents 6.1. The LOOP Facility 6.1.1. Mixing Termination Test Clauses 6.1.2. Iteration variables in the loop epilogue 6.1.3. Backward Compatibility 6.2. Miscellaneous 6.1. The LOOP Facility [sec_6-1] 6.1.1. Mixing Termination Test Clauses 6.1.2. Iteration variables in the loop epilogue 6.1.3. Backward Compatibility 6.1.1. Mixing Termination Test Clauses [sec_6-1-4] Mixing termination test clauses with different default return values is not allowed because it is not specifed whether  (loop repeat 1 thereis nil never nil)  should return T (the default return value from NEVER) of NIL (the default return value from THEREIS). 6.1.2. Iteration variables in the loop epilogue The standard is unambiguous in that the iteration variables do still exist in the FINALLY clause, but not as to what values these variables might have. Therefore the code which relies on the values of such variables, e.g., (loop for x on y finally (return x)) is inherently non-portable across Common Lisp implementations, and should be avoided. 6.1.3. Backward Compatibility There have been some tightening in the LOOP syntax between [CLtL2] and [ANSI CL standard], e.g., the following form is legal in the former but not the latter:  (loop initially for i from 1 to 5 do (print i) finally return i)  When CUSTOM:*LOOP-ANSI* is NIL, such forms are still accepted in CLISP but elicit a warning at macro-expansion time. When CUSTOM:*LOOP-ANSI* is non-NIL, an ERROR is SIGNALed. 6.2. Miscellaneous The macros DOLIST and DOTIMES establish a single binding for the iteration variable and assign it on each iteration. Chapter 7. Objects [chap-7] Table of Contents 7.1. Standard Method Combination 7.1. Standard Method Combination [sec_7-6-6-2] Generic function CLOS:NO-PRIMARY-METHOD (similar to NO-APPLICABLE-METHOD) is called when there is an applicable method but no applicable primary method. The default methods for CLOS:NO-PRIMARY-METHOD, NO-APPLICABLE-METHOD and NO-NEXT-METHOD SIGNAL an ERROR of type CLOS:METHOD-CALL-ERROR . You can find out more information about the error using functions CLOS:METHOD-CALL-ERROR-GENERIC-FUNCTION, CLOS:METHOD-CALL-ERROR-ARGUMENT-LIST, and (only for NO-NEXT-METHOD) CLOS:METHOD-CALL-ERROR-METHOD. Moreover, when the generic function has only one dispatching argument, (i.e., such an argument that not all the corresponding parameter specializers are T), an ERROR of type CLOS:METHOD-CALL-TYPE-ERROR is SIGNALed, additionally making TYPE-ERROR-DATUM and TYPE-ERROR-EXPECTED-TYPE available. Chapter 8. Structures [chap-8] Table of Contents 8.1. The options for DEFSTRUCT 8.1.1. The :PRINT-FUNCTION option 8.1.2. The :INHERIT option 8.2. The structure Meta-Object Protocol 8.1. The options for DEFSTRUCT 8.1.1. The :PRINT-FUNCTION option 8.1.2. The :INHERIT option 8.1.1. The :PRINT-FUNCTION option The :PRINT-FUNCTION option should contain a lambda expression (LAMBDA (object stream depth) (declare (ignore depth)) ...) This lambda expression names a FUNCTION whose task is to output the external representation of the STRUCTURE-OBJECT object onto the STREAM stream. This may be done by outputting text onto the stream using WRITE-CHAR, WRITE-STRING, WRITE, PRIN1, PRINC, PRINT, PPRINT, FORMAT and the like. The following rules must be obeyed: The value of *PRINT-ESCAPE* must be respected. The treatment of *PRINT-PRETTY* is up to you. The value of *PRINT-CIRCLE* need not be respected. This is managed by the system. (But the print-circle mechanism handles only those objects that are direct or indirect components of the structure.) The value of *PRINT-LEVEL* is respected by WRITE, PRIN1, PRINC, PRINT, PPRINT, FORMAT instructions ~A, ~S, ~W, and FORMAT instructions ~R, ~D, ~B, ~O, ~X, ~F, ~E, ~G, ~$ with not-numerical arguments. Therefore the print-level mechanism works automatically if only these functions are used for outputting objects and if they are not called on objects with nesting level > 1. (The print-level mechanism does not recognize how many parentheses you have output. It only counts how many times it was called recursively.) The value of *PRINT-LENGTH* must be respected, especially if you are outputting an arbitrary number of components. The value of *PRINT-READABLY* must be respected. Remember that the values of *PRINT-ESCAPE*, *PRINT-LEVEL*, *PRINT-LENGTH* are ignored if *PRINT-READABLY* is true. The value of *PRINT-READABLY* is respected by PRINT-UNREADABLE-OBJECT, WRITE, PRIN1, PRINC, PRINT, PPRINT, FORMAT instructions ~A, ~S, ~W, and FORMAT instructions ~R, ~D, ~B, ~O, ~X, ~F, ~E, ~G, ~$ with not-numerical arguments. Therefore *PRINT-READABLY* will be respected automatically if only these functions are used for printing objects. You need not worry about the values of *PRINT-BASE*, *PRINT-RADIX*, *PRINT-CASE*, *PRINT-GENSYM*, *PRINT-ARRAY*, CUSTOM:*PRINT-CLOSURE*, CUSTOM:*PRINT-RPARS*, CUSTOM:*PRINT-INDENT-LISTS*. 8.1.2. The :INHERIT option The :INHERIT option is exactly like :INCLUDE except that it does not create new accessors for the inherited slots (this is a CLISP extension). 8.2. The structure Meta-Object Protocol The following functions accept a structure name as the only argument. If DEFSTRUCT was given the :TYPE option (i.e., DEFSTRUCT did not define a new type), then (FIND-CLASS name) fails (and the regular CLOS Meta-Object Protocol is not applicable), but these functions still work. EXT:STRUCTURE-SLOTS Return the LIST of effective slot definition metaobjects. EXT:STRUCTURE-DIRECT-SLOTS Return the LIST of direct slot definition metaobjects. EXT:STRUCTURE-KEYWORD-CONSTRUCTOR Return the name (a SYMBOL) of the keyword constructor function for the structure, or NIL if the structure has no keyword constructor. EXT:STRUCTURE-BOA-CONSTRUCTORS Return the LIST of names (SYMBOLs) of BOA constructors for the structure. EXT:STRUCTURE-COPIER Return the name (a SYMBOL) of the copier for the structure. EXT:STRUCTURE-PREDICATE Return the name (a SYMBOL) of the predicate for the structure. Chapter 9. Conditions [chap-9] Table of Contents 9.1. Embedded Newlines in Condition Reports 9.2. Mentioning Containing Function in Condition Reports 9.3. Interfaces to Restarts 9.4. Assertions When an error occurred, you are in a break loop. You can evaluate forms as usual. The help command (or help key if there is one) lists the available debugger commands. 9.1. Embedded Newlines in Condition Reports [sec_9-1-3-1-3] The error message prefix for the first line is “*** - ”. All subsequent lines are indented by 6 characters. Long lines are broken on whitespace (see Section 30.8, “Class EXT:FILL-STREAM”). 9.2. Mentioning Containing Function in Condition Reports [sec_9-1-3-1-5] Contrary to the recommendation of the standard, CLISP usually does print the name of the containing function to simplify debugging in batch mode, see EXT:EXIT-ON-ERROR. 9.3. Interfaces to Restarts [sec_9-1-4-2-2] Macro RESTART-CASE. In (RESTART-CASE form {restart-clause}*), the argument list can also be specified after the keyword/value pairs instead of before them, i.e., each restart-clause can be either (restart-name EXT:*ARGS* {keyword-value-pair}* {form}*) or (restart-name {keyword-value-pair}* EXT:*ARGS* {form}*). Macro EXT:WITH-RESTARTS. The macro EXT:WITH-RESTARTS is like RESTART-CASE, except that the forms are specified after the restart clauses instead of before them, and the restarts created are not implicitly associated with any CONDITION. (EXT:WITH-RESTARTS ({restart-clause}*) {form}*) is therefore equivalent to (RESTART-CASE (PROGN {form}*) {restart-clause}*). Function COMPUTE-RESTARTS. COMPUTE-RESTARTS and FIND-RESTART behave as specified in [ANSI CL standard]: If the optional condition argument is non-NIL, only RESTARTs associated with that CONDITION and RESTARTs associated with no CONDITION at all are considered. Therefore the effect of associating a restart to a condition is not to activate it, but to hide it from other conditions. This makes the syntax-dependent implicit association performed by RESTART-CASE nearly obsolete. Macro EXT:MUFFLE-CERRORS. The macro (EXT:MUFFLE-CERRORS {form}*) executes the forms; when a continuable ERROR occurs whose CONTINUE RESTART can be invoked non-interactively (this includes all continuable ERRORs signaled by the function CERROR), no message is printed, instead, the CONTINUE RESTART is invoked. Macro EXT:APPEASE-CERRORS. The macro (EXT:APPEASE-CERRORS {form}*) executes the forms; when a continuable ERROR occurs whose CONTINUE RESTART can be invoked non-interactively (this includes all continuable ERRORs SIGNALed by the function CERROR), it is reported as a WARNING, and the CONTINUE RESTART is invoked. Macro EXT:ABORT-ON-ERROR. The macro (EXT:ABORT-ON-ERROR {form}*) executes the forms; when an ERROR occurs, or when a Control+C interrupt occurs, the error message is printed and the ABORT RESTART is invoked. Macro EXT:EXIT-ON-ERROR. The macro (EXT:EXIT-ON-ERROR {form}*) executes the forms; when an ERROR occurs, or when a Control+C interrupt occurs, the error message is printed and CLISP terminates with an error status. Variable CUSTOM:*REPORT-ERROR-PRINT-BACKTRACE*. When this variable is non-NIL the error message printed by EXT:ABORT-ON-ERROR and EXT:EXIT-ON-ERROR includes the backtrace (stack). Function EXT:SET-GLOBAL-HANDLER. The function (EXT:SET-GLOBAL-HANDLER condition handler) establishes a global handler for the condition. The handler should be FUNCALLable (a SYMBOL or a FUNCTION). If it returns, the next applicable handler is invoked, so if you do not want to land in the debugger, it should not return. E.g., the option -on-error abort and the macro EXT:ABORT-ON-ERROR are implemented by installing the following handler: (defun sys::abortonerror (condition)   (sys::report-error condition)   (INVOKE-RESTART (FIND-RESTART 'ABORT condition))) When handler is NIL, the handler for condition is removed and returned. When condition is also NIL, all global handlers are removed and returned as a LIST, which can then be passed to EXT:SET-GLOBAL-HANDLER as the first argument and the handlers re-established. Macro EXT:WITHOUT-GLOBAL-HANDLERS. The macro (EXT:WITHOUT-GLOBAL-HANDLERS &BODY body) removes all global handlers by (EXT:SET-GLOBAL-HANDLER NIL NIL), executes body (where unhandled conditions now invoke the debugger), and then restores the handlers. 9.4. Assertions [sec-9-1-5] The prompt for replacement values (RESTARTs STORE-VALUE, USE-VALUE et al) is terminated with CUSTOM:*PROMPT-FINISH* to indicate that the value entered is treated as usual for the Lisp read-eval-print loop, i.e., it is EVALuated. Chapter 10. Symbols [chap-10] No notes. Chapter 11. Packages [chap-11] Table of Contents 11.1. Introduction to Packages 11.1.1. Function MAKE-PACKAGE 11.1.2. Macro DEFPACKAGE 11.1.3. Function EXT:RE-EXPORT 11.1.4. Function EXT:PACKAGE-CASE-INVERTED-P 11.1.5. Function EXT:PACKAGE-CASE-SENSITIVE-P 11.2. Constraints on the “COMMON-LISP” Package for Conforming Programs - package locking 11.3. The “COMMON-LISP-USER” Package 11.4. Implementation-Defined Packages 11.5. Package Case-Sensitivity 11.5.1. User Package for the Case-sensitive World 11.5.2. Package Names 11.5.3. Gensyms and Keywords 11.5.4. Migration Tips 11.5.5. Using case-sensitive packages by default The [ANSI CL standard] packages present in CLISP “COMMON-LISP” with the nicknames “CL” and “LISP” “COMMON-LISP-USER” with the nicknames “CL-USER” and “USER” “KEYWORD” with no nicknames 11.1. Introduction to Packages [sec_11-1-1] 11.1.1. Function MAKE-PACKAGE 11.1.2. Macro DEFPACKAGE 11.1.3. Function EXT:RE-EXPORT 11.1.4. Function EXT:PACKAGE-CASE-INVERTED-P 11.1.5. Function EXT:PACKAGE-CASE-SENSITIVE-P 11.1.1. Function MAKE-PACKAGE The default value of the :USE argument is (“COMMON-LISP”). MAKE-PACKAGE accepts additional keyword arguments :CASE-SENSITIVE and :CASE-INVERTED (but not :MODERN!) 11.1.2. Macro DEFPACKAGE DEFPACKAGE accepts additional options :CASE-SENSITIVE, :CASE-INVERTED, and :MODERN. When the package being defined already exists, it is modified as follows (and in this order): :CASE-SENSITIVE adjusted with (SETF EXT:PACKAGE-CASE-SENSITIVE-P) (with a warning) :CASE-INVERTED adjusted with (SETF EXT:PACKAGE-CASE-INVERTED-P) (with a warning) :MODERN if “COMMON-LISP” is being used, it is un-used and “CS-COMMON-LISP” is used instead; also, “CS-COMMON-LISP” is used instead of “COMMON-LISP” throughout the DEFPACKAGE form, e.g.,  (DEFPACKAGE ""FOO""   (:MODERN T)   (:USE ""COMMON-LISP"" ""EXT""))  is equivalent to  (DEFPACKAGE ""FOO""   (:CASE-SENSITIVE T)   (:CASE-INVERTED T)   (:USE ""CS-COMMON-LISP"" ""EXT""))  (:MODERN NIL) reverts the effects of (:MODERN T). :NICKNAMES adjusted with RENAME-PACKAGE :DOCUMENTATION reset to the new value with (SETF DOCUMENTATION) :SHADOW adjusted with SHADOW :SHADOWING-IMPORT-FROM adjusted with SHADOWING-IMPORT :USE adjusted with USE-PACKAGE and UNUSE-PACKAGE :IMPORT-FROM adjusted with IMPORT :INTERN adjusted with INTERN (but not UNINTERN) :EXPORT adjusted with INTERN and EXPORT (but not UNEXPORT) :SIZE ignored 11.1.3. Function EXT:RE-EXPORT The function (EXT:RE-EXPORT FROM-PACK TO-PACK) re-EXPORTs all external SYMBOLs from FROM-PACK also from TO-PACK, provided it already uses FROM-PACK; and SIGNALs an ERROR otherwise. 11.1.4. Function EXT:PACKAGE-CASE-INVERTED-P Returns T if the argument is a case-inverted package. This function is SETFable, although it is probably not a good idea to change the case-inverted status of an existing package. 11.1.5. Function EXT:PACKAGE-CASE-SENSITIVE-P Returns T if the argument is a :CASE-SENSITIVE PACKAGE. This function is SETFable, although it is probably not a good idea to change the case-sensitive status of an existing package. 11.2. Constraints on the “COMMON-LISP” Package for Conforming Programs - package locking [sec_11-1-2-1-2] Note Locking discussed in this section has nothing to do with MT:MUTEX-LOCK. Function EXT:PACKAGE-LOCK . Packages can be “locked”. When a package is locked, attempts to change its symbol table or redefine functions which its symbols name result in a continuable ERROR (continuing overrides locking for this operation). When CUSTOM:*SUPPRESS-CHECK-REDEFINITION* is T (not a good idea!), the ERROR is not SIGNALed for redefine operations. Function (EXT:PACKAGE-LOCK package) returns the generalized boolean indicating whether the package is locked. A package (or a list thereof) can be locked using (SETF (EXT:PACKAGE-LOCK package-or-list) T). CLISP locks its system packages (specified in the variable CUSTOM:*SYSTEM-PACKAGE-LIST*). Macro EXT:WITHOUT-PACKAGE-LOCK. If you want to evaluate some forms with certain packages unlocked, you can use EXT:WITHOUT-PACKAGE-LOCK :  (EXT:WITHOUT-PACKAGE-LOCK (“COMMON-LISP” “EXT” “CLOS”)   (defun restart () ...))  or  (EXT:WITHOUT-PACKAGE-LOCK (“COMMON-LISP”) (trace read-line))  (EXT:WITHOUT-PACKAGE-LOCK () ...) temporarily unlocks all packages in CUSTOM:*SYSTEM-PACKAGE-LIST*. Variable CUSTOM:*SYSTEM-PACKAGE-LIST*. This variable specifies the default packages to be locked by EXT:SAVEINITMEM and unlocked by EXT:WITHOUT-PACKAGE-LOCK as a list of package names. You may add names to this list, e.g., a module will add its package, but you should not remove CLISP internal packages from this list. Discussion - see also the USENET posting by Steven M. Haflich. This should prevent you from accidentally hosing yourself with  (DEFSTRUCT instance ...)  and allow enforcing modularity. Note that you will also get the continuable ERROR when you try to assign (with SETQ, PSETQ, etc.) a value to an internal special variable living in a locked package and not accessible in your current *PACKAGE*, but only in the interpreted code and during compilation. There is no check for package locks in compiled code because of the performance considerations. 11.3. The “COMMON-LISP-USER” Package [sec_11-1-2-2] The “COMMON-LISP-USER” package uses the “COMMON-LISP” and “EXT” packages. 11.4. Implementation-Defined Packages [sec_11-1-2-4] The following additional packages exist: Implementation-Defined Packages “CLOS” EXPORTs all CLOS-specific symbols, including some additional symbols. “SYSTEM” has the nickname “SYS”, and has no EXPORTed symbols. It defines many system internals. “EXT” is the umbrella package for all extensions: it imports and EXT:RE-EXPORTs all the external symbols in all CLISP extensions, so a simple (USE-PACKAGE ""EXT"") is enough to make all the extensions available in the current package. This package uses packages (in addition to “COMMON-LISP”): “POSIX”, “SOCKET”, “GSTREAM”, “GRAY”, “I18N”, “CUSTOM”. “CHARSET” defines and EXPORTs some character sets, for use with EXT:MAKE-ENCODING and as :EXTERNAL-FORMAT argument. “FFI” implements the foreign function interface. Some platforms only. “SCREEN” defines an API for random screen access. Some platforms only. “CS-COMMON-LISP” “CS-COMMON-LISP-USER” :CASE-SENSITIVE versions of “COMMON-LISP” and “COMMON-LISP-USER”. See Section 11.5, “Package Case-Sensitivity”. All pre-existing packages except “COMMON-LISP-USER” belong to the implementation, in the sense that the programs that do not follow [sec_11-1-2-1-2] (“Constraints on the ‘COMMON-LISP’ Package for Conforming Programs”) cause undefined behavior. 11.5. Package Case-Sensitivity 11.5.1. User Package for the Case-sensitive World 11.5.2. Package Names 11.5.3. Gensyms and Keywords 11.5.4. Migration Tips 11.5.5. Using case-sensitive packages by default CLISP supports programs written with case sensitive symbols. For example, with case sensitive symbols, the symbols cdr (the function equivalent to REST) and the symbol CDR (a user-defined type denoting a Call Data Record) are different and unrelated. There are some incompatibilities between programs assuming case sensitive symbols and programs assuming the [ANSI CL standard] case insensitive symbols. For example, (eq 'KB 'Kb) evaluates to false in a case sensitive world and to true in a case insensitive world. However, unlike some commercial Common Lisp implementations, CLISP allows both kinds of programs to coexist in the same process and interoperate with each other. Example: OLD.lisp  (IN-PACKAGE ""OLD"") (DEFUN FOO () ...)  modern.lisp  (in-package ""NEW"") (defun bar () (old:foo)) (symbol-name 'bar) ; ⇒ ""bar""  This is achieved through specification of the symbol case policy at the package level. A modern package is one that is declared to be both case-sensitive and case-inverted and which use the symbols from the “CS-COMMON-LISP” package. A case-sensitive package is one whose DEFPACKAGE declaration (or MAKE-PACKAGE creation form) has the option (:CASE-SENSITIVE T). In a case-sensitive package, the reader does not uppercase the symbol name before calling INTERN. Similarly, the printer, when printing the SYMBOL-NAME part of a SYMBOL (i.e. the part after the package markers), behaves as if the readtable's case were set to :PRESERVE. See also Section 11.1.5, “Function EXT:PACKAGE-CASE-SENSITIVE-P”. A case-inverted package is one whose DEFPACKAGE declaration (or MAKE-PACKAGE creation form) has the option (:CASE-INVERTED T). In the context of a case-inverted package, symbol names are case-inverted: upper case characters are mapped to lower case, lower case characters are mapped to upper case, and other characters are left untouched. Every symbol thus conceptually has two symbol names: an old-world symbol name and a modern-world symbol name, which is the case-inverted old-world name. The first symbol name is returned by the function SYMBOL-NAME, the modern one by the function cs-cl:symbol-name. The internal functions for creating or looking up symbols in a package, which traditionally took a string argument, now conceptually take two string arguments: old-style-string and inverted-string. Actually, a function like INTERN takes the old-style-string as argument and computes the inverted-string from it; whereas the function cs-cl:intern takes the inverted-string as argument and computes the old-style-string from it. See also Section 11.1.4, “Function EXT:PACKAGE-CASE-INVERTED-P”. For a few built-in functions, a variant for the case-inverted world is defined in the “CS-COMMON-LISP” package, which has the nickname “CS-CL”: cs-cl:symbol-name returns the case-inverted symbol name. cs-cl:intern cs-cl:find-symbol work consistently with cs-cl:symbol-name. cs-cl:shadow cs-cl:find-all-symbols cs-cl:string= cs-cl:string/= cs-cl:string< cs-cl:string> cs-cl:string<= cs-cl:string>= cs-cl:string-trim cs-cl:string-left-trim cs-cl:string-right-trim convert a SYMBOL to a STRING and therefore exist in a variant that uses cs-cl:symbol-name instead of SYMBOL-NAME. cs-cl:make-package creates a case-inverted PACKAGE. 11.5.1. User Package for the Case-sensitive World A package “CS-COMMON-LISP-USER” is provided for the user to modify and work in. It plays the same role as “COMMON-LISP-USER”, but for the case-sensitive world. 11.5.2. Package Names The handling of package names is unchanged. Package names are still usually uppercase. The package names are also subject to (READTABLE-CASE *READTABLE*). 11.5.3. Gensyms and Keywords Note that gensyms and keywords are still treated traditionally: even in a case-sensitive package,  (STRING= '#:FooBar '#:foobar) ⇒ T (EQ ':KeyWord ':keyword) ⇒ T We believe this has a limited negative impact for the moment, but can be changed some time in the future. 11.5.4. Migration Tips The following practices will pose no problems when migrating to a modern case-sensitive world: Using [ANSI CL standard] symbols in lowercase. Macros that create symbols by suffixing or prefixing given symbols. Comparing symbol names as in (STRING= (SYMBOL-NAME x) (SYMBOL-NAME y)). The following practices will not work in a case-sensitive world or can give problems: Accessing the same symbol in both upper- and lowercase from the same source file. Macros that create symbols in other packages than the original symbols. Comparing SYMBOL-NAME return values with EQ. Comparing (SYMBOL-NAME x) with (cs-cl:symbol-name y). 11.5.5. Using case-sensitive packages by default CLISP supports a command-line option -modern that sets the *PACKAGE* initially to the “CS-COMMON-LISP-USER” package, and *PRINT-CASE* to :DOWNCASE. For packages to be located in the “modern” (case-sensitive) world, you need to augment their DEFPACKAGE declaration by adding the option (:MODERN T), see Section 11.1.2, “Macro DEFPACKAGE”. Chapter 12. Numbers [chap-12] Table of Contents 12.1. Numeric Types 12.2. Number Concepts 12.2.1. Numeric Operations 12.2.1.1. Additional Integer Functions 12.2.1.2. Function DECODE-FLOAT 12.2.1.3. Boolean Operations 12.2.1.4. Byte Operations on Integers 12.2.1.5. Floating Point Arithmetics 12.2.2. Implementation-Dependent Numeric Constants 12.2.2.1. Fixnum Limits 12.2.2.2. Bignum Limits 12.2.2.3. Float Limits 12.2.3. Rule of Float Substitutability 12.2.4. Floating-point Computations 12.2.4.1. Rule of Float Precision Contagion 12.2.4.2. Rule of Float and Rational Contagion 12.2.5. Complex Computations 12.2.6. Rule of Canonical Representation for Complex Rationals 12.2.7. Random-State Operations 12.1. Numeric Types The type NUMBER is the disjoint union of the types REAL and COMPLEX (exhaustive partition) The type REAL is the disjoint union of the types RATIONAL and FLOAT. The type RATIONAL is the disjoint union of the types INTEGER and RATIO. The type INTEGER is the disjoint union of the types FIXNUM and BIGNUM. The type FLOAT is the disjoint union of the types SHORT-FLOAT, SINGLE-FLOAT, DOUBLE-FLOAT and LONG-FLOAT. 12.2. Number Concepts [sec_12-1] 12.2.1. Numeric Operations 12.2.1.1. Additional Integer Functions 12.2.1.2. Function DECODE-FLOAT 12.2.1.3. Boolean Operations 12.2.1.4. Byte Operations on Integers 12.2.1.5. Floating Point Arithmetics 12.2.2. Implementation-Dependent Numeric Constants 12.2.2.1. Fixnum Limits 12.2.2.2. Bignum Limits 12.2.2.3. Float Limits 12.2.3. Rule of Float Substitutability 12.2.4. Floating-point Computations 12.2.4.1. Rule of Float Precision Contagion 12.2.4.2. Rule of Float and Rational Contagion 12.2.5. Complex Computations 12.2.6. Rule of Canonical Representation for Complex Rationals 12.2.7. Random-State Operations 12.2.1. Numeric Operations [sec_12-1-1] 12.2.1.1. Additional Integer Functions 12.2.1.2. Function DECODE-FLOAT 12.2.1.3. Boolean Operations 12.2.1.4. Byte Operations on Integers 12.2.1.5. Floating Point Arithmetics 12.2.1.1. Additional Integer Functions Function EXT:! (EXT:! n) returns the factorial of n, n being a nonnegative INTEGER. Function EXT:EXQUO. (EXT:EXQUO x y) returns the integer quotient x/y of two integers x,y, and SIGNALs an ERROR when the quotient is not integer. (This is more efficient than /.) Function EXT:XGCD. (EXT:XGCD x1 ... xn) returns the values l, k1, ..., kn, where l is the greatest common divisor of the integers x1, ..., xn, and k1, ..., kn are the integer coefficients such that  l = (GCD x1 ... xn)   = (+ (* k1 x1) ... (* kn xn))  Function EXT:MOD-EXPT. (EXT:MOD-EXPT k l m) is equivalent to (MOD (EXPT k l) m) except it is more efficient for very large arguments. 12.2.1.2. Function DECODE-FLOAT FLOAT-RADIX always returns 2. (FLOAT-DIGITS number digits) coerces number (a REAL) to a floating point number with at least digits mantissa digits. The following always evaluates to T:  (>= (FLOAT-DIGITS (FLOAT-DIGITS number digits)) digits)  12.2.1.3. Boolean Operations [convar_boole-_cm_boole-xor] Table 12.1. Boolean operations constant value BOOLE-CLR 0 BOOLE-SET 15 BOOLE-1 10 BOOLE-2 12 BOOLE-C1 5 BOOLE-C2 3 BOOLE-AND 8 BOOLE-IOR 14 BOOLE-XOR 6 BOOLE-EQV 9 BOOLE-NAND 7 BOOLE-NOR 1 BOOLE-ANDC1 4 BOOLE-ANDC2 2 BOOLE-ORC1 13 BOOLE-ORC2 11 12.2.1.4. Byte Operations on Integers [sec_12-1-1-3-2] Byte specifiers are objects of built-in type BYTE, not INTEGERs. 12.2.1.5. Floating Point Arithmetics Function EXPT. (EXPT base exponent) is not very precise if exponent has a large absolute value. Function LOG. (LOG number base) SIGNALs an ERROR if base = 1. Constant PI. The value of PI is a LONG-FLOAT with the precision given by (EXT:LONG-FLOAT-DIGITS). When this precision is changed, the value of PI is automatically recomputed. Therefore PI is not a constant variable. Function UPGRADED-COMPLEX-PART-TYPE. When the argument is not a recognizable subtype or REAL, UPGRADED-COMPLEX-PART-TYPE SIGNALs an ERROR, otherwise it returns its argument (even though a COMPLEX number in CLISP can always have REALPART and IMAGPART of any type) because it allows the most precise type inference. Variable CUSTOM:*DEFAULT-FLOAT-FORMAT*. When rational numbers are to be converted to floats (due to FLOAT, COERCE, SQRT or a transcendental function), the result type is given by the variable CUSTOM:*DEFAULT-FLOAT-FORMAT*. See also *READ-DEFAULT-FLOAT-FORMAT*. Macro EXT:WITHOUT-FLOATING-POINT-UNDERFLOW. The macro (EXT:WITHOUT-FLOATING-POINT-UNDERFLOW {form}*) executes the forms, with errors of type FLOATING-POINT-UNDERFLOW inhibited. Floating point operations will silently return zero instead of SIGNALing an ERROR of type FLOATING-POINT-UNDERFLOW. Condition FLOATING-POINT-INVALID-OPERATION. This CONDITION is never SIGNALed by CLISP. Condition FLOATING-POINT-INEXACT. This CONDITION is never SIGNALed by CLISP. 12.2.2. Implementation-Dependent Numeric Constants [sec_12-1-2] 12.2.2.1. Fixnum Limits 12.2.2.2. Bignum Limits 12.2.2.3. Float Limits 12.2.2.1. Fixnum Limits Table 12.2. Fixnum limits CPU type 32-bit CPU 64-bit CPU MOST-POSITIVE-FIXNUM 224-1 = 16777215 248-1 = 281474976710655 MOST-NEGATIVE-FIXNUM -224 = -16777216 -248 = -281474976710656 12.2.2.2. Bignum Limits BIGNUMs are limited in size. Their maximum size is 32*(216-2)=2097088 bits. The largest representable BIGNUM is therefore 22097088-1. 12.2.2.3. Float Limits Together with PI, the other LONG-FLOAT constants LEAST-NEGATIVE-LONG-FLOAT LONG-FLOAT-EPSILON LEAST-NEGATIVE-NORMALIZED-LONG-FLOAT LONG-FLOAT-NEGATIVE-EPSILON LEAST-POSITIVE-LONG-FLOAT MOST-NEGATIVE-LONG-FLOAT LEAST-POSITIVE-NORMALIZED-LONG-FLOAT MOST-POSITIVE-LONG-FLOAT are recomputed whenever (EXT:LONG-FLOAT-DIGITS) is SETFed. They are not constant variables. Warning Since the exponent of a LONG-FLOAT is a signed 32-bits integer, MOST-POSITIVE-LONG-FLOAT is about 2231, which is much larger that the largest representable BIGNUM, which is less than 2221. This, obviously, means that ROUND, TRUNCATE, FLOOR and CEILING SIGNALs an ERROR on large LONG-FLOATs. Less obviously, this means that (FORMAT NIL ""~E"" MOST-POSITIVE-LONG-FLOAT) also fails. 12.2.3. Rule of Float Substitutability [sec_12-1-3-3] When a mathematical function may return an exact (RATIONAL) or inexact (FLOAT) result, it always returns the exact result. 12.2.4. Floating-point Computations [sec_12-1-4] 12.2.4.1. Rule of Float Precision Contagion 12.2.4.2. Rule of Float and Rational Contagion There are four floating point types: SHORT-FLOAT, SINGLE-FLOAT, DOUBLE-FLOAT and LONG-FLOAT: type sign mantissa exponent comment SHORT-FLOAT 1 bit 16+1 bits 8 bits immediate SINGLE-FLOAT 1 bit 23+1 bits 8 bits IEEE 754 DOUBLE-FLOAT 1 bit 52+1 bits 11 bits IEEE 754 LONG-FLOAT 1 bit >=64 bits 32 bits variable length The single and double float formats are those of the IEEE 754 “Standard for Binary Floating-Point Arithmetic”, except that CLISP does not support features like ±0, ±inf, NaN, gradual underflow, etc. Common Lisp does not make use of these features, so, to reduce portability problems, CLISP by design returns the same floating point results on all platforms (CLISP has a floating-point emulation built in for platforms that do not support IEEE 754). Note that When you got a NaN in your program, your program is broken, so you will spend time determining where the NaN came from. It is better to SIGNAL an ERROR in this case. When you got unnormalized floats in your program, your results will have a greatly reduced accuracy anyway. Since CLISP has the means to cope with this - LONG-FLOATs of variable precision - it does not need unnormalized floats. This is why *FEATURES* does not contain the :IEEE-FLOATING-POINT keyword. Arbitrary Precision Floats. LONG-FLOATs have variable mantissa length, which is a multiple of 16 (or 32, depending on the word size of the processor). The default length used when LONG-FLOATs are READ is given by the place (EXT:LONG-FLOAT-DIGITS). It can be set by (SETF (EXT:LONG-FLOAT-DIGITS) n), where n is a positive INTEGER. E.g., (SETF (EXT:LONG-FLOAT-DIGITS) 3322) sets the default precision of LONG-FLOATs to about 1000 decimal digits. 12.2.4.1. Rule of Float Precision Contagion [sec_12-1-4-4] The floating point contagion is controlled by the variable CUSTOM:*FLOATING-POINT-CONTAGION-ANSI*. When it is non-NIL, contagion is done as per the [ANSI CL standard]: SHORT-FLOAT → SINGLE-FLOAT → DOUBLE-FLOAT → LONG-FLOAT. Rationale: See it pragmatically: save what you can and let others worry about the rest. Brief: Common Lisp knows the number's precision, not accuracy, so preserving the precision can be accomplished reliably, while anything relating to the accuracy is just a speculation - only the user (programmer) knows what it is in each case. Detailed: A computer float is an approximation of a real number. One can think of it as a random variable with the mean equal to itself and standard deviation equal to half the last significant digit. E.g., 1.5 is actually 1.5±0.05. Consider adding 1.5 and 1.75. [ANSI CL standard] requires that (+ 1.5 1.75) return 3.25, while traditional CLISP would return 3.3. The implied random variables are: 3.25±0.005 and 3.3±0.05. Note that the traditional CLISP way does lie about the mean: the mean is 3.25 and nothing else, while the standard way could be lying about the deviation (accuracy): if the implied accuracy of 1.5 (i.e., 0.05) is its actual accuracy, then the accuracy of the result cannot be smaller that that. Therefore, since Common Lisp has no way of knowing the actual accuracy, [ANSI CL standard] (and all the other standard engineering programming languages, like C, Fortran etc) decided that keeping the accuracy correct is the business of the programmer, while the language should preserve what it can - the precision. Experience: Rounding errors accumulate, and if a computation is conducted with insufficient precision, an outright incorrect result can be returned. (E.g., E(x2) - E(x)2 can be negative!) The user should not mix floats of different precision (that's what CUSTOM:*WARN-ON-FLOATING-POINT-CONTAGION* is for), but one should not be penalized for this too harshly. When CUSTOM:*FLOATING-POINT-CONTAGION-ANSI* is NIL, the traditional CLISP method is used, namely the result of an arithmetic operation whose arguments are of different float types is rounded to the float format of the shortest (least precise) of the arguments: RATIONAL → LONG-FLOAT → DOUBLE-FLOAT → SINGLE-FLOAT → SHORT-FLOAT (in contrast to [sec_12-1-4-4]!) Rationale: See it mathematically. Add intervals: {1.0 ± 1e-8} + {1.0 ± 1e-16} = {2.0 ± 1e-8}. So, if we add 1.0s0 and 1.0d0, we should get 2.0s0. Brief: Do not suggest high accuracy of a result by giving it a precision that is greater than its accuracy. Example: (- (+ 1.7 PI) PI) should not return 1.700000726342836417234L0, it should return 1.7f0 (or 1.700001f0 if there were rounding errors). Experience: If in a computation using thousands of SHORT-FLOATs, a LONG-FLOAT (like PI) happens to be used, the long precision should not propagate throughout all the intermediate values. Otherwise, the long result would look precise, but its accuracy is only that of a SHORT-FLOAT; furthermore much computation time would be lost by calculating with LONG-FLOATs when only SHORT-FLOATs would be needed. Variable CUSTOM:*WARN-ON-FLOATING-POINT-CONTAGION* If the variable CUSTOM:*WARN-ON-FLOATING-POINT-CONTAGION* is non-NIL, a WARNING is emitted for every coercion involving different floating-point types. As explained above, float precision contagion is not a good idea. You can avoid the contagion by doing all your computations with the same floating-point type (and using FLOAT to convert all constants, e.g., PI, to your preferred type). This variable helps you eliminate all occurrences of float precision contagion: set it to T to have CLISP SIGNAL a WARNING on float precision contagion; set it to ERROR to have CLISP SIGNAL an ERROR on float precision contagion, so that you can look at the stack backtrace. 12.2.4.2. Rule of Float and Rational Contagion [sec_12-1-4-1] The contagion between floating point and rational numbers is controlled by the variable CUSTOM:*FLOATING-POINT-RATIONAL-CONTAGION-ANSI*. When it is non-NIL, contagion is done as per the [ANSI CL standard]: RATIONAL → FLOAT. When CUSTOM:*FLOATING-POINT-RATIONAL-CONTAGION-ANSI* is NIL, the traditional CLISP method is used, namely if the result is mathematically an exact rational number, this rational number is returned (in contrast to [sec_12-1-4-1]!) CUSTOM:*FLOATING-POINT-RATIONAL-CONTAGION-ANSI* has an effect only in those few cases when the mathematical result is exact although one of the arguments is a floating-point number, such as (* 0 1.618), (/ 0 1.618), (ATAN 0 1.0), (EXPT 2.0 0), (PHASE 2.718). Variable CUSTOM:*WARN-ON-FLOATING-POINT-RATIONAL-CONTAGION* If the variable CUSTOM:*WARN-ON-FLOATING-POINT-RATIONAL-CONTAGION* is non-NIL, a WARNING is emitted for every avoidable coercion from a rational number to a floating-point number. You can avoid such coercions by calling FLOAT to convert the particular rational numbers to your preferred floating-point type. This variable helps you eliminate all occurrences of avoidable coercions to a floating-point number when a rational number result would be possible: set it to T to have CLISP SIGNAL a WARNING in such situations; set it to ERROR to have CLISP SIGNAL an ERROR in such situations, so that you can look at the stack backtrace. Variable CUSTOM:*PHASE-ANSI* A similar variable, CUSTOM:*PHASE-ANSI*, controls the return value of PHASE when the argument is an exact nonnegative REAL. Namely, if CUSTOM:*PHASE-ANSI* is non-NIL, it returns a floating-point zero; if CUSTOM:*PHASE-ANSI* is NIL, it returns an exact zero. Example: (PHASE 2/3) 12.2.5. Complex Computations [sec_12-1-5] Complex numbers can have a real part and an imaginary part of different types. For example, (SQRT -9.0) evaluates to the number #C(0 3.0), which has a real part of exactly 0, not only 0.0 (which would mean “approximately 0”). The type specifier for this is (COMPLEX INTEGER SINGLE-FLOAT), and (COMPLEX type-of-real-part type-of-imaginary-part) in general. The type specifier (COMPLEX type) is equivalent to (COMPLEX type type). 12.2.6. Rule of Canonical Representation for Complex Rationals [sec_12-1-5-3] Complex numbers can have a real part and an imaginary part of different types. If the imaginary part is EQL to 0, the number is automatically converted to a real number. This has the advantage that (LET ((x (SQRT -9.0))) (* x x)) - instead of evaluating to #C(-9.0 0.0), with x = #C(0.0 3.0) - evaluates to #C(-9.0 0) = -9.0, with x = #C(0 3.0). 12.2.7. Random-State Operations [sec_12-1-7] To ease reproducibility, the variable *RANDOM-STATE* is initialized to the same value on each invocation, so that $ clisp -norc -x '(RANDOM 1s0)' will always print the same number. If you want a new random state on each invocation, you can arrange for that by using init function:  $ clisp -norc -x '(EXT:SAVEINITMEM ""foo"" :init-function (LAMBDA () (SETQ *RANDOM-STATE* (MAKE-RANDOM-STATE T))))' $ clisp -norc -M foo.mem -x '(RANDOM 1s0)' or by placing (SETQ *RANDOM-STATE* (MAKE-RANDOM-STATE T)) into your RC file. Chapter 13. Characters [chap-13] Table of Contents 13.1. Introduction to Characters 13.1.1. Function CHAR-CODE 13.1.2. Type BASE-CHAR 13.1.3. Function EXT:CHAR-WIDTH 13.2. Character sets 13.3. Character Scripts 13.4. Character Attributes 13.4.1. Input Characters 13.5. Graphic Characters 13.6. Alphabetic Characters 13.7. Characters With Case 13.7.1. Function EXT:CHAR-INVERTCASE 13.7.2. Case of Implementation-Defined Characters 13.8. Numeric Characters 13.9. Ordering of Characters 13.10. Treatment of Newline during Input and Output 13.11. Character Encodings 13.12. Documentation of Implementation-Defined Scripts 13.13. Platform-Dependent Characters 13.14. Obsolete Constants 13.1. Introduction to Characters [sec_13-1] 13.1.1. Function CHAR-CODE 13.1.2. Type BASE-CHAR 13.1.3. Function EXT:CHAR-WIDTH 13.1.1. Function CHAR-CODE CHAR-CODE takes values from 0 (inclusive) to CHAR-CODE-LIMIT (exclusive), i.e., the implementation supports exactly CHAR-CODE-LIMIT characters. Table 13.1. Number of characters binaries built without UNICODE support with UNICODE support CHAR-CODE-LIMIT 28 = 256 17 * 216 = 1114112 13.1.2. Type BASE-CHAR The types EXT:STRING-CHAR and BASE-CHAR are equivalent to CHARACTER. EXT:STRING-CHAR used to be available as STRING-CHAR prior to removal from [ANSI CL standard] by CHARACTER-PROPOSAL:2. 13.1.3. Function EXT:CHAR-WIDTH (EXT:CHAR-WIDTH char) returns the number of screen columns occupied by char. The value is 0 for non-spacing characters (such as control characters and many combining characters); 2 for double-width East Asian characters; 1 for all other characters. See also function EXT:STRING-WIDTH. 13.2. Character sets The characters are ordered according to a superset of the ASCII character set. Platform Dependent: Only in CLISP built with compile-time flag UNICODE More precisely, CLISP uses the 21-bit Unicode 3.2 character set (ISO 10646, also known as UCS-4). Platform Dependent: Only in CLISP built without compile-time flag UNICODE More precisely, CLISP uses the ISO Latin-1 (ISO 8859-1) character set:   #x0 #x1 #x2 #x3 #x4 #x5 #x6 #x7 #x8 #x9 #xA #xB #xC #xD #xE #xF #x00 ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** #x10 ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** #x20   ! "" # $ % & ' ( ) * + , - . / #x30 0 1 2 3 4 5 6 7 8 9 : ; < = > ? #x40 @ A B C D E F G H I J K L M N O #x50 P Q R S T U V W X Y Z [ \ ] ^ _ #x60 ` a b c d e f g h i j k l m n o #x70 p q r s t u v w x y z { | } ~   #x80                               #x90                               #xA0   ¡ ¢ £ ¤ ¥ ¦ § ¨ © ª « ¬ ­ ® ¯ #xB0 ° ± ² ³ ´ µ ¶ · ¸ ¹ º » ¼ ½ ¾ ¿ #xC0 À Á Â Ã Ä Å Æ Ç È É Ê Ë Ì Í Î Ï #xD0 Ð Ñ Ò Ó Ô Õ Ö × Ø Ù Ú Û Ü Ý Þ ß #xE0 à á â ã ä å æ ç è é ê ë ì í î ï #xF0 ð ñ ò ó ô õ ö ÷ ø ù ú û ü ý þ ÿ Here ** are control characters, not graphic characters. (The characters left blank here cannot be represented in this character set). Table 13.2. Standard characters character code #\Space #x20 #\Newline #x0A Table 13.3. Semi-standard characters character code #\Backspace #x08 #\Tab #x09 #\Linefeed #x0A #\Page #x0C #\Return #x0D #\Newline is the line terminator. Table 13.4. Additional Named Characters character code #\Null #x00 #\Bell #x07 #\Escape #x1B Table 13.5. Additional syntax for characters with code from #x00 to #x1F: character code #\^@ #x00 #\^A … #\^Z #x01 … #x1A #\^[ #x1B #\^\ #x1C #\^] #x1D #\^^ #x1E #\^_ #x1F See also Section 2.6.1, “Sharpsign Backslash ”. 13.3. Character Scripts [sec_13-1-2-1] The only defined character script is the type CHARACTER itself. 13.4. Character Attributes [sec_13-1-3] 13.4.1. Input Characters Characters have no implementation-defined or [CLtL1] font and bit attributes. All characters are simple characters. 13.4.1. Input Characters For backward compatibility, there is a class SYS::INPUT-CHARACTER representing either a character with font and bits, or a keystroke. The following functions work with objects of types CHARACTER and SYS::INPUT-CHARACTER. Note that EQL or EQUAL are equivalent to EQ on objects of type SYS::INPUT-CHARACTER. EXT:CHAR-FONT-LIMIT = 16 The system uses only font 0. EXT:CHAR-BITS-LIMIT = 16 Character bits: key value :CONTROL EXT:CHAR-CONTROL-BIT :META EXT:CHAR-META-BIT :SUPER EXT:CHAR-SUPER-BIT :HYPER EXT:CHAR-HYPER-BIT (EXT:CHAR-FONT object) returns the font of a CHARACTER or SYS::INPUT-CHARACTER. (EXT:CHAR-BITS object) returns the bits of a CHARACTER or SYS::INPUT-CHARACTER. (EXT:MAKE-CHAR char [bits [font]]) returns a new SYS::INPUT-CHARACTER, or NIL if such a character cannot be created. (EXT:CHAR-BIT object name) returns T if the named bit is set in object, else NIL. (EXT:SET-CHAR-BIT object name new-value) returns a new SYS::INPUT-CHARACTER with the named bit set or unset, depending on the BOOLEAN new-value. Warning SYS::INPUT-CHARACTER is not a subtype of CHARACTER. Platform Dependent: UNIX, Win32 platforms only. The system itself uses this SYS::INPUT-CHARACTER type only to mention special keys and Control/Alternate/Shift key status on return from (READ-CHAR EXT:*KEYBOARD-INPUT*). 13.5. Graphic Characters [sec_13-1-4-1] The graphic characters are those UNICODE characters which are defined by the UNICODE standard, excluding the ranges U0000 … U001F and U007F … U009F. 13.6. Alphabetic Characters [sec_13-1-4-2] The alphabetic characters are those UNICODE characters which are defined as letters by the UNICODE standard, e.g., the ASCII characters              ABCDEFGHIJKLMNOPQRSTUVWXYZ              abcdefghijklmnopqrstuvwxyz and the international alphabetic characters from the character set:              ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜßáíóúñÑªºãõØøÀÃÕ etc. 13.7. Characters With Case [sec_13-1-4-3] 13.7.1. Function EXT:CHAR-INVERTCASE 13.7.2. Case of Implementation-Defined Characters 13.7.1. Function EXT:CHAR-INVERTCASE (EXT:CHAR-INVERTCASE char) returns the corresponding character in the other case for CHAR, i.e., CHAR-UPCASE for a lowercase character and CHAR-DOWNCASE for an uppercase character; for a character that does not have a case attribute, the argument is returned. See also EXT:STRING-INVERTCASE and EXT:NSTRING-INVERTCASE. 13.7.2. Case of Implementation-Defined Characters [sec_13-1-4-3-4] The characters with case are those UNICODE characters c, for which the upper case mapping uc and the lower case mapping lc have the following properties: uc and lc are different c is one of uc and lc the upper case mapping of uc and of lc is uc the lower case mapping of uc and of lc is lc The titlecase property of UNICODE characters has no equivalent in Common Lisp. 13.8. Numeric Characters [sec_13-1-4-4] The numeric characters are those UNICODE characters which are defined as digits by the UNICODE standard. 13.9. Ordering of Characters [sec_13-1-6] The characters are ordered according to their UNICODE code. The functions CHAR-EQUAL CHAR-NOT-EQUAL, CHAR-LESSP, CHAR-GREATERP, CHAR-NOT-GREATERP, CHAR-NOT-LESSP ignore bits and font attributes of their arguments. 13.10. Treatment of Newline during Input and Output [sec_13-1-8] Newlines are written according to the stream's EXT:ENCODING, see the function STREAM-EXTERNAL-FORMAT and the description of EXT:ENCODINGs, in particular, line terminators. The default behavior is as follows: Platform Dependent: Win32 platform only. When writing to a file, #\Newline is converted to CR/LF. (This is the usual convention on DOS.) For example, #\Return+#\Newline is written as CR/CR/LF. When reading from a file, CR/LF is converted to #\Newline (the usual convention on DOS), and CR not followed by LF is converted to #\Newline as well (the usual conversion on MacOS, also used by some programs on Win32). If you do not want this, i.e., if you really want to distinguish LF, CR and CR/LF, you have to resort to binary input (function READ-BYTE). Justification. Unicode Newline Guidelines say: “Even if you know which characters represents NLF on your particular platform, on input and in interpretation, treat CR, LF, CRLF, and NEL the same. Only on output do you need to distinguish between them.” Rationale. In CLISP, #\Newline is identical to #\Linefeed (which is specifically permitted by the [ANSI CL standard] in [sec_13-1-7] “Character Names”). Consider a file containing exactly this string: (CONCATENATE 'STRING ""foo"" (STRING #\Linefeed) ""bar"" (STRING #\Return) (STRING #\Linefeed)) Suppose we open it with (OPEN ""foo"" :EXTERNAL-FORMAT :DOS). What should READ-LINE return? Right now, it returns ""foo"" (the second READ-LINE returns ""bar"" and reaches end-of-stream). If our i/o were “faithful”, READ-LINE would have returned the string (CONCATENATE 'STRING ""foo"" (STRING #\Linefeed) ""bar""), i.e., a string with an embedded #\Newline between ""foo"" and ""bar"" (because a single #\Linefeed is not a #\Newline in the specified :EXTERNAL-FORMAT, it will not make READ-LINE return, but it is a CLISP #\Newline!) Even though the specification for READ-LINE does not explicitly forbids newlines inside the returned string, such behavior would be quite surprising, to say the least. Moreover, this line (with an embedded #\Newline) would be written as two lines (when writing to a STREAM with :EXTERNAL-FORMAT of :DOS), because the embedded #\Newline would be written as CR+LF. 13.11. Character Encodings [sec_13-1-9] The integer returned by CHAR-INT is the same as the character's code (CHAR-CODE). 13.12. Documentation of Implementation-Defined Scripts [sec_13-1-10] See Section 31.5, “Encodings”. 13.13. Platform-Dependent Characters The characters that are not graphic chars and the space character have names: Table 13.6. Additional characters (Platform Dependent: Win32 platform only.) code char (CODE-CHAR #x00) #\Null (CODE-CHAR #x07) #\Bell (CODE-CHAR #x08) #\Backspace (CODE-CHAR #x09) #\Tab (CODE-CHAR #x0A) #\Newline #\Linefeed (CODE-CHAR #x0B) #\Code11 (CODE-CHAR #x0C) #\Page (CODE-CHAR #x0D) #\Return (CODE-CHAR #x1A) #\Code26 (CODE-CHAR #x1B) #\Escape #\Esc (CODE-CHAR #x20) #\Space (CODE-CHAR #x7F) #\Rubout Table 13.7. Additional characters (Platform Dependent: UNIX platform only.) code char (CODE-CHAR #x00) #\Null #\Nul (CODE-CHAR #x01) #\Soh (CODE-CHAR #x02) #\Stx (CODE-CHAR #x03) #\Etx (CODE-CHAR #x04) #\Eot (CODE-CHAR #x05) #\Enq (CODE-CHAR #x06) #\Ack (CODE-CHAR #x07) #\Bell #\Bel (CODE-CHAR #x08) #\Backspace #\Bs (CODE-CHAR #x09) #\Tab #\Ht (CODE-CHAR #x0A) #\Newline #\Nl #\Linefeed (CODE-CHAR #x0B) #\Vt (CODE-CHAR #x0C) #\Page #\Np (CODE-CHAR #x0D) #\Return #\Cr (CODE-CHAR #x0E) #\So (CODE-CHAR #x0F) #\Si (CODE-CHAR #x10) #\Dle (CODE-CHAR #x11) #\Dc1 (CODE-CHAR #x12) #\Dc2 (CODE-CHAR #x13) #\Dc3 (CODE-CHAR #x14) #\Dc4 (CODE-CHAR #x15) #\Nak (CODE-CHAR #x16) #\Syn (CODE-CHAR #x17) #\Etb (CODE-CHAR #x18) #\Can (CODE-CHAR #x19) #\Em (CODE-CHAR #x1A) #\Sub (CODE-CHAR #x1B) #\Escape #\Esc (CODE-CHAR #x1C) #\Fs (CODE-CHAR #x1D) #\Gs (CODE-CHAR #x1E) #\Rs (CODE-CHAR #x1F) #\Us (CODE-CHAR #x20) #\Space #\Sp (CODE-CHAR #x7F) #\Rubout #\Delete #\Del 13.14. Obsolete Constants Table 13.8. Character bit constants (obsolete) constant value EXT:CHAR-CONTROL-BIT 1 EXT:CHAR-META-BIT 2 EXT:CHAR-SUPER-BIT 4 EXT:CHAR-HYPER-BIT 8 Chapter 14. Conses [chap-14] Table of Contents 14.1. Conses as Lists 14.1.1. Mapping Functions 14.1. Conses as Lists [sec_14-1-2] 14.1.1. Mapping Functions 14.1.1. Mapping Functions Function EXT:MAPCAP. The function EXT:MAPCAP is like MAPCAN, except that it concatenates the resulting lists with APPEND instead of NCONC: (EXT:MAPCAP function x1 ... xn) ≡ (APPLY #'APPEND (MAPCAR function x1 ... xn)) (Actually a bit more efficient that this would have been.) Function EXT:MAPLAP. The function EXT:MAPLAP is like MAPCON, except that it concatenates the resulting lists with APPEND instead of NCONC: (EXT:MAPLAP function x1 ... xn) ≡ (APPLY #'APPEND (MAPLIST function x1 ... xn)) (Actually a bit more efficient that this would have been.) Chapter 15. Arrays [chap-15] Table of Contents 15.1. Array Elements Function MAKE-ARRAY. MAKE-ARRAY can return specialized arrays for the ARRAY-ELEMENT-TYPEs (UNSIGNED-BYTE 2), (UNSIGNED-BYTE 4), (UNSIGNED-BYTE 8), (UNSIGNED-BYTE 16), (UNSIGNED-BYTE 32), and, of course, the required specializations NIL, BIT and CHARACTER. Function ADJUST-ARRAY for displaced arrays. An array to which another array is displaced should not be shrunk (using ADJUST-ARRAY) in such a way that the other array points into void space. This cannot be checked at the time ADJUST-ARRAY is called! 15.1. Array Elements [sec_15-1-1] Table 15.1. Array limits CPU type 32-bit CPU 64-bit CPU ARRAY-RANK-LIMIT 212 = 4096 ARRAY-DIMENSION-LIMIT 224-1 = 16777215 232-1 = 4294967295 ARRAY-TOTAL-SIZE-LIMIT 224-1 = 16777215 232-1 = 4294967295 Chapter 16. Strings [chap-16] Table of Contents 16.1. Miscellaneous 16.1.1. String Comparison 16.1.2. Function EXT:STRING-WIDTH 16.1.3. Functions EXT:STRING-INVERTCASE and EXT:NSTRING-INVERTCASE 16.1. Miscellaneous 16.1.1. String Comparison 16.1.2. Function EXT:STRING-WIDTH 16.1.3. Functions EXT:STRING-INVERTCASE and EXT:NSTRING-INVERTCASE 16.1.1. String Comparison String comparison (STRING< and friends) is based on the function CHAR<= (see Section 13.9, “Ordering of Characters ”). Therefore diphthongs do not obey the usual national rules. Example: o < oe < z < ö. 16.1.2. Function EXT:STRING-WIDTH (EXT:STRING-WIDTH string &KEY start end) returns the number of screen columns occupied by string. This is computed as the sum of all EXT:CHAR-WIDTHs of all of the string's characters:  (REDUCE #'+ string :KEY #'EXT:CHAR-WIDTH)  16.1.3. Functions EXT:STRING-INVERTCASE and EXT:NSTRING-INVERTCASE (EXT:STRING-INVERTCASE string &KEY start end) and (EXT:NSTRING-INVERTCASE string &KEY start end) are similar to STRING-UPCASE et al: they use EXT:CHAR-INVERTCASE to invert the case of each characters in the argument string region. Chapter 17. Sequences [chap-17] Table of Contents 17.1. Additional Functions 17.1.1. Function EXT:TRIM-IF 17.2. Additional Macros 17.2.1. Macro EXT:DOSEQ 17.3. Functions NREVERSE & NRECONC 17.4. Functions REMOVE & DELETE 17.5. Functions SORT & STABLE-SORT 17.1. Additional Functions 17.1.1. Function EXT:TRIM-IF 17.1.1. Function EXT:TRIM-IF Function (EXT:TRIM-IF predicate sequence) returns the portion of sequence without the leading and trailing elements which match predicate. 17.2. Additional Macros 17.2.1. Macro EXT:DOSEQ 17.2.1. Macro EXT:DOSEQ For iteration through a sequence, a macro EXT:DOSEQ, similar to DOLIST, may be used instead of MAP:  (EXT:DOSEQ (variable sequence-form [result-form])   {declaration}*   {tag|form}*)  EXT:DOSEQ forms are iteration forms. 17.3. Functions NREVERSE & NRECONC Function NREVERSE. The result of NREVERSE is always EQ to the argument. NREVERSE on a VECTOR swaps pairs of elements. NREVERSE on a LIST swaps the first and the last element and reverses the list chaining between them. Function NRECONC. The result of NRECONC is EQ to the first argument unless it is NIL, in which case the result is EQ to the second argument. 17.4. Functions REMOVE & DELETE REMOVE, REMOVE-IF, REMOVE-IF-NOT, REMOVE-DUPLICATES return their argument unchanged, if no element has to be removed. DELETE, DELETE-IF, DELETE-IF-NOT, DELETE-DUPLICATES destructively modify their argument: If the argument is a LIST, the CDR parts are modified. If the argument is a VECTOR with fill pointer, the fill pointer is lowered and the remaining elements are compacted below the new fill pointer. Variable CUSTOM:*SEQUENCE-COUNT-ANSI*. Contrary to the [ANSI CL standard] issue RANGE-OF-COUNT-KEYWORD:NIL-OR-INTEGER, negative :COUNT keyword arguments are not allowed unless you set CUSTOM:*SEQUENCE-COUNT-ANSI* to a non-NIL value, in which case “using a negative integer value is functionally equivalent to using a value of zero”, as per the [ANSI CL standard] issue. 17.5. Functions SORT & STABLE-SORT SORT and STABLE-SORT accept two additional keyword arguments :START and :END:  (SORT sequence predicate &KEY :KEY :START :END) (STABLE-SORT sequence predicate &KEY :KEY :START :END)  SORT and STABLE-SORT are identical. They implement the mergesort algorithm. Worst case complexity: O(n*log(n)) comparisons, where n is the LENGTH of the subsequence bounded by the :START and :END arguments. Chapter 18. Hash Tables [chap-18] Table of Contents 18.1. Modifying Hash Table Keys 18.2. Function MAKE-HASH-TABLE 18.2.1. Interaction between HASH-TABLEs and garbage-collection 18.3. Macro EXT:DEFINE-HASH-TABLE-TEST 18.4. Function HASH-TABLE-TEST 18.5. Macro EXT:DOHASH 18.1. Modifying Hash Table Keys [sec_18-1-2] If you “visibly modify” a key, consequences are unpredictable:  (LET ((hash-table (MAKE-HASH-TABLE :test 'EQUALP)))   (SETF (GETHASH hash-table hash-table) T)   (GETHASH hash-table hash-table)) ⇒ NIL ; ⇒ NIL because (SETF GETHASH) modifies hash-table, the very next GETHASH does not find it in itself. 18.2. Function MAKE-HASH-TABLE 18.2.1. Interaction between HASH-TABLEs and garbage-collection MAKE-HASH-TABLE accepts two additional keyword arguments :INITIAL-CONTENTS and :WEAK:  (MAKE-HASH-TABLE &KEY :TEST :INITIAL-CONTENTS :SIZE                  :REHASH-SIZE :REHASH-THRESHOLD                  :WARN-IF-NEEDS-REHASH-AFTER-GC :WEAK)  The :TEST argument can be, other than one of the symbols EQ, EQL, EQUAL, EQUALP, one of the symbols EXT:FASTHASH-EQ and EXT:STABLEHASH-EQ. Both of these tests use EQ as the comparison function; they differ in their performance characteristics. EXT:FASTHASH-EQ This uses the fastest possible hash function. Its drawback is that its hash codes become invalid at every garbage-collection (except if all keys are immediate objects), thus requiring a reorganization of the hash table at the first access after each garbage-collection. Especially when generational garbage-collection is used, which leads to frequent small garbage-collections, large hash table with this test can lead to scalability problems. EXT:STABLEHASH-EQ This uses a slower hash function that has the property that its hash codes for instances of the classes SYMBOL, EXT:STANDARD-STABLEHASH (subclass of STANDARD-OBJECT) and EXT:STRUCTURE-STABLEHASH (subclass of STRUCTURE-OBJECT) are stable across GCs. This test can thus avoid the scalability problems if all keys, other than immediate objects, are SYMBOL, EXT:STANDARD-STABLEHASH or EXT:STRUCTURE-STABLEHASH instances. One can recommend to use EXT:FASTHASH-EQ for short-lived hash tables. For tables with a longer lifespan which can be big or accessed frequently, it is recommended to use EXT:STABLEHASH-EQ, and to modify the objects that are used as its keys to become instances of EXT:STANDARD-STABLEHASH or EXT:STRUCTURE-STABLEHASH. When the symbol EQ or the function #'eq is used as a :TEST argument, the value of the variable CUSTOM:*EQ-HASHFUNCTION* is used instead. This value must be one of EXT:FASTHASH-EQ, EXT:STABLEHASH-EQ. Similarly, the :TEST argument can also be one of the symbols EXT:FASTHASH-EQL, EXT:STABLEHASH-EQL, EXT:FASTHASH-EQUAL, EXT:STABLEHASH-EQUAL. The same remarks apply as for EXT:FASTHASH-EQ and EXT:STABLEHASH-EQ. When the symbol EQL or the function #'eql is used as a :TEST argument, the value of the variable CUSTOM:*EQL-HASHFUNCTION* is used instead; this value must be one of EXT:FASTHASH-EQL, EXT:STABLEHASH-EQL. Similarly, when the symbol EQUAL or the function #'equal is used as a :TEST argument, the value of the variable CUSTOM:*EQUAL-HASHFUNCTION* is used instead; this value must be one of EXT:FASTHASH-EQUAL, EXT:STABLEHASH-EQUAL. The :WARN-IF-NEEDS-REHASH-AFTER-GC argument, if true, causes a WARNING to be SIGNALed when an object is stored into the table which will force table reorganizations at the first access of the table after each garbage-collection. This keyword argument can be used to check whether EXT:STABLEHASH-EQ should be preferred over EXT:FASTHASH-EQ for a particular table. Use HASH-TABLE-WARN-IF-NEEDS-REHASH-AFTER-GC to check and SETF this parameter after the table has been created. The :INITIAL-CONTENTS argument is an association list that is used to initialize the new hash table. The :REHASH-THRESHOLD argument is ignored. The :WEAK argument can take the following values: NIL (default) :KEY :VALUE :KEY-AND-VALUE :KEY-OR-VALUE and specifies whether the HASH-TABLE is weak: if the key, value, either or both are not accessible for the garbage-collection purposes, i.e., if they are only accessible via weak HASH-TABLEs and EXT:WEAK-POINTERs, it is garbage-collected and removed from the weak HASH-TABLE. The SETFable predicate EXT:HASH-TABLE-WEAK-P checks whether the HASH-TABLE is weak. Note that the only test that makes sense for weak hash tables are EQ and its variants EXT:FASTHASH-EQ and EXT:STABLEHASH-EQ. Just like all other weak objects, weak HASH-TABLEs cannot be printed readably. See also Section 31.7.9, “Weak Hash Tables”. 18.2.1. Interaction between HASH-TABLEs and garbage-collection When a hash table contains keys to be compared by identity - such as NUMBERs in HASH-TABLEs with the HASH-TABLE-TEST EQ; or CONSes in tables which test with EQ or EQL; or VECTORs in tables which test with EQ, EQL or EQUAL; or STANDARD-OBJECT or STRUCTURE-OBJECT instances in tables which test with EQ, EQL, EQUAL or EQUALP; - the hash code will in general depend on the object's address in memory. Therefore it will in general be invalidated after a garbage-collection, and the hash table's internal structure must be recomputed at the next table access. While :WARN-IF-NEEDS-REHASH-AFTER-GC can help checking the efficiency of a particular HASH-TABLE, the variable CUSTOM:*WARN-ON-HASHTABLE-NEEDING-REHASH-AFTER-GC* achieves the same effect for all HASH-TABLEs in the system at once: when CUSTOM:*WARN-ON-HASHTABLE-NEEDING-REHASH-AFTER-GC* is true and a HASH-TABLE needs to be rehashed after a garbage-collection, a warning is issued that shows the inefficient HASH-TABLE. What can be done to avoid the inefficiencies detected by these warnings? In many cases you can solve the problem by using the STABLEHASH variant of the hash test. In other cases, namely STANDARD-OBJECT or STRUCTURE-OBJECT instances, you can solve the problem by making the key object classes inherit from EXT:STANDARD-STABLEHASH or EXT:STRUCTURE-STABLEHASH, respectively. In the remaining cases, you should store a hash key inside the object, of which you can guarantee uniqueness through your application (for example the ID of an object in a database, or the serial number of an object), and use this key as hash key instead of the original object. 18.3. Macro EXT:DEFINE-HASH-TABLE-TEST You can define a new hash table test using the macro EXT:DEFINE-HASH-TABLE-TEST: (EXT:DEFINE-HASH-TABLE-TEST test-name test-function hash-function), after which name can be passed as the :TEST argument to MAKE-HASH-TABLE. E.g.: (EXT:DEFINE-HASH-TABLE-TEST string STRING= SXHASH) ⇒ STRING (MAKE-HASH-TABLE :test 'string) ⇒ #S(HASH-TABLE :TEST (#<SYSTEM-FUNCTION STRING=> . #<SYSTEM-FUNCTION SXHASH>)) (which is not too useful because it is equivalent to an EQUAL HASH-TABLE but less efficient). The fundamental requirement is that the test-function and hash-function are consistent:  (FUNCALL test-function x y) ⇒ (= (FUNCALL hash-function x) (FUNCALL hash-function y)) This means that the following definition:  (EXT:DEFINE-HASH-TABLE-TEST number = SXHASH)	; broken! is not correct because  (= 1 1d0) ⇒ T	; same object! (= (SXHASH 1) (SXHASH 1d0)) ⇒ NIL	; different buckets! The correct way is, e.g.:  (EXT:DEFINE-HASH-TABLE-TEST number = (LAMBDA (x) (SXHASH (COERCE x 'SHORT-FLOAT)))) Note Note that COERCEing to a SHORT-FLOAT does not cons up fresh objects while COERCEing to a DOUBLE-FLOAT does. 18.4. Function HASH-TABLE-TEST Function HASH-TABLE-TEST returns either one of EXT:FASTHASH-EQ EXT:FASTHASH-EQUAL EXT:STABLEHASH-EQ EXT:STABLEHASH-EQUAL EXT:FASTHASH-EQL EQUALP EXT:STABLEHASH-EQL   (but not EQ, EQL nor EQUAL anymore), or, for HASH-TABLEs created with a user-defined HASH-TABLE-TEST (see macro EXT:DEFINE-HASH-TABLE-TEST), a CONS cell (test-function . hash-function). 18.5. Macro EXT:DOHASH For iteration through a HASH-TABLE, a macro EXT:DOHASH, similar to DOLIST, can be used instead of MAPHASH:  (EXT:DOHASH (key-var value-var hash-table-form [resultform])   {declaration}*   {tag|form}*)  EXT:DOHASH forms are iteration forms. Chapter 19. Filenames [chap-19] Table of Contents 19.1. Pathname Components 19.1.1. Directory canonicalization 19.1.2. Platform-specific issues 19.2. :UNSPECIFIC as a Component Value 19.3. External notation 19.4. Logical Pathnames 19.5. Miscellaneous 19.5.1. Function TRANSLATE-PATHNAME 19.5.2. Function TRANSLATE-LOGICAL-PATHNAME 19.5.3. Function PARSE-NAMESTRING 19.5.4. Function MERGE-PATHNAMES 19.5.5. Function LOAD-LOGICAL-PATHNAME-TRANSLATIONS 19.5.6. Function EXT:ABSOLUTE-PATHNAME For most operations, pathnames denoting files and pathnames denoting directories cannot be used interchangeably. Platform Dependent: UNIX platform only. For example, #P""foo/bar"" denotes the file #P""bar"" in the directory #P""foo"", while #P""foo/bar/"" denotes the subdirectory #P""bar"" of the directory #P""foo"". Platform Dependent: Win32 platform only. For example, #P""foo\\bar"" denotes the file #P""bar"" in the directory #P""foo"", while #P""foo\\bar\\"" denotes the subdirectory #P""bar"" of the directory #P""foo"". Platform Dependent: Win32 and Cygwin platforms only. User variable CUSTOM:*DEVICE-PREFIX* controls translation between Cygwin pathnames (e.g., #P""/cygdrive/c/gnu/clisp/"") and native Win32 pathnames (e.g., #P""C:\\gnu\\clisp\\"") When it is set to NIL, no translations occur and the Cygwin port will not understand the native paths and the native Win32 port will not understand the Cygwin paths. When its value is a string, it is used by PARSE-NAMESTRING to translate into the appropriate platform-specific representation, so that on Cygwin, (PARSE-NAMESTRING ""c:/gnu/clisp/"") returns #P""/cygdrive/c/gnu/clisp/"", while on Win32 (PARSE-NAMESTRING ""/cygdrive/c/gnu/clisp/"") returns #P""C:/gnu/clisp/"". The initial value is ""cygdrive"", you should edit config.lisp to change it. This is especially important for the directory-handling functions. Table 19.1. The minimum filename syntax that may be used portably pathname meaning ""xxx"" for a file with name xxx ""xxx.yy"" for a file with name xxx and type yy "".yy"" for a pathname with type yy and no name or with name .yy and no type, depending on the value of CUSTOM:*PARSE-NAMESTRING-DOT-FILE*. Hereby xxx denotes 1 to 8 characters, and yy denotes 1 to 3 characters, each of which being either an alphanumeric character or the underscore #\_. Other properties of pathname syntax vary between operating systems. 19.1. Pathname Components [sec_19-2-1] 19.1.1. Directory canonicalization 19.1.2. Platform-specific issues When a pathname is to be fully specified (no wildcards), that means that no :WILD, :WILD-INFERIORS is allowed, no wildcard characters are allowed in the strings, and name EQ NIL may not be allowed either. 19.1.1. Directory canonicalization As permitted by the MAKE-PATHNAME specification, the PATHNAME directory component is canonicalized when the pathname is constructed: """" and ""."" are removed "".."", ""*"", and ""**"" are converted to :UP, :WILD and :WILD-INFERIORS, respectively patterns foo/../ are collapsed 19.1.2. Platform-specific issues Platform Dependent: UNIX platform only. Pathname components host always NIL device always NIL directory = (startpoint . subdirs) element values meaning startpoint :RELATIVE | :ABSOLUTE   subdirs () | (subdir . subdirs)   subdir :WILD-INFERIORS ** or ..., all subdirectories subdir SIMPLE-STRING, may contain wildcard characters ""?"" and ""*"" (may also be specified as :WILD)   name type NIL or SIMPLE-STRING, may contain wildcard characters ""?"" and ""*"" (may also be specified as :WILD) version NIL or :WILD or :NEWEST (after merging the defaults) A UNIX filename is split into name and type. External notation: ""server:sub1.typ/sub2.typ/name.typ"" using defaults: ""sub1.typ/sub2.typ/name.typ"" or ""name.typ"" or ""sub1.typ/**/sub3.typ/x*.lisp"" or similar.   Platform Dependent: Win32 platform only. Pathname components host NIL or SIMPLE-STRING, wildcard characters may occur but do not act as wildcards device NIL or :WILD or A|...|Z directory = (startpoint . subdirs) element values meaning startpoint :RELATIVE | :ABSOLUTE   subdirs () | (subdir . subdirs)   subdir :WILD-INFERIORS ** or ..., all subdirectories subdir SIMPLE-STRING, may contain wildcard characters ""?"" and ""*"" (may also be specified as :WILD)   name type NIL or SIMPLE-STRING, may contain wildcard characters ""?"" and ""*"" (may also be specified as :WILD) version NIL or :WILD or :NEWEST (after merging the defaults) If host is non-NIL, device must be NIL. A Win32 filename is split into name and type. External notation: ""A:\sub1.typ\sub2.typ\name.typ"" using defaults: ""\sub1.typ\sub2.typ\name.typ"" or ""name.typ"" or ""*:\sub1.typ\**\sub3.typ\x*.lisp"" or similar.   Instead of ""\"" one may use ""/"", as usual for DOS calls. If host is non-NIL and the directory's startpoint is not :ABSOLUTE, (PARSE-NAMESTRING (NAMESTRING pathname)) will not be the same as pathname. Platform Dependent: UNIX, Win32 platforms only. The wildcard characters: ""*"" matches any sequence of characters, ""?"" matches any one character. Name/type namestring split.  Platform Dependent: UNIX, Win32 platforms only. A filename is split into name and type according to the following rule: if there is no ""."" in the filename, then the name is everything, type is NIL; if there is a ""."", then name is the part before and type the part after the last dot. if the only ""."" is the first character, then the behavior depends on the value of the user variable CUSTOM:*PARSE-NAMESTRING-DOT-FILE* which can be either :TYPE NIL name, everything after the ""."" is the type; or :NAME NIL type, everything is the name Note Due to this name/type splitting rule, there are pathnames that cannot result from PARSE-NAMESTRING. To get a pathname whose type contains a dot or whose name contains a dot and whose type is NIL, MAKE-PATHNAME must be used. Example: (MAKE-PATHNAME :NAME ""foo.bar""). 19.2. :UNSPECIFIC as a Component Value [sec_19-2-2-2-3] The symbol :UNSPECIFIC is not permitted as a pathname component for any slot of any pathname. It is also illegal to pass it as an argument to MAKE-PATHNAME, although it is a legal argument (treated as NIL) to USER-HOMEDIR-PATHNAME. The only use for :UNSPECIFIC is that it is returned by PATHNAME-DEVICE for LOGICAL-PATHNAMEs, as required by [sec_19-3-2-1]. 19.3. External notation External notation of pathnames (cf. PARSE-NAMESTRING and NAMESTRING), of course without spaces, [,],{,}: Platform Dependent: UNIX platform only. [ ""/"" ] ""/"" denotes absolute pathnames { name ""/"" } each name is a subdirectory [ name [""."" type] ] filename with type (extension) Name and type may be STRINGs of any LENGTH (consisting of printing CHARACTERs, except ""/""). Platform Dependent: Win32 platform only. [ [drivespec] : ] a letter ""*""|a|...|z|A|...|Z { name [. type] \ } each name is a subdirectory, ""\"" may be replaced by ""/"" [ name [. type] ] filename with type (extension) Name and type may be STRINGs of any LENGTH (consisting of printing CHARACTERs, except ""/"", ""\"", "":""). 19.4. Logical Pathnames [sec_19-3] No notes. 19.5. Miscellaneous 19.5.1. Function TRANSLATE-PATHNAME 19.5.2. Function TRANSLATE-LOGICAL-PATHNAME 19.5.3. Function PARSE-NAMESTRING 19.5.4. Function MERGE-PATHNAMES 19.5.5. Function LOAD-LOGICAL-PATHNAME-TRANSLATIONS 19.5.6. Function EXT:ABSOLUTE-PATHNAME Pathname Designators. When CUSTOM:*PARSE-NAMESTRING-ANSI* is NIL, SYMBOL is also treated as a pathname designator, namely its SYMBOL-NAME is converted to the operating system's preferred pathname case. Function PATHNAME-MATCH-P. PATHNAME-MATCH-P does not interpret missing components as wild. 19.5.1. Function TRANSLATE-PATHNAME TRANSLATE-PATHNAME accepts three additional keyword arguments: (TRANSLATE-PATHNAME source from-wildname to-wildname &KEY :ALL :MERGE :ABSOLUTE) If :ALL is specified and non-NIL, a list of all resulting pathnames, corresponding to all matches of (PATHNAME-MATCH-P source from-wildname), is returned. If :MERGE is specified and NIL, unspecified pieces of to-pathname are not replaced by corresponding pieces of source. If :ABSOLUTE is specified and non-NIL, the returned pathnames are converted to absolute by merging in the current process' directory, therefore rendering pathnames suitable for the OS and external programs. So, to pass a pathname to an external program, you do (NAMESTRING (TRANSLATE-PATHNAME pathname #P"""" #P"""" :ABSOLUTE T)) or (NAMESTRING (EXT:ABSOLUTE-PATHNAME pathname)). 19.5.2. Function TRANSLATE-LOGICAL-PATHNAME TRANSLATE-LOGICAL-PATHNAME accepts an additional keyword argument :ABSOLUTE, similar to Section 19.5.1, “Function TRANSLATE-PATHNAME”. 19.5.3. Function PARSE-NAMESTRING (PARSE-NAMESTRING string &OPTIONAL host defaults &KEY start end junk-allowed) returns a logical pathname only if host is a logical host or host is NIL and defaults is a LOGICAL-PATHNAME. To construct a logical pathname from a string, the function LOGICAL-PATHNAME can be used. The [ANSI CL standard] behavior of recognizing logical pathnames when the string begins with some alphanumeric characters followed by a colon (#\:) can be very confusing (cf. ""c:/autoexec.bat"", ""home:.clisprc"" and ""prep:/pub/gnu"") and therefore is disabled by default. To enable the [ANSI CL standard] behavior, you should set CUSTOM:*PARSE-NAMESTRING-ANSI* to non-NIL. Note that this also disables treating SYMBOLs as pathname designators. 19.5.4. Function MERGE-PATHNAMES (MERGE-PATHNAMES pathname [default-pathname]) returns a logical pathname only if default-pathname is a LOGICAL-PATHNAME. To construct a logical pathname from a STRING, the function LOGICAL-PATHNAME can be used. When both pathname and default-pathname are relative pathnames, the behavior depends on CUSTOM:*MERGE-PATHNAMES-ANSI*: when it is NIL, then CLISP retains its traditional behavior: (MERGE-PATHNAMES #P""x/"" #P""y/"") evaluates to #P""x/"" Rationale. MERGE-PATHNAMES is used to specify default components for pathnames, so there is some analogy between (MERGE-PATHNAMES a b) and (OR a b). Obviously, putting in the same default a second time should do the same as putting it in once: (OR a b b) is the same as (OR a b), so (MERGE-PATHNAMES (MERGE-PATHNAMES a b) b) should be the same as (MERGE-PATHNAMES a b). (This question actually does matter because in Common Lisp there is no distinction between “pathnames with defaults merged-in” and “pathnames with defaults not yet applied”.) Now, (MERGE-PATHNAMES (MERGE-PATHNAMES #P""x/"" #P""y/"") #P""y/"") and (MERGE-PATHNAMES #P""x/"" #P""y/"") are EQUAL in CLISP (when CUSTOM:*MERGE-PATHNAMES-ANSI* is NIL), but not in implementations that strictly follow the [ANSI CL standard]. In fact, the above twice-default = once-default rule holds for all pathnames in CLISP. Conversely, when CUSTOM:*MERGE-PATHNAMES-ANSI* is non-NIL, the normal [ANSI CL standard] behavior is exhibited: (MERGE-PATHNAMES #P""x/"" #P""y/"") evaluates to #P""y/x/"". Rationale. “merge” is merge and not or. 19.5.5. Function LOAD-LOGICAL-PATHNAME-TRANSLATIONS When the host argument to LOAD-LOGICAL-PATHNAME-TRANSLATIONS is not a defined logical host yet, we proceed as follows: If both environment variables LOGICAL_HOST_host_FROM and LOGICAL_HOST_host_TO exist, then their values define the map of the host. If the environment variable LOGICAL_HOST_host exists, its value is read from, and the result is passed to (SETF LOGICAL-PATHNAME-TRANSLATIONS). Variable CUSTOM:*LOAD-LOGICAL-PATHNAME-TRANSLATIONS-DATABASE* is consulted. Its value should be a LIST of files and/or directories, which are searched for in the CUSTOM:*LOAD-PATHS*, just like for LOAD. When the element is a file, it is repeatedly READ from, Allegro CL-style, odd objects being host names and even object being their LOGICAL-PATHNAME-TRANSLATIONS. When the element is a directory, a file, named host or host.host, in that directory, is READ from once, CMUCL-style, the object read being the LOGICAL-PATHNAME-TRANSLATIONS of the host. 19.5.6. Function EXT:ABSOLUTE-PATHNAME (EXT:ABSOLUTE-PATHNAME pathname) converts the pathname to a physical pathname, then - if its directory component is not absolute - converts it to an absolute pathname, by merging in the current process' directory. This is like TRUENAME, except that it does not verify that a file named by the pathname exists, not even that its directory exists. It does no filesystem accesses, except to determine the current directory. This function is useful when you want to save a pathname over time, or pass a pathname to an external program. Chapter 20. Files [chap-20] Table of Contents 20.1. Directory is not a file 20.1.1. Function EXT:PROBE-PATHNAME 20.2. File functions 20.2.1. Function PROBE-FILE 20.2.2. Function FILE-AUTHOR 20.2.3. Function DELETE-FILE 20.2.4. Function RENAME-FILE 20.3. Directory functions 20.3.1. Function EXT:PROBE-DIRECTORY 20.3.2. Function DIRECTORY 20.3.3. Function EXT:DIR 20.3.4. Function EXT:CD 20.3.5. Function EXT:DEFAULT-DIRECTORY 20.3.6. Function EXT:MAKE-DIRECTORY 20.3.7. Function EXT:DELETE-DIRECTORY 20.3.8. Function EXT:RENAME-DIRECTORY 20.1. Directory is not a file 20.1.1. Function EXT:PROBE-PATHNAME CLISP has traditionally taken the view that a directory is a separate object and not a special kind of file, so whenever the standard says that a function operates on files without specifically mentioning that it also works on directories, CLISP SIGNALs an ERROR when passed a directory. CLISP provides separate directory functions, such as EXT:DELETE-DIRECTORY, EXT:RENAME-DIRECTORY et al. You can use DIRECTORY or EXT:PROBE-PATHNAME to figure out whether a given namestring refers to a file or a directory. 20.1.1. Function EXT:PROBE-PATHNAME Function EXT:PROBE-PATHNAME figures out whether the argument refers to an existing directory or an existing regular file, and returns 4 values if the filesystem object exists: TRUENAME EXT:ABSOLUTE-PATHNAME FILE-WRITE-DATE POSIX:FILE-SIZE or NIL if it does not exist. E.g., if you have a file file, a directory directory, a symbolic link link-file pointing to file and a symbolic link link-dir pointing to directory, then  (EXT:PROBE-PATHNAME #P""filename"") ⇒ #P""/.../filename"" ⇒ #P""/.../filename"" ⇒ 3427467015 ⇒ 3171976 (EXT:PROBE-PATHNAME #P""filename/"") ⇒ #P""/.../filename"" ⇒ #P""/.../filename"" ⇒ 3427467015 ⇒ 3171976 (EXT:PROBE-PATHNAME #P""directory"") ⇒ #P""/.../directory/"" ⇒ #P""/.../directory/"" ⇒ 3426940352 ⇒ 1024 (EXT:PROBE-PATHNAME #P""directory/"") ⇒ #P""/.../directory/"" ⇒ #P""/.../directory/"" ⇒ 3426940352 ⇒ 1024 (EXT:PROBE-PATHNAME #P""link-file"") ⇒ #P""/.../filename"" ⇒ #P""/.../link-file"" ⇒ 3427467015 ⇒ 3171976 (EXT:PROBE-PATHNAME #P""link-file/"") ⇒ #P""/.../filename"" ⇒ #P""/.../link-file"" ⇒ 3427467015 ⇒ 3171976 (EXT:PROBE-PATHNAME #P""link-dir"") ⇒ #P""/.../directory/"" ⇒ #P""/.../link-dir/"" ⇒ 3426940352 ⇒ 1024 (EXT:PROBE-PATHNAME #P""link-dir/"") ⇒ #P""/.../directory/"" ⇒ #P""/.../link-dir/"" ⇒ 3426940352 ⇒ 1024  20.2. File functions 20.2.1. Function PROBE-FILE 20.2.2. Function FILE-AUTHOR 20.2.3. Function DELETE-FILE 20.2.4. Function RENAME-FILE 20.2.1. Function PROBE-FILE PROBE-FILE cannot be used to check whether a directory exists. Use functions EXT:PROBE-DIRECTORY, EXT:PROBE-PATHNAME or DIRECTORY for this. 20.2.2. Function FILE-AUTHOR FILE-AUTHOR always returns NIL, because the operating systems CLISP is ported to do not store a file's author in the file system. Some operating systems, such as UNIX, have the notion of a file's owner, and some other Common Lisp implementations return the user name of the file owner. CLISP does not do this, because owner and author are not the same; in particular, authorship is preserved by copying, while ownership is not. Use OS:FILE-OWNER to find the owner of the file. See also OS:FILE-PROPERTIES (Platform Dependent: Win32 platform only.). 20.2.3. Function DELETE-FILE (DELETE-FILE pathname) deletes the pathname pathname, not its TRUENAME, and returns the absolute pathname it actually removed or NIL if pathname did not exist. When pathname points to a file which is currently open in CLISP, an ERROR is SIGNALed. To remove a directory, use EXT:DELETE-DIRECTORY instead. 20.2.4. Function RENAME-FILE This functions accepts and extra keyword argument :IF-EXISTS. When it is :ERROR (the default), an ERROR is SIGNALed if the destination pathname names an existing file, otherwise (e.g., if it is :OVERWRITE) the destination file atomically overwritten. When CUSTOM:*ANSI* is non-NIL, only the standard two arguments are accepted, and and ERROR is SIGNALed when the destination pathname names an existing file. This function cannot operate on directories, use EXT:RENAME-DIRECTORY to rename a directory. 20.3. Directory functions 20.3.1. Function EXT:PROBE-DIRECTORY 20.3.2. Function DIRECTORY 20.3.3. Function EXT:DIR 20.3.4. Function EXT:CD 20.3.5. Function EXT:DEFAULT-DIRECTORY 20.3.6. Function EXT:MAKE-DIRECTORY 20.3.7. Function EXT:DELETE-DIRECTORY 20.3.8. Function EXT:RENAME-DIRECTORY 20.3.1. Function EXT:PROBE-DIRECTORY (EXT:PROBE-DIRECTORY pathname) tests whether pathname exists and is a directory. It will, unlike PROBE-FILE or TRUENAME, not SIGNAL an ERROR if the parent directory of pathname does not exist. 20.3.2. Function DIRECTORY (DIRECTORY &OPTIONAL pathname &KEY :FULL :CIRCLE :IF-DOES-NOT-EXIST) can run in two modes: If pathname contains no name or type component, a list of all matching directories is produced. E.g., (DIRECTORY ""/etc/*/"") lists all subdirectories in the directory #P""/etc/"". Otherwise a list of all matching files is returned. E.g., (DIRECTORY ""/etc/*"") lists all regular files in the directory #P""/etc/"". If you want all the files and subdirectories in the current directory, you should use (NCONC (DIRECTORY ""*/"") (DIRECTORY ""*"")). If you want all the files and subdirectories in all the subdirectories under the current directory (similar to the ls -R UNIX command), use (NCONC (DIRECTORY ""**/"") (DIRECTORY ""**/*"")). Keyword arguments accepted by DIRECTORY :FULL If this argument is non-NIL, additional information is returned: for each matching file you get a LIST of at least four elements (file-pathname file-truename file-write-date-as-decoded-time file-length). :CIRCLE If this argument is non-NIL, DIRECTORY avoids endless loops that may result from symbolic links. :IF-DOES-NOT-EXIST This argument controls the treatment of links pointing to non-existent files and can take the following values: :DISCARD (default) discard the bad directory entries :ERROR an ERROR is SIGNALed on bad directory entries (this corresponds to the default behavior of DIRECTORY in CMU CL) :KEEP keep bad directory entries in the returned list (this roughly corresponds to the (DIRECTORY ... :TRUNAMEP NIL) call in CMU CL) :IGNORE Similar to :DISCARD, but also do not signal an error when a directory is unaccessible (contrary to the [ANSI CL standard] specification). 20.3.3. Function EXT:DIR (EXT:DIR &OPTIONAL pathname) is like DIRECTORY, but displays the pathnames instead of returning them. (EXT:DIR) shows the contents of the current directory. 20.3.4. Function EXT:CD (EXT:CD pathname) sets the current working directory, (EXT:CD) returns it. Platform Dependent: UNIX platform only. (EXT:CD [pathname]) manages the current directory. Platform Dependent: Win32 platform only. (EXT:CD [pathname]) manages the current device and the current directory. 20.3.5. Function EXT:DEFAULT-DIRECTORY (EXT:DEFAULT-DIRECTORY) is equivalent to (EXT:CD). (SETF (EXT:DEFAULT-DIRECTORY) pathname) is equivalent to (EXT:CD pathname), except for the return value. 20.3.6. Function EXT:MAKE-DIRECTORY (EXT:MAKE-DIRECTORY directory) creates a new subdirectory. 20.3.7. Function EXT:DELETE-DIRECTORY (EXT:DELETE-DIRECTORY directory) removes an (empty) subdirectory. 20.3.8. Function EXT:RENAME-DIRECTORY (EXT:RENAME-DIRECTORY old-directory new-directory) renames a subdirectory to a new name. Chapter 21. Streams [chap-21] Table of Contents 21.1. Interactive Streams 21.1.1. Initialization of Standard Streams 21.2. Terminal interaction 21.2.1. Command line editing with GNU readline 21.2.2. Macro EXT:WITH-KEYBOARD 21.3. Binary Input and Output 21.3.1. Binary input, READ-BYTE, EXT:READ-INTEGER & EXT:READ-FLOAT 21.3.2. Binary output, WRITE-BYTE, EXT:WRITE-INTEGER & EXT:WRITE-FLOAT 21.4. Bulk Input and Output 21.4.1. Bulk Input 21.4.2. Bulk Output 21.4.3. Rationale 21.5. Non-Blocking Input and Output 21.6. Newline Convention 21.6.1. Should programs output a newline before or after each line of output? 21.6.2. Analysis 21.6.3. Conclusion 21.6.4. Solution 21.6.5. Elastic Newline Analysis 21.7. Function STREAM-EXTERNAL-FORMAT 21.8. Function STREAM-ELEMENT-TYPE 21.8.1. Binary input from *STANDARD-INPUT* 21.9. Function EXT:MAKE-STREAM 21.10. Function FILE-POSITION 21.11. Function EXT:ELASTIC-NEWLINE 21.12. Function OPEN 21.13. Function CLEAR-INPUT 21.14. Function CLOSE 21.15. Function OPEN-STREAM-P 21.16. Class BROADCAST-STREAM 21.17. Functions EXT:MAKE-BUFFERED-INPUT-STREAM and EXT:MAKE-BUFFERED-OUTPUT-STREAM 21.1. Interactive Streams [sec_21-1-1-1-3] 21.1.1. Initialization of Standard Streams Interactive streams are those whose next input might depend on a prompt one might output. 21.1.1. Initialization of Standard Streams When run interactively, CLISP creates a single “terminal” STREAM and binds *TERMINAL-IO* to it. All other standard streams (*STANDARD-INPUT*, *STANDARD-OUTPUT* *ERROR-OUTPUT*, *TRACE-OUTPUT*, *QUERY-IO*, *DEBUG-IO*) are SYNONYM-STREAMs pointing to *TERMINAL-IO*. This has the benefit of avoiding unwanted blank lines from FRESH-LINE, see Section 21.6, “Newline Convention”. However, there may be situations, especially in batch mode, when one wants to use a C-style i/o where *STANDARD-OUTPUT* and *ERROR-OUTPUT* point to different OS file descriptor so that they can be redirected to files in the command line and examined separately. Often CLISP can detect such situations (stdout and stderr not being the terminal) and handle them just as expected. However, there may be cases when one needs to do something like:  (SETQ *STANDARD-INPUT* (EXT:MAKE-STREAM :INPUT)       *STANDARD-OUTPUT* (EXT:MAKE-STREAM :OUTPUT :BUFFERED T)       *ERROR-OUTPUT* (EXT:MAKE-STREAM :ERROR :BUFFERED T))  in the script or init function. 21.2. Terminal interaction 21.2.1. Command line editing with GNU readline 21.2.2. Macro EXT:WITH-KEYBOARD See also Section 32.1, “Random Screen Access”. 21.2.1. Command line editing with GNU readline Platform Dependent: Only in CLISP linked against the GNU readline library. Input through *TERMINAL-IO* uses the GNU readline library. Arrow keys can be used to move within the input history. The TAB key completes the SYMBOL name or PATHNAME that is being typed. See readline user manual for general details and TAB key for CLISP-specific extensions. Warning The GNU readline library is not used (even when CLISP is linked against it) if the stdin and stdout do not both refer to the same terminal. This is determined by the function stdio_same_tty_p in file src/stream.d. In some exotic cases, e.g., when running under gdb in an rxvt window under Cygwin, this may be determined incorrectly. See also Section 33.4, “Advanced Readline and History Functionality”. Linking against GNU readline. For CLISP to use GNU readline it has to be detected by the configure process. If you run it as $ ./configure --with-readline it will fail if it cannot find a valid modern GNU readline installation. If you use the option --without-readline, it will not even try to find GNU readline. The default behavior (--with-readline=default) is to use GNU readline if it is found and link CLISP without it otherwise. You can find out whether GNU readline has been detected by running $ grep HAVE_READLINE config.h in your build directory. 21.2.2. Macro EXT:WITH-KEYBOARD Platform Dependent: UNIX, Win32 platforms only. *TERMINAL-IO* is not the only stream that communicates directly with the user: During execution of the body of a (EXT:WITH-KEYBOARD . body) form, EXT:*KEYBOARD-INPUT* is the STREAM that reads the keystrokes from the keyboard. It returns every keystroke in detail as an SYS::INPUT-CHARACTER with the following slots (see Section 13.4.1, “Input Characters” for accessing them): char the CHARACTER for standard keys (accessed with CHARACTER) Note For non-standard keys CHARACTER SIGNALs an ERROR, use EXT:CHAR-KEY:  (EXT:WITH-KEYBOARD  (LOOP :for char = (READ-CHAR EXT:*KEYBOARD-INPUT*)    :for key = (OR (EXT:CHAR-KEY char) (CHARACTER char))    :do (PRINT (LIST char key))    :when (EQL key #\Space) :return (LIST char key)))  key the key name, for non-standard keys (accessed with EXT:CHAR-KEY): Platform Dependent: UNIX, Win32 platforms only. key value F1..F12 :F1..:F12 Insert :INSERT Delete :DELETE Home :HOME End :END Center :CENTER PgUp :PGUP PgDn :PGDN Arrow keys :LEFT :RIGHT :UP :DOWN bits :HYPER (Platform Dependent: Win32 platform only.) if a non-standard key. These keys are: [Win32]: Function keys, cursor keypads, numeric keypad. :SUPER (Platform Dependent: Win32 platform only.) if pressed together with Shift key(s) and if the keystroke would have been different without Shift. :CONTROL if pressed together with the Control key. :META (Platform Dependent: Win32 platform only.) if pressed together with the Alternate key. font Always 0. This keyboard input is not echoed on the screen. During execution of a (EXT:WITH-KEYBOARD . body) form, no input from *TERMINAL-IO* or any synonymous stream should be requested. Warning Since SYS::INPUT-CHARACTER is not a subtype of CHARACTER, READ-LINE on EXT:*KEYBOARD-INPUT* is illegal. 21.3. Binary Input and Output 21.3.1. Binary input, READ-BYTE, EXT:READ-INTEGER & EXT:READ-FLOAT 21.3.2. Binary output, WRITE-BYTE, EXT:WRITE-INTEGER & EXT:WRITE-FLOAT 21.3.1. Binary input, READ-BYTE, EXT:READ-INTEGER & EXT:READ-FLOAT The function (EXT:READ-INTEGER stream element-type &OPTIONAL ENDIANNESS eof-error-p eof-value) reads a multi-byte INTEGER from stream, which should be a STREAM with STREAM-ELEMENT-TYPE (UNSIGNED-BYTE 8). element-type should be type equivalent to (UNSIGNED-BYTE n), where n is a multiple of 8. (EXT:READ-INTEGER stream element-type) is like (READ-BYTE stream) if stream's STREAM-ELEMENT-TYPE were set to element-type, except that stream's FILE-POSITION will increase by n/8 instead of 1. Together with (SETF STREAM-ELEMENT-TYPE), this function permits mixed character/binary input from a stream. The function (EXT:READ-FLOAT stream element-type &OPTIONAL ENDIANNESS eof-error-p eof-value) reads a floating-point number in IEEE 754 binary representation from stream, which should be a STREAM with STREAM-ELEMENT-TYPE (UNSIGNED-BYTE 8). element-type should be type equivalent to SINGLE-FLOAT or DOUBLE-FLOAT. Endianness. ENDIANNESS can be :LITTLE or :BIG. The default is :LITTLE, which corresponds to the READ-BYTE behavior in CLISP. 21.3.2. Binary output, WRITE-BYTE, EXT:WRITE-INTEGER & EXT:WRITE-FLOAT The function (EXT:WRITE-INTEGER integer stream element-type &OPTIONAL ENDIANNESS) writes a multi-byte INTEGER to stream, which should be a STREAM with STREAM-ELEMENT-TYPE (UNSIGNED-BYTE 8). element-type should be type equivalent to (UNSIGNED-BYTE n), where n is a multiple of 8. (EXT:WRITE-INTEGER integer stream element-type) is like (WRITE-BYTE integer stream) if stream's STREAM-ELEMENT-TYPE were set to element-type, except that stream's FILE-POSITION will increase by n/8 instead of 1. Together with (SETF STREAM-ELEMENT-TYPE), this function permits mixed character/binary output to a STREAM. The function (EXT:WRITE-FLOAT float stream element-type &OPTIONAL ENDIANNESS) writes a floating-point number in IEEE 754 binary representation to stream, which should be a STREAM with STREAM-ELEMENT-TYPE (UNSIGNED-BYTE 8). element-type should be type equivalent to SINGLE-FLOAT or DOUBLE-FLOAT. 21.4. Bulk Input and Output 21.4.1. Bulk Input 21.4.2. Bulk Output 21.4.3. Rationale 21.4.1. Bulk Input In addition to READ-SEQUENCE, the following two functions are provided: EXT:READ-BYTE-SEQUENCE performs multiple READ-BYTE operations: (EXT:READ-BYTE-SEQUENCE sequence stream &KEY :START :END :NO-HANG :INTERACTIVE) fills the subsequence of sequence specified by :START and :END with INTEGERs consecutively read from stream. It returns the index of the first element of sequence that was not updated (= end or < end if the stream reached its end). When no-hang is non-NIL, it does not block: it treats input unavailability as end-of-stream. When no-hang is NIL and interactive is non-NIL, it can block for reading the first byte but does not block for any further bytes. This function is especially efficient if sequence is a (VECTOR (UNSIGNED-BYTE 8)) and stream is a file/pipe/socket STREAM with STREAM-ELEMENT-TYPE (UNSIGNED-BYTE 8). EXT:READ-CHAR-SEQUENCE performs multiple READ-CHAR operations: (EXT:READ-CHAR-SEQUENCE sequence stream &KEY :START :END) fills the subsequence of sequence specified by :START and :END with characters consecutively read from stream. It returns the index of the first element of sequence that was not updated (= end or < end if the stream reached its end). This function is especially efficient if sequence is a STRING and stream is a file/pipe/socket STREAM with STREAM-ELEMENT-TYPE CHARACTER or an input STRING-STREAM. 21.4.2. Bulk Output In addition to WRITE-SEQUENCE, the following two functions are provided: EXT:WRITE-BYTE-SEQUENCE performs multiple WRITE-BYTE operations: (EXT:WRITE-BYTE-SEQUENCE sequence stream &KEY :START :END :NO-HANG :INTERACTIVE) outputs the INTEGERs of the subsequence of sequence specified by :START and :END to stream. When no-hang is non-NIL, does not block. When no-hang is NIL and interactive is non-NIL, it can block for writing the first byte but does not block for any further bytes. Returns two values: sequence and the index of the first byte that was not output. This function is especially efficient if sequence is a (VECTOR (UNSIGNED-BYTE 8)) and stream is a file/pipe/socket STREAM with STREAM-ELEMENT-TYPE (UNSIGNED-BYTE 8). EXT:WRITE-CHAR-SEQUENCE performs multiple WRITE-CHAR operations: (EXT:WRITE-CHAR-SEQUENCE sequence stream &KEY :START :END) outputs the characters of the subsequence of sequence specified by :START and :END to stream. Returns the sequence argument. This function is especially efficient if sequence is a STRING and stream is a file/pipe/socket STREAM with STREAM-ELEMENT-TYPE CHARACTER. 21.4.3. Rationale The rationale for EXT:READ-CHAR-SEQUENCE, EXT:READ-BYTE-SEQUENCE, EXT:WRITE-CHAR-SEQUENCE and EXT:WRITE-BYTE-SEQUENCE is that some STREAMs support both character and binary i/o, and when you read into a SEQUENCE that can hold both (e.g., LIST or SIMPLE-VECTOR) you cannot determine which kind of input to use. In such situation READ-SEQUENCE and WRITE-SEQUENCE SIGNAL an ERROR, while EXT:READ-CHAR-SEQUENCE, EXT:READ-BYTE-SEQUENCE, EXT:WRITE-CHAR-SEQUENCE and EXT:WRITE-BYTE-SEQUENCE work just fine. 21.5. Non-Blocking Input and Output In addition to the standard functions LISTEN and READ-CHAR-NO-HANG, CLISP provides the following functionality facilitating non-blocking input and output, both binary and character. (EXT:READ-CHAR-WILL-HANG-P stream) EXT:READ-CHAR-WILL-HANG-P queries the stream's input status. It returns NIL if READ-CHAR and PEEK-CHAR with a peek-type of NIL will return immediately. Otherwise it returns T. (In the latter case the standard LISTEN function would return NIL.) Note the difference with (NOT (LISTEN stream)): When the end-of-stream is reached, LISTEN returns NIL, whereas EXT:READ-CHAR-WILL-HANG-P returns NIL. Note also that EXT:READ-CHAR-WILL-HANG-P is not a good way to test for end-of-stream: If EXT:READ-CHAR-WILL-HANG-P returns T, this does not mean that the stream will deliver more characters. It only means that it is not known at this moment whether the stream is already at end-of-stream, or will deliver more characters. (EXT:READ-BYTE-LOOKAHEAD stream) To be called only if stream's STREAM-ELEMENT-TYPE is (UNSIGNED-BYTE 8) or (SIGNED-BYTE 8). Returns T if READ-BYTE would return immediately with an INTEGER result. Returns :EOF if the end-of-stream is already known to be reached. If READ-BYTE's value is not available immediately, returns NIL instead of waiting. (EXT:READ-BYTE-WILL-HANG-P stream) To be called only if stream's STREAM-ELEMENT-TYPE is (UNSIGNED-BYTE 8) or (SIGNED-BYTE 8). Returns NIL if READ-BYTE will return immediately. Otherwise it returns true. (EXT:READ-BYTE-NO-HANG stream &OPTIONAL eof-error-p eof-value) To be called only if stream's STREAM-ELEMENT-TYPE is (UNSIGNED-BYTE 8) or (SIGNED-BYTE 8). Returns an INTEGER or does end-of-stream handling, like READ-BYTE, if that would return immediately. If READ-BYTE's value is not available immediately, returns NIL instead of waiting. LISTEN on binary streams The [ANSI CL standard] specification for LISTEN mentions “character availability” as the criterion that determines the return value. Since a CHARACTER is never available on a binary STREAM (i.e., a stream with STREAM-ELEMENT-TYPE being a subtype of INTEGER), LISTEN returns NIL for such streams. (You can use SOCKET:SOCKET-STATUS to check binary streams). Any other behavior would be hard to make consistent: consider a bivalent stream, i.e., a STREAM that can be operated upon by both READ-CHAR and READ-BYTE. What should LISTEN return on such a stream if what is actually available on the stream at the moment is only a part of a multi-byte character? Right now one can use first SOCKET:SOCKET-STATUS to check if anything at all is available and then use LISTEN to make sure that a full CHARACTER is actually there. 21.6. Newline Convention 21.6.1. Should programs output a newline before or after each line of output? 21.6.2. Analysis 21.6.3. Conclusion 21.6.4. Solution 21.6.5. Elastic Newline Analysis 21.6.1. Should programs output a newline before or after each line of output? The answer is complicated. There is an antagonism between the “old Lisp way” of outputting a newline before the line's contents (exemplified by the functions PRINT and PPRINT) and the “Unix way” of outputting a newline after the line's contents. Which one is “right”? A newline convention is, by definition, a consistent way to use the TERPRI and FRESH-LINE functions or - in FORMAT notation - ~% and ~& directives in such a way that the resulting output is properly subdivided into lines. Three newline conventions are conceivable: Print a newline before the line, and nothing after it. As a format string: “~%First line.~%Second line.” Print a newline if needed before the line, and a newline always after it. As a format string: “~&First line.~%Second line.~%” Print nothing before the line, and a newline always after it. As a format string: “First line.~%Second line.~%” The most important criterion is interoperability. Two newline conventions are interoperable if, when parts of a program use one of the convention and other parts of the program use the other conventions, lines are still properly separated. It is easily seen that A and B are interoperable, B and C are interoperable as well, but A and C are not interoperable: When an output with convention A is followed by output in convention C, two lines are appended without a line separator. This should not happen. Therefore, in what follows, we consider five kinds of programs: A: using convention A exclusively, AB: mixing conventions A and B, B: using convention B exclusively, BC: mixing conventions B and C, C: using convention C exclusively. Which of these five kinds of programs operation is satisfactory? Let us consider different criteria: Do extra blank lines occur during normal operation? What happens if FRESH-LINE prints a newline when it is not needed, i.e. when it cannot tell for sure whether the current column is 0? (This situation happens, for example, when logging to a file: After the user has entered a line interactively, the column on screen is 0, but since the input has not been echoed in the log file, the column in the log file is usually not 0, and FRESH-LINE must output a newline. Then a blank line is visible on the screen.) What happens if FRESH-LINE omits a newline when it would be needed? (This is more rare, but can happen, for example, when standard output and standard error are different streams but are joined outside the Lisp implementation, at the OS level. Such as in lisp | cat.) Is it possible to reliably output a blank line before or after a paragraph of text? I.e. what happens with “~%~%First line.~%Second line.” “~%First line.~%Second line.~%” “~&~%First line.~%Second line.~%” “~&First line.~%Second line.~%~%” “~%First line.~%Second line.~%” “First line.~%Second line.~%~%” Is is possible to optimize away blank lines? I.e. is it possible to avoid a blank line even though another piece of code uses one of A1 ... C2, without risking that adjacent lines be unseparated? 21.6.2. Analysis A: No extra blank lines. AB: An extra blank line each time one switches from convention B to A. B: No extra blank lines. BC: No extra blank lines. C: No extra blank lines. A: No extra blank lines. AB: Blank lines can occur when convention B is used. B: Blank lines can occur. BC: Blank lines can occur when convention B is used. C: No extra blank lines. A: No problem. AB: Lines can be unseparated when one switches from convention A to B. B: No problem. BC: No problem. C: No problem. A: No problem. AB: The blank line is omitted when using A2 before switching to B. B: No problem. BC: No problem. C: No problem. A: Yes, using “~&First line.~%Second line.” eats a previous blank line. AB: Not really: Using “~&First line.~%Second line.” may eat a previous blank line or a following blank line, but you cannot know in advance which one. B: Yes, using “~&First line.~%Second line.” eats a following blank line. BC: Impossible. C: Impossible. To optimize blank lines in case C would require the opposite of FRESH-LINE, namely a conditional newline that is annullated if the next output on the stream will be a newline. (EXT:ELASTIC-NEWLINE, see below.) 21.6.3. Conclusion Each approach has its advantages and disadvantages. When used globally (i.e. no interoperability requirements), A, B, C can be compared as follows: A and C are equally perfect if eating blank lines is not a requirement. If eating blank lines is desirable, A is perfect. B is not so good, because it is suboptimal in case 2. For CLISP built-ins, however, the interoperability requirement with both A and C is a major requirement. Therefore we have to choose B, and accept the drawbacks: AB: An extra blank line each time one switches from convention B to A. B: When logging to a file, blank lines can occur. AB: When joining two output streams into one, lines can be unseparated. AB: Blank lines after a paragraph can be eaten by CLISP. AB: Optimizing blank lines is not really possible. And to minimize the drawbacks, we recommend the user programs to use approach B or C, but not A. Another drawback of B is, however, that in interactive sessions the cursor is nearly always positioned at the beginning of a line, pointing the user's focus to the wrong point and taking away a screen line. 21.6.4. Solution To solve this, we introduce the concept of an elastic newline, output by the function EXT:ELASTIC-NEWLINE. This is the converse of FRESH-LINE: It waits for the next character and outputs a newline when the next character is not a newline; then the next character is processed normally. As a FORMAT directive, we write it ~.. EXT:ELASTIC-NEWLINE followed by FRESH-LINE leads to exactly one newline always. Elastic newline leads to a slightly different newline convention: B': Print a newline if needed before the line, and a newline if needed after it. As a format string: “~&First line.~%Second line.~.” The five programs being considered are now: A: using convention A exclusively, AB': mixing conventions A and B', B': using convention B' exclusively, B'C: mixing conventions B' and C, C: using convention C exclusively, 21.6.5. Elastic Newline Analysis A: No extra blank lines. AB': No extra blank lines. B': No extra blank lines. B'C: No extra blank lines. C: No extra blank lines. A: No extra blank lines. AB': Blank lines can occur when convention B' is used. B': Blank lines can occur. B'C: Blank lines can occur when convention B' is used. C: No extra blank lines. A: No problem. AB': Lines can be unseparated when one switches from convention A to B'. B': Lines can be unseparated when one switches from one stream to another without performing a FORCE-OUTPUT. This is a general problem with buffered streams; CLISP's FRESH-LINE contains a workaround that is limited to *STANDARD-OUTPUT* and *ERROR-OUTPUT*. B'C: No problem. C: No problem. A: No problem. AB': The blank line is omitted when using A2 before switching to B' or when using B2 before switching to A. B': No problem. B'C: No problem. C: No problem. A: Yes, using “~&First line.~%Second line.” eats a previous blank line. AB': Not really: Using “~&First line.~%Second line.” may eat a previous blank line or a following blank line, but you cannot know in advance which one. B': Yes, using “~&First line.~%Second line.” eats a following blank line. B'C: Impossible. C: Yes, using “First line.~%Second line.~.” eats a following blank line. Now criterium 1 is satisfied perfectly. We therefore choose B', not B, for use inside CLISP, and programs can use either A or C without problems during normal operation. 21.7. Function STREAM-EXTERNAL-FORMAT STREAM-EXTERNAL-FORMAT is SETFable: (SETF (STREAM-EXTERNAL-FORMAT stream [direction]) encoding), direction can be :INPUT, :OUTPUT, or NIL. If no direction is given, the operation is nonrecursive. This will not work on *TERMINAL-IO* et al, use CUSTOM:*TERMINAL-ENCODING* instead. 21.8. Function STREAM-ELEMENT-TYPE 21.8.1. Binary input from *STANDARD-INPUT* STREAM-ELEMENT-TYPE is SETFable. The STREAM-ELEMENT-TYPE of STREAMs created by the functions OPEN, EXT:MAKE-PIPE-INPUT-STREAM EXT:MAKE-PIPE-OUTPUT-STREAM, EXT:MAKE-PIPE-IO-STREAM, SOCKET:SOCKET-ACCEPT, SOCKET:SOCKET-CONNECT can be modified, if the old and the new STREAM-ELEMENT-TYPEs are either both equivalent to CHARACTER or (UNSIGNED-BYTE 8) or (SIGNED-BYTE 8); or both equivalent to (UNSIGNED-BYTE n) or (SIGNED-BYTE n), with the same n. Functions STREAM-ELEMENT-TYPE and (SETF STREAM-ELEMENT-TYPE) are GENERIC-FUNCTIONs, see Chapter 30, Gray streams. Warning CLISP expects to be able to do CHARACTER i/o on standard streams like *TERMINAL-IO*, *STANDARD-OUTPUT*, *STANDARD-INPUT*, *ERROR-OUTPUT*, *QUERY-IO* et al, thus is is a very bad idea to change their STREAM-ELEMENT-TYPE even when you can. Use EXT:MAKE-STREAM instead, see Section 21.8.1, “Binary input from *STANDARD-INPUT*”. 21.8.1. Binary input from *STANDARD-INPUT* Note that you cannot change STREAM-ELEMENT-TYPE for some built-in streams, such as terminal streams, which is normally the value of *TERMINAL-IO*. Since *STANDARD-INPUT* normally is a SYNONYM-STREAM pointing to *TERMINAL-IO*, you cannot use READ-BYTE on it. Since CGI (Common Gateway Interface) provides the form data for METHOD=""POST"" on the stdin, and the server will not send you an end-of-stream on the end of the data, you will need to use (EXT:GETENV ""CONTENT_LENGTH"") to determine how much data you should read from stdin. CLISP will detect that stdin is not a terminal and create a regular FILE-STREAM which can be passed to (SETF STREAM-ELEMENT-TYPE). To test this functionality interactively, you will need to open the standard input in the binary mode:  (let ((buf (MAKE-ARRAY (PARSE-INTEGER (EXT:GETENV ""CONTENT_LENGTH""))                        :element-type '(UNSIGNED-BYTE 8))))   (WITH-OPEN-STREAM (in (EXT:MAKE-STREAM :INPUT :ELEMENT-TYPE '(UNSIGNED-BYTE 8)))     (READ-SEQUENCE buf in))   buf)  21.9. Function EXT:MAKE-STREAM Function EXT:MAKE-STREAM creates a Lisp stream out of an OS file descriptor: (EXT:MAKE-STREAM object &KEY :DIRECTION :ELEMENT-TYPE :EXTERNAL-FORMAT :BUFFERED) object designates an OS handle (a file descriptor), and should be one of the following: number denotes the file descriptor of this value :INPUT denotes CLISP process standard input, that is, the file descriptor corresponding to stdin (0 on UNIX) :OUTPUT denotes CLISP process standard output, that is, the file descriptor corresponding to stdout (1 on UNIX) :ERROR denotes CLISP process error output, that is, the file descriptor corresponding to stderr (2 on UNIX) STREAM denotes the handle of this stream, which should be a FILE-STREAM or a SOCKET:SOCKET-STREAM Beware of buffering! When there are several Lisp STREAMs backed by the same OS file descriptor, the behavior may be highly confusing when some of the Lisp streams are :BUFFERED. Use FORCE-OUTPUT for output STREAMs, and bulk input for input STREAMs. The handle is duplicated (with dup), so it is safe to CLOSE a STREAM returned by EXT:MAKE-STREAM. 21.10. Function FILE-POSITION FILE-POSITION works on any FILE-STREAM. Platform Dependent: Win32 platform only. When a #\Newline is output to (respectively input from) a FILE-STREAM, its file position is increased by 2 since #\Newline is encoded as CR/LF in the file. 21.11. Function EXT:ELASTIC-NEWLINE The function (EXT:ELASTIC-NEWLINE [stream]) is like FRESH-LINE but the other way around: It outputs a conditional newline on stream, which is canceled if the next output on stream happens to be a newline. More precisely, it causes a newline to be output right before the next character is written on stream, if this character is not a newline. The newline is also output if the next operation on the stream is FRESH-LINE, FINISH-OUTPUT, FORCE-OUTPUT or CLOSE. The functionality of EXT:ELASTIC-NEWLINE is also available through the FORMAT directive ~.. A technique for avoiding unnecessary blank lines in output is to begin each chunk of output with a call to FRESH-LINE and to terminate it with a call to EXT:ELASTIC-NEWLINE. See also Section 21.6, “Newline Convention”. 21.12. Function OPEN OPEN accepts an additional keyword :BUFFERED. The acceptable values for the arguments to the file/pipe/socket STREAM functions :ELEMENT-TYPE types equivalent to CHARACTER or (UNSIGNED-BYTE n), (SIGNED-BYTE n); if the stream is to be un:BUFFERED, n must be a multiple of 8. If n is not a multiple of 8, CLISP will use the specified number of bits for i/o, and write the file length (as a number of n-bit bytes) in the preamble. This is done to ensure the input/output consistency: suppose you open a file with :ELEMENT-TYPE of (UNSIGNED-BYTE 3) and write 7 bytes (i.e., 21 bit) there. The underlying OS can do input/output only in whole 8-bit bytes. Thus the OS will report the size of the file as 3 (8-bit) bytes. Without the preamble CLISP will have no way to know how many 3-bit bytes to read from this file - 6, 7 or 8. See also Section 21.8, “Function STREAM-ELEMENT-TYPE”. :EXTERNAL-FORMAT EXT:ENCODINGs, (constant) SYMBOLs in the “CHARSET” package, STRINGs (denoting iconv-based encodings), the symbol :DEFAULT, and the line terminator keywords :UNIX, :MAC, :DOS. The default encoding is CUSTOM:*DEFAULT-FILE-ENCODING*. This argument determines how the lisp CHARACTER data is converted to/from the 8-bit bytes that the underlying OS uses. See also Section 21.7, “Function STREAM-EXTERNAL-FORMAT”. :BUFFERED NIL, T, or :DEFAULT. Have CLISP manage an internal buffer for input or output (in addition to the buffering that might be used by the underlying OS). Buffering is a known general technique to significantly speed up i/o. for functions that create SOCKET:SOCKET-STREAMs and pipes, :DEFAULT is equivalent to T on the input side and to NIL on the output side; it you are transmitting a lot of data then using buffering will significantly speed up your i/o; for functions that open files, :DEFAULT means that buffered file streams will be returned for regular files and (on UNIX) block-devices, and unbuffered file streams for special files. Note that some files, notably those on the /proc filesystem (on UNIX systems), are actually, despite their innocuous appearance, special files, so you might need to supply an explicit :BUFFERED NIL argument for them. Actually, CLISP detects that the file is a /proc file, so that one is covered, but there are probably more strange beasts out there! Variable CUSTOM:*REOPEN-OPEN-FILE* When an already opened file is opened again, and not both the existing and the new STREAMs are read-only (i.e., :DIRECTION is :INPUT or :INPUT-IMMUTABLE), the streams can mess up each other and produce unexpected results. The user variable CUSTOM:*REOPEN-OPEN-FILE* controls how CLISP handles the situation and can take 4 values: NIL do nothing: do not even check that there are other STREAMs pointing to the same file WARN SIGNAL a WARNING and proceed CLOSE CLOSE the other STREAMs and proceed (this could be dangerous and is not generally recommended) ERROR (default) SIGNAL a continuable ERROR 21.13. Function CLEAR-INPUT Calling CLEAR-INPUT on a STREAM removes the end-of-stream state, thus making it available for further input. This allows reading from a file as it is being appended to, as if with tail -f. 21.14. Function CLOSE Function CLOSE is a GENERIC-FUNCTION, see Chapter 30, Gray streams. When the :ABORT argument is non-NIL, CLOSE will not SIGNALs an ERROR even when the underlying OS call fails. GET-OUTPUT-STREAM-STRING returns the same value after CLOSE as it would before it. CLOSE on an already closed STREAM does nothing and returns T. If you do not CLOSE your STREAM explicitly, it will be closed at garbage-collection time automatically (with (CLOSE stream :ABORT T)). This is not recommended though because garbage-collection is not deterministic. Please use WITH-OPEN-STREAM etc. 21.15. Function OPEN-STREAM-P Function OPEN-STREAM-P is a GENERIC-FUNCTION, see Chapter 30, Gray streams. 21.16. Class BROADCAST-STREAM INPUT-STREAM-P and INTERACTIVE-STREAM-P return false for BROADCAST-STREAMs. 21.17. Functions EXT:MAKE-BUFFERED-INPUT-STREAM and EXT:MAKE-BUFFERED-OUTPUT-STREAM (EXT:MAKE-BUFFERED-OUTPUT-STREAM function). Returns a buffered output STREAM. function is a FUNCTION expecting one argument, a SIMPLE-STRING. WRITE-CHAR collects the CHARACTERs in a STRING, until a newline character is written or FORCE-OUTPUT/FINISH-OUTPUT is called. Then function is called with a SIMPLE-STRING as argument, that contains the characters collected so far. CLEAR-OUTPUT discards the characters collected so far. (EXT:MAKE-BUFFERED-INPUT-STREAM function mode). Returns a buffered input STREAM. function is a FUNCTION of 0 arguments that returns either NIL (stands for end-of-stream) or up to three values string, start, end. READ-CHAR returns the CHARACTERs of the current string one after another, as delimited by start and end, which default to 0 and NIL, respectively. When the string is consumed, function is called again. The string returned by function should not be changed by the user. function should copy the string with COPY-SEQ or SUBSEQ before returning if the original string is to be modified. mode determines the behavior of LISTEN when the current string buffer is empty: NIL the stream acts like a FILE-STREAM, i.e. function is called T the stream acts like an interactive stream without end-of-stream, i.e. one can assume that further characters will always arrive, without calling function FUNCTION this FUNCTION tells, upon call, if further non-empty strings are to be expected. CLEAR-INPUT discards the rest of the current string, so function will be called upon the next READ-CHAR operation. Chapter 22. Printer [chap-22] Table of Contents 22.1. Multiple Possible Textual Representations 22.2. Printing Floats 22.3. Printing Characters 22.4. Package Prefixes for Symbols 22.5. Printing Other Vectors 22.6. Printing Other Arrays 22.6.1. Printing Pathnames 22.7. The Lisp Pretty Printer 22.7.1. Pretty Print Dispatch Table 22.8. Formatted Output 22.9. Functions WRITE & WRITE-TO-STRING 22.10. Macro PRINT-UNREADABLE-OBJECT 22.11. Miscellaneous Issues 22.1. Multiple Possible Textual Representations [sec_22-1-1-1] Variable CUSTOM:*PRINT-CLOSURE* An additional variable CUSTOM:*PRINT-CLOSURE* controls whether compiled and interpreted functions (closures) are output in detailed form. If CUSTOM:*PRINT-CLOSURE* is non-NIL, a readable syntax is used for closures: interpreted closures #S(FUNCTION ...) compiled closures #Y(...) (this is what you would see if you open a CLISP #P"".fas"" in a text editor) This feature is turned off by WITH-STANDARD-IO-SYNTAX because it is easy to get wrong (see below) and non-portable. Warning Closures often refer to value cells or other entities from the lexical environment. The correct operation of a FUNCTION may depend on the access to the same value cells as some other, related FUNCTIONs. If you want to WRITE and READ back FUNCTIONs so that their semantics is preserved, you have to WRITE and READ all FUNCTIONs that share some structure in the lexical environment together, and you have to either bind *PRINT-READABLY* to T or use WITH-STANDARD-IO-SYNTAX:  (SETF (VALUES my-pop my-push)       `(LET ((storage ()))          (VALUES (LAMBDA () (POP storage))                  (LAMBDA (x) (PUSH x storage))))) (LET ((pair (READ-FROM-STRING              (WITH-STANDARD-IO-SYNTAX                (LET ((CUSTOM:*PRINT-CLOSURE* T))                  (PRIN1-TO-STRING (CONS my-pop my-push)))))))    (SETQ my-pop-1 (CAR pair)          my-push-1 (CDR pair)))  Note that my-pop and my-push share environment between themselves but not with my-pop-1 and my-push-1 which can be easily seen if you do  (LET ((CUSTOM:*PRINT-CLOSURE* T) (*PRINT-CIRCLE* T))   (PRINT (LIST my-pop my-push my-pop-1 my-push-1)))  but which is not at all obvious from the usual #< output. CUSTOM:*PRINT-CLOSURE* is initially set to NIL. Variable CUSTOM:*PRINT-RPARS* An additional variable CUSTOM:*PRINT-RPARS* controls the output of the right (closing) parentheses. If CUSTOM:*PRINT-RPARS* is non-NIL, closing parentheses which do not fit onto the same line as the the corresponding opening parenthesis are output just below their corresponding opening parenthesis, in the same column. CUSTOM:*PRINT-RPARS* is initially set to NIL. Variable CUSTOM:*PRINT-INDENT-LISTS* An additional variable CUSTOM:*PRINT-INDENT-LISTS* controls the indentation of lists that span more than one line. It specifies by how many characters items within the list will be indented relative to the beginning of the list. CUSTOM:*PRINT-INDENT-LISTS* is initially set to 1. Variable CUSTOM:*PPRINT-FIRST-NEWLINE* An additional variable CUSTOM:*PPRINT-FIRST-NEWLINE* controls pretty-printing of multi-line objects. When CUSTOM:*PPRINT-FIRST-NEWLINE* is non-NIL, and the current line already has some characters on it, and the next object will be printed on several lines, and it does not start with a #\Newline, then a #\Newline is printed before the object. E.g., when you type (FORMAT T ""return value: ~S~%"" v) you want want to see a terse one-line output when v is something short (like 0 or NIL or T), but you probably want to see something nice, like  return value: (long list which does not fit  on one line) instead of  return value: (long list which does not fit  on one line) when it does not. CUSTOM:*PPRINT-FIRST-NEWLINE* has no effect if *PRINT-PRETTY* is NIL. CUSTOM:*PPRINT-FIRST-NEWLINE* is initially set to T. 22.2. Printing Floats [sec_22-1-3-1-3] In the absence of SYS::WRITE-FLOAT-DECIMAL, floating point numbers are output in radix 2. This function is defined in floatprint.lisp and is not available if you run CLISP without a memory image (which you should never do anyway!) If *PRINT-READABLY* is true, *READ-DEFAULT-FLOAT-FORMAT* has no influence on the way FLOATs are printed. 22.3. Printing Characters [sec_22-1-3-2] Characters are printed as specified in [ANSI CL standard] using #\, with one exception: when printer escaping is in effect, the space character is printed as “#\Space” when the variable CUSTOM:*PRINT-SPACE-CHAR-ANSI* is NIL. When CUSTOM:*PRINT-SPACE-CHAR-ANSI* is non-NIL, it is printed as “#\ ”; this is how [ANSI CL standard] specifies it. 22.4. Package Prefixes for Symbols [sec_22-1-3-3-1] Variable CUSTOM:*PRINT-SYMBOL-PACKAGE-PREFIX-SHORTEST*. When CUSTOM:*PRINT-SYMBOL-PACKAGE-PREFIX-SHORTEST* is non-NIL, the package prefix is not the PACKAGE-NAME but the shortest (nick)name as returned by EXT:PACKAGE-SHORTEST-NAME. This variable is ignored when *PRINT-READABLY* is non-NIL. 22.5. Printing Other Vectors [sec_22-1-3-7] When *PRINT-READABLY* is true, other vectors are written as follows: if the ARRAY-ELEMENT-TYPE is T, the syntax #(x1 ... xn) is used. Otherwise, the syntax #A(element-type dimensions contents) is used. 22.6. Printing Other Arrays [sec_22-1-3-8] 22.6.1. Printing Pathnames When *PRINT-READABLY* is true, other arrays are written as follows: if the ARRAY-ELEMENT-TYPE is T, the syntax #rankA contents is used. Otherwise, the syntax #A(element-type dimensions contents) is used. As explicitly permitted by this section, specialized BIT and CHARACTER ARRAYs are printed with the innermost lists generated by the printing algorithm being instead printed using BIT-VECTOR and STRING syntax, respectively. Variable CUSTOM:*PRINT-EMPTY-ARRAYS-ANSI*. Empty ARRAYs, i.e., arrays with no elements and zero ARRAY-TOTAL-SIZE (because one of its dimensions is zero) are printed with the readable syntax #A(element-type dimensions contents), unless the variable CUSTOM:*PRINT-EMPTY-ARRAYS-ANSI* is non-NIL, in which case the arrays are printed using the [ANSI CL standard]-prescribed syntax #rankA contents which often loses the dimension information. 22.6.1. Printing Pathnames [sec_22-1-3-11] Pathnames are printed as follows: If *PRINT-ESCAPE* is NIL, only the namestring is printed; otherwise it is printed with the #P syntax, as per the [ANSI CL standard] issue PRINT-READABLY-BEHAVIOR:CLARIFY. But, if *PRINT-READABLY* is true, we are in trouble as #P is ambiguous (which is verboten when *PRINT-READABLY* is true), while being mandated by the [ANSI CL standard]. Therefore, in this case, CLISP's behavior is determined by the value of CUSTOM:*PRINT-PATHNAMES-ANSI*: when it is NIL, we print pathnames like this: #-CLISP #P""..."" #+CLISP #S(PATHNAME ...). Otherwise, when the variable CUSTOM:*PRINT-PATHNAMES-ANSI* is non-NIL, the #P notation is used as per [sec_1-5-1-4-1] “Resolution of Apparent Conflicts in Exceptional Situations”. Note The #S notation for PATHNAMEs is used extensively in the [Common Lisp HyperSpec] (see examples for PATHNAME, PATHNAMEP, PARSE-NAMESTRING et al), but was decided against, see PATHNAME-PRINT-READ:SHARPSIGN-P. Warning When both *PRINT-READABLY* and CUSTOM:*PRINT-PATHNAMES-ANSI* are non-NIL and the namestring will be parsed to a dissimilar object (with the current value of CUSTOM:*PARSE-NAMESTRING-DOT-FILE*), an ERROR of type PRINT-NOT-READABLE is SIGNALed. 22.7. The Lisp Pretty Printer [sec_22-2] 22.7.1. Pretty Print Dispatch Table The Lisp Pretty Printer implementation is not perfect yet. PPRINT-LOGICAL-BLOCK does not respect *PRINT-LINES*. 22.7.1. Pretty Print Dispatch Table [sec_22-2-1-4] A pprint dispatch table is a CONS of a SYMBOL *PRINT-PPRINT-DISPATCH* and an association list which maps types into priorities and print functions. Their use is strongly discouraged because of the performance issues: when *PRINT-PPRINT-DISPATCH* is non-trivial and *PRINT-PRETTY* is non-NIL, printing of every object requires a lookup in the table, which entails many calls to TYPEP (which cannot be made fast enough). 22.8. Formatted Output [sec_22-3] Function FORMAT The additional FORMAT instruction ~! is similar to ~/, but avoids putting a function name into a string, thus, even if the function is not interned in the “COMMON-LISP-USER” package, you might not need to specify the package explicitly. (FORMAT stream ""~arguments!"" function object) is equivalent to (FUNCALL function stream object colon-modifier-p atsign-modifier-p arguments). The additional FORMAT instruction ~. is a kind of opposite to ~&: It outputs a conditional newline, by calling the function EXT:ELASTIC-NEWLINE. ~n. outputs n-1 newlines followed by an EXT:ELASTIC-NEWLINE. ~0. does nothing. FORMAT ~R and FORMAT ~:R can output only integers in the range |n| < 1066. The output is in English, according to the American conventions, and these conventions are identical to the British conventions only in the range |n| < 109. FORMAT ~:@C does not output the character itself, only the instruction how to type the character. For FORMAT ~E and FORMAT ~G, the value of *READ-DEFAULT-FLOAT-FORMAT* does not matter if *PRINT-READABLY* is true. FORMAT ~T can determine the current column of any built-in stream. 22.9. Functions WRITE & WRITE-TO-STRING The functions WRITE and WRITE-TO-STRING have an additional keyword argument :CLOSURE which is used to bind CUSTOM:*PRINT-CLOSURE*. 22.10. Macro PRINT-UNREADABLE-OBJECT Variable CUSTOM:*PRINT-UNREADABLE-ANSI*. The macro PRINT-UNREADABLE-OBJECT, when invoked without body forms, suppresses the trailing space if only the type is to be printed, and suppresses the leading space if only the identity is to be printed. This behaviour can be turned off set setting the variable CUSTOM:*PRINT-UNREADABLE-ANSI* to a non-NIL value: in this case, a trailing or leading space are output, as prescribed by [ANSI CL standard]. 22.11. Miscellaneous Issues *PRINT-CASE* controls the output not only of symbols, but also of characters and some #<unreadable> objects. Platform Dependent: UNIX, Win32 platforms only. *PRINT-PRETTY* is initially NIL but set to T in config.lisp. This makes screen output prettier. *PRINT-ARRAY* is initially set to T. Chapter 23. Reader [chap-23] Table of Contents 23.1. Effect of Readtable Case on the Lisp Reader 23.2. The recursive-p argument 23.1. Effect of Readtable Case on the Lisp Reader [sec_23-1-2] When the value of (READTABLE-CASE readtable) is :INVERT, it applies to the package name and the symbol name of a symbol separately (not to the entire token at once). An alternative to the use of READTABLE-CASE is the use of the :CASE-SENSITIVE option of MAKE-PACKAGE and DEFPACKAGE. 23.2. The recursive-p argument [sec_23-1-3-2] When non-NIL recursive-p argument is passed to a top-level READ call, an ERROR is SIGNALed. Chapter 24. System Construction [chap-24] Table of Contents 24.1. Function COMPILE-FILE 24.2. Function COMPILE-FILE-PATHNAME 24.3. Function REQUIRE 24.3.1. Additional LOAD locations 24.3.2. Interaction with COMPILE-FILE 24.4. Function LOAD 24.5. Variable *FEATURES* 24.6. Function EXT:FEATUREP [CLRFI-1] 24.7. Function EXT:COMPILED-FILE-P [CLRFI-2] The compiler can be called not only by the functions COMPILE, COMPILE-FILE and DISASSEMBLE, but also by the declaration (COMPILE). 24.1. Function COMPILE-FILE COMPILE-FILE compiles a file to a platform-independent bytecode:  (COMPILE-FILE filename &KEY :OUTPUT-FILE :LISTING :EXTERNAL-FORMAT                             ((:WARNINGS CUSTOM:*COMPILE-WARNINGS*) CUSTOM:*COMPILE-WARNINGS*)                             ((:VERBOSE *COMPILE-VERBOSE*) *COMPILE-VERBOSE*)                             ((:PRINT *COMPILE-PRINT*) *COMPILE-PRINT*))  Options for COMPILE-FILE filename the file to be compiled, should be a pathname designator. :OUTPUT-FILE should be NIL or T or a pathname designator or an output STREAM. The default is T. :LISTING should be NIL or T or a pathname designator or an output STREAM. The default is NIL. :EXTERNAL-FORMAT the EXT:ENCODING of the filename. :WARNINGS specifies whether warnings should also appear on the screen. :VERBOSE specifies whether error messages should also appear on the screen. :PRINT specifies whether an indication which forms are being compiled should appear on the screen. The variables CUSTOM:*COMPILE-WARNINGS* , *COMPILE-VERBOSE*, *COMPILE-PRINT* provide defaults for the :WARNINGS, :VERBOSE, :PRINT keyword arguments, respectively, and are bound by COMPILE-FILE to the values of the arguments, i.e., these arguments are recursive. For each input file (default file type: #P"".lisp"") the following files are generated: File When Default file type Contents output file only if :OUTPUT-FILE is not NIL #P"".fas"" can be loaded using the LOAD function auxiliary output file only if :OUTPUT-FILE is not NIL #P"".lib"" used by COMPILE-FILE when compiling a REQUIRE form referring to the input file listing file only if :LISTING is not NIL #P"".lis"" disassembly of the output file C output file only if :OUTPUT-FILE is not NIL #P"".c"" “FFI”; this file is created only if the source contains “FFI” forms Warning If you have two files in the same directory - #P""foo.lisp"" and #P""foo.c"", and you compile the first file with CLISP, the second file will be clobbered if you have any “FFI” forms in the first one! 24.2. Function COMPILE-FILE-PATHNAME The default for the :OUTPUT-FILE argument is T, which means #P"".fas"". 24.3. Function REQUIRE 24.3.1. Additional LOAD locations 24.3.2. Interaction with COMPILE-FILE The function REQUIRE receives as the optional argument either a PATHNAME or a LIST of PATHNAMEs: files to be LOADed if the required module is not already present. 24.3.1. Additional LOAD locations In addition to (and before) CUSTOM:*LOAD-PATHS*, REQUIRE tries to find the file to LOAD in the following locations: Platform Dependent: Only in CLISP built without configure flag --without-dynamic-modules. The system-wide external modules directory (MERGE-PATHNAMES ""dynmod/"" CUSTOM:*LIB-DIRECTORY*). Platform Dependent: Only in CLISP built without configure flag --without-dynamic-modules. The user external modules directory (MERGE-PATHNAMES ""dynmod/"" CUSTOM:*USER-LIB-DIRECTORY*) (when CUSTOM:*USER-LIB-DIRECTORY* is non-NIL). When REQUIRE was called while LOADing, the directory with the file being loaded (i.e., (MAKE-PATHNAME :name NIL :type NIL :defaults *LOAD-TRUENAME*)). 24.3.2. Interaction with COMPILE-FILE At compile time, (REQUIRE #P""foo"") forms are treated specially: CUSTOM:*LOAD-PATHS* is searched for #P""foo.lisp"" and #P""foo.lib"". If the latest such file is a #P"".lisp"", it is compiled; otherwise the #P"".lib"" is loaded. If neither is found, (REQUIRE #P""foo"") is called. Warning It is a very bad idea to name your files the same way as CLISP modules (whether system-supplied or user-installed) because then REQUIRE will use different files at compile and execution times. The #P"".lib"" is a “header” file which contains the constant, variable, inline and macro definitions necessary for compilation of the files that REQUIRE this file, but not the function definitions and calls that are not necessary for that. Thus it is not necessary to either enclose REQUIRE forms in EVAL-WHEN or to load the required files in the makefiles: if you have two files, #P""foo.lisp"" and #P""bar.lisp"", and the latter requires the former, you can write in your Makefile:  all: foo.fas bar.fas  foo.fas: foo.lisp 	clisp -c foo  bar.fas: bar.lisp foo.fas 	clisp -c bar  instead of the more cumbersome (and slower, since #P"".lib""s are usually smaller and load faster that #P"".fas""s):  bar.fas: bar.lisp foo.fas         clisp -i foo -c bar  Thus, you do not need to (LOAD #P""foo"") in order to (COMPILE-FILE #P""bar.lisp""). If memory is tight, and if #P""foo.lisp"" contains only a few inline functions, macros, constants or variables, this is a space and time saver. If #P""foo.lisp"" does a lot of initializations or side effects when being loaded, this is important as well. 24.4. Function LOAD LOAD accepts four additional keyword arguments :ECHO, :COMPILING, :EXTRA-FILE-TYPES, and :OBSOLETE-ACTION.  (LOAD filename &KEY ((:VERBOSE *LOAD-VERBOSE*) *LOAD-VERBOSE*)                     ((:PRINT *LOAD-PRINT*) *LOAD-PRINT*)                     ((:ECHO CUSTOM:*LOAD-ECHO*) CUSTOM:*LOAD-ECHO*) :IF-DOES-NOT-EXIST                     ((:COMPILING CUSTOM:*LOAD-COMPILING*) CUSTOM:*LOAD-COMPILING*) :EXTRA-FILE-TYPES                     ((:OBSOLETE-ACTION CUSTOM:*LOAD-OBSOLETE-ACTION*) CUSTOM:*LOAD-OBSOLETE-ACTION*))  :VERBOSE causes LOAD to emit a short message that a file is being loaded. The default is *LOAD-VERBOSE*, which is initially T, but can be changed by the -v option. :PRINT causes LOAD to print the value of each form. The default is *LOAD-PRINT*, which is initially NIL, but can be changed by the -v option. :ECHO causes the input from the file to be echoed to *STANDARD-OUTPUT* (normally to the screen). Should there be an error in the file, you can see at one glance where it is. The default is CUSTOM:*LOAD-ECHO* , which is initially NIL, but can be changed by the -v option. :COMPILING causes each form read to be compiled on the fly. The compiled code is executed at once and - in contrast to COMPILE-FILE - not written to a file. The default is CUSTOM:*LOAD-COMPILING* , which is initially NIL, but can be changed by the -C option. :EXTRA-FILE-TYPES Specifies the LIST of additional file types considered for loading, in addition to CUSTOM:*SOURCE-FILE-TYPES* (which is initially (""lisp"" ""lsp"" ""cl"")) and CUSTOM:*COMPILED-FILE-TYPES* (which is initially (""fas"")). When filename does not specify a unique file (e.g., filename is #P""foo"" and both #P""foo.lisp"" and #P""foo.fas"" are found in the CUSTOM:*LOAD-PATHS*), then the newest file is loaded. :OBSOLETE-ACTION Specifies the action to take when loading a #P"".fas"" with a different bytecode version from the one supported by this CLISP version. The possible actions are :DELETE delete the #P"".fas"" and proceed as with NIL :ERROR SIGNAL an ERROR :COMPILE recompile the source file (if found in CUSTOM:*LOAD-PATHS*) and LOAD the result NIL (default) WARN and look for another matching file If no file can be loaded and :IF-DOES-NOT-EXIST is non-NIL, an ERROR is SIGNALed. The default is CUSTOM:*LOAD-OBSOLETE-ACTION* , which is initially NIL. The variables *LOAD-VERBOSE*, *LOAD-PRINT*, CUSTOM:*LOAD-OBSOLETE-ACTION*, CUSTOM:*LOAD-COMPILING*, and CUSTOM:*LOAD-ECHO* are bound by LOAD when it receives a corresponding keyword argument (:VERBOSE, :PRINT, :OBSOLETE-ACTION, :COMPILING, and :ECHO), i.e., these arguments are recursive, just like the arguments :WARNINGS, :VERBOSE, and :PRINT for COMPILE-FILE. When evaluation of a read form SIGNALs an ERROR, three RESTARTs are available: SKIP Skip this form and read the next one. RETRY Try to evaluate this form again. STOP Stop loading the file. Variable CUSTOM:*LOAD-PATHS*. The variable CUSTOM:*LOAD-PATHS* contains a list of directories where the files are looked for - in addition to the specified or current directory - by LOAD, REQUIRE, COMPILE-FILE and LOAD-LOGICAL-PATHNAME-TRANSLATIONS. 24.5. Variable *FEATURES* The variable *FEATURES* initially contains the following symbols Default *FEATURES* :CLISP the name of this implementation :ANSI-CL CLISP purports to conform to [ANSI CL standard] :COMMON-LISP required by [ANSI CL standard] :INTERPRETER EVAL is implemented :COMPILER COMPILE and COMPILE-FILE are implemented :SOCKETS see Section 32.4, “Socket Streams” :MT see Section 32.5, “Multiple Threads of Execution” :GENERIC-STREAMS see Section 31.6, “Generic streams” :LOGICAL-PATHNAMES Logical Pathnames are implemented :FFI if a foreign function interface (see Section 32.3, “The Foreign Function Call Facility”) is supported (Platform Dependent: Many UNIX, Win32 platforms only) :GETTEXT if internationalization (see Section 31.4, “Internationalization of CLISP”) using the GNU gettext package is supported (Platform Dependent: most UNIX platforms only) :UNICODE if UNICODE (ISO 10646) characters are supported (see Section 31.5, “Encodings”) :LOOP “extended” LOOP form is implemented :CLOS CLOS is implemented :MOP Meta-Object Protocol is implemented :WORD-SIZE=64 if CLISP was built for a 64-bit CPU. This could be useful on platforms with 64-bit CPUs which have a 32-bit mode emulation (e.g., i386 is emulated on x86_64 and ia64) so that the user can decide which ABI library to load dynamically using “FFI”. :WIN32 if hardware = PC (clone) and operating system = Win32 (Windows 95/98/Me/NT/2000/XP) :PC386 if hardware = PC (clone). It can be used as an indicator for the mainstream hardware characteristics (such as the existence of a graphics card with a non-graphics text mode, or the presence of a keyboard with arrows and Insert/Delete keys, or an ISA/VLB/PCI bus) or software characteristics (such as the Control+Alternate+Delete keyboard combination). :UNIX if operating system = UNIX (in this case the hardware is irrelevant!) :BEOS if operating system = BeOS (in that case :UNIX is also present) :CYGWIN if CLISP is using the Cygwin UNIX compatibility layer on top of Win32 (in that case :UNIX is also present) :MACOS if operating system = Mac OS X (in that case :UNIX is also present) Each module should add the appropriate keyword, e.g., :SYSCALLS, :DIRKEY, :REGEXP, :PCRE, etc. 24.6. Function EXT:FEATUREP [CLRFI-1] (EXT:FEATUREP form) provides run-time access to the read-time conditionals #+ and #-. form is a feature exression. 24.7. Function EXT:COMPILED-FILE-P [CLRFI-2] (EXT:COMPILED-FILE-P filename) returns non-NIL when the file filename exists, is readable, and appears to be a CLISP-compiled #P"".fas"" file compatible with the currently used bytecode format. System definition facilities (such as asdf or defsystem) can use it to determine whether the file needs to be recompiled. Chapter 25. Environment [chap-25] Table of Contents 25.1. Top Level Loop 25.1.1. User-defined Commands 25.2. Debugging Utilities 25.2.1. Function DISASSEMBLE 25.2.2. Function EXT:UNCOMPILE 25.2.3. Function DOCUMENTATION 25.2.4. Function DESCRIBE 25.2.5. Macro TRACE 25.2.6. Function INSPECT 25.2.7. Macro TIME 25.2.8. Function ED 25.2.9. Functions APROPOS & APROPOS-LIST 25.2.10. Function DRIBBLE 25.2.10.1. Scripting and DRIBBLE 25.3. Environment Inquiry 25.3.1. Function ROOM 25.3.2. Function EXT:GC 25.3.3. Machine 25.3.4. Function LISP-IMPLEMENTATION-VERSION 25.3.5. Function EXT:ARGV 25.4. Time 25.1. Top Level Loop [sec_25-1-1] 25.1.1. User-defined Commands The debugger may be invoked through the functions INVOKE-DEBUGGER, BREAK, SIGNAL, ERROR, CERROR, WARN. The stepper is invoked through the macro STEP. Debugger and stepper execute subordinate read-eval-print loop (called break loops) which are similar to the main read-eval-print loop except for the prompt and the set of available commands. Commands must be typed literally, in any case, without surrounding quotes or whitespace. Each command has a keyword abbreviation, indicated in the second column. Table 25.1. Commands common to the main loop, the debugger and the stepper command abbreviation operation help :h print a list of available commands LocalSymbols :ls print the list of SYMBOLs INTERNed in a given PACKAGE. Table 25.2. Commands common to the debugger and the stepper command abbreviation operation Abort :a abort to the next most recent read-eval-print loop Unwind :uw abort to the next most recent read-eval-print loop Quit :q quit to the top read-eval-print loop The stack is organized into frames and other stack elements. Usually every invocation of an interpreted function and every evaluation of an interpreted form corresponds to one stack frame. Special forms such as LET, LET*, UNWIND-PROTECT and CATCH produce special kinds of stack frames. In a break loop there is a current stack frame, which is initially the most recent stack frame but can be moved using the debugger commands Up and Down. Evaluation of forms in a break loop occurs in the lexical environment of the current stack frame and at the same time in the dynamic environment of the debugger's caller. This means that to inspect or modify a lexical variable all you have to do is to move the current stack frame to be just below the frame that corresponds to the form or the function call that binds that variable. There is a current stack mode which defines in how much detail the stack is shown by the stack-related debugger commands: All the stack elements are considered. This mode works fine for debugging compiled functions. All the frames are considered. Only lexical frames (frames that correspond to special forms that modify the lexical environment) are considered. Only EVAL and APPLY frames are considered. Every evaluation of a form in the interpreter corresponds to an EVAL frame. This is the default. Only APPLY frames are considered. Every invocation of an interpreted function corresponds to one APPLY frame. Table 25.3. Commands common to the debugger and the stepper command abbreviation operation Error :e print the last error object. Inspect :i INSPECT the last error object. Where :w shows the current stack frame. Up :u goes up one frame, i.e., to the caller if in mode-5 Down :d does down one frame, i.e., to the callee if in mode-5 Top :t goes to top frame, i.e., to the top-level form if in mode-4 Bottom :b goes to bottom (most recent) frame, i.e., most probably to the form or function that caused the debugger to be entered. Mode mode :m mode sets the current stack mode Frame-limit l :fl set the frame-limit: this many frames will be printed by Backtrace at most. Backtrace [mode [l]] :bt [mode [l]] lists the stack in the given mode, bottom frame first, top frame last; at most l frames are printed. If the current stack frame is an EVAL or APPLY frame, the following commands are available as well: Table 25.4. Commands specific to EVAL/APPLY command abbreviation operation Break+ :br+ sets a breakpoint in the current frame. When the corresponding form or function will be left, the debugger will be entered again, with the variable EXT:*TRACE-VALUES* containing a list of its values. Break- :br- removes a breakpoint from the current frame. Redo :rd re-evaluates the corresponding form or function call. This command can be used to restart parts of a computation without aborting it entirely. Return value :rt value leaves the current frame, returning the given value. Table 25.5. Commands specific to the debugger command abbreviation operation Continue :c continues evaluation of the program. Table 25.6. Commands specific to the stepper command abbreviation operation Step :s step into a form: evaluate this form in single step mode Next :n step over a form: evaluate this form at once Over :o step over this level: evaluate at once up to the next return Continue :c switch off single step mode, continue evaluation The stepper is usually used like this: If some form returns a strange value or results in an error, call (STEP form) and navigate using the commands Step and Next until you reach the form you regard as responsible. If you are too fast (execute Next once and get the error), there is no way back; you have to restart the entire stepper session. If you are too slow (stepped into a function or a form which certainly is OK), a couple of Next commands or one Over command will help. 25.1.1. User-defined Commands You can set CUSTOM:*USER-COMMANDS* to a list of FUNCTIONs, each returning a LIST of bindings, i.e., either a STRING the help string printed by help in addition to the standard CLISP help CONS (STRING . FUNCTION) the actual binding: when the user types the string, the function is called on the remainder of the string, i.e., the part of the string after the command. E.g.,  (setq CUSTOM:*USER-COMMANDS*       (list (lambda () (list (format nil ""~2%User-defined commands:"")))             (lambda ()               (flet ((panic (argline)                        (format t ""don't panic~@[ because of ~A~], ~D~%""                                (and (plusp (length argline)) argline)                                (random 42))))                 (list (format nil ""~%panic   :p    hit the panic button!"")                       (cons ""panic"" #'panic)                       (cons "":p"" #'panic))))             (lambda ()               (let ((curses #(""ouch"" ""yuk"" ""bletch"")))                 (flet ((swear (argline)                          (format t ""~A: ~A!~%"" argline                                  (aref curses (random (length curses))))))                   (list (format nil ""~%swear   :e    curse"")                         (cons ""swear"" #'swear)                         (cons "":e"" #'swear)))))))  25.2. Debugging Utilities [sec_25-1-2] 25.2.1. Function DISASSEMBLE 25.2.2. Function EXT:UNCOMPILE 25.2.3. Function DOCUMENTATION 25.2.4. Function DESCRIBE 25.2.5. Macro TRACE 25.2.6. Function INSPECT 25.2.7. Macro TIME 25.2.8. Function ED 25.2.9. Functions APROPOS & APROPOS-LIST 25.2.10. Function DRIBBLE 25.2.10.1. Scripting and DRIBBLE List of Examples 25.1. Identifying Individual Calls in TRACE 25.2.1. Function DISASSEMBLE Platform Dependent: UNIX platform only. DISASSEMBLE can disassemble to machine code, provided that GNU gdb is present. In that case the argument may be a EXT:SYSTEM-FUNCTION, a FFI:FOREIGN-FUNCTION, a special operator handler, a SYMBOL denoting one of these, an INTEGER (address), or a STRING. 25.2.2. Function EXT:UNCOMPILE The function EXT:UNCOMPILE does the converse of COMPILE: (EXT:UNCOMPILE function) reverts a compiled function (name), that has been entered or loaded in the same session and then compiled, back to its interpreted form. 25.2.3. Function DOCUMENTATION No on-line documentation is available for the system functions (yet), but see Section 25.2.4, “Function DESCRIBE”. 25.2.4. Function DESCRIBE When CUSTOM:*BROWSER* is non-NIL, and CUSTOM:CLHS-ROOT returns a valid URL, DESCRIBE on a standard Common Lisp symbol will point your web browser to the appropriate [Common Lisp HyperSpec] page. Also, when CUSTOM:*BROWSER* is non-NIL, and CUSTOM:IMPNOTES-ROOT returns a valid URL, DESCRIBE on symbols and packages documented in these implementation notes will point your web browser to the appropriate page. To do this, DESCRIBE will retrieve the appropriate tables from CUSTOM:CLHS-ROOT and CUSTOM:IMPNOTES-ROOT on the first relevant invocation. These operations are logged to CUSTOM:*HTTP-LOG-STREAM*. Function CUSTOM:CLHS-ROOT. Function CUSTOM:CLHS-ROOT is defined in config.lisp. By default it looks at (EXT:GETENV ""CLHSROOT"") and CUSTOM:*CLHS-ROOT-DEFAULT*, but you may redefine it in config.lisp or RC file. The return value should be a STRING terminated with a ""/"", e.g., http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/ or /usr/doc/HyperSpec/. If the return value is NIL, the feature is completely disabled. CUSTOM:*CLHS-ROOT-DEFAULT* is initialized in config.lisp based on the --hyperspec passed to the top-level configure script when CLISP was built. Function CUSTOM:IMPNOTES-ROOT. Function CUSTOM:IMPNOTES-ROOT is defined in config.lisp. By default it looks at (EXT:GETENV ""IMPNOTES"") and CUSTOM:*IMPNOTES-ROOT-DEFAULT*, but you may redefine it in config.lisp or RC file. The return value should be a STRING terminated with a ""/"", e.g., http://clisp.cons.org/impnotes/, or the path to the monolithic page, e.g., http://clisp.cons.org/impnotes.html or /usr/doc/clisp/impnotes.html. If the return value is NIL, the feature is completely disabled. 25.2.5. Macro TRACE List of Examples 25.1. Identifying Individual Calls in TRACE (TRACE function-name ...) makes the functions function-name, ... traced. Each function-name should be either a function name or a LIST (function-name &KEY :SUPPRESS-IF :MAX-DEPTH :STEP-IF :BINDINGS :PRE :POST :PRE-BREAK-IF :POST-BREAK-IF :PRE-PRINT :POST-PRINT :PRINT), where :SUPPRESS-IF form no trace output as long as form is true :MAX-DEPTH form no trace output as long as (> *trace-level* form). This is useful for tracing functions that are use by the tracer itself, such as PRINT-OBJECT, or otherwise when tracing would lead to an infinite recursion. :STEP-IF form invokes the stepper as soon as form is true :BINDINGS ((variable form)...) binds variables to the result of evaluation of forms around evaluation of all of the following forms :PRE form evaluates form before calling the function :POST form evaluates form after return from the function :PRE-BREAK-IF form goes into the break loop before calling the function if form is true :POST-BREAK-IF form goes into the break loop after return from the function if form is true :PRE-PRINT form prints the values of form before calling the function :POST-PRINT form prints the values of form after return from the function :PRINT form prints the values of form both before calling and after return from the function In all these forms you can access the following variables: EXT:*TRACE-FUNCTION* the traced function itself EXT:*TRACE-ARGS* the arguments to the function EXT:*TRACE-FORM* the function/macro call as form EXT:*TRACE-VALUES* after return from the function: the list of return values from the function call and you can leave the function call with specified values by using RETURN. TRACE and UNTRACE are also applicable to functions (SETF symbol) and to macros, but not to locally defined functions and macros. Trace output TRACE prints this line before evaluating the form: trace level. Trace: form and after evaluating the form it prints: trace level. Trace: function-name ==> result where “trace level” is the total nesting level. Variable CUSTOM:*TRACE-INDENT* If you want the TRACE level to be indicated by the indentation in addition to the printed numbers, set CUSTOM:*TRACE-INDENT* to non-NIL. Initially it is NIL since many nested traced calls will easily exhaust the available line length. Examples Example 25.1. Identifying Individual Calls in TRACE Suppose the trace level above is not enough for you to identify individual calls. You can give each call a unique id and print it:  (defun f0 (x)   (cond ((zerop x) 1)         ((zerop (random 2)) (* x (f0 (1- x))))         (t (* x (f1 (1- x)))))) ⇒ F0 (defun f1 (x)   (cond ((zerop x) 1)         ((zerop (random 2)) (* x (f0 (1- x))))         (t (* x (f1 (1- x)))))) ⇒ F1 (defvar *f0-call-count* 0) ⇒ *F0-CALL-COUNT* (defvar *id0*) ⇒ *ID0* (defvar *cc0*) ⇒ *CC0* (defvar *f1-call-count* 0) ⇒ *F1-CALL-COUNT* (defvar *id1*) ⇒ *ID1* (defvar *cc1*) ⇒ *CC1* (trace (f0 :bindings ((*cc0* (incf *f0-call-count*))                       (*id0* (gensym ""F0-"")))            :pre-print (list 'enter *id0* *cc0*)            :post-print (list 'exit *id0* *cc0*))        (f1 :bindings ((*cc1* (incf *f1-call-count*))                       (*id1* (gensym ""F1-"")))            :pre-print (list 'enter *id1* *cc1*)            :post-print (list 'exit *id1* *cc1*))) ;; Tracing function F0. ;; Tracing function F1. ⇒ (F0 F1) (f0 10) 1. Trace: (F0 '10) (ENTER #:F0-2926 1) 2. Trace: (F1 '9) (ENTER #:F1-2927 1) 3. Trace: (F0 '8) (ENTER #:F0-2928 2) 4. Trace: (F1 '7) (ENTER #:F1-2929 2) 5. Trace: (F1 '6) (ENTER #:F1-2930 3) 6. Trace: (F1 '5) (ENTER #:F1-2931 4) 7. Trace: (F1 '4) (ENTER #:F1-2932 5) 8. Trace: (F0 '3) (ENTER #:F0-2933 3) 9. Trace: (F1 '2) (ENTER #:F1-2934 6) 10. Trace: (F0 '1) (ENTER #:F0-2935 4) 11. Trace: (F1 '0) (ENTER #:F1-2936 7) (EXIT #:F1-2936 7) 11. Trace: F1 ==> 1 (EXIT #:F0-2935 4) 10. Trace: F0 ==> 1 (EXIT #:F1-2934 6) 9. Trace: F1 ==> 2 (EXIT #:F0-2933 3) 8. Trace: F0 ==> 6 (EXIT #:F1-2932 5) 7. Trace: F1 ==> 24 (EXIT #:F1-2931 4) 6. Trace: F1 ==> 120 (EXIT #:F1-2930 3) 5. Trace: F1 ==> 720 (EXIT #:F1-2929 2) 4. Trace: F1 ==> 5040 (EXIT #:F0-2928 2) 3. Trace: F0 ==> 40320 (EXIT #:F1-2927 1) 2. Trace: F1 ==> 362880 (EXIT #:F0-2926 1) 1. Trace: F0 ==> 3628800 ⇒ 3628800 *f0-call-count* ⇒ 4 *f1-call-count* ⇒ 7 25.2.6. Function INSPECT The function INSPECT accepts a keyword argument :FRONTEND, which specifies the way CLISP will interact with the user, and defaults to CUSTOM:*INSPECT-FRONTEND*. Available :FRONTENDs for INSPECT in CLISP :TTY The interaction is conducted via the *TERMINAL-IO* stream. Please use the help command to get the list of all available commands. :HTTP A window in your Web browser (specified by the :BROWSER keyword argument) is opened and it is controlled by CLISP via a SOCKET:SOCKET-STREAM, using the HTTP protocol. You should be able to use all the standard browser features. Since CLISP is not multitasking at this time, you will not be able to do anything else during an INSPECT session. Please click on the quit link to terminate the session. Please be aware though, that once you terminate an INSPECT session, all links in all INSPECT windows in your browser will become obsolete and using them in a new INSPECT session will result in unpredictable behavior. The function INSPECT also accepts a keyword argument :BROWSER, which specifies the browser used by the :HTTP front-end and defaults to CUSTOM:*INSPECT-BROWSER*. The function INSPECT binds some pretty-printer variables: Variable Bound to *PRINT-LENGTH* CUSTOM:*INSPECT-PRINT-LENGTH* *PRINT-LEVEL* CUSTOM:*INSPECT-PRINT-LEVEL* *PRINT-LINES* CUSTOM:*INSPECT-PRINT-LINES* User variable CUSTOM:*INSPECT-LENGTH* specifies the number of sequence elements or slots printed in detail when a sequence or a structure or a CLOS object is inspected. 25.2.7. Macro TIME The timing data printed by the macro TIME includes: the real time (“wall” time, GET-INTERNAL-REAL-TIME), the run time (processor time for this process,"	"null"	"null"	"A GNU implementation; contains a compiler and an interpreter..."	"true"
"Implementations"	"SBCL"	"http://www.sbcl.org/index.html"	"A fork of CMUCL; compiles to machine code.. Public domain, with some parts under and."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"About - Steel Bank Common Lisp Steel Bank Common Lisp About News Download Getting Started History and Copyright Porting Maintainer public keys Manual Project Page Bug Database Links About Steel Bank Common Lisp (SBCL) is a high performance Common Lisp compiler. It is open source / free software, with a permissive license. In addition to the compiler and runtime system for ANSI Common Lisp, it provides an interactive environment including a debugger, a statistical profiler, a code coverage tool, and many other extensions. SBCL runs on a number of POSIX platforms, and experimentally on Windows. See the download page for supported platforms, and getting started guide for additional help. The most recent version is SBCL 1.3.7, released June 30, 2016 (release notes). Documentation SBCL's manual is available on the web in html and pdf formats. See the doc/manual directory in the source code for the current version in TeXInfo source. Reporting Bugs Bugs can either be reported directly to SBCL's bug database on Launchpad, or by sending email to the sbcl-bugs mailing list -- no subscription required."	"null"	"null"	"A fork of CMUCL; compiles to machine code.. Public domain, with some parts under and."	"true"
"Utilities"	"puri-unicode"	"https://github.com/hankhero/cl-json"	"Pure URI library with Unicode support.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"33"	"7"	"21"	"GitHub - hankhero/cl-json: Json encoder and decoder for Common-Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 33 Fork 21 hankhero/cl-json Code Issues 10 Pull requests 2 Pulse Graphs Json encoder and decoder for Common-Lisp 155 commits 1 branch 1 release 4 contributors Common Lisp 99.3% CSS 0.7% Common Lisp CSS Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v0.5.0 Nothing to show New pull request Latest commit 6dfebb9 Nov 8, 2014 hankhero Merge pull request #8 from agrostis/master … Added ABCL as CLOS-capable implementation (fix #6). Permalink Failed to load latest commit information. doc Version 0.5.0 mentioned in doc and asd Nov 18, 2012 src Merge pull request #8 from agrostis/master Nov 8, 2014 t Added ABCL as CLOS-capable implementation (fix #6). Oct 2, 2014 .gitignore added basic gitignore Nov 18, 2012 CONTRIBUTORS Added Robert Goldman to CONTRIBUTORS Jan 6, 2010 LICENSE Version 0.5.0 mentioned in doc and asd Nov 18, 2012 README.md Updated readme Nov 13, 2012 TODO added a TODO file with some ideas Jan 6, 2010 cl-json.asd Added ABCL as CLOS-capable implementation (fix #6). Oct 2, 2014 README.md CL-JSON CL-JSON provides an encoder of Lisp objects to JSON format and a corresponding decoder of JSON data to Lisp objects. Both the encoder and the decoder are highly customizable; at the same time, the default settings ensure a very simple mode of operation, similar to that provided by YASON or ST-JSON. CL-JSON is well tested and the automated testcases includes the JSON_checker tests. History 2006 First version by Henrik Hjelte 2009 Major update by Boris Smilga, adding lots of features. 2009 New alternative encoder, the explicit sexp-encoder. 2011 Json-rpc version 2 format by Robert Goldman. 2012 Move from darcs to git. Licence MIT. Documentation Documentation is at the project page on common-lisp.net. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/hankhero/cl-json"	"Pure URI library with Unicode support.."	"true"
"JSON"	"jsown"	"https://github.com/madnificent/jsown"	"A reader and writer for the JSON format.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"39"	"5"	"8"	"GitHub - madnificent/jsown: reader/writer for the JSON format in common lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 39 Fork 8 madnificent/jsown Code Issues 1 Pull requests 0 Pulse Graphs reader/writer for the JSON format in common lisp 84 commits 2 branches 1 release Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags devel master Nothing to show 1.0.0 Nothing to show New pull request Latest commit f894a58 Dec 22, 2015 madnificent Abide order of specified keys for programatically created objects … When a json object is parsed and written, the order of the keys is correct.  However, when you add keys to an object, the keys are added to the front of the object, rather than to the back.  This is indeed somewhat faster, but it doesn't feel nice when looking at the resulting json files.  We're switching this around for nicer json output. Permalink Failed to load latest commit information. tests .gitignore LICENSE README.textile accessors.lisp jsown.asd packages.lisp reader.lisp writer.lisp README.textile jsown, high performance Common Lisp json parser jsown is a high performance Common Lisp json parser. Its aim is to allow for the fast parsing of json objects in CL. Recently, functions and macros have been added to ease the burden of writing and editing jsown objects. jsown allows you to parse json objects quickly to a modifiable lisp list and write them back. If you only need partial retrieval of objects, jsown allows you to select the keys which you would like to see parsed. jsown also has a json writer and some helper methods to alter the json objects themselves. parsing json objects In order to parse a json object, simply use the parse function.   (jsown:parse ""{\""foo\"":\""bar\"",\""baz\"":100.25}"")   =>(:OBJ (""foo"" . ""bar"") (""baz"" . 401/4)) Without any extra arguments, the parse function will return all keywords. In order to select only a few keywords, you can add those keywords in which you’re interested:   (jsown:parse ""{\""foo\"":\""bar\"",\""frolic\"":100,\""fragrance\"":10.01,\""for\"":\""markup\""}"" ""foo"" ""frolic"" ""fragrance"")   => (:OBJ (""foo"" . ""bar"") (""frolic"" . 100) (""fragrance"" . 1001/100)) In order to achieve high performance when parsing specific keywords, the keywords to be found should be known at compile time. The compiler-macro-function can calculate the keyword container with the requested keywords at compile-time. When specifying the keywords in which you’re interested you should ignore any escaped characters. For instance, supplying the string “foo” will automatically match “f\\\\oo” too."" Using jsown objects jsown ships with some convience functions to inspect and alter the returned json content. The fetching of the value given to a certain keyword may be done by using the val function. This function also has a setf defined on it. The (setf val) function may alter the original object, it is however not guaranteed to do so.   (jsown:val '(:obj (""foo"" . ""bar"") (""frolic"" . 100) (""fragrance"" . 1001/100)) ""frolic"")   => 100   (setf (jsown:val '(:obj (""foo"" . ""bar"") (""frolic"" . 100) (""fragrance"" . 1001/100)) ""frolic"") ""I wasn't here before"")   => (:obj (""foo"" . ""bar"") (""frolic"" . ""I wasn't here before"") (""fragrance"" . 1001/100)) You can build objects by using the val function too, albeit it doesn’t look really sexy.   (setf (jsown:val (setf (jsown:val (setf (jsown:val (jsown:empty-object) ""foo"") ""bar"") ""bang"") (list 1 2 3 ""foo"" 4 5)) ""bingo"") 24.93)   =>(:obj (""bingo"" . 24.93) (""bang"" 1 2 3 ""foo"" 4 5) (""foo"" . ""bar"")) For building objects, the macros new-js and extend-js can be used. new-js creates a new jsown object, extend-js extends an existing jsown object.   (jsown:new-js     (""foo"" ""bar"")     (""baz"" (+ 100 0.25)))   => (:obj (""baz"" . 100.25) (""foo"" . ""bar"")) This object can be extended by use of extend-js. Say we store the previously built json object in the parameter *jsown-obj*, then we can extend it like so:   epicdb> (jsown:extend-js *jsown-obj*     (""bing"" ""bang"")     (""ping"" (print ""Adding ping"") ""pong""))   => (:obj (""ping"" . ""pong"") (""bing"" . ""bang"") (""baz"" . 100.25) (""foo"" . ""bar"")) For didactical purposes, we’ve defined ping in more than one form. In order to see which keywords have been defined in a parsed json object, you can use the keywords function:   (jsown:keywords '(:obj (""foo"" . ""bar"") (""frolic"" . 100) (""fragrance"" . 1001/100)))   => (""foo"" ""frolic"" ""fragrance"") You can traverse over all keywords by using the do-json-keys macro.   CL-USER> (jsown:do-json-keys (keyword value)                '(:obj (""foo"" . ""bar"") (""frolic"" . 100) (""fragrance"" . 1001/100))              (format T ""~A => ~A~&"" keyword value))   foo => bar   frolic => 100   fragrance => 1001/100   NIL Lastly, the filter function allows you to traverse a tree of json objects and interpret its results.   (jsown:filter (jsown:new-js                   (""one"" 100)                   (""two"" (jsown:new-js                            (""three"" (list (jsown:new-js (""four"" (jsown:new-js                                                                   (""five"" ""result-one""))))                                           (jsown:new-js (""four"" (jsown:new-js                                                                   (""five"" ""result-two""))))                                           (jsown:new-js (""four"" (jsown:new-js                                                                   (""five"" ""result-three"")))))))))                 ""two"" ""three"" map ""four"" ""five"")   => (""result-one"" ""result-two"" ""result-three"") Writing json objects jsown supports the writing of json objects too, use the to-json CLOS method for this. You can provide an implementation for this method for your own objects so those can easily be converted to json too (and it will ensure that nested objects are correctly transformed to json).   (jsown:to-json '(:obj (""bingo"" . 24.93) (""bang"" 1 2 3 ""foo"" 4 5) (""foo"" . ""bar"")))   => ""{\""bingo\"":24.93,\""bang\"":[1,2,3,\""foo\"",4,5],\""foo\"":\""bar\""}"" When reading json objects, jsown converts their content to the most lispy translation of what was in there. As such json’s false will be translated to nil, which coincidentally also be the translation of json’s []. When writing objects lisp’s nil is translated to the empty json list []. You can write json’s false by writing lisp’s keywords :false or :f.   (jsown:to-json (jsown:new-js                    (""items"" nil)                    (""falseIsEmptyList"" :f)                    (""success"" t))) ""{\""success\"":true,\""falseIsEmptyList\"":false,\""items\"":[]}"" Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/madnificent/jsown"	"A reader and writer for the JSON format.."	"true"
"Beginner"	"Learn X in Y minutes | Where X = Common Lisp"	"https://learnxinyminutes.com/docs/common-lisp/"	"Small Common Lisp tutorial covering the essentials."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"3696"	"155"	"1438"	"GitHub - adambard/learnxinyminutes-docs: Code documentation written as code! How novel and totally my idea! Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 155 Star 3,696 Fork 1,438 adambard/learnxinyminutes-docs Code Issues 82 Pull requests 84 Pulse Graphs Code documentation written as code! How novel and totally my idea! http://learnxinyminutes.com/ 5,144 commits 7 branches 0 releases 857 contributors TeX 99.9% HTML 0.1% TeX HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master-cn master-es master new-contributing p6-array2list revert-1115-master revert-1936-master Nothing to show Nothing to show New pull request Latest commit 8f99c7a Jul 12, 2016 vendethiel committed on GitHub fix #2308 Permalink Failed to load latest commit information. bg-bg Create bg-bg/perl.html.markdown (#2255) May 13, 2016 cs-cz Fix cs-cz/javascript headers (#1773) May 27, 2016 de-de [java/de] Initial translation added. (#1391) Jun 27, 2016 el-gr Update css-gr.html.markdown (#2263) May 19, 2016 es-es #1672 metadata Jun 26, 2016 fa-ir fix fa-ir/css Mar 13, 2016 fi-fi Fix capitalization of GitHub Feb 23, 2016 fr-fr [fr/ruby-ecosytem] Translated ruby-ecosytem article in French (#1857) Jun 29, 2016 hd-hd Metadata fixups for #1673 Jun 26, 2016 hu-hu metadata fixup for #1874 Jun 26, 2016 id-id [json/id-id] update changes for ID translation (#2305) Jul 9, 2016 it-it #1630 Jun 26, 2016 ja-jp [bash-jp/ja-jp] Corrected spelling. seperated -> separated Feb 17, 2016 ko-kr adds Korean translation for Erlang Feb 28, 2016 lt-lt Update json-lt.html.markdown Mar 21, 2016 ms-my Merge pull request #1691 from hack1m/sass-my-translation Mar 13, 2016 nl-nl Add dutch translation of markdown (#1724) Jun 26, 2016 no-nb translating done Apr 26, 2015 pl-pl [json/pl] Translated JSON tutorial (#2079) Jun 26, 2016 pt-br #1421 Jun 26, 2016 pt-pt Update swift.html.markdown Jun 26, 2016 ro-ro Attempt at #2299 Jul 6, 2016 ru-ru Merge pull request #2186 from kafeg/patch-1 May 28, 2016 sk-sk #1517 Jun 26, 2016 sv-se Fix folder name, lang value and a typo Mar 15, 2016 ta_in Clean up various errors Feb 12, 2016 tr-tr TypeScript Turkish translation (#2246) Apr 28, 2016 uk-ua add me to list of contributors May 14, 2016 vi-vn Update objective-c-vi.html.markdown Mar 15, 2016 zh-cn update according to reviewer feedback Jun 7, 2016 zh-tw [Elixir/zh-Tw]Translation for Elixir of zh-tw Apr 22, 2016 .gitignore Updated, referencing #2185 Mar 14, 2016 CONTRIBUTING.markdown Resolve conflicts from merge Feb 15, 2016 HTML-fr.html.markdown Create HTML-fr.html.markdown (#1843) Jun 27, 2016 PULL_REQUEST_TEMPLATE.md YESSSSS! Feb 17, 2016 README.markdown Resolve conflicts from merge Feb 15, 2016 amd.html.markdown removing whitespace all over Oct 7, 2015 asciidoc.html.markdown [asciidoc/en] fixed a couple of typos Feb 17, 2016 asymptotic-notation.html.markdown Fixed typos and content exceeding beyond 80 chars Mar 12, 2016 bash.html.markdown [bash/en] Addition to bash (#2302) Jul 10, 2016 bf.html.markdown brainfuck->bf Feb 12, 2016 binary-search.html.markdown fixup filename for #1879 Jun 26, 2016 c++.html.markdown Added the Logical and bitwise operators section, fixes merge issue with Jun 27, 2016 c.html.markdown Fix c - the first character of ILoveC is I not i (#2253) May 12, 2016 chapel.html.markdown Fix capitalization of GitHub Feb 24, 2016 clojure-macros.html.markdown removing whitespace all over Oct 8, 2015 clojure.html.markdown Copy arrow docs from french. Oct 18, 2015 cmake.html.markdown tiny fixes to cmake May 30, 2016 coffeescript.html.markdown Merge pull request #1424 from AndyBrown91/coffeescript Oct 9, 2015 coldfusion.html.markdown replaced &lt; and &gt; in pre block Dec 18, 2015 common-lisp.html.markdown [common-lisp/en] Fix code in examples Dec 9, 2015 compojure.html.markdown Use keywords in POST/PUT examples May 30, 2015 csharp.html.markdown Correct ""Bycles"" to ""Bicycles"""" (#2293) Jun 28, 2016 css.html.markdown [CSS/en] Adding border related styleguides (#2301) Jul 8, 2016 d.html.markdown fix parallelism example typo Jan 2, 2016 dart.html.markdown Update dart.html.markdown Oct 31, 2015 dynamic-programming.html.markdown Feature: adds Dynamic Programming tutorial (#1885) Jun 26, 2016 edn.html.markdown Clean up various errors Feb 13, 2016 elisp.html.markdown [elisp/en] Fix typo Oct 22, 2015 elixir.html.markdown Elixir agents/maps, Ruby conventions/docs (#2116) Jul 12, 2016 elm.html.markdown fix #2295 Jul 2, 2016 erlang.html.markdown Replaced 'or' with a semicolons Nov 19, 2015 factor.html.markdown [factor/en] minor typo. dont -> don't Mar 5, 2016 file.erb Added filename parameter Jun 29, 2013 forth.html.markdown [forth/en] don't -> don't Mar 14, 2016 fsharp.html.markdown [fsharp/en] typos Mar 15, 2016 git.html.markdown Fix git pull --rebase explanation (#2262) May 18, 2016 go.html.markdown Updated closure Jun 4, 2016 groovy.html.markdown [groovy/es] Groovy translated to Spanish (#1791) May 27, 2016 hack.html.markdown removing whitespace all over Oct 8, 2015 haml.html.markdown Merge pull request #1438 from chashmeetsingh/patch-8 Oct 12, 2015 haskell.html.markdown Merge pull request #1758 from patrikja/patch-2 Feb 11, 2016 haxe.html.markdown [haxe/en] Adding colon after comments May 20, 2015 hy.html.markdown Merge pull request #1574 from Zirak/patch-1 Mar 11, 2016 inform7.html.markdown Add a try at an Inform 7 tutorial. Jan 22, 2016 java.html.markdown [Java/en] Adding a reference for treemap (#2300) Jul 8, 2016 javascript.html.markdown Added new resource to javascript Oct 31, 2015 json.html.markdown [json/en] Cut noise, formatting, links. Oct 20, 2015 julia.html.markdown Update Dict and Set Syntax (#2296) Jul 2, 2016 kotlin.html.markdown [kotlin/en] Add examples of sequences (#2214) Jun 26, 2016 latex.html.markdown Replace invite sign $ by > in compilation example Mar 31, 2016 less.html.markdown [less/en] paranthesis -> parenthesis Mar 6, 2016 livescript.html.markdown removing whitespace all over Oct 8, 2015 lua.html.markdown [elisp/en] Fix typo Oct 28, 2015 make.html.markdown Merge pull request #2167 from divayprakash/typos-fix Mar 12, 2016 markdown.html.markdown fixed content extending beyond 80 chars Mar 18, 2016 matlab.html.markdown Add a section on code sections/cells (#1855) Jun 26, 2016 neat.html.markdown removing whitespace all over Oct 8, 2015 nim.html.markdown [nim/en] Correct syntax highlighting Mar 23, 2016 nix.html.markdown Remove nix highlighting (we don't have it) May 19, 2016 objective-c.html.markdown fix #2308 Jul 12, 2016 ocaml.html.markdown Change anonymous function in List.filter example Mar 26, 2016 paren.html.markdown Updating header with contribution name Oct 20, 2015 pcre.html.markdown Add an example of trap command (#1826) Jun 26, 2016 perl.html.markdown [perl/en] Fix line formatting and use $x instead of $a Apr 15, 2016 perl6.html.markdown Fixed instance where wrong variable name was used Mar 20, 2016 pets.csv Create pets.csv Jun 29, 2013 php-composer.html.markdown [php-composer/en] Add new tool document for Composer, PHP's dependenc… Oct 20, 2015 php.html.markdown Change curly braces statement (#1804) Jun 16, 2016 pogo.html.markdown Fixed typo at the end Dec 22, 2014 powershell.html.markdown [PowerShell/en]: fixed typos/layout. Added some extra aliases/info. Jan 8, 2016 purescript.html.markdown [purescript/en] comparisions -> comparisons Feb 27, 2016 python.html.markdown [python/en] Set, dict, and generator comprehensions (#2298) Jul 3, 2016 python3.html.markdown [python/en] Set, dict, and generator comprehensions (#2298) Jul 3, 2016 pythonstatcomp.html.markdown Update pythonstatcomp.html.markdown Mar 18, 2016 qt.html.markdown Added document about Qt framework (#1444) Jun 26, 2016 r.html.markdown fix spaces at end-of-lines again Oct 20, 2015 racket.html.markdown [racket/en] Add more details about Racket (#2278) Jun 26, 2016 red.html.markdown removing whitespace all over Oct 8, 2015 rst.html.markdown [en/RST] Add RST introduction (#1723) Jun 26, 2016 ruby-ecosystem.html.markdown Ruby 1.9.x is also retired Oct 6, 2015 ruby.html.markdown Elixir agents/maps, Ruby conventions/docs (#2116) Jul 12, 2016 rust.html.markdown Update rust.html.markdown Jun 26, 2016 sass.html.markdown [SASS] Add control directives, and misc. fixes (#1805) Jun 19, 2016 scala.html.markdown Add example of an int is divided by a double (#2284) Jun 21, 2016 self.html.markdown [self-en] separeated -> separated Feb 22, 2016 smalltalk.html.markdown Update smalltalk.html.markdown May 11, 2016 solidity.html.markdown Security additions + edits (#2281) Jun 20, 2016 standard-ml.html.markdown [racket/en] Add more details about Racket (#2278) Jun 26, 2016 swift.html.markdown Add documentation comment for If let Feb 19, 2016 tcl.html.markdown tcl: fix error in no-braces example (#2274) Jun 6, 2016 tmux.html.markdown Remove obsolete utf-8 options. (#2294) Jun 28, 2016 typescript.html.markdown Added typescript-pt.html.markdown (#1699) Jun 26, 2016 vim.html.markdown Added vim.html.markdown (#1744) Apr 28, 2016 visualbasic.html.markdown correction Nov 8, 2015 whip.html.markdown [whip/en] Fix typos Oct 31, 2015 wolfram.html.markdown Rename wolfram.md to wolfram.html.markdown Jan 1, 2016 xml.html.markdown [xml/en] Grammar, formatting. Made more 'inlined'. Oct 20, 2015 yaml.html.markdown [yaml/en] Add more resources (#1666) Apr 28, 2016 zfs.html.markdown Merge pull request #1644 from fliiiix/patch-1 Mar 11, 2016 README.markdown Learn X in Y minutes Whirlwind tours of (several, hopefully many someday) popular and ought-to-be-more-popular programming languages, presented as valid, commented code and explained as they go. We need YOU!... ... to write more inline code tutorials. Just grab an existing file from this repo and copy the formatting (don't worry, it's all very simple). Make a new file, send a pull request, and if it passes muster I'll get it up pronto. Remember to fill in the ""contributors"" fields so you get credited properly! Contributing All contributions are welcome, from the tiniest typo to a brand new article. Translations in all languages are welcome (or, for that matter, original articles in any language). Send a pull request or open an issue any time of day or night. Please prepend the tag [language/lang-code] to your issues and pull requests. For example, [python/en] for English Python. This will help everyone pick out things they care about. We're happy for any contribution in any form, but if you're making more than one major change (i.e. translations for two different languages) it would be super cool of you to make a separate pull request for each one so that someone can review them more effectively and/or individually. For a detailed style guide, please review the full CONTRIBUTING guidelines. License Contributors retain copyright to their work, and can request removal at any time. By uploading a doc here, you agree to publish your work under the default Creative Commons Attribution-ShareAlike 3.0 Unported licensing included on each doc page. Anything not covered by the above -- basically, this README -- you can use as you wish, I guess. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/adambard/learnxinyminutes-docs"	"Small Common Lisp tutorial covering the essentials."	"true"
"Beginner"	"Practical Common Lisp"	"http://www.gigamonkeys.com/book/"	"A good introductory text to Common Lisp, with practical examples."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Practical Common Lisp Practical Common Lisp that book is dead sexy —Xach on #lisp (more blurbs) This page, and the pages it links to, contain text of the Common Lisp book Practical Common Lisp published by Apress These pages now contain the final text as it appears in the book. If you find errors in these pages, please send email to book@gigamonkeys.com. These pages will remain online in perpetuity—I hope they will serve as a useful introduction to Common Lisp for folks who are curious about Lisp but maybe not yet curious enough to shell out big bucks for a dead-tree book and a good Common Lisp tutorial for folks who want to get down to real coding right away. However, don't let that stop you from buying the printed version available from Apress at your favorite local or online bookseller. For the complete bookstore browsing experience, you can read the letter to the reader that appears on the back cover of the treeware edition of the book. Coders at Work out! My new book, Coders at Work, a collection of Q&A interviews with fifteen all-time great programmers and computer scientists, is out and available from Amazon, Barnes & Noble, Powell's, other fine booksellers near you and as an eBook from Apress. Buy Practical Common Lisp now Amazon | Powells | Barnes & Noble Download source code: tar.gz | zip Spread the word Like what you've read? Then help spread the word. Recommend this book to your friends. Write a review on Amazon. Blog about it. Link to this page from your web site. Whatever. Apress took a chance, publishing this book when other publishers thought there was no market for a Lisp book. While it's unlikely that I'll get rich off my royalties, we don't have to sell all that many copies for Apress to turn a profit and show the naysayers that Lisp has legs yet. Introduction: Why Lisp? Lather, Rinse, Repeat: A Tour of the REPL Practical: A Simple Database Syntax and Semantics Functions Variables Macros: Standard Control Constructs Macros: Defining Your Own Practical: Building a Unit Test Framework Numbers, Characters, and Strings Collections They Called It LISP for a Reason: List Processing Beyond Lists: Other Uses for Cons Cells Files and File I/O Practical: A Portable Pathname Library Object Reorientation: Generic Functions Object Reorientation: Classes A Few FORMAT Recipes Beyond Exception Handling: Conditions and Restarts The Special Operators Programming in the Large: Packages and Symbols LOOP for Black Belts Practical: A Spam Filter Practical: Parsing Binary Files Practical: An ID3 Parser Practical: Web Programming with AllegroServe Practical: An MP3 Database Practical: A Shoutcast Server Practical: An MP3 Browser Practical: An HTML Generation Library, the Interpreter Practical: An HTML Generation Library, the Compiler Conclusion: What's Next? Copyright © 2003-2009, Peter Seibel"	"null"	"null"	"A good introductory text to Common Lisp, with practical examples."	"true"
"Beginner"	"Common LISP: A Gentle Introduction to Symbolic Computation"	"http://www.cs.cmu.edu/afs/cs.cmu.edu/user/dst/www/LispBook/index.html"	"A nice introduction into the language."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Common Lisp: A Gentle Introduction to Symbolic Computation Common Lisp: A Gentle Introduction to Symbolic Computation David S. Touretzky This book, with minor revisions, is back in print from Dover Publications and can be purchased in paperback form at Amazon.com, Barnes & Noble, etc. An e-book version will be released in late February, 2013. Free software accompanying the book is also available. This 1990 edition may be distributed in hardcopy form, for non-profit educational purposes, provided that no fee is charged to the recipient beyond photocopying costs. All other rights reserved. You may not redistribute the Postscript file, e.g., you may not put a copy on another web page, or include it on a CD-ROM. Entire book -- Postscript (1.75 MB file) Entire book -- PDF (1 MB file) Figures missing from the book (780K PDF) Free software accompanying this book is also available. Materials provided by David S. Touretzky, Carnegie Mellon University. Last modified: Mon Feb 4 17:29:07 EST 2013"	"null"	"null"	"A nice introduction into the language."	"true"
"Beginner"	"Learn LISP: Simply Easy Learning"	"http://www.tutorialspoint.com/lisp/index.htm"	"A good set of introductory tutorials; includes interactive examples."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"LISP Tutorial We are hiring Home Tutorials Library Coding Ground Tutor Connect Send18 Tools Search LISP Tutorial LISP - Home LISP - Overview LISP - Environment LISP - Program Structure LISP - Basic Syntax LISP - Data Types LISP - Macros LISP - Variables LISP - Constants LISP - Operators LISP - Decisions LISP - Loops LISP - Functions LISP - Predicates LISP - Numbers LISP - Characters LISP - Arrays LISP - Strings LISP - Sequences LISP - Lists LISP - Symbols LISP - Vectors LISP - Set LISP - Tree LISP - Hash Table LISP - Input & Output LISP - File I/O LISP - Structures LISP - Packages LISP - Error Handling LISP - CLOS LISP Useful Resources Lisp - Quick Guide Lisp - Useful Resources Lisp - Discussion Selected Reading Developer's Best Practices Questions and Answers Effective Resume Writing HR Interview Questions Computer Glossary Who is Who Previous Page Next Page   LISP Tutorial PDF Version Quick Guide Resources Job Search Discussion Lisp is the second-oldest high-level programming language after Fortran and has changed a great deal since its early days, and a number of dialects have existed over its history. Today, the most widely known general-purpose Lisp dialects are Common Lisp and Scheme. Lisp was invented by John McCarthy in 1958 while he was at the Massachusetts Institute of Technology (MIT). This reference will take you through simple and practical approach while learning LISP Programming language. Audience This reference has been prepared for the beginners to help them understand the basic to advanced concepts related to LISP Programming language. Prerequisites Before you start doing practice with various types of examples given in this reference, I'm making an assumption that you are already aware about what is a computer program and what is a computer programming language? Execute Lisp Online For most of the examples given in this tutorial you will find Try it option, so just make use of this option to execute your Lisp programs at the spot and enjoy your learning. Try following example using Try it option available at the top right corner of the below sample code box −  (write-line ""Hello World"")  Previous Page Print PDF Next Page   Advertisements Write for us FAQ's Helping Contact © Copyright 2016. All Rights Reserved. go"	"null"	"null"	"A good set of introductory tutorials; includes interactive examples."	"true"
"Beginner"	"Common Lisp Koans"	"https://github.com/google/lisp-koans"	"The project guides the learner progressively through many Common Lisp language features."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"1502"	"124"	"318"	"GitHub - google/lisp-koans: Common Lisp Koans is a language learning exercise in the same vein as the ruby koans, python koans and others.   It is a port of the prior koans with some modifications to highlight lisp-specific features.  Structured as ordered groups of broken unit tests, the project guides the learner progressively through many Common Lisp language features. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 124 Star 1,502 Fork 318 google/lisp-koans Code Issues 8 Pull requests 2 Wiki Pulse Graphs Common Lisp Koans is a language learning exercise in the same vein as the ruby koans, python koans and others. It is a port of the prior koans with some modifications to highlight lisp-specific features. Structured as ordered groups of broken unit tests, the project guides the learner progressively through many Common Lisp language features. 105 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit 971d9d0 May 16, 2016 bileschi Merge pull request #69 from matthewschallenkamp/master … Fix Issue #47 Permalink Failed to load latest commit information. koans Fix Issue #47 May 16, 2016 .gitignore first commit. May 24, 2013 .koans Moves :format lesson later in the curriculum. Feb 28, 2016 LICENSE first commit. May 24, 2013 README.md readme matches softer error message Jun 6, 2013 TODO update todo to add item about error reporting Jun 6, 2013 contemplate.lsp Merge pull request #58 from astronaut-wannabe/add-color-to-output Feb 28, 2016 lisp-unit.lsp dealing with unused variable warnings Jun 5, 2013 unused-test-ideas.lsp first commit. May 24, 2013 README.md Getting Started From a terminal, execute your lisp interpreter on the file 'contemplate.lsp' e.g. sbcl --script contemplate.lsp  Running on a fresh version should output the following: Thinking about ASSERTS     ASSERT-TRUE requires more meditation.  You have not yet reached enlightenment ...   A koan is incomplete.  Please meditate on the following code:    File ""koans/asserts.lsp""    Koan ""ASSERT-TRUE""    Current koan assert status is ""(INCOMPLETE)""  You are now 0/169 koans and 0/25 lessons closer to reaching enlightenment  This indicates that the script has completed, and that the learner should look to asserts.lsp to locate and fix the problem. The problem will be within a define-test expression such as (define-test assert-true     ""t is true.  Replace the blank with a t""     (assert-true ___))  In this case, the test is incomplete, and the student should fill in the blank (____) with appropriate lisp code to make the assert pass. In order to test code, or evaluate tests interactively, students may copy and paste code into the lisp command line REPL. Quoting the Ruby Koans instructions:: ""In test-driven development the mantra has always been, red, green, refactor. Write a failing test and run it (red), make the test pass (green), then refactor it (that is look at the code and see if you can make it any better). In this case you will need to run the koan and see it fail (red), make the test pass (green), then take a moment and reflect upon the test to see what it is teaching you and improve the code to better communicate its intent (refactor)."" Content The Common Lisp koans are based on the python koans and ruby koans projects. Additionally, many of the tests are based on new material that is special to Common Lisp. Note that the unit on threads uses an SBCL specific threading API. A reader macro will remove this unit on Lisp implementations other than SBCL. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/google/lisp-koans"	"The project guides the learner progressively through many Common Lisp language features."	"true"
"Intermediate"	"Common Lisp tips"	"http://lisptips.com/"	"A blog with useful tips and tricks."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Common Lisp Tips Home Submit a tip Mobile RSS Common Lisp Tips Text Making a directory from a pathname Sometimes I want to create a directory pathname relative to some existing file pathname. For example, when I want to refer to files that are in the same directory as the currently loading file, I might work relative to *load-truename*. I used to do it like this: (make-pathname :directory (pathname-directory *load-truename*))  This worked fine for me, but after getting bug reports from Windows users, I’ve changed it to this: (make-pathname :defaults *load-truename*                :type nil                :name nil                :version nil)  That way all the properties of *load-truename* are carried over, except the name and type. edit Added :version nil per Fare’s comment. Tags: lisp November 14, 2015 0 comments 2 notes Text When a synonym-stream is useful Imagine your project has a special variable whose value is a stream to which some output is directed, e.g. my-project:*log-output*. You can change where the output goes by setting the value of the special variable, but by default, output should go to *standard-output*. The naive way to do this is a direct reference: (defvar *log-output* *standard-output*)  However, this can run into trouble if *standard-output* is bound to something unexpected when that form is evaluated. For example, if file loading output is temporarily suppressed by binding *standard-output* to (make-broadcast-stream), output to *log-output* is then also discarded. One way to work around it is with make-synonym-stream: (defvar *log-output* (make-synonym-stream '*standard-output*))  With that setup, any output sent to *log-output* is sent to the stream that is the dynamic value of the symbol '*standard-output*. And since the dynamic value is looked up for each output, the output to *log-output* will go to *standard-output* even if *standard-output* is assigned some other stream value later on. Tags: lisp August 24, 2015 0 comments 3 notes Text Declining to handle a condition Occasionally it is convenient for a handler to decide whether to deal with a condition after it already has control. Sometimes I see that idiom written with a `handler-case` that resignals the condition if it decides it can’t take care of it. The downside of that approach is that `handler-case` only resignals the condition after unwinding the stack and removing any restarts that were in place. `handler-bind` avoids those downsides. When a `handler-bind` handler does not transfer control it is said to “decline to handle” the condition. The condition will then percolate up to surrounding handlers or the debugger with the stack and restarts still in tact, as if the handler had never been entered. (defun baz ()   (handler-bind ((error (lambda (c)                           (when (i-got-this-p c)                             (return-from baz (quux))))))     (foo)))  August 21, 2014 0 comments 2 notes Text Adding an item to a sorted list Here’s a quick way to add an item to a sorted list: (merge 'list (list item) sorted-list test) Via Bernhard Pfahringer on comp.lang.lisp, 1998. June 26, 2013 0 comments 1 note Text The usefullness of EQUALP Among the 4 Lisp’s equality operators equalp may be the least used, but it has some really cool features: it matches strings ignoring case (this is well-known, I suppose) it also matches structs it also matches vectors and arrays and it matches hash-tables The last 3 are really useful, because unlike strings and other primitive types, there’s no specialized equality predicates for built-in structural types, so equalp fills this role. (contributed by @vseloved) June 17, 2013 0 comments 1 note Text Formatting integers in different radixes format has four directives for formatting integers with different radixes: ~B formats as binary: (format nil ""~B"" 42) => ""101010"" ~O formats as octal: (format nil ""~O"" 42) => ""52"" ~X formats as hexadecimal: (format nil ""~X"" 666) => ""29A"" ~R formats with an arbitrary radix between 2 and 36: (format nil ""~36R"" 18321) => ""E4X"" Each directive takes padding and pad-character options (as well as other options). I define these functions in my init files to quickly dump out hex and bit views of integers: (defun :hex (value &optional (size 4))   (format t ""~v,'0X"" size value))  (defun :bits (value &optional (size 8))   (format t ""~v,'0B"" size value))    * (:bits 42) 00101010  * (:hex 666) 029A  The lower-level write function accepts a :base argument that specifies a radix to use when printing integers. The default value is taken from *print-base*. For example, (write-to-string 65535 :base 16) => ""FFFF"". Since write underlies how other standard functions produce output, binding *print-base* will affect pretty much everything. March 03, 2013 0 comments 3 notes Text Literal syntax for integers There are several ways to write literal integers with different radixes in Common Lisp. #b… is for binary, #o… is for octal, #x… is for hexadecimal, and #r is for an arbitrary radix from 2 to 36. Section 2.4.8.10 has this example: #2r11010101  ;Another way of writing 213 decimal   #b11010101   ;Ditto                                #b+11010101  ;Ditto                                #o325        ;Ditto, in octal radix                #xD5         ;Ditto, in hexadecimal radix          #16r+D5      ;Ditto                                #o-300       ;Decimal -192, written in base 8      #3r-21010    ;Same thing in base 3                 #25R-7H      ;Same thing in base 25                #xACCEDED    ;181202413, in hexadecimal radix   March 02, 2013 0 comments 1 note Text How do I convert an integer to a list of bits? Novices sometimes ask how to get a convert an integer to a list of bits, often for the purpose of iterating over the bits somehow. Common Lisp has a rich set of functions for directly accessing the bits of an integer, so constructing an intermediate list of bits is rarely necessary. Here are a few examples of accessing the bits of an integer. With integer-length and logbitp to test the bit at a particular index: (defun list-of-bits (integer)   (loop for index below (integer-length integer)         collect (if (logbitp index integer) 1 0)))  With ash to shift the integer to the right and logand to test the least-significant bit: (defun list-of-bits (integer)   (loop repeat (integer-length integer)         for i = integer then (ash i -1)         collect (logand i 1)))  With ash to shift a one-bit mask to the left and logtest to test the mask bit against the integer: (defun list-of-bits (integer)   (loop repeat (integer-length integer)         for mask = 1 then (ash mask 1)         collect (if (logtest mask integer) 1 0)))  With byte to construct a byte specifier and ldb to extract a field from the integer: (defun list-of-bits (integer)   (loop for position below (integer-length integer)         collect (ldb (byte 1 position) integer)))  update Unfortunately, all these examples are buggy - they collect bits in the wrong order. I used loop/collect to avoid having to reverse the results, but didn’t think it through properly. Here are some updated definitions with dotimes that give the results in the intended order: (defun list-of-bits (integer)   (let ((bits '()))     (dotimes (index (integer-length integer) bits)       (push (if (logbitp index integer) 1 0) bits))))  (defun list-of-bits (integer)   (let ((i integer)         (bits '()))     (dotimes (j (integer-length integer) bits)       (push (logand i 1) bits)       (setf i (ash i -1)))))  (defun list-of-bits (integer)   (let ((mask 1)         (bits '()))     (dotimes (i (integer-length integer) bits)       (push (if (logtest mask integer) 1 0) bits)       (setf mask (ash mask 1)))))  (defun list-of-bits (integer)   (let ((bits '()))     (dotimes (position (integer-length integer) bits)       (push (ldb (byte 1 position) integer) bits))))  February 28, 2013 0 comments 1 note Text The optional arguments of deftype deftype can be used to create user-defined types that expand into built-in types. For example: (deftype octet-vector (length)   `(simple-array (unsigned-byte 8) (,length)))  Given this deftype, in a type context, (octet-vector 32) expands into (simple-array (unsigned-byte 8) (32)), or a one-dimensional octet array of length 32. Lambda lists for deftype are very similar to lambda lists for defmacro, with an important difference: where optional arguments to defmacro with no initialization form default to nil, the default value in deftype is the symbol *. The deftype above could be rewritten to take advantage of this: (deftype octet-vector (&optional length)   `(simple-array (unsigned-byte 8) (,length)))  Now, in a type context, a plain octet-vector expands into (simple-array (unsigned-byte 8) (*)), or a one-dimensional octet array of indeterminate length, and (octet-vector 32) expands into (simple-array (unsigned-byte 8) (32)). For more information, see section 3.4.8, Deftype Lambda Lists. February 27, 2013 0 comments Text Trying again with with-simple-restart I have some code that reads data from a config file. If there’s a problem loading, I’d like the opportunity to fix it, outside of Lisp, and retry loading. It’s easy to do that with with-simple-restart and loop: (loop    (with-simple-restart (try-again ""Try again"")     (return       (progn         (setf *config* (load-config-file))))  If any error occurs during load-config-file, I can either fix up the file and choose the try-again restart, or give up and use an abort restart. (Thanks to Frode Vatvedt Fjeld for the concise idiom.) February 26, 2013 0 comments 1 note Archive Random Next Page Page 1 of 6 About Common Lisp tips, by Zach Beane. Got a tip to share? Email it to lisptips@xach.com. © Common Lisp Tips. All Rights Reserved. Powered by Tumblr. Lightweight Theme by Artur Kim"	"null"	"null"	"A blog with useful tips and tricks."	"true"
"Intermediate"	"CommonQt tutorial"	"https://cheryllium.wordpress.com/2014/02/22/commonqt-tutorial-1/"	"A nice introduction to CommonQt."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"CommonQt Tutorial #1: Hello World – cheryllium ShowShow Skip to content cheryllium the secret ingredient CommonQt Tutorial #1: Hello World February 22, 2014March 4, 2014 Posted in Lisp. This tutorial will walk you through the very basics of getting a Window to show up (and start customizing it) with CommonQt. If you need to, you can install CommonQt easily here. This tutorial assumes a basic familiarity with programming in Lisp. In this tutorial, we’ll make a very simple application: a blank window with the title “Hello World!” We will write these into a Lisp file that you can name whatever you want. Mine is called helloworld.lisp. Our strategy will be to create a class called hello-world-app that subclasses QWidget, set some properties of this class, and then run it. 1. Load CommonQt The first thing to do in this file is load CommonQt with Quicklisp. Then, set the current package and readtable to Qt. (One thing this allows us to do is reference things in Qt without prefacing them with “qt::”.) (ql:quickload :qt) (in-package :qt)  (named-readtables:in-readtable :qt) 2. Subclass QWidget Now, let’s create a subclass of QWidget with a descriptive name: hello-world-app. You must include the line about the metaclass. In the case of qt-superclass, only include this when you’re subclassing a class that doesn’t already have it. So, for instance, if we were to subclass hello-world-app with something, that class would not have to specify a qt-superclass. Here’s what our class definition looks like so far: (defclass hello-world-app () ()    (:metaclass qt-class)   (:qt-superclass ""QWidget"")) The next step is writing the constructor for the class. Make sure you always call the C++ constructor using “(new instance)” as seen below: (defmethod initialize-instance :after    ((instance hello-world-app) &key)      (new instance)) 3. Two useful methods: setGeometry and setWindowTitle At this point, we have defined a nice subclass of QWidget. However, it doesn’t do anything. Let’s add two method calls to initialize-instance to customize this window a bit. In CommonQt, you can call instance methods by adding “#_” to the method name, which you will see below. setGeometry(x, y, width, height) The setGeometry method does two things at once: It positions the window on the screen, and sets its size. It takes four integer arguments. The first two arguments are the coordinates (x,y) of the top left corner of the window on your computer screen. The second two arguments specify the width and height of your window, in that order. Let’s say we want our app to spawn at (200,200) on our screen, and have a size of 300×300. We can add a setGeometry call to our constructor like this to do that: (defmethod initialize-instance :after ((instance hello-world-app) &key)   (new instance)    (#_setGeometry instance 200 200 300 300)) Make sure you pass “instance” to setGeometry (this represents the current instance that’s being initialized). setWindowTitle(string) The method setWindowTitle is not so complicated: You simply give it a string, and it will set that as the title of your window. We can set our window’s title to “Hello World” by adding a setWindowTitle call like so: (defmethod initialize-instance :after ((instance hello-world-app) &key)   (new instance)    (#_setGeometry instance 200 200 300 300)   (#_setWindowTitle instance ""Hello World!"")) Now, we’ve finished making and customizing our hello-world-app. All we need to do now is run it… 4. Finally: The main application loop! The last step is to make a QApplication, instantiate hello-world-app, and run the loop! To do this, we first call make-qapplication to create our application. This can only be called once. (make-qapplication) Now, we will create a new instance of hello-world-app called window, and use a nice macro called with-main-window to display it and execute the app: (with-main-window (window (make-instance 'hello-world-app))) with-main-window contains a call to (#_show window) and (#_exec *qapplication*) – that is, it shows your window instance, and then starts your main application loop. Now, you should be able to open up your REPL, type (load ""helloworld.lisp"") and see a nice blank window with the title “Hello World!” What a cute little baby GUI we have here. I think it’s saying hi to the world! Of course, this isn’t THAT exciting. But you now know how to set up a basic application. In the next tutorial, we add some GUI elements to our window, and even start playing with Qt’s signals and slots. The full source code for this tutorial can be found here. If you’re having trouble getting your program to run, you can compare it with this source to see what might be going wrong. Check out Tutorial #2: Hello Name here! Share this: Twitter Facebook Google Like this: Like Loading... common lispcommonqthelloworldtutorial Post navigation Previous: Previous post: CommonQt Installer for Windows Next: Next post: CommonQt Tutorial #2: Hello Name Leave a Reply Cancel reply Enter your comment here... Fill in your details below or click an icon to log in: Email (required) (Address never made public) Name (required) Website You are commenting using your WordPress.com account. ( Log Out / Change ) You are commenting using your Twitter account. ( Log Out / Change ) You are commenting using your Facebook account. ( Log Out / Change ) You are commenting using your Google+ account. ( Log Out / Change ) Cancel Connecting to %s Notify me of new comments via email. Notify me of new posts via email. Search for: Recent Posts CommonQt Tutorial #4: Menu and Status Bars CommonQt Tutorial #3: Intro to Layouts CommonQt Tutorial #2: Hello Name CommonQt Tutorial #1: Hello World CommonQt Installer for Windows Recent Comments Michael on CommonQt Installer for Wi… Archives April 2014 March 2014 February 2014 Categories Lisp Meta Register Log in Entries RSS Comments RSS WordPress.com Blog at WordPress.com. | The Sapor Theme. | cheryllium Follow Follow “cheryllium” Get every new post delivered to your Inbox. Build a website with WordPress.com %d bloggers like this:"	"null"	"https://github.com/cheryllium/9359706"	"A nice introduction to CommonQt."	"true"
"Intermediate"	"A tutorial for creating and publishing open-source Common Lisp software"	"http://arxiv.org/abs/1209.5626"	"A handy tutorial for using Quicklisp and a bunch of other tools to create and publish a project in Common Lisp."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"[1209.5626] A Tutorial for Creating and Publishing Open Source Lisp Software <p><img src=""//webanalytics.library.cornell.edu/piwik.php?idsite=538"" style=""border:0;"" alt=""""> Cornell University Library We gratefully acknowledge support from the Simons Foundation and member institutions arXiv.org > cs > arXiv:1209.5626 Search or Article-id (Help | Advanced search)   All papers Titles Authors Abstracts Full text Help pages Full-text links: Download: PDF PostScript Other formats (license) Current browse context: cs.OH < prev | next > new | recent | 1209 Change to browse by: cs References & Citations NASA ADS DBLP - CS Bibliography listing | bibtex Robert Smith Bookmark (what is this?) Computer Science > Other Computer Science Title: A Tutorial for Creating and Publishing Open Source Lisp Software Authors: Robert Smith (Submitted on 25 Sep 2012) Abstract: The proliferation and accessability of the Internet have made it simple to view, download, and publish source code. This paper gives a short tutorial on how to create a new Common Lisp project and publish it. Comments: Accepted for the International Lisp Conference 2012 Subjects: Other Computer Science (cs.OH) ACM classes: A.m; D.2.6; D.2.7; D.2.13 Cite as: arXiv:1209.5626 [cs.OH]   (or arXiv:1209.5626v1 [cs.OH] for this version) Submission history From: Robert Smith [view email] [v1] Tue, 25 Sep 2012 14:41:47 GMT (23kb,S) Which authors of this paper are endorsers? | Disable MathJax (What is MathJax?) Link back to: arXiv, form interface, contact."	"null"	"null"	"A handy tutorial for using Quicklisp and a bunch of other tools to create and publish a project in Common Lisp."	"true"
"Advanced"	"Let Over Lambda"	"http://letoverlambda.com/"	"A book on advanced macro techniques. All eight chapters are available in the print copy."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Let Over Lambda Let Over Lambda—50 Years of Lisp by Doug Hoyte About the Book Table of Contents Text Mode Reviews Buy It Errata Clarifications Production Code Original Code References About the Book Let Over Lambda (ISBN 978-1-4357-1275-1, 376+iv pp.) is one of the most hardcore computer programming books out there. Starting with the fundamentals, it describes the most advanced features of the most advanced language: COMMON LISP. The point of this book is to expose you to ideas that you might otherwise never be exposed to. This book is about macros, that is programs that write programs. Macros are what make lisp the greatest programming language in the world. When used properly, macros enable amazing feats of abstraction, programmer productivity, and code efficiency and security that are unheard of elsewhere. Macros let you do things you simply cannot do in other languages. If you are looking for a dry coding manual that re-hashes common-sense techniques in whatever langue du jour, this book is not for you. This book is about pushing the boundaries of what we know about programming. While this book teaches useful macro skills that can help solve your programming problems today and now, it has also been designed to be entertaining and inspiring. If you have ever wondered what lisp or even programming itself is really about, this is the book you have been looking for. News Chapter 6 is now open. It takes a detour through anaphoric macros and culminates in what I think is a very interesting macro: pandoric-eval. Official Japanese translation available at JUNKUDO or GEO-Online or any other fine Japanese book store. Chapter 5 now open. This is one of my favourite chapters. Enjoy. Added a clarifications page to better explain the Let Over Lambda message. Matthew Lamari wrote a review on Amazon and gave the book 5/5 stars. Chapter 4 has been opened. Read about it in Press Release #2. Adam Petersen wrote a review. Press Release #1 is available. It contains summaries of all the chapters. Let Over Lambda has an ISBN: 978-1-4357-1275-1 References are available in a lispy format. The back cover is confirmed. Thanks Leo! λ All material is (C) Doug Hoyte unless otherwise noted or implied. All rights reserved."	"null"	"null"	"A book on advanced macro techniques. All eight chapters are available in the print copy."	"true"
"Advanced"	"On Lisp"	"http://www.paulgraham.com/onlisp.html"	"Paul Graham's amazing book on Lisp macros (and other interesting things)."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"On Lisp On Lisp is a comprehensive study of advanced Lisp techniques, with bottom-up programming as the unifying theme. It gives the first complete description of macros and macro applications. The book also covers important subjects related to bottom-up programming, including functional programming, rapid prototyping, interactive development, and embedded languages. The final chapter takes a deeper look at object-oriented programming than previous Lisp books, showing the step-by-step construction of a working model of the Common Lisp Object System (CLOS). As well as an indispensable reference, On Lisp is a source of software. Its examples form a library of functions and macros that readers will be able to use in their own Lisp programs. Prentice Hall, 1993, 432 pages, paperback. ISBN 0130305529. New: Download it for free. ""The first book that really explains what Lisp is all about."" - John Foderaro, Franz Inc. ""On Lisp draws the reader in from the very first sentence. The author's writing style is clear and articulate, but comfortably informal. The subject matter is important, and has not been adequately treated in previous books. The chapters on macros present important material that is virtually unique to this book. The chapter on object-oriented programming is excellent. The author builds a nice mini-CLOS to teach basic object-oriented techniques, but then wisely switches to real CLOS to cover the more advanced topics."" - David Touretzky, Carnegie-Mellon University ""An excellent description of the real essence of Lisp."" - Thomas Cheatham, Harvard University ""As with his other book, ANSI Common Lisp, Graham writes in a fluid style that is a pleasure to read."" - Amazon.Com ""The topics On Lisp covers are extremely useful for any seriously aspiring Lisp programmer. I think it's a great idea to collect in one place programming techniques normally attainable only the hard way. The examples, which are plentiful and excellent, are one of the significant strengths of the book."" - Skona Brittain, Developer of NanoLisp Download Amazon Code Errata Call for Bugs"	"null"	"null"	"Paul Graham's amazing book on Lisp macros (and other interesting things)."	"true"
"Beginner"	"Land of Lisp"	"http://landoflisp.com/"	"A fun, game-oriented introduction to Common Lisp."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Email Conrad Barski, The Author | Sample Chapter | Source Code | Errata | Forum | Lisperati.com Latest News 11/3/10: Slashdot.com book reviews gives it a 10 out of 10 rating! ""Turns out the border between genius and insanity is a pretty cheery place"" says Paul Graham! Land of Lisp is now fully in stock and also available for download in eBook form. It should be in stock at Amazon this Friday. Download the song: MP3 OGG So, you still don't think it's worth learning Lisp? Well, you'll have to make your own decisions on how to make the best use of your valuable free time. However, Lisp really does contain some great programming ideas that you may never encounter anywhere else. In the interactive comic below (adapted from the epilogue of the book) I've given my best shot at explaining, precisely, what the most interesting features in Lisp are that you'd be missing out on... So why don't you give it a quick read? Oh, and be sure to click on all the throbbing text!"	"null"	"null"	"A fun, game-oriented introduction to Common Lisp."	"true"
"Intermediate"	"ANSI Common Lisp"	"http://www.paulgraham.com/acl.html"	"A thorough, practical covering of the entire language, with exercises. Not recommended as a starter text, due to."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"ANSI Common Lisp ANSI Common Lisp combines an introduction to Lisp programming, and a convenient, up-to-date reference manual for ANSI Common Lisp. Beginners will find that its careful explanations and interesting examples make Lisp programming easy to learn. Professional programmers will appreciate its thorough, practical approach. Prentice Hall, 1995, 432 pages, paperback. ISBN 0133708756. Buy at SoftPro (friends of mine and very reliable) or Amazon. An up-to-date reference manual for ANSI Common Lisp. An in-depth look at object-oriented programming. Explains the Common Lisp Object System (CLOS), and also shows how to write your own object-oriented language. Over 20 substantial examples, including programs for ray-tracing, text generation, pattern-matching, logical inference, generating HTML, sorting and searching, file I/O, compression, and date arithmetic. Special attention to critical concepts, including prefix syntax, code vs. data, recursion, functional programming, types, implicit pointers, dynamic allocation, closures, macros, class precedence, and generic functions vs. message-passing. A complete guide to optimization. The clearest and most thorough explanation of macros in any introductory book. Examples that illustrate Lisp programming styles, including rapid prototyping, bottom-up programming, object-oriented programming, and embedded languages. An appendix on debugging, with examples of common errors. ""A straightforward and well-written tutorial and reference to elementary and intermediate ANSI Common Lisp. It's more than just an introductory book-- because of its extensive reference section, it may be, for most readers, a useful alternative to Steele."" - Richard Fateman, University of California at Berkeley ""This book would be ideal for a classroom text. It is the only book up-to-date with respect to the ANSI standard."" - John Foderaro, Franz Inc. ""Paul Graham has done it again. His first book, On Lisp, provided an excellent description of some of the advanced features of Lisp while the present one provides a completely thorough introduction to the language, including such topics as tuning a program for speed."" - Thomas Cheatham, Harvard University ""The final chapter is brilliant. It simultaneously explains some of the key ideas behind object-oriented programming and takes the reader through several versions of an object-oriented system, each more sophisticated than the previous."" - David Touretzky, Carnegie-Mellon University ""Graham's well-known text On Lisp set a new standard for books on advanced Lisp programming. With ANSI Common Lisp he has provided the ideal introductory text--a compact tutorial and a complete reference on the latest standard. This book would be excellent either for a standalone Lisp or functional programming course or for courses on AI, compilers, or object-oriented programming that use Lisp. I will certainly be using it in my courses, and my students will be happy that they no longer have to buy both a Lisp text and Steele's reference. I would also recommend it highly to programmers wishing to move into the Lisp language. The style is intelligent and lively, the examples are interesting and well-chosen, and the standard of explanation is impeccable."" - Stuart Russell, University of California at Berkeley ""The book's clear and engaging format explains complicated constructs simply. This format makes ANSI Common Lisp accessible to a general audience--even those who have never programmed before."" - Amazon.Com Chapter 1 Chapter 2 Amazon Code Errata Japanese Translation Chapter 1, Chinese Translation Chapter 2, Chinese Translation"	"null"	"null"	"A thorough, practical covering of the entire language, with exercises. Not recommended as a starter text, due to."	"true"
"Intermediate"	"some caveats"	"http://www.cs.northwestern.edu/academics/courses/325/readings/graham/graham-notes.html"	"A thorough, practical covering of the entire language, with exercises. Not recommended as a starter text, due to."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Graham Crackers Annotations on Graham's ANSI Common Lisp General Comments Graham has an excellent Lisp coding style. His code is maintainable and portable. Function definitions are short and well-motivated, and, for the most part, variable and function names are clear and helpful. Exceptions are noted below. However, there are a few areas where Graham's coding style should not be considered typical: Strong preference for if rather than cond, even when using if leads to nested if's or embedded progn's. Strong distaste for loop, because it is so complex and different from the functional programming style. Sometimes, however, loop is the clearest simplest way to write something. Preference for recursion over iteration, even if it might lead to code that causes stack overflows on very long lists. Here are more detailed comments on particular chapters: Chapter 2 Chapter 3 Chapter 4 Chapter 6 Chapter 7 Chapter 8 Chapter 9 A data-driven ray tracer An object-oriented ray tracer Chapter 10 Chapter 11 Chapter 15 Chapter 16 Appendix A Appendix D Comments? Send mail to Chris Riesbeck."	"null"	"null"	"A thorough, practical covering of the entire language, with exercises. Not recommended as a starter text, due to."	"true"
"Advanced"	"Object-Oriented Programming in Common Lisp: A Programmer's Guide to CLOS"	"http://www.goodreads.com/book/show/1175730.Object_Oriented_Programming_in_Common_LISP"	"An old, but very thorough book on CLOS."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Object-Oriented Programming in Common LISP: A Programmer's Guide to Clos by Sonya E. Keene — Reviews, Discussion, Bookclubs, Lists  Home My Books Browse ▾ Recommendations Choice Awards Giveaways New Releases Lists News & Interviews Explore Genres Art Biography Business Chick Lit Children's Christian Classics Comics Contemporary Cookbooks Crime Ebooks Fantasy Fiction Gay and Lesbian Graphic Novels Historical Fiction History Horror Humor and Comedy Manga Memoir Music Mystery Nonfiction Paranormal Philosophy Poetry Psychology Religion Romance Science Science Fiction Self Help Suspense Spirituality Sports Thriller Travel Young Adult Community ▾ Groups Quotes Ask the Author Trivia Quizzes Creative Writing People Events Sign In Join Goodreads helps you keep track of books you want to read. Start by marking “Object-Oriented Programming in Common LISP: A Programmer's Guide to Clos” as Want to Read: Want to Read saving… Want to Read Currently Reading Read Other editions Enlarge cover Want to Read saving… Error rating book. Refresh and try again. Rate this book Clear rating 1 of 5 stars2 of 5 stars3 of 5 stars4 of 5 stars5 of 5 stars Open Preview See a Problem? We’d love your help. Let us know what’s wrong with this preview of Object-Oriented Programming in Common LISP by Sonya E. Keene. Problem: It’s the wrong book It’s the wrong edition Other Details (if other):   Cancel Thanks for telling us about the problem. Return to Book Page Not the book you’re looking for? Preview — Object-Oriented Programming in Common LISP by Sonya E. Keene <iframe id=""wrongBookKindlePreviewScreen""> Object-Oriented Programming in Common LISP: A Programmer's Guide to Clos by Sonya E. Keene Object-Oriented Programming in Common LISP: A Programmer's Guide to Clos 4.03  ·  Rating Details  ·  38 Ratings  ·  3 Reviews PROGRAMMERS GUIDE Paperback, 288 pages Published January 11th 1989 by Addison-Wesley Professional More Details... Original Title Object-Oriented Programming in Common Lisp: A Programmer's Guide to CLOS ISBN 0201175894 (ISBN13: 9780201175899) Edition Language English Other Editions None found All Editions | Add a New Edition | Combine ...Less Detail edit details Get a copy: Kindle eBook Online Stores ▾ Amazon Audible Barnes & Noble Kobo Apple iBooks Google Play Abebooks Book Depository Indigo Half.com Alibris Better World Books IndieBound Libraries Or buy for Friend Reviews To see what your friends thought of this book, please sign up. Reader Q&A To ask other readers questions about Object-Oriented Programming in Common LISP, please sign up. Be the first to ask a question about Object-Oriented Programming in Common LISP Lists with This Book This book is not yet featured on Listopia. Add this book to your favorite list » Community Reviews (showing 1-30 of 111) filter  |  sort: default (?)  |  Rating Details Nov 05, 2008 Ehsan Shams rated it it was amazing I was frustrated and looking for a book on CLOS that didn't have incomprehensible brevities and this book was excellent. It has a very modest tone of writing and avoids confusing the user. There are other less thorough and more expert-tuned intros to CLOS, but this one is for the absolute idiot like me who needs some decent intro to CLOS. I absolutely recommend it. flag 1 like · Like · see review Aug 14, 2015 John rated it really liked it Assuming you already know Lisp this is a clear exposition of CLOS and how OO should have been implemented. Alas, the brain-dead single-dispatch Simula version took over the world. Sic Trasnit Gloria Mundi. flag Like · see review May 03, 2010 Michael rated it really liked it Shelves: computing, research, 2010_read, favorite-computing-books probably the best CLOS book I've ever read. flag Like · see review Morton Fox added it Jun 06, 2016 Npas4 added it Apr 23, 2016 Charles Bennett marked it as to-read Apr 17, 2016 Red added it Apr 09, 2016 Yegor Bugayenko rated it it was amazing Mar 23, 2016 Thiago Silva rated it really liked it Mar 01, 2016 Sawan marked it as to-read Feb 25, 2016 Matthew added it Feb 12, 2016 Terje Didriksen rated it it was amazing Jan 26, 2016 Juanito Fatas marked it as to-read Jan 08, 2016 Roman Kashitsyn added it Jan 04, 2016 Phillip rated it really liked it Dec 08, 2015 Alessandro added it Dec 07, 2015 Dominic Humphries marked it as to-read Dec 02, 2015 Gabriel rated it it was amazing Nov 29, 2015 Kaung marked it as to-read Nov 11, 2015 Li Jia Li marked it as to-read Oct 12, 2015 Calvin Lai marked it as to-read Sep 19, 2015 H Durer rated it really liked it Aug 27, 2015 Dave Lambert rated it it was ok Aug 23, 2015 B rated it liked it Aug 23, 2015 Daniel Lowe rated it really liked it Jul 01, 2015 Lucas Teixeira marked it as to-read Jun 15, 2015 Aohori marked it as to-read Jun 03, 2015 Ezekiel Smithburg marked it as to-read May 26, 2015 Prabu_venkat added it May 21, 2015 Ye mon Kyaw rated it it was amazing Nov 14, 2015 « previous 1 2 3 4 next » new topicDiscuss This Book There are no discussion topics on this book yet. Be the first to start one » Recommend It  |  Stats  |  Recent Status Updates Goodreads is hiring! If you like books and love to build cool products, we may be looking for you. Learn more » Genres Computer Science > Programming 7 users Science > Technology 2 users Science > Computer Science 2 users See top shelves… Books by Sonya E. Keene More… Share This Book Tweet Share on your website title link preview: Object-Oriented Programming in Common LISP: A Programmer's Guide to Clos avg rating preview: Object-Oriented Programming in Common LISP: A Programmer's Guide to Clos Goodreads rating: 4.03 (38 ratings) small image preview: click here [close] med image preview: click here [close] BBCode [url=http://www.goodreads.com/book/show/1175730.Object_Oriented_Programming_in_Common_LISP?utm_medium=api&utm_source=blog_book][img]http://d.gr-assets.com/books/1348422430l/1175730.jpg[/img][/url]       [url=http://www.goodreads.com/book/show/1175730.Object_Oriented_Programming_in_Common_LISP?utm_medium=api&utm_source=blog_book]Object-Oriented Programming in Common LISP: A Programmer's Guide to Clos by Sonya E. Keene[/url] + Share on your website Trivia About Object-Oriented P... No trivia or quizzes yet. Add some now » © 2016 Goodreads Inc about us advertise author program jobs api our blog authors & advertisers blog terms privacy help switch to: mobile version Welcome back. Just a moment while we sign you in to your Goodreads account."	"null"	"null"	"An old, but very thorough book on CLOS."	"true"
"Advanced"	"Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp"	"http://norvig.com/paip.html"	"A book on programming AI that covers some advanced Lisp."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Paradigms of Artificial Intelligence Programming Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp by Peter Norvig A book published by Morgan Kaufmann, 1992. Paperbound, xxviii + 946 pages, ISBN 1-55860-191-0. As seen on TV!   Rated at Amazon. Source code from the book. The book is rated #1 in certain circles. Excerpts from the preface, including why Lisp? A retrospective on what the author and the readers may have gotten from the book. Comments by readers and reviewers. Order the book from Morgan Kaufmann or Amazon.com. Errata: corrections for bugs and typos. A larger version of the cover image (500KB). Sample courses that use the book. Another AI text by Norvig. Contents I: Introduction to Common Lisp 1. Introduction to Lisp 2. A Simple Lisp Program 3. Overview of Lisp II: Early AI Programs 4. GPS: The General Problem Solver 5. ELIZA: Dialog with a Machine 6. Building Software Tools 7. STUDENT: Solving Algebra Word Problems 8. Symbolic Mathematics: A Simplification Program III: Tools and Techniques 9. Efficiency Issues 10. Low Level Efficiency Issues 11. Logic Programming 12. Compiling Logic Programs 13. Object-Oriented Programming 14. Knowledge Representation and Reasoning IV: Advanced AI Programs 15. Symbolic Mathematics with Canonical Form 16. Expert Systems 17. Line-Diagram Labeling by Constraint Satisfaction 18. Search and the Game of Othello 19. Introduction to Natural Language 20. Unification Grammars 21. A Grammar of English V: The Rest of Lisp 22. Scheme: An Uncommon Lisp 23. Compiling Lisp 24. ANSI Common Lisp 25. Troubleshooting Peter Norvig"	"null"	"null"	"A book on programming AI that covers some advanced Lisp."	"true"
"Library Manager"	"qlot"	"https://github.com/fukamachi/qlot"	"A project-local library installer, similar to Bundler or Carton.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"72"	"17"	"8"	"GitHub - fukamachi/qlot: A project-local library installer for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 17 Star 72 Fork 8 fukamachi/qlot Code Issues 2 Pull requests 2 Pulse Graphs A project-local library installer for Common Lisp 222 commits 3 branches 0 releases 8 contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags dont-bundle master userlocal Nothing to show Nothing to show New pull request Latest commit 75c399f Feb 21, 2016 fukamachi Fix qlot:bundle to work even when the system depends on the other sys… … …tem which is in the user application directory. Permalink Failed to load latest commit information. roswell Tweak usage in qlot.ros. Aug 1, 2015 src Fix qlot:bundle to work even when the system depends on the other sys… Feb 21, 2016 t Tweak a test. Nov 5, 2015 .gitignore Rename qlfile.snapshot to qlfile.lock. Jul 31, 2014 .travis.yml Run tests with Travis CI. Nov 5, 2015 README.markdown Run tests with Travis CI. Nov 4, 2015 circle.yml Use the latest release of Roswell for CI. Jul 31, 2015 qlot-install.asd Revert ""Replace YASON by Jonathan."" Aug 27, 2015 qlot-test.asd Replace cl-fad by UIOP. Aug 27, 2015 qlot.asd Disallow to install local quicklisp to other than ""quicklisp/"". Jun 9, 2015 README.markdown qlot Qlot is a project-local library installer using Quicklisp facility. This aims to be like Bundler of Ruby or Carton of Perl. Warning: This software is still ALPHA quality. The APIs will be likely to change. Usage # ""qlfile"" of ""myapp"" git clack https://github.com/fukamachi/clack.git github datafly fukamachi/datafly :branch v0.7.x ql log4cl 2014-03-17  ;; Installing libraries project-locally. (qlot:install :myapp)  ;; Loading a project with its project-local quicklisp. (qlot:quickload :myapp)  ;; Updating depending libraries of a project. (qlot:update :myapp) What qlot is trying to solve We have Quicklisp, the central library registry. It made installation of libraries damn easy. However, what only you can specify is the month of distribution. Which means you have to use all libraries of the same moment and you cannot use a newer/older version of a library for your project. ""local-projects/"" or ASDF configurations may be a solution to this problem, but there are a couple of problems. 1) They are not project-local. If you have multiple projects that use the different version of the same library, it would be a problem. 2) They are difficult to fix the version or to update them. If your project need to work on other than your machine, for instance on other people's machine or on servers, the version of depending libraries should be the same. This is what qlot is trying to solve. Installation via Quicklisp As qlot is going to be included in Quicklisp dist in August 2014, you can install it through Quicklisp. (ql:quickload :qlot) via Roswell It also can be installed with Roswell. $ ros install qlot  # Install from a local copy $ ros -l qlot.asd install qlot  It's almost the same as using Quicklisp, except it also introduces a shell command ""qlot"". $ which qlot /Users/nitro_idiot/.roswell/bin/qlot $ qlot Usage: qlot [install | update | bundle | exec shell-args..]  Tutorial Adding ""qlfile"" Put a file ""qlfile"" at the root of your project directory. See qlfile syntax section to know how to write it. Installation of libraries You can install libraries into the project directory via: (qlot:install :myapp) It creates quicklisp/ directory in the project directory and a file qlfile.lock. qlfile.lock is similar to qlfile except the library versions are qualified. This will ensure that other developers or your deployment environment use exactly the same versions of libraries you just installed. Make sure you add qlfile and qlfile.lock to your version controlled repository and make the quicklisp/ directory ignored. $ echo quicklisp/ >> .gitignore $ git add qlfile qlfile.lock $ git commit -m 'Start using qlot.'  Loading your application To load your qlot-ready application, use qlot:quickload instead of ql:quickload. (qlot:quickload :myapp) Executing forms with project-local Quicklisp Although qlot:quickload loads a project with its project-local Quicklisp, the Quicklisp path will be restored to the default one after that. This could cause significant problem if your application loads other libraries during run-time. For example, Clack loads a server handler when executing clackup and, the important part is, it loads with the system default Quicklisp, not the project-local one. To prevent the mess, wrap all code which would load other libraries in run-time with qlot:with-local-quicklisp. (qlot:with-local-quicklisp :myapp   (clack:clackup *app* :server :wookie)) Updating the project-local quicklisp You can update the content of quicklisp/ directory via: (qlot:update :myapp) It will also overwrite qlfile.lock. Bundling libraries You can bundle all depending libraries by qlot:bundle into bundle-libs/. (qlot:bundle :myapp) $ git add bundle-libs/ $ git commit -m 'Bundle dependencies.'  Commands install qlot:install will install Quicklisp and libraries that declared in qlfile project-locally. qlfile.lock will be used with precedence if it exists. (qlot:install :myapp) (qlot:install #P""/path/to/myapp/"") (qlot:install #P""/path/to/myapp/my-qlfile"") update qlot:update will update the project-local quicklisp/ directory using qlfile. (qlot:update :myapp) (qlot:update #P""/path/to/myapp/"") (qlot:update #P""/path/to/myapp/my-qlfile"") bundle qlot:bundle will bundle dependencies into bundle-libs/ by using ql:bundle-systems. (qlot:bundle :myapp) (qlot:bundle #P""/path/to/myapp/"") quickload qlot:quickload is similar to ql:quickload except it uses its project-local quicklisp/ directory. (qlot:quickload :myapp) with-local-quicklisp Eval the given form in the local quicklisp environment. (qlot:with-local-quicklisp :myapp   (ql:quickload :drakma)) qlfile syntax ""qlfile"" is a collection of Quicklisp dist declarations. Each line of that represents a dist. <source> <project name> [arg1, arg2..]  Currently, <source> must be one of ql, http, git or github. ql ql <project name> <version> ql <project name> :latest ql :all <version>  ql source will download libraries from Quicklisp official dist, but you can specify the version. If you want to use Clack in Quicklisp dist of January 13, 2014, qlfile would be like this. ql clack 2014-01-13  ql source also allows :all as <dist name> and :latest as the version. ql :all 2014-01-13 ql clack :latest  http http <project name> <url> [<file md5>]  http source will download a tarball. http yason http://netzhansa.com/yason.tar.gz  git git <project name> <repos url> git <project name> <repos url> :ref <commit ref> git <project name> <repos url> :branch <branch name> git <project name> <repos url> :tag <tag name>  git source will download libraries from a public git repository. git clack https://github.com/fukamachi/clack.git  You can also specify :ref, :branch or :tag. git clack https://github.com/fukamachi/clack.git :branch develop git datafly https://github.com/fukamachi/datafly.git :tag v0.7.4 git cl-dbi https://github.com/fukamachi/cl-dbi.git :ref 54928984e5756e92ba298aae51de8b95a6b0cf4b  github github <project name> <repos> github <project name> <repos> :ref <commit ref> github <project name> <repos> :branch <branch name> github <project name> <repos> :tag <tag name>  github source is similar to git, but it is specifically for GitHub. As it uses GitHub API and tarballs GitHub serves, it doesn't require ""git"" command. github datafly fukamachi/datafly github datafly fukamachi/datafly :branch develop  Priorities of distributions If multiple distributions provide the same library, lower one would take priority over higher ones. Author Eitaro Fukamachi (e.arrows@gmail.com) Copyright Copyright (c) 2014 Eitaro Fukamachi (e.arrows@gmail.com) License Licensed under the MIT License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/qlot"	"A project-local library installer, similar to Bundler or Carton.."	"true"
"Library Manager"	"Quickutil"	"https://github.com/tarballs-are-good/quickutil"	"A utility manager, similar to Quicklisp, but for small utilities rather than whole libraries.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"54"	"16"	"3"	"GitHub - tarballs-are-good/quickutil: The solution to the Utility Library problem. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 16 Star 54 Fork 3 tarballs-are-good/quickutil Code Issues 14 Pull requests 0 Pulse Graphs The solution to the Utility Library problem. 436 commits 1 branch 0 releases Fetching contributors Common Lisp 76.3% JavaScript 7.7% CSS 7.2% HTML 6.7% Python 1.6% Makefile 0.5% Common Lisp JavaScript CSS HTML Python Makefile Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. quickutil-client quickutil-server quickutil-utilities .gitignore .gitmodules README.md README.md Quickutil Summary Quickutil is a new way of thinking about utilities. See http://quickutil.org for details. Authors Eitarow Fukamachi Robert Smith Acknowledgements Thanks to Stas Boukarev (stassats) for a nearly comprehensive review of all of the utilities, finding countless enhancements and many bugs. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/tarballs-are-good/quickutil"	"A utility manager, similar to Quicklisp, but for small utilities rather than whole libraries.."	"true"
"Natural Language Processing"	"cl-nlp"	"https://github.com/vseloved/cl-nlp"	"Natural language processing toolset.."	"null"	"null"	"null"	"Apache2.0"	"http://directory.fsf.org/wiki/License:Apache2.0"	"null"	"null"	"79"	"28"	"17"	"GitHub - vseloved/cl-nlp: Common Lisp NLP toolset Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 28 Star 79 Fork 17 vseloved/cl-nlp Code Issues 6 Pull requests 0 Pulse Graphs Common Lisp NLP toolset 116 commits 2 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master temp Nothing to show Nothing to show New pull request Latest commit 795d97a Apr 3, 2016 vseloved Merge pull request #28 from dkochmanski/master … replace +project-root+ Permalink Failed to load latest commit information. contrib corpora coursera-nlang data docs lib models/pos-tagging nltk src test .gitignore .travis.yml LICENSE README.md cl-nlp-contrib.asd cl-nlp.asd cl-nltk.asd coursera-nlang.asd mkdocs.yml version.txt README.md CL-NLP -- a Lisp NLP toolkit Brief description Eventually, CL-NLP will provide a comprehensive and extensible set of tools to solve natural language processing problems in Common Lisp. The goals of the project include the following: support for constructing arbitrary NLP pipelines on top of it support for easy and fast experimentation and development of new models and approaches serve as a good framework for teaching NLP concepts It comprises of a number of utility/horizontal and end-user/vertical modules that implement the basic functions and provide a way to add own extensions and models. The utility layer includes: tools for transforming raw natural language text, as well as various corpora into a form suitable for further processing basic support for language modelling support for a number of linguistic concepts support for working with machine learning models and a number of training algorithms The end-user layer will provide: POS taggers constituency parsers dependency parsers other stuff (will be added step-by-step, suggestions are welcome) How to start working with CL-NLP The project has already reached a stage of usefulness for the primary author: for instance, it supports my current language modelling experiments by providing easy access to treebanks and other utilities. Yet, it is far from being production-ready. So, if you want to use it for production tasks, expect to bleed on the bleeding edge. Otherwise, if you want to contribute to developing the toolkit, you're very welcome. Here are a few write-ups to give you the sense of the project and to help get started: Writing a POS tagger with CL-NLP NLTK series - to be continued, by the way... CL-NLP Style Guide You'll also, probably, need to track the latest version of RUTILS from git. For CL-NLP to reach v.0.1 that may be considered suitable for limited use by non-contributors, the following things should be finished (work-in-progress): implement a comprehensive test-suite and fix all bugs encountered in the process describe available models and their quality metrics Technical notes Current limitations: targeted at English language only Dependencies RUTILS Closure XML DRAKMA ZIP USERIAL For development: SHOULD-TEST License The license of CL-NLP is Apache 2.0. Specific models may have different license due to the limitations of the dataset they are built with. Please see a <model>.license file accompanying each model for details. (c) 2013-2014, Vsevolod Dyomkin vseloved@gmail.com Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/vseloved/cl-nlp"	"Natural language processing toolset.."	"true"
"Natural Language Processing"	"babel2"	"http://emergent-languages.org/Babel2/"	"A Fluid Construction Grammar implementation, computational framework, and unification-based grammar formalism."	"null"	"null"	"null"	"Apache2.0"	"http://directory.fsf.org/wiki/License:Apache2.0"	"null"	"null"	"null"	"null"	"null"	"Babel2 Home NEW installation script! Installing Lisp Installing Babel2 Getting started Mailing list Babel 2 Download Babel 2 in a nutshell Babel2 connects the implementations of our core technologies such as Fluid Construction Grammar (FCG) and Incremental Recruitment Language (IRL) with mechanisms for multi-agent interactions, robotic embodiment, cognitive processing and learning. An extensive monitoring system gives access to every detail of Babel2’s intermediate representations and dynamics and a high modularity ensures that the system can be used in a very wide variety of scenarios. Babel2 is written in Common Lisp and runs in most major Lisp implementations (CCL, Lispworks) on all major platforms (linux, MAC OS X, Windows). Its source code is frequently released to the public under the Apache License. We recommend using the Sublime Text editor for Babel development (or Emacs if you are already familiar with it). The best place for Babel and FCG discussion is the mailing list. Get more info at the mailing list page. Fluid Construction Grammar (FCG) FCG is a computational framework for exploring issues in construction grammar. This unification-based grammar formalism uses feature structures for representing linguistic knowledge, and it can apply the same constructions in both parsing and production. FCG also comes with a web interface for visualizing the application of constructions during language processing and the resulting constructs. Learn more Incremental Recruitement Language (IRL) Incremental Recruitment Language is a fully operational computational formalism for representing and processing semantic structures that underlie compositional grammatical utterances. IRL represents meaning as networks of procedural cognitive operations. It comes with mechanisms for goal-driven conceptualization from perceptual data streams and for their interpretation. Learn more Multi-agent language game framework Babel2 also ships with mechanisms for multi-agent interactions, robotic embodiment, cognitive processing and meta-level learning. An extensive monitoring system opens up every detail of Babel2’s intermediate representations and underlying dynamics. A modular design ensures that the system can be used in a wide variety of scenarios. Learn more NEW installation method! Have you tried our new installation script? It works magically! It will install only what you are missing and configure all the pieces to work together. If you run OSX or Linux, try our new installation script and get everything you need for Babel development in a breeze. If you run Windows or prefer the classic method, scroll further, but it's your loss... Setting up a Lisp environment (Psst! You might want to save time using our new installation script instead!) Babel2 is written in Common Lisp because we strongly believe that Lisp is the best programming language for doing what we do. What’s not so great about using Lisp is that setting up a proper Lisp environment can be difficult sometimes. But don’t surrender, it can be done and I hope this page will help you to succeed. If you get stuck or find problems with this instruction, don’t hesitate to us. For running Babel2 you need three key things: A Lisp environment, ​Gnuplot for creating graphs and ​Graphviz for network visualizations. Babel2 runs on a number of Lisps, including Clozure Common Lisp (CCL) and Lispworks. If you have one of these Lisps installed, then most of the work is already done and you only need to install the other tools. Note that Babel2 will not work if your Lisp doesn’t support threads. If you don’t have a Lisp on your machine, then we recommend ​CCL as a Lisp implementation, ​Emacs as an editor and development environment (don’t frown, it’s still better than vi) and ​Slime for the communication between the lisp and Emacs. Computer experts feel free to install any of the above Lisps (plus gnuplot and graphviz) and all others follow the instructions for their operating system below. Please note that Babel2 will not run in the free Lispworks Personal Edition because it has a heap size limit. Good luck! Mac OS X Windows Linux VirtualBox Babel 2 brings together a multi-agent experiment framework with bi-directional language processing and data-driven conceptualization. Installing Babel2 (Psst! You might want to save time using our new installation script instead!) Make sure you have a running Lisp installation. If not follow these steps first. Download and unpack Babel2. Put the folder somewhere (please note that on Windows it has to be somewhere on drive C:/) We now need to create an initialization file for Babel2. The following instructions are for CCL. Windows Vista, 7 and 8 Create a plain text file called ccl-init.lisp in your home directory, most likely C:/Users/Username/ccl-init.lisp Add the following two lines to this text file      (load ""C:/Users/Username/Babel2/libraries/asdf"")     (load ""C:/Users/Username/Babel2/init-babel"")  Mac OS X Create a plain text file called .ccl-init.lisp in your home directory, most likely /Users/Username/.ccl-init.lisp Add the following two lines to this text file      (load ""/Users/Username/Babel2/libraries/asdf"")     (load ""/Users/Username/Babel2/init-babel"")  Linux Create a plain text file called .ccl-init.lisp in your home directory, most likely /home/username/.ccl-init.lisp Add the following two lines to this text file      (load ""/home/username/Babel2/libraries/asdf"")     (load ""/home/username/Babel2/init-babel"")  The next time you start your lisp, Babel2 will be automatically initialized. You can test your installation by opening the file Babel2/test-babel-installation.lisp in Emacs. Read the comments in this file and evaluate the expressions one by one. Read here for how to use Emacs to evaluate Lisp expressions. This is how the result of some of the tests should look like. Getting started We assume you have a working lisp environment and Babel2 installation. The following documentation is intended to get you started with the core frameworks of Babel2. Each getting started guide is accompanied by an example found in the Babel2 release. A good starting point for Fluid Construction Grammar is the ""Syntax and Semantics of FCG"" document. We also recommend you subscribe to the Babel/FCG mailing list. It's the best place to ask questions and share with the rest of users and developers. Get more info at the mailing list page. © Pieter Wellens. All rights reserved. | Inspired by: HTML5 UP"	"null"	"null"	"A Fluid Construction Grammar implementation, computational framework, and unification-based grammar formalism."	"true"
"Network and Internet"	"aserve"	"https://github.com/franzinc/aserve"	"AllegroServe; a web server.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"55"	"11"	"12"	"GitHub - franzinc/aserve: AllegroServe, a web server written in Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 11 Star 55 Fork 12 franzinc/aserve Code Issues 1 Pull requests 2 Pulse Graphs AllegroServe, a web server written in Common Lisp http://www.franz.com/support/documentation/current/doc/aserve/aserve.html 676 commits 20 branches 511 releases Fetching contributors Common Lisp 87.5% HTML 12.1% Other 0.4% Common Lisp HTML Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags acl6 acl7 acl8_win64 acl8 acl50 acl60beta acl60 acl61beta acl61 acl62beta acl62 acl70beta acl70 acl80b acl81b acl81 master smp ws ws2 Nothing to show save2011_02_16 release10.0_t3 release10.0_t2 release10.0_t1 release10.0_rc9 release10.0_rc8 release10.0_rc7 release10.0_rc6 release10.0_rc5 release10.0_rc4 release10.0_rc3 release10.0_rc2 release10.0_rc1 release10.0.pre-final.30_release_point release10.0.pre-final.17_release_point release10.0.beta_t13 release10.0.beta_t12 release10.0.beta_t11 release10.0.beta_t10 release10.0.beta_t9 release10.0.beta_t8 release10.0.beta_t7 release10.0.beta_t6 release10.0.beta_t5 release10.0.beta_t4 release10.0.beta_t3 release10.0.beta_t2 release10.0.beta_t1 release10.0.beta_release_point release10.0.beta_rc2 release10.0.beta_rc1 release_aclt2 release_acl100b14t8 release_acl100b11t7 release_acl100b10t6 release_acl100b8t5 release_acl100b7t4 release_acl100b6t3 release_acl100b4t2 release_acl100b2t1 release_acl90b21rc5 release_acl90b20_release_point release_acl90b20rc4 release_acl90b19rc3 release_acl90b18rc2 release_acl90b15_release_point release_acl90b15rc1 release_acl90b13t1 release_acl90b11t1 release_acl90b9t1 release_acl90b8t1 release_acl90b6_release_point release_acl90b6rc2 release_acl90b_release_point release_acl90a52rc1 release_acl90a44rc2 release_acl90a43rc1 release_acl90a39 release_acl90a39rc2 release_acl90a32 release_acl90a27 release_acl90a25 release_acl90a24 release_acl90a23 release_acl90a20 release_acl90a18 install-spider_2013-04-26T12-55-31 install-spider_2013-04-25T12-56-58 install-spider_2013-04-24T16-52-55 install-spider_2013-04-24T16-42-42 install-spider_2013-04-24T16-29-36 install-spider_2013-04-24T15-47-16 install-spider_2013-04-24T15-37-01 install-spider_2013-04-24T15-02-09 install-spider_2013-04-23T11-10-35 install-spider_2013-04-12T14-51-27 install-spider_2013-04-12T14-36-20 install-spider_2013-04-11T14-18-51 install-spider_2013-04-03T19-20-51 install-spider_2013-04-03T17-25-35 install-spider_2013-04-02T17-28-57 install-spider_2013-03-26T15-43-22 install-spider_2013-03-21T13-34-28 install-spider_2013-03-20T13-46-29 install-spider_2013-03-20T01-19-31 install-spider_2013-01-29T13-26-10 install-spider_2013-01-16T17-31-40 install-spider_2013-01-16T16-43-49 install-spider_2012-11-29T20-34-03 install-spider_2012-11-14T13-43-28 install-spider_2012-11-14T08-05-32 install-spider_2012-10-30T13-50-49 install-spider_2012-10-12T11-40-36 install-spider_2012-09-18T18-29-59 install-spider_2012-09-12T15-43-10 install-spider_2012-09-12T15-24-10 install-spider_2012-09-12T14-50-31 install-spider_2012-09-06T14-19-49 install-spider_2012-08-28T12-31-12 install-spider_2012-08-27T20-00-25 Nothing to show New pull request Latest commit 604f75d May 3, 2016 Gary King committed with dklayer v1.3.40: Add methods for socket-bytes-read|written … Add methods for socket-bytes-read|written to aserve streams, so programs can introspect their traffic.  %Testing: make test, though no new tests  Change-Id: I3c65bef70fb8289115c310014603e1913c141fa9 Reviewed-on: https://gerrit.franz.com:9080/5642 Reviewed-by: Gary Warren King <gwking@franz.com> Reviewed-by: Kevin Layer <layer@franz.com> Tested-by: Kevin Layer <layer@franz.com> Permalink Failed to load latest commit information. doc 1.3.37 add support for setting trailers Oct 15, 2015 examples Remove CVS Ids; fix copyright Apr 8, 2016 htmlgen Remove CVS Ids; fix copyright Apr 9, 2016 test Fix processing of chunked requests sent over SSL May 16, 2016 webactions Remove CVS Ids; fix copyright Apr 9, 2016 .gitignore Include local makefiles if they exist Sep 17, 2015 README.md Corrected typo in README.md Mar 10, 2011 aserve.asd Add call to disable-output-translations in asd file Jan 24, 2013 authorize.cl Remove CVS Ids; fix copyright Apr 9, 2016 cgi.cl Remove CVS Ids; fix copyright Apr 9, 2016 chunker.cl v1.3.40: Add methods for socket-bytes-read|written Jul 12, 2016 client.cl v1.3.40: Add methods for socket-bytes-read|written Jul 12, 2016 decode.cl headers.cl Remove CVS Ids; fix copyright Apr 9, 2016 license-allegroserve.txt 1.1.17 May 16, 2000 license-lgpl.txt join from acl50 branch Mar 16, 2000 load.cl testing -- fixes to last commit Jun 7, 2012 loadonly.cl log.cl Remove CVS Ids; fix copyright Apr 9, 2016 macs.cl Remove CVS Ids; fix copyright Apr 9, 2016 main.cl v1.3.40: Add methods for socket-bytes-read|written Jul 12, 2016 makefile Make ACL 10.0 the default Jul 12, 2016 packages.cl v1.3.40: Add methods for socket-bytes-read|written Jul 12, 2016 parse.cl Remove CVS Ids; fix copyright Apr 9, 2016 playback.cl Remove CVS Ids; fix copyright Apr 9, 2016 proxy.cl Remove CVS Ids; fix copyright Apr 9, 2016 publish.cl Remove CVS Ids; fix copyright Apr 9, 2016 queue.cl Remove CVS Ids; fix copyright Apr 9, 2016 README.md The AllegroServe Webserver Table of contents Description Author Author comments Documentation Platforms Dependencies Installation Configuration Licence Notes Examples Open Source Description AllegroServe has these components: HTTP/1.1 compliant web server capable of serving static and dynamic pages HTML generation facility that seamlessly merges html tag printing with computation of dynamic content. The HTML generator matches perfectly with the HTML parser (which is in another project) to allow web pages to be read, modifed in Lisp and then regenerated. HTTP client functions to access web sites and retrieve data. Secure Socket Layer (SSL) for both the server and client. Web Proxy facility with a local cache. Comprehensive regression test suite that verifies the functionality of the client, server, proxy and SSL high performance for static and dynamic web page delivery Licensed under terms that ensure that it will always be open source and that encourages its use in commercial settings. A publish function that builds a page from static and dynamic data and handles caching of the result. Access control mechanisms for publishing directories that gives the webmaster the ability to specify which files and directories in the tree should be visible. The ability to run external CGI programs. An improved virtual hosting system that supports different logging and error streams for each virtual host. We've recently added these features: The ability to compress and inflate files on the fly. Support for chunking and http/1.1 Security up through TLS 1.0 (SSL 3.1). See the latest Allegro CL Release Notes for more information on AllegroServe changes. Author John Foderaro, Franz Inc. Author comments The server part of AllegroServe can be used either as a standalone web server or a module loaded into an application to provide a user interface to the application. AllegroServe's proxy ability allows it to run on the gateway machine between a company's internal network and the internet. AllegroServe's client functions allow Lisp programs to explore the web. AllegroServe was also written and open sourced as a way to demonstrate network programming in Allegro Common Lisp. AllegroServe was written according to a certain coding standard to demonstrate how Lisp programs are more readable if certain macros and special forms are avoided. Platforms AllegroServe works on all versions of Allegro Common Lisp since 6.0. Dependencies There are no dependences for AllegroServe. In order to run the allegroserve test suite you'll need to have the tester module (available at https://github.com/franzinc) loaded. Installation start lisp This should work in a lisp running in a :case-insensitive-upper or :case-sensitive-lower mode, although we do most of our running and testing in a :case-sensitive-lower lisp. The current case mode is the value of excl:*current-case-mode* load in the file load.cl user(1):  :ld <path-to-aserve>/load.cl  it will compile and and load all of AllegroServe, and it will load in the examples file too. start the server user(2):  (net.aserve:start :port 8000)  you can omit the port argument on Windows where any process can allocate port 80 (as long as it's unused). try out the server go to a web browser and try http://your-machine-name:8000/. If the web browser is on the same machine as AllegroServe is running you can use http://localhost:8000/ as well. Now that you've verified that it works, you'll want to create an aserve.fasl that you can load into your application. change lisp's current directory to the AllegroServe source user(3): :cd  <path-to-aserve>  make a distribution user(4): (make-aserve.fasl)  now you'll find aserve.fasl in the aserve source directory. Configuration See the doc/aserve.html file that is part of this project for more information on configuring AllegroServe. Documentation For complete documentation see the contents of the doc directory, which is part of this project or visit the online version of the AllegroServe documentation. Quick Start Documentation cd to the directory containing the distribution and start Allegro cl (or start Allegro and use the toplevel "":cd"" command to cd to the directory containing the aserve). load aserve.fasl user(1): :ld aserve.fasl  load the examples (either the compiled or source version) user(2): :ld examples/examples  start the webserver user(3):  (net.aserve:start :port 8010)  view in a browser http://localhost:8010/  Usage notes the steps to load the examples and start the server are interchangeable. if you're running on a PC (or running as root on Unix) you can allocate port 80, so you don't have to specify a port when running the net.aserve:start function. See the doc directory that is part of this project for more detailed usage documenation. License The aserve source code is licensed under the terms of the Lisp Lesser GNU Public License, known as the LLGPL. The LLGPL consists of a preamble and the LGPL. Where these conflict, the preamble takes precedence. This project is referenced in the preamble as the LIBRARY. Notes Webactions is a session-based framework for building web sites mixing static and dynamic content that builds upon AllegroServe and is part of this project. See the webactions/doc/webactions.html file for more information. For other links that may be of interest are: Portable AllegroServe Source to the if* macro CL-HTTP Examples and Information See the doc/tutorial.html file and the contents under the examples directory that are part of this project for more examples on how to work with AllegroServe. Franz Inc. Open Source Info This project's homepage is https://github.com/franzinc/aserve. There is an informal community support and development mailing list opensource@franz.com for these open source projects. We encourage you to take advantage by subscribing to the list. Once you're subscribed, email to opensource@franz.com with your questions, comments, suggestions, and patches. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/franzinc/aserve"	"AllegroServe; a web server.."	"true"
"Network and Internet"	"avatar-api"	"https://github.com/eudoxia0/avatar-api"	"Get avatars from Google+, Gravatar and others.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"7"	"2"	"0"	"GitHub - eudoxia0/avatar-api: Get avatars from Gravatar and other services. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 7 Fork 0 eudoxia0/avatar-api Code Issues 0 Pull requests 0 Pulse Graphs Get avatars from Gravatar and other services. 12 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src t .gitignore .travis.yml README.md avatar-api-test.asd avatar-api.asd README.md avatar-api avatar-api is a library for getting avatars from Gravatar, Google+ and others. Usage cl-user> (avatar-api:gravatar ""jdoe@initech.com"") ""http://www.gravatar.com/avatar/6aef61d98ad63bd1aaa89345eb150df2"" License Copyright (c) 2014 Fernando Borretti Licensed under the MIT License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/eudoxia0/avatar-api"	"Get avatars from Google+, Gravatar and others.."	"true"
"Network and Internet"	"Caveman"	"https://github.com/fukamachi/caveman"	"A powerful web framework.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"367"	"54"	"41"	"GitHub - fukamachi/caveman: Lightweight web application framework for Common Lisp. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 54 Star 367 Fork 41 fukamachi/caveman Code Issues 29 Pull requests 4 Pulse Graphs Lightweight web application framework for Common Lisp. http://8arrow.org/caveman/ 366 commits 4 branches 12 releases Fetching contributors Common Lisp 97.6% HTML 1.8% Other 0.6% Common Lisp HTML Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags clack-v2 fix-parse-parameters-with-requirements gh-pages master Nothing to show 12.06.0 12.04.1 12.04.0 12.03.1 12.03.0 12.02.0 12.01.0 11.11.0 11.10.0 11.09.0 11.08.0 11.07.0 Nothing to show New pull request Latest commit d4c6c54 Feb 13, 2016 fukamachi Throw a condition for ignoring the rest when 'redirect' is called. Permalink Failed to load latest commit information. v1 Replace Drakma by Dexador. Aug 27, 2015 v2 Throw a condition for ignoring the rest when 'redirect' is called. Feb 13, 2016 .gitignore Add tests of Caveman2. Nov 7, 2013 .travis.yml Use Roswell for CI. Dec 16, 2015 README.markdown Add a note about Server::Starter friendly handlers. Dec 16, 2015 README.v1.markdown Caveman2 beta is going to be released. Aug 6, 2014 caveman-middleware-dbimanager.asd caveman-middleware-dbimanager (obsolete) is still using Clack v1 API. Jun 5, 2015 caveman-test.asd Replace Drakma by Dexador. Aug 27, 2015 caveman.asd Replace cl-fad by UIOP. Aug 27, 2015 caveman2-db.asd Remove ""w"" at the end of my name. Jul 3, 2014 caveman2-test.asd Replace Drakma by Dexador. Aug 27, 2015 caveman2.asd v2.4.0 Jun 5, 2015 README.markdown Caveman2 - Lightweight web application framework Usage (defparameter *web* (make-instance '<app>))  @route GET ""/"" (defun index ()   (render #P""index.tmpl""))  @route GET ""/hello"" (defun say-hello (&key (|name| ""Guest""))   (format nil ""Hello, ~A"" |name|)) About Caveman2 What's the difference from Caveman ""1""? All of them. Caveman2 was written from scratch. These are noticeable points. Bases on ningle Database integration New separated configuration system (Envy) New routing macro The reason I wrote it from scratch One of the most frequently asked questions was ""Which should I use ningle or Caveman? What are the differences?"" I think it was because the roles of them were too similar. Both of them are saying ""micro"" and no database support. Caveman2 is no more ""micro"" web application framework. It supports CL-DBI and has database connection management by default. Caveman has started growing up. Design Goal Caveman is intended to be a collection of common parts of web applications. Caveman has 3 rules to make decisions. Be extensible. Be practical. Don't force anything. Quickstart You came here because you're interested in living like a caveman, right? There's no Disneyland, but it's good place to start. Let's get into a cave. Installation Caveman2 is now available on Quicklisp. (ql:quickload :caveman2) Generating a project skeleton (caveman2:make-project #P""/path/to/myapp/""                        :author ""<Your full name>"") ;-> writing /path/to/myapp/.gitignore ;   writing /path/to/myapp/README.markdown ;   writing /path/to/myapp/app.lisp ;   writing /path/to/myapp/db/schema.sql ;   writing /path/to/myapp/shlyfile.lisp ;   writing /path/to/myapp/myapp-test.asd ;   writing /path/to/myapp/myapp.asd ;   writing /path/to/myapp/src/config.lisp ;   writing /path/to/myapp/src/db.lisp ;   writing /path/to/myapp/src/main.lisp ;   writing /path/to/myapp/src/view.lisp ;   writing /path/to/myapp/src/web.lisp ;   writing /path/to/myapp/static/css/main.css ;   writing /path/to/myapp/t/myapp.lisp ;   writing /path/to/myapp/templates/_errors/404.html ;   writing /path/to/myapp/templates/index.tmpl ;   writing /path/to/myapp/templates/layout/default.tmpl Routing Caveman2 provides 2 ways to define a route -- @route and defroute. You can choose which to use. @route is an annotation macro defined by using cl-annot. It takes a method, an URL-string and a function. @route GET ""/"" (defun index ()   ...)  ;; A route with no name. @route GET ""/welcome"" (lambda (&key (|name| ""Guest""))   (format nil ""Welcome, ~A"" |name|)) This is similar to Caveman1's @url except its argument list. You don't have to specify an argument when you don't need it. defroute is just a macro. It provides same feature to @route. (defroute index ""/"" ()   ...)  ;; A route with no name. (defroute ""/welcome"" (&key (|name| ""Guest""))   (format nil ""Welcome, ~A"" |name|)) Since Caveman bases on ningle, Caveman also has the Sinatra-like routing system. ;; GET request (default) @route GET ""/"" (lambda () ...) (defroute (""/"" :method :GET) () ...)  ;; POST request @route POST ""/"" (lambda () ...) (defroute (""/"" :method :POST) () ...)  ;; PUT request @route PUT ""/"" (lambda () ...) (defroute (""/"" :method :PUT) () ...)  ;; DELETE request @route DELETE ""/"" (lambda () ...) (defroute (""/"" :method :DELETE) () ...)  ;; OPTIONS request @route OPTIONS ""/"" (lambda () ...) (defroute (""/"" :method :OPTIONS) () ...)  ;; For all methods @route ANY ""/"" (lambda () ...) (defroute (""/"" :method :ANY) () ...) Route pattern may contain ""keyword"" to put the value into the argument. (defroute ""/hello/:name"" (&key name)   (format nil ""Hello, ~A"" name)) The above controller will be invoked when you access to ""/hello/Eitaro"" or ""/hello/Tomohiro"", and then name will be ""Eitaro"" and ""Tomohiro"". (&key name) is almost same as a lambda list of Common Lisp, excepts it always allows other keys. (defroute ""/hello/:name"" (&rest params &key name)   ;; ...   ) Route patterns may also contain ""wildcard"" parameters. They are accessible by splat. (defroute ""/say/*/to/*"" (&key splat)   ; matches /say/hello/to/world   splat ;=> (""hello"" ""world"")   ))  (defroute ""/download/*.*"" (&key splat)   ; matches /download/path/to/file.xml   splat ;=> (""path/to/file"" ""xml"")   )) If you'd like to write a regular expression for URL rule, :regexp t should work for it. (defroute (""/hello/([\\w]+)"" :regexp t) (&key captures)   (format nil ""Hello, ~A!"" (first captures))) Normally, routes are matched in the order they are defined. Only the first route matched is invoked and rest of them just will be ignored. But, a route can punt processing to the next matching route using next-route. (defroute ""/guess/:who"" (&key who)   (if (string= who ""Eitaro"")       ""You got me!""       (next-route)))  (defroute ""/guess/*"" ()   ""You missed!"") You can return following formats as the result of defroute. String Pathname Clack's response list (containing Status, Headers and Body) Structured query/post parameters Parameter keys contain square brackets (""["" & ""]"") will be parsed as structured parameters. You can access the parsed parameters as _parsed in routers. <form action=""/edit"">   <input type=""name"" name=""person[name]"" />   <input type=""name"" name=""person[email]"" />   <input type=""name"" name=""person[birth][year]"" />   <input type=""name"" name=""person[birth][month]"" />   <input type=""name"" name=""person[birth][day]"" /> </form> (defroute ""/edit"" (&key _parsed)   (format nil ""~S"" (cdr (assoc ""person"" _parsed :test #'string=)))) ;=> ""((\""name\"" . \""Eitaro\"") (\""email\"" . \""e.arrows@gmail.com\"") (\""birth\"" . ((\""year\"" . 2000) (\""month\"" . 1) (\""day\"" . 1))))"" Blank keys mean they have multiple values. <form action=""/add"">   <input type=""text"" name=""items[][name]"" />   <input type=""text"" name=""items[][price]"" />    <input type=""text"" name=""items[][name]"" />   <input type=""text"" name=""items[][price]"" />    <input type=""submit"" value=""Add"" /> </form> (defroute ""/add"" (&key _parsed)   (format nil ""~S"" (assoc ""items"" _parsed :test #'string=))) ;=> ""(((\""name\"" . \""WiiU\"") (\""price\"" . \""30000\"")) ((\""name\"" . \""PS4\"") (\""price\"" . \""69000\"")))"" Templates Caveman adopts Djula for the default templating engine. {% extends ""layouts/default.html"" %} {% block title %}Users | MyApp{% endblock %} {% block content %} <div id=""main"">   <ul>   {% for user in users %}     <li><a href=""{{ user.url }}"">{{ user.name }}</a></li>   {% endfor %}   </ul> </div> {% endblock %} (import 'myapp.view:render)  (render #P""users.html""         '(:users ((:url ""/id/1""                    :name ""nitro_idiot"")                   (:url ""/id/2""                    :name ""meymao""))           :has-next-page T)) If you want to get something from a database or execute any function using Djula you have to explicity call list when passing the arguments to render so that the code executes. (import 'myapp.view:render)  (render #P""users.html""         (list :users (get-users-from-db))) JSON API This is an example of a JSON API. (defroute ""/user.json"" (&key |id|)   (let ((person (find-person-from-db |id|)))     ;; person => (:|name| ""Eitaro Fukamachi"" :|email| ""e.arrows@gmail.com"")     (render-json person)))  ;=> {""name"":""Eitaro Fukamachi"",""email"":""e.arrows@gmail.com""} render-json is a part of a skeleton project. You can find its code in ""src/view.lisp"". Static file Images, CSS, JS, favicon.ico and robot.txt in ""static/"" directory will be served by default. /images/logo.png => {PROJECT_ROOT}/static/images/logo.png /css/main.css    => {PROJECT_ROOT}/static/css/main.css /js/app/index.js => {PROJECT_ROOT}/static/js/app/index.js /robot.txt       => {PROJECT_ROOT}/static/robot.txt /favicon.ico     => {PROJECT_ROOT}/static/favicon.ico  You can change these rules by rewriting ""PROJECT_ROOT/app.lisp"". See Clack.Middleware.Static for detail. Configuration Caveman adopts Envy as a configuration switcher. It allows to define multiple configurations and to switch them by an environment variable. This is a typical example. (defpackage :myapp.config   (:use :cl         :envy)) (in-package :myapp.config)  (setf (config-env-var) ""APP_ENV"")  (defconfig :common   `(:application-root ,(asdf:component-pathname (asdf:find-system :myapp))))  (defconfig |development|   '(:debug T     :databases     ((:maindb :sqlite3 :database-name ,(merge-pathnames #P""test.db""                                                         *application-root*)))))  (defconfig |production|   '(:databases     ((:maindb :mysql :database-name ""myapp"" :username ""whoami"" :password ""1234"")      (:workerdb :mysql :database-name ""jobs"" :username ""whoami"" :password ""1234""))))  (defconfig |staging|   `(:debug T     ,@|production|)) Every configuration is a property list. You can choose the configuration which to use by setting APP_ENV. To get a value from the current configuration, call myapp.config:config with a key you want. (import 'myapp.config:config)  (setf (osicat:environment-variable ""APP_ENV"") ""development"") (config :debug) ;=> T Database When you add :databases to the configuration, Caveman enables database support. :databases is an association list of database settings. (defconfig |production|   '(:databases     ((:maindb :mysql :database-name ""myapp"" :username ""whoami"" :password ""1234"")      (:workerdb :mysql :database-name ""jobs"" :username ""whoami"" :password ""1234"")))) db in a package myapp.db is a function for connecting to each databases configured the above. Here is an example. (use-package '(:myapp.db :sxql :datafly))  (defun search-adults ()   (with-connection (db)     (retrieve-all       (select :*         (from :person)         (where (:>= :age 20)))))) The connection is alive during the Lisp session and will be reused in each HTTP requests. retrieve-all and the query language came from datafly and SxQL. See those documentations for more informations. Set HTTP headers or HTTP status There are several special variables available during a HTTP request. *request* and *response* represents a request and a response. If you are familiar with Clack, these are instances of subclasses of Clack.Request and Clack.Response. (use-package :caveman2)  ;; Get a value of Referer header. (http-referer *request*)  ;; Set Content-Type header. (setf (getf (response-headers *response* :content-type) ""application/json"")  ;; Set HTTP status. (setf (status *response*) 304) If you would like to set Content-Type ""application/json"" for all ""*.json"" requests, next-route will help you. (defroute ""/*.json"" ()   (setf (getf (response-headers *response*) :content-type) ""application/json"")   (next-route))  (defroute ""/user.json"" () ...) (defroute ""/search.json"" () ...) (defroute (""/new.json"" :method :POST) () ...) Using session Session data is for memorizing user-specific data. *session* is a hash table represents session data. This example increments :counter in the session and displays it for each visitors. (defroute ""/counter"" ()   (format nil ""You came here ~A times.""           (incf (gethash :counter *session* 0)))) Caveman2 stores the session data in-memory by default. To change it, specify :store to :session in ""PROJECT_ROOT/app.lisp"". This example uses RDBMS to store it.       '(:backtrace         :output (getf (config) :error-log))       nil) - :session + (:session +  :store (make-dbi-store :connector (lambda () +                                      (apply #'dbi:connect +                                             (myapp.db:connection-settings)))))   (if (productionp)       nil       (lambda (app) NOTE: Don't forget to add :lack-session-store-dbi as :depends-on of your app. It is not a part of Clack/Lack. See the source code of Lack.Session.Store.DBi for more informations. Lack.Session.Store.Dbi Throw an HTTP status code (import 'caveman2:throw-code)  (defroute (""/auth"" :method :POST) (&key |name| |password|)   (unless (authorize |name| |password|)     (throw-code 403))) Specify error pages To specify error pages for 404, 500 or so, define a method on-exception of your app. (defmethod on-exception ((app <web>) (code (eql 404)))   (declare (ignore app code))   (merge-pathnames #P""_errors/404.html""                    *template-directory*)) Start a server Your application has functions named start and stop to start/stop your web application. This is a example assuming that the name of your application is ""myapp"". (myapp:start :port 8080) As Caveman bases on Clack/Lack, you can choose which server to run on -- Hunchentoot, mod_lisp or FastCGI. (myapp:start :server :hunchentoot :port 8080) (myapp:start :server :fcgi :port 8080) I recommend you to use Hunchentoot in local machine and use FastCGI/Woo for production environment. You can also start your application by using clackup command. $ ros install clack $ which clackup /Users/nitro_idiot/.roswell/bin/clackup  $ APP_ENV=development clackup --server :fcgi --port 8080 app.lisp  Hot Deployment Though Caveman doesn't have a feature for hot deployment, Server::Starter -- a Perl module -- makes it easy. $ APP_ENV=production start_server --port 8080 -- clackup --server :fcgi app.lisp  NOTE: Server::Starter requires the server to support binding on a specific fd, which means only :fcgi and :woo are the ones work with start_server command. To restart the server, send HUP signal (kill -HUP <pid>) to the start_server process. Error Log Caveman outputs error backtraces to a file which is specified at :error-log in your configuration. (defconfig |default|   `(:error-log #P""/var/log/apps/myapp_error.log""     :databases     ((:maindb :sqlite3 :database-name ,(merge-pathnames #P""myapp.db""                                                         *application-root*))))) Use another templating library CL-WHO (import 'cl-who:with-html-output-to-string)  (defroute ""/"" ()   (with-html-output-to-string (output nil :prologue t)     (:html       (:head (:title ""Welcome to Caveman!""))       (:body ""Blah blah blah."")))) ;=> ""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Strict//EN\"" \""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\""> ;   <html><head><title>Welcome to Caveman!</title></head><body>Blah blah blah.</body></html>"" CL-WHO Website CL-Markup (import 'cl-markup:xhtml)  (defroute ""/"" ()   (xhtml     (:head (:title ""Welcome to Caveman!""))     (:body ""Blah blah blah.""))) ;=> ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Transitional//EN\"" \""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\""><html><head><title>Welcome to Caveman!</title></head><body>Blah blah blah.</body></html>"" CL-Markup repository cl-closure-template {namespace myapp.view}  {template renderIndex} <!DOCTYPE html> <html> <head>   <title>""Welcome to Caveman!</title> </head> <body>   Blah blah blah. </body> </html> {/template} (import 'myapp.config:*template-directory*)  (closure-template:compile-cl-templates (merge-pathnames #P""index.tmpl""                                                         *template-directory*))  (defroute ""/"" ()   (myapp.view:render-index)) cl-closure-template Closure Templates Documentation See Also Clack - Web application environment. Lack - The core of Clack. ningle - Super micro web application framework Caveman bases on. Djula - HTML Templating engine. CL-DBI - Database independent interface library. SxQL - SQL builder library. Envy - Configuration switcher. Roswell - Common Lisp implementation manager. Author Eitaro Fukamachi (e.arrows@gmail.com) License Licensed under the LLGPL License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/caveman"	"A powerful web framework.."	"true"
"Network and Internet"	"chirp"	"https://github.com/Shinmera/chirp"	"A Twitter client library.."	"null"	"null"	"null"	"Artistic License 2.0"	"http://directory.fsf.org/wiki/License:ArtisticLicense2.0"	"null"	"null"	"32"	"4"	"3"	"GitHub - Shinmera/chirp: A twitter client library for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 4 Star 32 Fork 3 Shinmera/chirp Code Issues 2 Pull requests 0 Pulse Graphs A twitter client library for Common Lisp https://shinmera.github.io/chirp 164 commits 2 branches 0 releases Fetching contributors HTML 57.7% Common Lisp 42.3% HTML Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Latest commit 360a6c2 Jul 9, 2016 Shinmera committed on GitHub Merge pull request #4 from dunn/typo … oauth: fix typo Permalink Failed to load latest commit information. LICENSE Added LICENSE Feb 22, 2014 README.md Update README.md Mar 2, 2014 about-template.html Updated about Mar 17, 2014 about.html Updated about Mar 17, 2014 account.lisp Copyright header update to Shirakumo Oct 9, 2014 blocks.lisp Copyright header update to Shirakumo Oct 9, 2014 chirp-logo-single.png New logo Mar 17, 2014 chirp-logo.png New logo Mar 17, 2014 chirp.asd uuh. Feb 2, 2016 cursor.lisp Copyright header update to Shirakumo Oct 9, 2014 direct-messages.lisp Copyright header update to Shirakumo Oct 9, 2014 documentation.lisp Copyright header update to Shirakumo Oct 9, 2014 entities.lisp Copyright header update to Shirakumo Oct 9, 2014 favorites.lisp Copyright header update to Shirakumo Oct 9, 2014 friends.lisp Copyright header update to Shirakumo Oct 9, 2014 generics.lisp Copyright header update to Shirakumo Oct 9, 2014 help.lisp Copyright header update to Shirakumo Oct 9, 2014 indent.lisp Copyright header update to Shirakumo Oct 9, 2014 lists.lisp Copyright header update to Shirakumo Oct 9, 2014 location.lisp Copyright header update to Shirakumo Oct 9, 2014 oauth.lisp oauth: fix typo Jul 9, 2016 package.lisp Copyright header update to Shirakumo Oct 9, 2014 saved-searches.lisp Copyright header update to Shirakumo Oct 9, 2014 search.lisp Copyright header update to Shirakumo Oct 9, 2014 statuses.lisp Copyright header update to Shirakumo Oct 9, 2014 stream.lisp Copyright header update to Shirakumo Oct 9, 2014 suggestions.lisp Copyright header update to Shirakumo Oct 9, 2014 timelines.lisp Copyright header update to Shirakumo Oct 9, 2014 toolkit.lisp Copyright header update to Shirakumo Oct 9, 2014 trends.lisp Copyright header update to Shirakumo Oct 9, 2014 user.lisp Fixed users/lookup - params named wrong and the call doesn't return a… Sep 24, 2015 README.md chirp A twitter client library for Common Lisp. See about.html for documentation, examples and package index. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Shinmera/chirp"	"A Twitter client library.."	"true"
"Network and Internet"	"cl-closure-template"	"https://github.com/archimag/cl-closure-template"	"Implementation of Google's Closure templates.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"60"	"9"	"22"	"GitHub - archimag/cl-closure-template: Common Lisp implementation of Google's Closure Templates. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 9 Star 60 Fork 22 archimag/cl-closure-template Code Issues 10 Pull requests 0 Pulse Graphs Common Lisp implementation of Google's Closure Templates. 285 commits 2 branches 12 releases Fetching contributors Common Lisp 64.5% JavaScript 29.4% Emacs Lisp 5.2% Other 0.9% Common Lisp JavaScript Emacs Lisp Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags devel master Nothing to show version-0.2.1 version-0.2.0 version-0.1.9 version-0.1.8 version-0.1.7 version-0.1.6 version-0.1.5 version-0.1.4 version-0.1.3 version-0.1.2 version-0.1.1 version-0.1 Nothing to show New pull request Latest commit f1983aa Jul 26, 2015 archimag Merge pull request #35 from TBRSS/fix-package-bug … Make sure the generated package doesn't :use :cl. Permalink Failed to load latest commit information. example Reflect RESTAS changes in the example. Sep 10, 2013 src Make sure the generated package doesn't :use :cl. Jul 24, 2015 t fixes test for ClozureCL Jan 11, 2013 COPYING update examples Feb 5, 2010 ClosureTemplate.py python backend Nov 15, 2012 README.markdown fix typo in README Jul 9, 2013 closure-template-html-mode.el Improved closure-template-html-mode Jan 23, 2013 closure-template.asd Implement custom print directives for Javascript backend Jan 13, 2013 README.markdown cl-closure-template - Common Lisp implementation of Closure Template from Google Sample Code  CL-USER> (asdf:operate 'asdf:load-op '#:closure-template)   CL-USER> (defparameter *template* ""  /*   *  Greets a person using 'Hello' by default.   */ {namespace closureTemplate.Example} {template helloName}    {if not $greetingWorld}       Hello {$name}!    {else}       {$greetingWorld} {$name}!     {/if} {/template}"") *TEMPLATE*   CL-USER> (closure-template:compile-template :common-lisp-backend *template*) #<PACKAGE ""CLOSURETEMPLATE.EXAMPLE""> CL-USER> (closuretemplate.example:hello-name '(:name ""Andrey"")) ""Hello Andrey!"" CL-USER> (closure-template.example:hello-name '(:name ""Andrey"" :greeting-world ""Hi"")) ""Hi Andrey!""   CL-USER> (closure-template:compile-template :javascript-backend *template*) ""if (typeof closureTemplate === 'undefined') { closureTemplate = {}; } if (typeof closureTemplate.Example === 'undefined') { closureTemplate.Example = {}; }  closureTemplate.Example.$isEmpty$ = function (obj) {     for (var prop in obj) if (obj.hasOwnProperty(prop)) return false;     return true; };  closureTemplate.Example.$escapeHTML$ = function (obj) {     if (typeof obj == 'string') return String(obj).split('&').join('&amp;').split( '<').join('&lt;').split('>').join('&gt;').split('\\\""').join('&quot;').split('\\'').join('&#039;');     else return obj; };  closureTemplate.Example.$round$ = function (number, ndigits) {     if (ndigits) {         var factor = Math.pow(10.0, ndigits);         return Math.round(number * factor) / factor;     }     else return Math.round(number) };  closureTemplate.Example.$objectFromPrototype$ = function (obj) {     function C () {}     C.prototype = obj;     return new C; };  closureTemplate.Example.helloName = function($env$, $target$) {     if (!$env$) { $env$ = {}; }     var $result$ = $target$ || [];      if (!$env$.greetingWorld) {         $result$.push(\""Hello \"");         $result$.push(closureTemplate.Example.$escapeHTML$($env$.name));         $result$.push(\""!\"");     }     else {         $result$.push(closureTemplate.Example.$escapeHTML$($env$.greetingWorld));         $result$.push(\"" \"");         $result$.push(closureTemplate.Example.$escapeHTML$($env$.name));         $result$.push(\""!\"");     }      if (!$target$) return $result$.join('');     else return null; }; ""  CL-USER> (closure-template:compile-template :requirejs-backend *template*) ""define(function () { var module = { }; module.$isEmpty$ = function (obj) {     for (var prop in obj) if (obj.hasOwnProperty(prop)) return false;     return true; };  module.$escapeHTML$ = function (obj) {     if (typeof obj == 'string') return String(obj).split('&').join('&amp;').split( '<').join('&lt;').split('>').join('&gt;').split('\\\""').join('&quot;').split('\\'').join('&#039;');     else return obj; };  module.$round$ = function (number, ndigits) {     if (ndigits) {         var factor = Math.pow(10.0, ndigits);         return Math.round(number * factor) / factor;     }     else return Math.round(number) };  module.$objectFromPrototype$ = function (obj) {     function C () {}     C.prototype = obj;     return new C; };  module.helloName = function($env$, $target$) {     if (!$env$) { $env$ = {}; }     var $result$ = $target$ || [];      if (!$env$.greetingWorld) {         $result$.push(\""Hello \"");         $result$.push(module.$escapeHTML$($env$.name));         $result$.push(\""!\"");     }     else {         $result$.push(module.$escapeHTML$($env$.greetingWorld));         $result$.push(\"" \"");         $result$.push(module.$escapeHTML$($env$.name));         $result$.push(\""!\"");     }      if (!$target$) return $result$.join('');     else return null; }; return module; });""  Adding Custom Print Directives You can add custom print directives. For example, printing integers as hexadecimal values: CL-USER> (closure-template:define-print-syntax printHex ""hex"" (:constant t))  CLOSURE-TEMPLATE.PARSER::PRINT-DIRECTIVE CL-USER> (closure-template:register-print-handler :common-lisp-backend 'printHex :function #'(lambda (params end value) (format nil ""~X"" value))) #<Anonymous Function #x302001B7085F> CL-USER> (defparameter *template* ""      /*       *  Greets a person using 'Hello' by default.       */     {namespace closureTemplate.Example}     {template helloName}     Hello {$name} {$param|hex}!     {/template}"") *TEMPLATE* CL-USER> (closure-template:compile-template :common-lisp-backend *template*) #<Package ""CLOSURE-TEMPLATE.EXAMPLE""> CL-USER> (closure-template.example:hello-Name '(:name ""Name"" :param 128)) ""Hello Name 80!""  To use Javascript backend, you need to register a handler for Javascript or RequireJS backends. This is a more complex example which shows how to handle parameters of the directive: CL-USER> (closure-template:define-print-syntax printHex (and ""hex"" (esrap:? (and "":"" (or ""upper"" ""lower""))))            (:destructure (tag value)                          (declare (ignore tag))                          (list (if (and value (string= (second value) ""lower"")) 'case-lower 'case-upper)))) PRINT-HEX CL-USER> (closure-template:register-print-handler :common-lisp-backend 'printHex                                                   :function #'(lambda (params env value)                                                                 (declare (ignore env))                                                                 (format nil (if (member 'case-lower params) ""~(~X~)"" ""~X"") value))) PRINT-HEX CL-USER> (closure-template:register-print-handler :javascript-backend 'printHex                                          :handler ""function (params, value) { var result = value.toString(16); if (params.case == \""upper\"") { result = result.toUpperCase(); } return result; }""                                          :parameter-converter #'(lambda (params)                                                                   (format nil ""{ case: \""~A\""; }"" (if (member 'case-lower params) ""lower"" ""upper""))))  PRINTHEX CL-USER> (defparameter *template* ""      /*       *  Greets a person using 'Hello' by default.       */     {namespace closureTemplate.Example}     {template helloName}     Hello {$name} {$param|hex:lower}!     {/template}"") *TEMPLATE* CL-USER> (closure-template.example:hello-name '(name ""Name"" :param 143)) ""Hello Name 8F!""  You can also use a predefined function by name or RequireJS module. For detals, please see docstrings for REGISTER-PRINT-HANDLER implementations. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/archimag/cl-closure-template"	"Implementation of Google's Closure templates.."	"true"
"Network and Internet"	"cl-irc"	"https://www.common-lisp.net/project/cl-irc/"	"An IRC client library.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"null"	"null"	"null"	"cl-irc cl-irc 0.9.2 cl-irc is a Common Lisp IRC client library that features (partial) DCC, CTCP and all relevant commands from the IRC RFCs (RFC2810, RFC2811 and RFC2812). It uses ASDF and has been tested mostly on SBCL but should work for other implementations with little or no extra code. The code is released under an MIT-style license. I need to mention that Jochen Schmidt laid the groundwork for this library with his Weird-IRC IRC client and that therefore some of the code is copyright him. News Version 0.9.2 released (SBCL destroy-thread deprecation) Version 0.9.1 released (lots of fixes) Version 0.8.1 released (small fixes: KICK message processing, channel mode tracking) Version 0.8.0 released (user and channel mode tracking, characterset support on the irc network) Version 0.7.0 released (RPL_ISUPPORT, many small tweaks and fixes) Version 0.6.0 released (interim release while common-lisp.net was down) Version 0.5.0 released (package rename and minor changes) Version 0.4.0 released (some documentation, beginnings of a test suite, better performance) Features implements all commands in the RFCs extra convenience commands such as op/deop, ban, ignore, etc. partial DCC SEND/CHAT support event driven model with hooks makes interfacing easy the user can keep multiple connections all CTCP commands Installation If you have asdf-install, just: $ asdf-install cl-irc cl-irc can manually be downloaded from here: cl-irc_latest.tar.gz . There is also anonymous Subversion and WebSVN . Contact Questions, feature requests, and bug-reports are welcome on cl-irc-devel@common-lisp.net. Sample usage    * (require :cl-irc)    * (in-package :irc)    * (defvar connection (connect :nickname ""mynick""                                 :server ""irc.somewhere.org""))    * (read-message-loop connection)  ;; That's it.  Interrupt the read-message-loop and do:    * (join connection ""#lisp"")  ;; etc. (look at command.lisp) to operate the library.  After issuing ;; a command, you need to get back on the feed:    * (read-message-loop connection)  ;; If you need to do something on every join, do:    * (defun my-hook (message)      <do-something>)    * (add-hook connection 'irc-join-message #'my-hook)  ;; and it will be run next time the library receives an ;; irc-join-message.  For a full list of messages you can hook into, ;; look at event.lisp.  ;; Your connection object will get updated by the library with regards ;; to users joining/parting channels, you joining/parting channels, ;; etc.  Look at protocol.lisp's connection object for slots and ;; methods."	"null"	"null"	"An IRC client library.."	"true"
"Network and Internet"	"cl-markup"	"https://github.com/arielnetworks/cl-markup"	"Modern markup generation library.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"35"	"8"	"4"	"GitHub - arielnetworks/cl-markup: Modern markup (HTML) generation library for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 8 Star 35 Fork 4 arielnetworks/cl-markup Code Issues 3 Pull requests 1 Pulse Graphs Modern markup (HTML) generation library for Common Lisp 75 commits 2 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags i18n master Nothing to show Nothing to show New pull request Latest commit e0eb7de Sep 17, 2013 fukamachi Add tests for *AUTO-ESCAPE*. Permalink Failed to load latest commit information. src test .gitignore added .gitignore Jan 6, 2011 README.markdown cl-markup-test.asd cl-markup.asd README.markdown CL-MARKUP - Modern markup generation library for Common Lisp Features & advantages Fast (even faster through compiling the code) Safety Support for multiple document types (markup, xml, html, html5, xhtml) Output with doctype Direct output to stream Usage (html  (:body   (:p :id ""title"" ""aiueo""))) ;=> ""<!DOCTYPE HTML PUBLIC \""-//W3C//DTD HTML 4.01 Transitional//EN\"" ;    \""http://www.w3.org/TR/html4/loose.dtd\""> ;    <html><body><p id=\""title\"">aiueo</p></body></html>""  Installation Is this really fast? Generally CL-MARKUP generates efficient codes which mainly consists of series of `write-string's as much as possible. See how following two examples are expanded by macro expansion. As you can see, the codes are a bit more complicated than that of CL-WHO because CL-MARKUP alters the destination of output in run-time. Example A: ;; Example A (let ((*output-stream* t))    (loop for (link . title) in '((""http://zappa.com/"" . ""Frank Zappa"")                                  (""http://marcusmiller.com/"" . ""Marcus Miller"")                                  (""http://www.milesdavis.com/"" . ""Miles Davis""))          do (markup (:a :href link                         (:b title))                     (:br))))  ;; Example A: generated by CL-MARKUP (let ((*output-stream* t))   (loop for (link . title) in '((""http://zappa.com/"" . ""Frank Zappa"")                                 (""http://marcusmiller.com/"" . ""Marcus Miller"")                                 (""http://www.milesdavis.com/"" . ""Miles Davis""))         do (if *output-stream*                (progn (write-string ""<a href=\"""" *output-stream*)                       (write-string (escape-string (cl-markup::ensure-string link))                                     *output-stream*)                       (write-string ""\""><b>"" *output-stream*)                       (write-string (escape-string (cl-markup::ensure-string title))                                     *output-stream*)                       (write-string ""</b></a><br />"" *output-stream*))                (with-output-to-string (#:G0)                  (write-string ""<a href=\"""" #:G0)                  (write-string (escape-string (cl-markup::ensure-string link)) #:G0)                  (write-string ""\""><b>"" #:G0)                  (write-string (escape-string (cl-markup::ensure-string title)) #:G0)                  (write-string ""</b></a><br />"" #:G0)))))  Example B: ;; Example B (markup  (:table :border 0 :cellpadding 4          (loop for i below 25 by 5                collect                (markup                  (:tr :align ""right""                       (loop for j from i below (+ i 5)                             collect                             (markup                               (:td :bgcolor                                    (if (oddp j)                                        ""pink""                                        ""green"")                                    (format nil ""~@R"" (1+ j))))))))))  ;; Example B: generated by CL-MARKUP (if *output-stream*     (progn (write-string ""<table border=\""0\"" cellpadding=\""4\"">""                          *output-stream*)            (write-string (let ((#:G0                                 (loop for i below 25 by 5                                       collect (markup                                                (:tr                                                 :align                                                 ""right""                                                 (loop for j                                                       from                                                       i                                                       below                                                       (+ i 5)                                                  collect (markup                                                           (:td                                                            :bgcolor                                                            (if                                                             (oddp j)                                                             ""pink""                                                             ""green"")                                                            (format                                                             nil                                                             ""~@r""                                                             (1+ j))))))))))                                 (if (consp #:G0)                                     (with-output-to-string (#:G1)                                       (dolist (#:G2 #:G0)                                         (write-string #:G2 #:G1)))                                     #:G0))                                *output-stream*)                            (write-string ""</table>"" *output-stream*))                          (with-output-to-string (#:G0)                            (write-string ""<table border=\""0\"" cellpadding=\""4\"">""                                          #:G0)                            (write-string (let                                           ((#:G0                                             (loop for i below 25 by 5                                              collect (markup                                                       (:tr                                                        :align                                                        ""right""                                                        (loop for j                                                              from                                                              i                                                              below                                                              (+ i 5)                                                         collect (markup                                                                  (:td                                                                   :bgcolor                                                                   (if                                                                    (oddp j)                                                                    ""pink""                                                                    ""green"")                                                                   (format                                                                    nil                                                                    ""~@r""                                                                    (1+                                                                     j))))))))))                                             (if                                              (consp #:G0)                                              (with-output-to-string                                               (#:G1)                                               (dolist                                                (#:G2 #:G0)                                                (write-string #:G2 #:G1)))                                              #:G0))                                            #:G0)                                           (write-string ""</table>"" #:G0)))  Markup language markup is the simplest way to generate HTML. (markup (:p ""あいうえお"")) ;=> ""<p>あいうえお</p>""  By default, CL-MARKUP follows XHTML valid styling. (markup (:br)) ;=> ""<br />""  You can configure the style by setting *markup-language*. (eval-when (:compile-toplevel :load-toplevel :execute)   (setf *markup-language* :html))  Don't forget to wrap setf with eval-when since it is used in compile-time in order to expand markup. This also means you are NOT allowed to write codes like this: ;; THIS IS A WRONG EXAMPLE!! (let ((*markup-language* :html))   (markup (:br))) ;=> ""<br />""  In case you really want to delay the decision until run-time, use markup*, a functional version of markup. ;; This is a correct one. ;; But I don't recommend this for performance. (let ((*markup-language* :xhtml))   (markup* '(:br))) ;=> ""<br>""  Other macros such as html, xhtml, html5, and xml output DOCTYPE before markup. (html (:p ""あいうえお"") (:br)) ;=> ""<!DOCTYPE HTML PUBLIC \""-//W3C//DTD HTML 4.01 Transitional//EN\"" \""http://www.w3.org/TR/html4/loose.dtd\""><html><p>あいうえお</p><br></html>""  (html5 (:p ""あいうえお"") (:br)) ;=> ""<!DOCTYPE html><html><p>あいうえお</p><br></html>""  (xhtml (:p ""あいうえお"") (:br)) ;=> ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Transitional//EN\"" \""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\""><html><p>あいうえお</p><br /></html>""  (xml (:p ""あいうえお"") (:br)) ;=> ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><p>あいうえお</p><br />""  Escape Embedded strings are escaped automatically. (markup (:p ""Tiffany & Co."")) ;=> ""<p>Tiffany &amp; Co.</p>""  If you don't want this behavior, set *auto-escape* nil or use raw for temporal suppression. (let ((*auto-escape* nil))   (markup (:p ""Tiffany & Co.""))) ;=> ""<p>Tiffany & Co.</p>""  (markup (:p (raw ""Tiffany & Co.""))) ;=> ""<p>Tiffany & Co.</p>""  Also, when you want to ensure a certain code to be escaped (maybe inside raw) use esc, which has the similar syntax as that of raw. Direct output to stream Markup macros returns html as a string. This behavior can be customized by modifying *output-stream* which is defaulted to *standard-output*. ;; Default behavior (let (*output-stream*)   (markup (:p ""hoge"")) ;=> ""<p>hoge</p>""  ;; Output to *standard-output* directly (let ((*output-stream* t))   (markup (:p ""hoge""))) ;;=> <p>hoge</p> ;=> ""<p>hoge</p>""  Markup syntax You can embed Lisp code in the body of each tag. (markup (:ul (loop for item in '(1 2 3) collect (markup (:li item)))))  For more readability, CL-MARKUP provides a reader macro #M which can be enabled by (enable-markup-syntax). (enable-markup-syntax) #M(:ul (loop for item in '(1 2 3) collect #M(:li item))))  License Copyright (c) 2011 Eitarow Fukamachi. Contributors: m7d - HTML5 support, April 21, 2012. Licensed under the LLGPL License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/arielnetworks/cl-markup"	"Modern markup generation library.."	"true"
"Network and Internet"	"cl-openid"	"https://common-lisp.net/project/cl-openid/darcs/cl-openid/"	"An implementation of OpenID.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Index of /project/cl-openid/darcs/cl-openid Index of /project/cl-openid/darcs/cl-openid Name Last modified Size Description Parent Directory   -   README.html 04-Sep-2011 23:24 31K   README.org 04-Sep-2011 23:24 14K   README.txt 12-Jun-2011 01:02 20K   _darcs/ 23-Feb-2013 05:29 -   cl-openid.asd 11-Jul-2011 23:47 2.4K   clopenid.patch 04-Sep-2011 22:21 9.4K   examples/ 15-Aug-2011 20:41 -   log 09-Jun-2010 21:28 26K   patch 23-Feb-2013 05:29 9.7K   shelf.lisp 18-Aug-2008 17:47 1.6K   src/ 23-Feb-2013 05:29 -   t/ 17-Aug-2011 01:19 -   CL-OpenID CL-OpenID Cl-OpenID is an implementation of OpenID protocol in Common Lisp. It implements OpenID Authentication 2.0 standard and is compatible with OpenID Authentication 1.1. Both Relying Party (formerly called OpenID Consumer), and OpenID Provider are implemented. CL-OpenID is available on terms of GNU Lesser General Public License version 2.1 with Franz Inc.'s preamble, also known as LLGPL (Lisp Lesser General Public License). The project is developed as a Google Summer of Code 2008 project, developed by Maciej Pasternacki and mentored by Anton Vodonosov. Original application is published at http://trac.common-lisp.net/cl-openid/wiki/OriginalProposal. Table of Contents 1 Contact 2 Downloading 2.1 Dependencies 2.1.1 CL-Librarian shelf 2.2 Example code 3 API 3.1 Relying Party 3.1.1 Class RELYING-PARTY 3.1.1.1 Accessor ROOT-URI relying-party ⇒ uri 3.1.1.2 Accessor REALM relying-party ⇒ uri 3.1.2 Constant +AUTHPROC-HANDLE-PARAMETER+ 3.1.3 Function INITIATE-AUTHENTICATION relying-party given-id &key immediate-p extra-parameters ⇒ uri 3.1.4 Function HANDLE-INDIRECT-RESPONSE relying-party message request-uri &optional auth-process ⇒ authendicated-id auth-process 3.1.5 Condition OPENID-ASSERTION-ERROR 3.1.5.1 Accessor CODE openid-assertion-error ⇒ keyword 3.1.5.2 Accessor REASON openid-assertion-error ⇒ string 3.1.5.3 Accessor AUTHPROC openid-assertion-error ⇒ auth-process 3.1.5.4 Accessor MESSAGE openid-assertion-error ⇒ message 3.1.6 Structure AUTH-PROCESS 3.1.6.1 Function AUTH-PROCESS-P object ⇒ boolean 3.1.6.2 Accessor PROTOCOL-VERSION-MAJOR auth-process ⇒ integer 3.1.6.3 Accessor PROTOCOL-VERSION-MINOR auth-process ⇒ integer 3.1.6.4 Accessor PROTOCOL-VERSION auth-process ⇒ cons 3.1.6.5 Accessor CLAIMED-ID auth-process ⇒ uri 3.1.6.6 Accessor OP-LOCAL-ID auth-process ⇒ uri 3.1.6.7 Accessor PROVIDER-ENDPOINT-URI auth-process ⇒ uri 3.1.6.8 Accessor RETURN-TO auth-process ⇒ uri 3.1.6.9 Accessor TIMESTAMP auth-process ⇒ universal-time 3.1.6.10 Accessor XRDS-LOCATION auth-process ⇒ uri 3.2 OpenID Provider 3.2.1 Class OPENID-PROVIDER 3.2.1.1 Accessor ENDPOINT-URI op ⇒ uri 3.2.2 Constant +INDIRECT-RESPONSE-CODE+ 3.2.3 Function HANDLE-OPENID-PROVIDER-REQUEST op message &key allow-unencrypted-association-p ⇒ response values 3.2.4 Function CANCEL-RESPONSE-URI op message ⇒ uri 3.2.5 Function SUCCESSFUL-RESPONSE-URI op auth-request-message ⇒ uri 3.2.6 Generic HANDLE-CHECKID-IMMEDIATE op message ⇒ generalized-boolean 3.2.7 Generic HANDLE-CHECKID-SETUP op message ⇒ response values 3.2.8 Protocol messages 3.2.8.1 Function MAKE-MESSAGE &rest parameters ⇒ message 3.2.8.2 Function COPY-MESSAGE message &rest parameters ⇒ message 3.2.8.3 Function IN-NS message &optional namespace ⇒ message 3.2.8.4 Function MESSAGE-FIELD message field-name ⇒ value 3.2.8.5 Function MESSAGE-V2-P message ⇒ boolean 3.2.8.6 Function AUTH-REQUEST-REALM auth-request-message ⇒ string 1 Contact Discussions regarding development are conducted on cl-openid-devel mailing list. This is the best place to bring up questions, suggestions or to discuss issues connected with CL-OpenID. Important announcements are posted to cl-openid-announce mailing list. This is a low-volume, announcement-only list. All the announcements are also posted on development list. Bugs are tracked on project's Trac bugtracker. Interface for submitting new tickets is available at http://trac.common-lisp.net/cl-openid/newticket. All ticket change notifications are sent to cl-openid-ticket mailing list. Miscellaneous information on project, of various quality and relevance, can be found on project's Trac wiki. 2 Downloading Project Web page is http://common-lisp.net/project/cl-openid/. Most recent version of the code can be downloaded with darcs:  darcs get http://common-lisp.net/project/cl-openid/darcs/cl-openid/  2.1 Dependencies Project depends on following libraries: drakma, ironclad, xmls, split-sequence, cl-base64, trivial-utf-8, bordeaux-threads puri, secure-random cl-html-parse (on implementations other than Allegro CL). Example code depends also on Hunchentoot. Unit tests depend on FiveAM testing framework. All required libraries should be ASDF-installable, so running darcs dist and then calling ASDF-INSTALL:INSTALL on resulting tarball should provide complete dependencies. 2.1.1 CL-Librarian shelf As an alternative to ASDF-Install, a CL-Librarian shelf definition for dependencies is provided. To use it, run following shell commands in CL-OpenID directory:  darcs get http://www.pasternacki.net/repos/cl-librarian/ lib cd lib sh bootstrap.sh cd ..  Then start your favourite Lisp implementation and call:  (load ""shelf"") (cl-librarian:download-shelf 'cl-openid.deps) ; for the first time or when new dependency is added (cl-librarian:use-shelf 'cl-openid.deps) ; when libraries are already downloaded (asdf:oos 'asdf:load-op :cl-openid) (asdf:oos 'asdf:test-op :cl-openid) ; run 5am unit tests  2.2 Example code Example implementation of Relying Party and OpenID Provider for Hunchentoot web server is included in examples/ subdirectory. For convenience, both examples can be loaded as CL-OPENID.EXAMPLES ASDF system:  (asdf:oos 'asdf:load-op :cl-openid.examples)  3 API 3.1 Relying Party 3.1.1 Class RELYING-PARTY Relying Party class. 3.1.1.1 Accessor ROOT-URI relying-party ⇒ uri Root URI address of the Relying Party instance. Used to generate return_to redirections. 3.1.1.2 Accessor REALM relying-party ⇒ uri Relying Party realm. 3.1.2 Constant +AUTHPROC-HANDLE-PARAMETER+ Name of HTTP GET parameter, sent in return_to URI, which contains AUTH-PROCESS object unique handle. 3.1.3 Function INITIATE-AUTHENTICATION relying-party given-id &key immediate-p extra-parameters ⇒ uri Initiate authentication process by relying-party for identifier given-id received from user. If immediate-p is true, initiates immediate authentication process. The extra-parameters is an optional key-value list to be added to the authentication request message. The list format is the same as for the MAKE-MESSAGE function. This parameter is needed for OpenID extensions, for example OAuth or Attribute Exchange. Returns multiple values: the URI to redirect the user's browser to; Unique handle (string) identifying the started authentication process; the AUTH-PROCESS structure identified by the handle. The latter two values are useful if the client code needs to track the process. 3.1.4 Function HANDLE-INDIRECT-RESPONSE relying-party message request-uri &optional auth-process ⇒ authendicated-id auth-process Handle indirect response message for relying-party, coming at request-uri, concerning authproc. authproc can be a literal AUTH-PROCESS object, or a string (unique authproc handle, sent earlier by Relying Party). When authproc is NIL or not supplied, its handle is taken from message field named +AUTHPROC-HANDLE-PARAMETER+. Returns claimed ID URI on success, NIL on failure. As second value, always returns AUTH-PROCESS object. 3.1.5 Condition OPENID-ASSERTION-ERROR Error signaled by Relying Party when indirect response cannot be verified correctly. 3.1.5.1 Accessor CODE openid-assertion-error ⇒ keyword Keyword code of error. Possible values are :SERVER-ERROR (received response is an erroor message), :SETUP-NEEDED (negative response to immediate request), :INVALID-RETURN-TO (request doesn't match previously sent openid.return_to), :INVALID-NAMESPACE (invalid openid.ns in received message), :INVALID-ENDPOINT (endpoint specified in assertion does not match previously discovered information), :INVALID-CLAIMED-ID (received claimed_id differs from specified previously, discovery for received claimed ID returns other endpoint), :INVALID-NONCE (repeated openid.nonce), :INVALID-SIGNATURE (signature verification failed), :INVALID-SIGNED-FIELDS (not all fields that need to be signed, were signed). 3.1.5.2 Accessor REASON openid-assertion-error ⇒ string Textual description of error. 3.1.5.3 Accessor AUTHPROC openid-assertion-error ⇒ auth-process The AUTH-PROCESS structure that was being verified. 3.1.5.4 Accessor MESSAGE openid-assertion-error ⇒ message Received message (an association list). 3.1.6 Structure AUTH-PROCESS Data structure gathering information about an ongoing authentication process. 3.1.6.1 Function AUTH-PROCESS-P object ⇒ boolean Returns true if object is an AUTH-PROCESS structure. 3.1.6.2 Accessor PROTOCOL-VERSION-MAJOR auth-process ⇒ integer Protocol version major number of auth-process. 3.1.6.3 Accessor PROTOCOL-VERSION-MINOR auth-process ⇒ integer Protocol version minor number of auth-process. 3.1.6.4 Accessor PROTOCOL-VERSION auth-process ⇒ cons Protocol version of an authentication process, as a cons (MAJOR . MINOR). 3.1.6.5 Accessor CLAIMED-ID auth-process ⇒ uri Claimed ID of an auth proces. 3.1.6.6 Accessor OP-LOCAL-ID auth-process ⇒ uri OP-local id of an auth process. 3.1.6.7 Accessor PROVIDER-ENDPOINT-URI auth-process ⇒ uri Discovered endpoint URI. 3.1.6.8 Accessor RETURN-TO auth-process ⇒ uri Authentication process' return_to address. It is Relying Party's root URI with added HTTP GET parameter named +AUTHPROC-HANDLE-PARAMETER+ whose value is authproc's unique handle. 3.1.6.9 Accessor TIMESTAMP auth-process ⇒ universal-time Universal time of authentication process structure's creation. 3.1.6.10 Accessor XRDS-LOCATION auth-process ⇒ uri Address of XRDS file used in auth-process discovery. 3.2 OpenID Provider 3.2.1 Class OPENID-PROVIDER OpenID Provider server abstract class. This class should be subclassed, and specialized methods should be provided at least for HANDLE-CHECKID-SETUP (preferably also for HANDLE-CHECKID-IMMEDIATE). 3.2.1.1 Accessor ENDPOINT-URI op ⇒ uri OpenID Provider instance's endpoint URI 3.2.2 Constant +INDIRECT-RESPONSE-CODE+ HTTP code recommented to use for indirect responses sent via HTTP redirect. 3.2.3 Function HANDLE-OPENID-PROVIDER-REQUEST op message &key allow-unencrypted-association-p ⇒ response values Handle request message for OpenID Provider instance op. secure-p should be passed by caller to indicate whether it is secure to use unencrypted association method. allow-unencrypted-association-p specifies whether it is allowable to use unencrypted association method. Set it to NIL unless your OP endopoint uses HTTPS. See OpenID Authentication 2.0 - Final, section 8.4.1. No-Encryption Association Sessions (http://openid.net/specs/openid-authentication-2\_0.html#assoc\_sess\_types). Returns two values: first is body, and second is HTTP code. On HTTP redirections (the second value between 300 and 399 inclusive), the primary returned value will be an URI to redirect the user to. 3.2.4 Function CANCEL-RESPONSE-URI op message ⇒ uri Returns the URI of the Relying Party to redirect the user's browser to. The URI parameters tell the Relying Party that the authentication failed. auth-request-message should be the oritinal OpenID authentication request message that was received from the Relying Party previously and passed to the HANDLE-CHECKID-SETUP. 3.2.5 Function SUCCESSFUL-RESPONSE-URI op auth-request-message ⇒ uri Returns the URI of the Relying Party to redirect the user's browser to. The URI parameters tell the Relying Party that the authentication was successful. auth-request-message should be the oritinal OpenID authentication request message that was received from the Relying Party previously and passed to the HANDLE-CHECKID-SETUP. 3.2.6 Generic HANDLE-CHECKID-IMMEDIATE op message ⇒ generalized-boolean Handle checkid_immediate requests. This generic should be specialized on concrete Provider classes to perform immediate login checks on MESSAGE. It should return at once, either true value (to indicate successful login), or NIL (to indicate immediate login failure). Default method always fails. 3.2.7 Generic HANDLE-CHECKID-SETUP op message ⇒ response values Handles checkid_setup requests. This generic should be specialized on concrete Provider classes to perform login checks with user dialogue, that would (possibly after some HTTP request-response cycles) end by redirecting the user's browser either to SUCCESSFUL-RESPONSE-URI, or to CANCEL-RESPONSE-URI. This generic is called by HANDLE-OPENID-PROVIDER-REQUEST, and the values returned by this function are then returned by HANDLE-OPENID-PROVIDER-REQUEST. I.e. it must return two values: response \""body\"" and HTTP status code. That way HANDLE-CHECKID-SETUP can either redirect user's browser somewhere, or just show him something. (With hunchentoot, HUNCHNTOOT:REDIRECT may also be used, which is a non-local transfer control). Default method just returns (VALUES (CANSEL-RESPONSE-URI …) +INDIRECT-RESPONSE-CODE+). 3.2.8 Protocol messages Messages passed between OpenID Provider and the Relying Party are composed of key-value pairs. Natural Lisp representation of those, and the one used in CL-OpenID, is an association list. A handful of conveniense function is provided to avoid tweaking messages on cons level. 3.2.8.1 Function MAKE-MESSAGE &rest parameters ⇒ message Make new message from arbitrary keyword parameters. Keyword specifies a message field key (actual key is lowercased symbol name), and value following the keyword specifies associated value. Value can be a string (which will be literal field value), symbol (symbol's name will be used as a value), vector of (UNSIGNED-BYTE 8) (which will be Base64-encoded), URI object or integer (which both will be PRINC-TO-STRING-ed). If value is NIL, field won't be included in the message at all. 3.2.8.2 Function COPY-MESSAGE message &rest parameters ⇒ message Create a copy of MESSAGE, updating PARAMETERS provided as keyword parameters. If MESSAGE already includes provided key, new value is used in the result; if a key is new, the field will be appended to result message. PARAMETERS are interpreted as by MAKE-MESSAGE function. 3.2.8.3 Function IN-NS message &optional namespace ⇒ message Add openid.namespace namespace to message. Default namespace is OpenID v2. Returns updated message alist. 3.2.8.4 Function MESSAGE-FIELD message field-name ⇒ value Get value of field-name field from message. 3.2.8.5 Function MESSAGE-V2-P message ⇒ boolean True if message is an OpenID v2 message (namespace check). 3.2.8.6 Function AUTH-REQUEST-REALM auth-request-message ⇒ string Returns the realm of the OpenID authentication request auth-request-message. Author: Maciej Pasternacki Date: 2011-09-04 03:41:16 HTML generated by org-mode 6.36c in emacs 23"	"null"	"null"	"An implementation of OpenID.."	"true"
"Network and Internet"	"cl-who"	"http://weitz.de/cl-who/"	"An HTML generator.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"41"	"9"	"13"	"GitHub - edicl/cl-who: Yet another Lisp markup language Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 9 Star 41 Fork 13 edicl/cl-who Code Issues 1 Pull requests 1 Pulse Graphs Yet another Lisp markup language http://weitz.de/cl-who/ 49 commits 1 branch 5 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v1.1.4 v1.1.3 v1.1.2 v1.1.1 v1.1.0 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. doc test CHANGELOG cl-who.asd packages.lisp specials.lisp util.lisp who.lisp Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/edicl/cl-who"	"An HTML generator.."	"true"
"Network and Internet"	"cl-ses"	"https://github.com/CodyReichert/cl-ses/"	"Library for AWS SES.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"10"	"2"	"0"	"GitHub - CodyReichert/cl-ses: Send emails from Common Lisp with AWS SES Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 10 Fork 0 CodyReichert/cl-ses Code Issues 0 Pull requests 0 Pulse Graphs Send emails from Common Lisp with AWS SES 8 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src t .gitignore LICENSE.txt README.org cl-ses-test.asd cl-ses.asd qi.yaml README.org cl-ses cl-ses is a Common Lisp package for sending email with AWS’s SES. Usage cl-ses exports the send-email function: (cl-ses:send-email :from ""me@example.com""                    :to ""you@example.com""                    :subject ""Hello from CL-SES""                    :message ""The body of the email message""                    :aws-access-key ""XXXXXX""                    :aws-secret-key ""XXXXXXXXXXX"") send-email returns T if the status was 200 (OK), and NIL otherwise. In the future I’ll hopefully have implemented better error reporting. Setting the Content-Type There is support for setting the email’s Content-Type. I’ve tested with text/plain and text/html, but others should work as well: (cl-ses:send-email ...                    ...                    :content-type ""text/html""                    ...) The content-type key is optional, and defaults to text/plain. Mulitple Recipients You can specify multiple recipients by using a comma separated list of email addresses: (cl-ses:send-email ...                    :to ""first@example.com,second@example.com""                    ...                    ...) Setting a name in the from field This isn’t really AWS Specific, but you can set a “Name” in the from parameter (you still need an email address): (cl-ses:send-email :from ""My Name <me@example.com>""                    ...                    ...) Dependencies Drakma is the only external dependency Installation With Qi Add it another system’s qi.yaml, or load it directly: (load ""cl-ses.asd"") (qi:install :cl-ses) With Quicklisp Install to local-projects, then it’s quickloadable: git clone git@github.com:CodyReichert/cl-ses ~/quicklisp/local-projects= (ql:quickload :cl-ses) Author Cody Reichert (codyreichert@gmail.com) Copyright Copyright (c) 2015 Cody Reichert (codyreichert@gmail.com) Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/CodyReichert/cl-ses/"	"Library for AWS SES.."	"true"
"Network and Internet"	"spinneret"	"https://github.com/ruricolist/spinneret"	"Common Lisp HTML5 generator.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"30"	"5"	"1"	"GitHub - ruricolist/spinneret: Common Lisp HTML5 generator Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 30 Fork 1 ruricolist/spinneret Code Issues 0 Pull requests 0 Pulse Graphs Common Lisp HTML5 generator 85 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit 5d0ef9c Jun 7, 2016 ruricolist Merge branch 'PuercoPop-remove-deftemplate' Permalink Failed to load latest commit information. LICENSE.txt Initial import. Apr 3, 2012 README.md Update readme. Jun 7, 2016 cl-markdown.lisp Split cl-markdown feature into its own system Aug 2, 2015 compile.lisp Split cl-markdown feature into its own system Aug 2, 2015 deftag.lisp Allow destructuring in deftag. Jan 28, 2016 functions.lisp Use tag name for lookups. Dec 29, 2014 package.lisp Remove deftemplate from exported symbols Jun 7, 2016 ps.lisp class-union -> join-tokens Dec 29, 2014 run.lisp Quiet Clozure style-warnings. Sep 15, 2014 spinneret.asd Update readme. Aug 4, 2015 spinneret.lisp Introduce *html-path*. Mar 22, 2013 syntax.lisp Simple iterative remove-substring. Nov 26, 2014 tags.lisp Remove duplicate entry, autofocus Jun 1, 2016 tests.lisp Test suite. Feb 9, 2015 README.md Spinneret In the crowded space of Common Lisp HTML generators, SPINNERET occupies the following coordinates: Modern. Targets HTML5. Does not treat XML and HTML as the same problem. Assumes you will be serving your documents as UTF-8. Composable. Makes it easy to refactor HTML generation into separate functions and macros. Pretty. Treats HTML as a document format, not a serialization. Output is idiomatic and readable, following the coding style of the HTML5 specification. Aggressive. If something can be interpreted as HTML, then it will be, meaning that some Lisp forms can't be mixed with HTML syntax. In the trade-off between 90% convenience and 10% correctness SPINNERET is on the side of convenience. Bilingual. Spinneret has the same semantics in Lisp and Parenscript. HTML generation with SPINNERET looks like this:  (in-package #:spinneret)   (defparameter *shopping-list*    '(""Atmospheric ponds""      ""Electric gumption socks""      ""Mrs. Leland's embyronic television combustion""      ""Savage gymnatic aggressors""      ""Pharmaceutical pianos""      ""Intravenous retribution champions""))   (defparameter *user-name* ""John Q. Lisper"")   (defparameter *last-login* ""12th Never"")   (defmacro with-page ((&key title) &body body)    `(with-html       (:doctype)       (:html         (:head          (:title ,title))         (:body ,@body))))   (defun shopping-list ()    (with-page (:title ""Home page"")      (:header       (:h1 ""Home page""))      (:section       (""~A, here is *your* shopping list: "" *user-name*)       (:ol (dolist (item *shopping-list*)              (:li (1+ (random 10)) item))))      (:footer (""Last login: ~A"" *last-login*))))  Which produces:  <!DOCTYPE html>  <html lang=en>   <head>    <meta charset=UTF-8>    <title>Home page</title>   </head>   <body>    <header>     <h1>Home page</h1>    </header>    <section>     John Q. Lisper, here is <em>your</em> shopping list:     <ol>      <li>10 Atmospheric ponds      <li>6 Electric gumption socks      <li>4 Mrs. Leland's embyronic television combustion      <li>9 Savage gymnatic aggressors      <li>6 Pharmaceutical pianos      <li>9 Intravenous retribution champions     </ol>    </section>    <footer>     Last login: 12th Never    </footer>   </body>  </html>  (Pretty-printing is pretty fast, but SPINNERET obeys *print-pretty* should you want to turn it off.) Syntax The rules for WITH-HTML are these: All generated forms write to *html*. A keyword in function position is interpreted as a tag name. If the name is not valid as a tag, it is ignored. Certain keywords are recognized as pseudo-tags and given special treatment: :RAW :DOCTYPE :!DOCTYPE :CDATA :!-- :COMMENT :HTML :HEAD The value of the LANG attribute of HTML is controlled by *html-lang*; the value of the meta charset attribute is controlled by *html-charset*. Constant classes and ids can be specified with a selector-like syntax. E.g.: (:div#wrapper (:div.section ...)) ≡ (:div :id ""wrapper"" (:div :class ""section"" ...)) Keyword-value pairs following a tag are interpreted as attributes. HTML syntax may not be used in attribute values. Attributes with nil values are omitted. Boolean attributes with non-nil values are minimized. Duplicate attributes are handled like duplicate keyword arguments: all values are evaluated, but only the leftmost value is used. The exception is the class attribute: the class of a tag is the union of all its :CLASS arguments. The argument :DATASET introduces a list of :DATA-FOO arguments: (:p :dataset (:duck (dolomphious) :fish 'fizzgigious :spoon ""runcible"")) ≡ (:p :data-duck (dolomphious) :data-fish 'fizzgigious :data-spoon ""runcible"") For flexibility, even at the cost of efficiency, the argument :ATTRS introduces a form to evaluate at run time for a plist of extra attributes and values. Forms after the attributes are treated as arguments. Each non-nil (primary) value returned by an argument to a tag is written to the stream by HTML, a generic function on which you can define your own methods. By default only literal arguments are printed. Literal arguments are strings, characters, numbers and symbols beside NIL. WITH-HTML-STRING is like WITH-HTML, but intercepts the generated HTML at run time and returns a string. Markdown If the additional system spinneret/cl-markdown is loaded, then a string in function position is first compiled as Markdown (using CL-MARKDOWN), then passed to format as a control string and applied to its arguments. This is useful for inline formatting, like links, where sexps would be clumsy: (with-html  (""Here is some copy, with [a link](~a)"" link))  (with-html   (:span ""Here is some copy, with ""     (:a :href link ""a link."")))  *html-path* Sometimes it is useful for a piece of HTML-generating code to know where in the document it appears. You might, for example, want to define a tabulate that prints list-of-lists as rows of cells, but only prints the surrounding <table></table> if it is not already within a table. The symbol *HTML-PATH* holds a list of open tags, from latest to earliest. Usually it will look something like   *html-path* ;-> '(:table :section :body :html)  Thus `tabulate' could be written  (defun tabulate (&rest rows)    (with-html      (flet ((tabulate ()               (loop for row in rows do                 (:tr (loop for cell in row do                   (:td cell))))))        (if (find :table *html-path*)            (tabulate)            (:table (:tbody (tabulate)))))))  deftag The stumbling block for all sexp-based HTML generators is order of evaluation. It's tempting to write something like this:  ;; Doesn't work  (defun field (control)    (with-html (:p control)))   (defun input (default &key name label (type ""text""))    (with-html      (:label :for name label)      (:input :name name :id name :type type :value default)))  But it won't work: in (field (input ""Default"" :name ""why"" :label ""Reason"")), (input) gets evaluated before (field), and the HTML is printed inside-out. Macros do work:  (defmacro field (control)    `(with-html (:p ,control)))   (defmacro input (name label &key (type ""text""))    `(with-html       (:label :for ,name ,label)       (:input :name ,name :id ,name :type ,type)))  But we can do better than this. Spinneret provides a macro-writing macro, deftag, which lets you refactor HTML without hiding it.  (deftag field (control attrs)   `(:p ,@attrs ,@control))   (deftag input (default attrs &key name label (type ""text""))    (once-only (name)      `(progn         (:label :for ,name ,label)         (:input :name ,name :id ,name :type ,type           ,@attrs           :value (progn ,@default)))))  A macro defined using deftag takes its arguments just like an HTML element. Instead of (input ""Default"" :name ""why"" :label ""Reason"") ; defmacro  You write (input :name ""why"" :label ""Reason"" ""Default"") ; deftag  The macro re-arranges the arguments so they can be bound to an ordinary lambda list, like the one above: the body of the tag is bound to the first argument, and matching attributes are bound to keywords. Multiple :class arguments, :dataset, and other shorthands are handled exactly as in the usual HTML syntax. But the great advantage of deftag is how it handles attributes which are not bound to keywords. In the definition of input using deftag, you see that the attrs catch-all argument is spliced into the call to :input. This means that any unhandled attributes pass through to the actual input element. (input :name ""why"" :label ""Reason"" :required t :class ""special"" ""Default"") => <label for=why>Reason</label>    <input class=special name=why id=why type=text required value=Default>  In effect, input extends the :input tag, almost like a subclass. This is a very idiomatic and expressive way of building abstractions over HTML. (SPINNERET used to provide a more elaborate way of building HTML abstractions, deftemplate, but deftag is simpler and more useful.) Parenscript The semantics of SPINNERET in Parenscript are almost the same. There is no with-html-string, and with-html returns a DocumentFragment. If Markdown support is enabled, strings in function position are still parsed as Markdown, but supplying arguments triggers an error (since Parenscript does not have format). *html-path* is not implemented for Parenscript. Validation SPINNERET does not do document validation, but it does warn, at compile time, about invalid tags and attributes. Although HTML5 does include a mechanism for application-specific attributes (the data- prefix), some client-side frameworks choose to employ their own prefixes instead. You can disable validation for a given prefix by adding it to *unvalidated-attribute-prefixes*. (pushnew ""ng-"" *unvalidated-attribute-prefixes* :test #’equal)  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/ruricolist/spinneret"	"Common Lisp HTML5 generator.."	"true"
"Network and Internet"	"Clack"	"https://github.com/fukamachi/clack"	"A web application environment inspired by Rack and WSGI.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"524"	"71"	"58"	"GitHub - fukamachi/clack: Web application environment for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 71 Star 524 Fork 58 fukamachi/clack Code Issues 19 Pull requests 3 Pulse Graphs Web application environment for Common Lisp http://clacklisp.org 1,068 commits 7 branches 13 releases 20 contributors Common Lisp 99.8% Nginx 0.2% Common Lisp Nginx Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags fix-clack-test-for-abcl fix-clack-v1-compat fix-hunchentoot-handler-multi-app fix-single-thread fix-url-decoding-error fix-wookie-memory-corruption master Nothing to show 12.06.0 12.04.0 12.03.0 12.02.0 12.01.0 11.12.0 11.11.0 11.10.1 11.10.0 11.09.0 11.08.0 11.07.0 11.06.0 Nothing to show New pull request Latest commit 84d49a9 Jun 15, 2016 fukamachi Add server tests. Permalink Failed to load latest commit information. roswell Fix parse-value in clackup.ros to be able to read ""nil"". Oct 5, 2015 src Add server tests. Jun 15, 2016 t Allow to use a random port for each subtest in handler test suites. Aug 20, 2015 tmp forgot to add ""tmp"" directory, using clack.test.suite. Jan 26, 2011 v1-compat Replace cl-fad by UIOP. Aug 27, 2015 .gitignore Fix JSON middleware to recognize Content-Type that specifies a charse… Oct 19, 2013 .travis.yml The latest version of Jonathan, fast-http and fast-io are not needed … Dec 16, 2015 CONTRIBUTING.md Add CONTRIBUTING.md. Dec 16, 2015 README.markdown Add CONTRIBUTING.md. Dec 16, 2015 clack-handler-fcgi.asd Clean clack-handler-fcgi up. Mar 26, 2015 clack-handler-hunchentoot.asd Clean clack-handler-hunchentoot up. Mar 26, 2015 clack-handler-toot.asd Clean clack-handler-toot up. Mar 26, 2015 clack-handler-wookie.asd Add clack-socket to abstract :clack.io sockets in handlers. Aug 10, 2015 clack-socket.asd Add clack-socket to abstract :clack.io sockets in handlers. Aug 10, 2015 clack-test.asd Move clack-test files. Mar 26, 2015 clack-v1-compat.asd Replace cl-fad by UIOP. Aug 26, 2015 clack.asd Don't raise a debugger when press C-c while clackup. Feb 21, 2016 t-clack-handler-fcgi.asd Move core files. Mar 26, 2015 t-clack-handler-hunchentoot.asd Move core files. Mar 26, 2015 t-clack-handler-toot.asd Move core files. Mar 26, 2015 t-clack-handler-wookie.asd Move core files. Mar 26, 2015 t-clack-v1-compat.asd Add clack.request & clack.response and fix tests. Mar 26, 2015 README.markdown Clack - Web Application Environment for Common Lisp Clack is a web application environment for Common Lisp inspired by Python's WSGI and Ruby's Rack. Usage (defvar *handler*     (clack:clackup       (lambda (env)         (declare (ignore env))         '(200 (:content-type ""text/plain"") (""Hello, Clack!""))))) Open your web browser and go to http://localhost:5000/. You should get ""Hello, Clack!"". To stop the server, use (clack:stop *handler*). Command-line interface Clack provides a script to start a web server. It's useful when you deploy to production environment. NOTE: Install Roswell before as it depends on it. When you execute ros install clack, it copies clackup script to $HOME/.roswell/bin. Make sure the path is in your shell $PATH. $ ros install clack $ which clackup /Users/nitro_idiot/.roswell/bin/clackup  $ cat <<EOF >> app.lisp (lambda (env)   (declare (ignore env))   '(200 (:content-type ""text/plain"") (""Hello, Clack!""))) EOF $ clackup app.lisp Hunchentoot server is started. Listening on localhost:5000.  Installation (ql:quickload :clack) Documentation Quickdocs Page Server Hunchentoot FastCGI Wookie Toot Woo How to contribute See CONTRIBUTING.md. See Also Lack: Clack application builder Author Eitaro Fukamachi (e.arrows@gmail.com) Copyright Copyright (c) 2011-2015 Eitaro Fukamachi & contributors License Licensed under the LLGPL License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/clack"	"A web application environment inspired by Rack and WSGI.."	"true"
"Network and Internet"	"clack-errors"	"https://github.com/eudoxia0/clack-errors"	"Error page middleware for Clack.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"17"	"4"	"2"	"GitHub - eudoxia0/clack-errors: Error page middleware for Clack. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 4 Star 17 Fork 2 eudoxia0/clack-errors Code Issues 0 Pull requests 0 Pulse Graphs Error page middleware for Clack. 55 commits 1 branch 0 releases Fetching contributors JavaScript 59.1% Common Lisp 21.2% CSS 15.3% HTML 4.4% JavaScript Common Lisp CSS HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. demo src static t templates .gitignore .gitmodules .travis.yml README.md clack-errors-demo.asd clack-errors-test.asd clack-errors.asd lack-middleware-clack-errors.asd screenshot-dev.png screenshot-prod.png README.md clack-errors A clone of better_errors for Clack. By default, when Clack throws an exception when rendering a page, the server waits for the response until it times out while the exception waits in the REPL. This isn't very useful. So now there's this. Usage This, (clack:clackup   (funcall clack-errors:*clack-error-middleware*            *my-clack-app*            :debug t)   :port 8000))) will wrap your Clack up in the clack-errors middleware, start the server and return a handler object. By default, the middleware will show all information. In a production environment, you'll want to initialize this with the :debug parameter set to NIL. Using a Custom Error Page The middleware can be initialized with the :fn slot set to a lambda that takes a condition as its argument and returns the HTML string to return to the client. (clack:clackup   (funcall clack-errors:*clack-error-middleware*     *app*     :fn (lambda (condition) ""500 Internal Server Error""))) License Copyright (c) 2013-2016 Fernando Borretti (eudoxiahp@gmail.com) Licensed under the LLGPL License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/eudoxia0/clack-errors"	"Error page middleware for Clack.."	"true"
"Network and Internet"	"colleen"	"https://github.com/Shinmera/colleen"	"IRC bot with a modular framework.."	"null"	"null"	"null"	"Artistic License 2.0"	"http://directory.fsf.org/wiki/License:ArtisticLicense2.0"	"null"	"null"	"23"	"4"	"5"	"GitHub - Shinmera/colleen: Common Lisp IRC bot with a modular framework. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 4 Star 23 Fork 5 Shinmera/colleen Code Issues 1 Pull requests 0 Pulse Graphs Common Lisp IRC bot with a modular framework. https://shinmera.github.io/colleen 679 commits 4 branches 2 releases Fetching contributors Common Lisp 58.7% HTML 41.1% NewLisp 0.2% Common Lisp HTML NewLisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags 2.0 gh-pages master v3 Nothing to show 2.1 2.0 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. modules .gitignore LICENSE MANUAL.md README.md about.html asdf-extra.lisp client.lisp colleen-logo.png colleen.asd command-handler.lisp conditions.lisp config.lisp event-handler.lisp event-priority.lisp event.lisp globals.lisp irc-codes.lisp irc-commands.lisp irc-events.lisp launcher.lisp module-storage.lisp module.lisp package.lisp sample.uc.lisp time-handler.lisp toolkit.lisp README.md About Colleen Colleen is a relatively large IRC bot framework with support for event handling, encapsulation through modules, command parsing, threading and more. However, it is also usable as a direct IRC bot straight away thanks to a plethora of modules that are included by default and should provide most of the functionality you might want out of a bot. How to Use Colleen as a Bot Load Colleen through Quicklisp or ASDF: (ql:quickload :colleen) (in-package :colleen)  And start it up! (startup)  Colleen is managed through a bunch of configuration files. By default it has servers configured for TymoonNET and Freenode. First though, let's change the default nick to something that is less likely to be taken already. With that done we'll save our configuration to a file. (setf (bot-config :servers :default :nick) ""Colleek"") (save-config)  This should save a file called colleen.uc.lisp to a config folder underneath the Colleen root folder. When you open the file you'll see it is organised using a lisp-like syntax, with extension for hash-tables. Another thing you'll notice is that all strings are preceded with a -. This is a necessary evil in order to serialise certain data types to string and be able to serialise them back. For more information on how the configuration storage works, see Universal-Config. Using the configuration file you can set the servers to connect to by default, which channels to join and so on. For now we'll do it manually with some code. (connect :freenode)  If all works nicely, you'll see some log messages informing you of the connection. You should now be able to fire up an IRC client to Freenode and start conversing with your bot. Since the essentials module is loaded by default, you can try commands like !time, or !echo hi. If you want to see what's going on behind the scene, you can change the logging level from :info to :trace: (setf (v:repl-level) :trace)  This'll show you quite a bit of output, including pings and all forms of event handling. It'll likely be much too noisy, but it can be very useful for debugging purposes. Since Colleen is not just a bot, but also a framework, we can use its functions to communicate ourselves. (irc:privmsg ""this-is-my-nick-here"" ""Hello REPL!"" :server (server :freenode))  Obviously change the nick to your own first. Colleen's functionality is managed through modules. By default the auth and essentials modules are loaded. You can load up more modules by putting them into the :MODULES list in the configuration, using the !module load command or directly using load-module. (load-module :silly)  Loading a module won't make it active yet though. For that you need to start it first. You can use either the command !module start or the start-module function. If you put it into the configuration instead, it'll also automatically start it for you when you startup Colleen. (start-module :silly)  Some modules like silly perform actions not on commands, but when certain things are said. In order to avoid causing unnecessary noise, you need to activate for a specific channel. You can usually do that with an activate sub command. In this case it would be !silly activate. When you try that now you will most likely be denied access. Colleen includes a simple permissions restriction in order to separate ""dangerous administrative commands"" from publicly available ones. The auth module that is present by default will authenticate users by either a simple password or through NickServ. First you need to put your nick on the list of recognised names though. The auth module has its separate configuration file that currently does not exist yet. Before setting that up, we'll simply bypass it by smuggling our nick directly onto the authenticated list: (push ""this-is-my-nick-here"" (auth-users (get-server :freenode)))  You should now be able to invoke !silly activate and try it with saying something like how the hell. You can stop it any time by invoking !silly deactivate or stopping the module entirely !module stop silly. Now in order to get the authentication set up properly, we first need the configuration file to appear. In order to manage configuration files for modules you can use !module storage save auth or save-storage. (save-storage (module :auth))  The file will most likely just contain a table stub. Change it to something like this to make yourself authenticate-able: {EQL :LOGINS {EQL          :this-is-my-nick-here ""-myPasswordGOESheeere!""}}  Don't forget the necessary ""-"" before your password. Next you can load the configuration back in using !module storage load auth or load-storage. (load-storage (module :auth))  Using !logout you can remove yourself from the authenticated list. If your nick is registered with NickServ you should now be able to use just !login to log back in, or alternatively pass your password along. Since everything is managed through configuration files you can create a running standalone bot by simply starting your lisp implementation with a file containing something akin to the following in it (ql:quickload :colleen) (funcall (find-symbol ""STARTUP"" ""COLLEEN""))  Colleen has a lot more to offer of course, but I think this should suffice as a setup guide. For all the different modules, have a look at the modules/ directory in Colleen's root. The commands each of them offer should be clear enough in the source, but if you prefer a more straight forward explanation of all the public functionality, there is a guide here. You can of course also experiment with the functionality without setting up your own and just using the live instance as mentioned in the guide. To shut Colleen down again nicely, simply invoke shutdown. Using Colleen as a Framework Functions are encapsulated in modules. A module requires a package and a define-module form within that package. A simple module stub would look something like this: (in-package #:colleen) (defpackage #:my-module   (:use #:cl #:colleen #:events)) (in-package #:my-module)  (define-module my-module () ())  The define-module form is the same as defclass, with some additional side effects to register it with the system. The extra package is necessary in order to provide an implicit environment to carry the current module and make commands like define-command and define-handler shorter. It is not strictly necessary to use a separate package per module, but it certainly is a good idea. Generally you'll want to use define-command, define-group and define-handler, although there exist more low-level constructs that allow you to do the same with more control over the output. (define-group my-commands :documentation ""A collection of commands for my test module!"")  (define-command (my-commands test) () (:documentation ""Simply performs a test."")   (respond event ""Testing, testing, 1, 2, 3."")  (define-handler (privmsg-event event) ()   (v:info :my-module ""Got a privmsg by ~a: ~a"" (nick event) (message event)))  By default within a define-command or define-handler body, the symbols event and module are bound to the current event instance and the current module instance. Furthermore, the module's storage is bound to uc:*config*. Especially the configuration is useful, as you don't need to handle that manually yourself. Colleen automatically provides storage for you and will save and load it accordingly when your module is loaded or started. Accessing the configuration happens through Universal-Config's config-tree, which is setf-able. For more information on how serialising and accessing and all that works, see the Universal-Config documentation. For now we'll use this to implement a simple last-message function: (define-handler (privmsg-event event) ()   (unless (command-p (message event))     (setf (uc:config-tree :last-message) (message event))))  (define-command last-message () ()   (respond event (uc:config-tree :last-message)))  Aside from commands and handlers, Colleen also includes a timer functionality in order to schedule tasks. See define-timer and schedule-timer. Generally having a look at all the already existing modules should give a good idea on how to make your own, they usually aren't big and shouldn't be hard to understand in what they do. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Shinmera/colleen"	"IRC bot with a modular framework.."	"true"
"Network and Internet"	"css-lite"	"https://github.com/paddymul/css-lite"	"A CSS grammar.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"47"	"7"	"9"	"GitHub - paddymul/css-lite: a css grammar for lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 47 Fork 9 paddymul/css-lite Code Issues 1 Pull requests 0 Pulse Graphs a css grammar for lisp 34 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit 6ee4e62 Mar 11, 2012 paddymul Merge pull request #5 from jasom/master … Fix for Issue #4.  Thanks Jasom. Permalink Failed to load latest commit information. COPYING added my name to the copying file, glad to see that Vladimir's name … Feb 6, 2010 README initial state of css-lite repository, as it came from vladimir Feb 6, 2010 README.org css-lite.asd css-lite.lisp Fix cascading with compound rules Mar 10, 2012 example-usage.lisp Exported the css function `comment' Jul 12, 2011 lite-utility.lisp seperated out into files baed on function Feb 6, 2010 package.lisp Bugfix: loading css-lite before loading parenscript no longer crashes Aug 4, 2011 paren-css-lite.lisp utility.lisp now with fully powerful lisp functions ROCK Feb 6, 2010 README.org css-lite is a library for generating CSS from an s-exp based syntax. When compiled with Parenscript loaded in the Lisp image, it also provides the same CSS generation facilities in Parenscript-generated JavaScript code. Instalation First, install Quicklisp. After that, type in your Lisp prompt the following: (ql:quickload 'css-lite) It should download and load css-lite. This download is only done once, after that Quicklisp will always load your local copy of css-lite. Note: In previous versions of css-lite there was a bug where you sometimes couldn’t call (ql:quickload 'css-lite) without having previously called (ql:quickload 'parenscript). This bug has hopefully now been fixed. Examples After loading the css-lite library, you are now ready to try these examples. First Example Set the width of the “body” tag to be 70% (css-lite:css   ((""body"") (:width ""70%"")))  Output: "" body { width:70%; } ""  By default, css-lite doesn’t indent the properties. If you wish to indent them, see the documentation for the variable css-lite:*indent-css*, or the section “Change the indentation” of this README. For example, if you change the value of the variable css-lite:*indent-css* to 4, this would be the output: "" body {     width:70%; } ""  Second Example Set the height of the ID “foo” to 50px and the width to 10em (css-lite:css   ((""#foo"")     (:height ""50px""      :width ""10em"")))  Output: "" #foo { height:50px; width:10em; } ""  To do the same thing, but to a class “foo”, simply replace “#foo” with “.foo”. (css-lite:css   (("".foo"")     (:height ""50px""      :width ""10em"")))  Output: "" .foo { height:50px; width:10em; } ""  Third Example Define the properties of rules “#foo” and “#foo li” (css-lite:css   ((""#foo"")     (:length ""50px""      :margin ""50 px 30 px""      :border ""1px solid red"")    ((""li"")     (:width ""50px""      :float ""left""      :margin ""50 px 30 px""      :border ""1px solid red""))))  Output: "" #foo { length:50px; margin:50 px 30 px; border:1px solid red; }  #foo li { width:50px; float:left; margin:50 px 30 px; border:1px solid red; } ""  Fourth Example In the third example, the rules “margin:50 px 30 px;” and “border:1px solid red;” are repeated twice. css-lite has something called CSS variables that allow to abstract this. You create a CSS variable by using the macro css-lite:make-css-var. (css-lite:make-css-var my-favorite-border-var '(:border ""1px solid red"")) (css-lite:make-css-var my-margin-var '(:margin ""50px 30px""))  Then you could write the third example as this: (css-lite:css    ((""#foo"")      (:length ""50px""       my-margin-var       my-favorite-border-var)     ((""li"")      (:width ""50px""       :float ""left""       my-margin-var       my-favorite-border-var))))  Output: "" #foo { length:50px; margin:50px 30px; border:1px solid red; }  #foo li { width:50px; float:left; margin:50px 30px; border:1px solid red; } ""  Fifth Example In addition to the CSS variables, css-lite also provides the ability to define CSS functions. This allows you to perform arbitrary modifications on the rules. This function is declared using the macro css-lite:make-css-func and can receive any number of arguments. However, it should return a list with 2 values, the first being the name of the property and the second its value. For example, to create a function that receives the name of a property and its value in inches and converts that value into centimeters use this: (css-lite:make-css-func convert-in-to-cm (property-name value)   ;; Assumes that `value' is a string with the following   ;; format: XXin, where XX represents a number greater than 0   (let* ((inches (parse-integer                    (string-right-trim ""in "" value)))           (centimeters (round (* inches 2.54))))     (list property-name       (concatenate 'string         (write-to-string centimeters)         ""cm""))))  So this call: (convert-in-to-cm :width ""10in"")  Returns this list: (:WIDTH ""4cm"")  So to use this function to convert the height of the identifier “#foo” from inches to centimeters, you would write this code: (css-lite:css   ((""#foo"")     (:length ""50px""      my-margin-var      (convert-in-to-cm :width ""10in"")      my-favorite-border-var)))  Output: "" #foo { length:50px; margin:50px 30px; width:4cm; border:1px solid red; } ""  Sixth Example To add a CSS comment use the function css-lite:comment (css-lite:css   ((""body"")     ((css-lite:comment ""These are the rules for the body tag"")      :width ""80%""      :float ""left"")))  Output: "" body { /*These are the rules for the body tag*/ width:80%; float:left; } ""  To see more examples, see the file example-usage.lisp Change the indentation As you can see be the above examples, by default, css-lite doesn’t indent the rules. However you can customize this behaviour by changing the value of the variable css-lite:*indent-css*. There are three possible values: nil - The default value, indicates that no indentation should be performed the symbol ‘tab - Indicates that the rules should be indented using a #\Tab character a number greater than 0 - Indicates that the rules should be indented with that many #\Space characters. For example, to indent the rules with 4 spaces, you would type: (setf css-lite:*indent-css* 4)  The next time you call the css-lite:css function, the code will be indented with 4 spaces. For example, calling the function css-lite:css with this value: (css-lite:css     ((""body"")       ((css-lite:comment ""These are the rules for the body tag"")        :width ""80%""        :float ""left"")))  Output: "" body {     /*These are the rules for the body tag*/     width:80%;     float:left; } ""  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/paddymul/css-lite"	"A CSS grammar.."	"true"
"Network and Internet"	"Djula"	"https://github.com/mmontone/djula"	"A port of Django's template engine to Common Lisp.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"41"	"9"	"10"	"GitHub - mmontone/djula: Common Lisp port of the Django templating language Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 9 Star 41 Fork 10 mmontone/djula forked from nallen05/djula Code Issues 4 Pull requests 1 Pulse Graphs Common Lisp port of the Django templating language http://mmontone.github.io/djula 227 commits 7 branches 0 releases Fetching contributors Common Lisp 88.6% HTML 8.1% CSS 2.7% Shell 0.6% Common Lisp HTML CSS Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags dev gh-pages master production staging test travis Nothing to show Nothing to show New pull request Pull request Compare This branch is 222 commits ahead of nallen05:master. Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. demo doc src templates Add *error-template* Sep 13, 2015 test .gitignore .travis.yml MIT-LICENSE README.md TODO djula-demo.asd djula-test.asd djula.asd README.md Djula Djula is a port of Python's Django template engine to Common Lisp. Nutshell Here a small example of a template::     {% extends ""base.html"" %}     {% block title %}Memberlist{% endblock %}     {% block content %}       <ul>       {% for user in users %}         <li><a href=""{{ user.url }}"">{{ user.username }}</a></li>       {% endfor %}       </ul>     {% endblock %} Philosophy Application logic is for the controller but don't try to make the life for the template designer too hard by giving him too few functionality. For more information visit the new Djula webpage and documentation. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/mmontone/djula"	"A port of Django's template engine to Common Lisp.."	"true"
"Network and Internet"	"Drakma"	"http://weitz.de/drakma/"	"An HTTP client.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"115"	"14"	"39"	"GitHub - edicl/drakma: HTTP client written in Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 14 Star 115 Fork 39 edicl/drakma Code Issues 6 Pull requests 2 Pulse Graphs HTTP client written in Common Lisp http://weitz.de/drakma/ 243 commits 1 branch 24 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v2.0.2 v2.0.1 v2.0.0 v1.3.15 v1.3.14 v1.3.13 v1.3.12 v1.3.11 v1.3.10 v1.3.9 v1.3.8 v1.3.7 v1.3.6 v1.3.5 v1.3.4 v1.3.3 v1.3.2 v1.3.1 v1.3.0 v1.2.9 v1.2.8 v1.2.7 v1.2.6 v1.2.5 Nothing to show New pull request Latest commit 411c87c Jan 29, 2016 hanshuebner Merge pull request #69 from turtle-bazon/master … Using host from :additional-headers when specified Permalink Failed to load latest commit information. doc release 2.0.2 Oct 8, 2015 test Add DECODE-CONTENT option Mar 13, 2015 .pre-release.sh add html documentation Dec 28, 2012 CHANGELOG release 2.0.2 Oct 8, 2015 README.md Update README.md Apr 20, 2015 conditions.lisp overhaul documentation and docstrings Dec 9, 2012 cookies.lisp Revert ""Use quri instead of puri"" Jul 10, 2015 drakma-test.asd Add test-op to ASDF for drakma and drakma-test systems. Mar 25, 2015 drakma.asd release 2.0.2 Oct 8, 2015 encoding.lisp Add DECODE-CONTENT option Mar 14, 2015 packages.lisp Add generic function for handling Transfer-Encoding and Content-Encod… Sep 15, 2014 read.lisp release 1.2.5 Jan 31, 2012 request.lisp Using host from :additional-headers when specified Jan 29, 2016 specials.lisp determine version number from asdf package Feb 25, 2014 util.lisp Support SNI with cl+ssl. Jul 27, 2015 README.md DRAKMA - http client written in Common Lisp DRAKMA is a http client written in Common Lisp. Please visit the documentation site for more information. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/edicl/drakma"	"An HTTP client.."	"true"
"Network and Internet"	"eco"	"https://github.com/eudoxia0/eco"	"Fast, flexible, designer-friendly template engine.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"11"	"2"	"1"	"GitHub - eudoxia0/eco: Fast, flexible, designer-friendly templates for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 11 Fork 1 eudoxia0/eco Code Issues 0 Pull requests 0 Pulse Graphs Fast, flexible, designer-friendly templates for Common Lisp 104 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src t .gitignore .travis.yml README.md eco-test.asd eco.asd README.md Eco - Fast, flexible, designer-friendly templates. Goals Simple: Eco is essentially just a string concatenator. It introduces no constructs of its own: Every tag is pure Common Lisp code, plain and simple. Easy to Use: Proper use of Eco should not require more than a cursory read of this README from time to time. Designer-friendly: Lispers have written template engine after template engine that turns S-expressions into HTML. Which is great, if you're a lisper. Eco is meant to be used for more than HTML and also to be usable to the many designers and programmers who don't know the language and should not be expected to learn an obscure template syntax to be able to contribute. Performance: Eco uses the many performance advantages of Common Lisp. Templates are not interpreted or run in a VM, but compiled to Common Lisp, which is then compiled down to efficient machine code. By making each template a function that takes an (Optionally typed) argument list rather than passing an environment hash table like most other template engines, one can leverage the type inference features of modern Common Lisp implementations to create performant templates. Usage A basic template (.eco extension) looks like this: <% deftemplate (index title &optional posts) () %>   <!DOCTYPE html>   <html>     <head>       <title><%= title %></title>     </head>     <body>       <% if posts %>         <h1>Recent Posts</h1>         <ul id=""post-list"">           <% loop for (title . snippet) in posts %>             <li><%= title %> - <%= snippet %></li>           <% end %>         </ul>       <% else %>         <span>No recent posts.</span>       <% end %>     </body>   </html> <% end %> To load this template, put this in your system definition file: (:eco-template ""filename"") To execute the template: (eco-template:index ""My Blog"" nil) Note: Eco is designed to be output-agnostic, so by default it will not autoescape HTML. Use the e function for that. You have been warned. Tags <%= <expr> %> becomes <expr>. <% <code> %><body><% end %> becomes (<code> <body>). Options *template-package*: The package the templates will be defined it. Defaults to :eco-template. Reference deftemplate Syntax: <% deftemplate name (&rest args) (&rest options) %>   <body> <% end %> Defines a template. Examples if Syntax: <% if cond %>   true branch <% else %>   false branch <% end %> Implementation Eco uses esrap to parse templates, which it then compiles down to Common Lisp code. License Copyright (c) 2014-2015 Fernando Borretti (eudoxiahp@gmail.com) Licensed under the MIT License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/eudoxia0/eco"	"Fast, flexible, designer-friendly template engine.."	"true"
"Network and Internet"	"hermetic"	"https://github.com/eudoxia0/hermetic"	"Security for Clack-based web applications.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"14"	"5"	"0"	"GitHub - eudoxia0/hermetic: Security for Clack-based Common Lisp web applications. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 14 Fork 0 eudoxia0/hermetic Code Issues 0 Pull requests 0 Pulse Graphs Security for Clack-based Common Lisp web applications. 26 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. contrib/crane demo src .gitignore README.md hermetic-crane-demo.asd hermetic-crane.asd hermetic-demo.asd hermetic.asd README.md Hermetic Simple authentication for Clack-based Common Lisp web applications. Usage See the demo app for a complete example. Available Password-Hashing Functions To mitigate the risks of the NSA convincing people to hash passwords with things like SHA-256, only PBKDF2 (And eventually scrypt) is supported :pbkdf2-sha1 :pbkdf2-sha256 :pbkdf2-sha512 setup Hermetic is not opinionated, doesn't integrate into an existing database or create any models. As such, it needs to be told how to find a user's information to provide authentication. This is what setup is for: (setup     :user-p        ;; str->bool, t if a username exists, nil otherwise     :user-pass     ;; str->str, maps a username to a password (hash, hopefully)     :user-roles    ;; str->(list sym), maps a username to a list of roles,                    ;; for example: (:user) (:user :tester :staff) (:user :admin)     :session       ;; the /expression/ for the session object. ningle:*session* on                    ;; Ningle <https://github.com/fukamachi/ningle>.     :denied        ;; A function that displays an ""access denied"" message                    ) For example, if your users are stored in a simple in-memory hash-table as in the demo app: (defmacro get-user (username)   `(gethash ,username *users*))  (setup  :user-p #'(lambda (user) (get-user user))  :user-pass #'(lambda (user) (getf (get-user user) :pass))  :user-roles #'(lambda (user) (getf (get-user user) :roles))  :session *session*) login When creating your login view, the login macro handles most of the work for you. auth Grants access to a site only to users whose roles intersect with the roles in the first argument. If an access denied page is not provided, the global one is used instead. Example: (setf (route *app* ""/user/profile/:userid"" :method :GET)       (lambda (params         (auth (:user)               (render-template ""templates/profile.html"")               (render-error ""You have to log in to view user profiles.""))))) Misc. When auth isn't enough to determine who gets to use what, Hermetic provides a few functions for accessing user data from inside a view. logged-in-p: Exactly what it says on the tin. user-name: Returns the username of the current user. roles: Returns the list of roles of the current user. role-p: Checks if a user has a role. logout Logs the user out. Takes two expressions, on-success and on-failure. License Copyright (c) 2013 Fernando Borretti (eudoxiahp@gmail.com). Licensed under the MIT License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/eudoxia0/hermetic"	"Security for Clack-based web applications.."	"true"
"Network and Internet"	"hh-web"	"https://github.com/hargettp/hh-web"	"Framework for building modern web apps.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"28"	"11"	"4"	"GitHub - hargettp/hh-web: Framework for building modern web applications in Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 11 Star 28 Fork 4 hargettp/hh-web Code Issues 3 Pull requests 0 Wiki Pulse Graphs Framework for building modern web applications in Lisp 51 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. l10n logs meta taglibraries templates Fixed code layout to match common convention (driven by paredit). Sho… Jun 17, 2012 .gitignore LICENSE README.md cache.lisp cookies.lisp doc_index.lisp docs.lisp documentation.lisp hh-web.asd images.lisp package.lisp Update package.lisp Oct 5, 2014 server.lisp services.lisp skeleton.lisp taglibraries.lisp tags.lisp templates.lisp urls.lisp useragents.lisp utils.lisp README.md About HH-Web HH-Web is the beginnings of a web application framework written in Lisp designed to streamline development of modern web applications. See the LICENSE file for the license covering all code within the HH-Web directory and any subdirectories. Basically, it's the MIT license, so you are free to do what you want, provided you reproduce the original copyright. Platforms The primary platform for HH-Web development is SBCL x64 on Mac OS X Lion (latest SBCL rev tested is 1.0.57); other Common Lisp implementations that appear to work correctly are CCL 1.8 x86, LispWorks 6.01, and ABCL 1.0.1. HH-Web has also been tested with SBCL 1.0.57 x64 on Ubuntu 11.04. Platforms with known issues include CCL x64 (problem with threads) and CMUCL (which does not like named-readtables). Features In its present form (as of June 2012), there are 4 principal features in HH-Web: Composable widgets: HH-Web let's the developer write a web page using conventional Lisp s-expression syntax, complete with properly generated CSS & Javascript. More importantly, commonly used fragments of HTML/CSS/Javascript can be bundled as a tag (just like HTML tags such as p, div, h1, etc.), and the corresponding HTML/CSS/Javascript for the expected fragment will be generated instead. Using custom tags means that most of the development of a new site involves identifying the common elements that make up the site's pages, creating custom tags (with parameters or ""attributes"", when necessary) as needed, and then authoring the pages as templates using both HTML tags and the site-specific custom tags. Regex-based URL dispatching: Inspired by Django's (and Rails') use of regex dispatching, HH-Web implements a similar technique, but in Lisp. Most importantly, if the regex contains ""variables"" (e.g., named registers, in regex parlance), then symbols will be interned for those variables and exposed as parameters to the URL's handler. Thus, components of an URL's path will automatically be extracted and made available as arguments to the handling code. Dynamic code reloading: HH-Web automatically monitors specific files for new URL dispatching rules, page template changes, and all taglibraries. Changes in the underlying code is by default automatically reflected the next time the page is refreshed in the browser. The intent is to provide the equivalent usability of other web authoring environments such as PHP or ASP: change the code for a page, and reflect that immediately in the browser. Integrated caching: HH-Web's support for caching is evolving, but in its current form it permits marking caching guidelines for specific URLs. Specifically, caching causes HH-Web to preseve any generated content (from templates and tags, typically) in an in-memory cache for later use. If a request for a page in its map appear again, then HH-Web will serve the content from the cache, rather than invoking code to regenerate the content fresh. Getting Started As an aide to starting new projects that use HH-Web to structure web application development, you can load the HH-Web system into the REPL using Quicklisp (included as of 7/3/2012--thanks Zach!): (ql:quickload :hh-web)  then execute the following expression: (hh-web:make-skeleton :for :acme :in #p""~/lisp/"")  Substitute your own project name for acme in the above expression. Note that the argument to the :for keyword must be a symbol or string, and the argument to the :in keyword must be a directory path (e.g., it must end in ""/""), although that directory should not exist, make-skeleton will not overwrite any files or directories that already present--it will raise an error instead. In the above example, the package for your new application will appear as a subdirectory of the one you provided, thus it will appear in ~/lisp/acme/. If you use Quicklisp and the ""~/lisp/"" directory is registered with ASDF as a source directory, then you can then run the following at your REPL to start your newly-created web application: (ql:quickload :acme) (acme:start-httpd-server)  Now just point your browser at http://localhost:8000, and you should see a boilerplate homepage. You can stop your application at any time by running the following: (acme:stop-httpd-server)  Additionally, the generated skeleton of a project also creates a single script called quickrun.lisp that lets you load and run your site in one step. For example, with SBCL: sbcl --load ~/lisp/acme/quickrun.lisp  Here's the directory structure created for your project: /acme   |   +-- acme.asd          # system declaration   +-- locales               # directory containing files to support i18n and l10n   +-- logs.lisp         # helpers for logging using log5   +-- package.lisp      # package declaration   +-- quickrun.lisp # script for loading and running the site   +-- server.lisp       # runs your site with hunchentoot   +-- taglibraries      # directory for your tag libraries   +-- templates         # directory for your templates   +-- templates.lisp    # file for declaring which templates to use   +-- urls.lisp         # file containing the regex rules for dispatching requests  To develop your site, edit the following files as needed, and refresh your browser to see changes take effect immediately: urls.lisp for your request dispatch rules templates.lisp for the declaring what templates you wish to use any file in the taglibraries folder for designing your tag or widget libraries any file in the templates folder for creating your own page templates The generated skeleton also demonstrates one mechanism for integrating Bootstrap and jQuery into a site, so that the resources of both libraries are always available. Note that the chosen method here may or may not be suitable for your scenario: the skeleton generates links to CDNs that host these libraries to ease other web sites. Learning More For more information on how HH-Web works and how to make use of it for your application, see the documentation on the wiki. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/hargettp/hh-web"	"Framework for building modern web apps.."	"true"
"Network and Internet"	"http-parse"	"https://github.com/orthecreedence/http-parse"	"An HTTP parser in Common Lisp.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"13"	"5"	"2"	"GitHub - orthecreedence/http-parse: An HTTP protocol parser in Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 13 Fork 2 orthecreedence/http-parse Code Issues 4 Pull requests 0 Pulse Graphs An HTTP protocol parser in Common Lisp 85 commits 2 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master steal-test Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. test LICENSE README.md http-parse-test.asd http-parse.asd multipart-parse.lisp package.lisp parse.lisp util.lisp README.md This library has been superceded by fast-http http-parse had a good, long life and served many HTTP requests, but it's now time for it to stand aside and let libraries better than itself take its place. fast-http is an incredible library (and is now the core parser used in Wookie). Use fast-http instead of http-parse. This library is retired. http-parse A pure-lisp library for parsing HTTP requests/responses. Right now the focus for this library is making it useful and easy to use. With time, slower parts of http-parse will be replaced to make it screaming fast. The purpose of this library is to be able to easily parse incoming HTTP data either synchronously or asynchronously (but it was mainly built for streaming HTTP data asynchronously). Documentation http (class) This is a base class extended by http-request and http-response. It holds values that both requests/responses deal with (HTTP version, headers, body). This class, and those that extend it, are meant to be instiantiated with no parameters and passed into the make-parser function, which fills in all the details which can be read out later. http-version Accessor for the parsed HTTP version out of the http object. http-headers Accessor for the headers parsed from the HTTP request/response http-store-body store-body specifies whether the HTTP body should be stored (in its entirety) in the http-body accessor. If this is set after initializing a parser, it should be done so no later than the header-callback being fired, or else pieces of the body may be missing. http-force-stream force-stream lets the parser know that you want every TCP packet that comes in to be passed into a body callback as if it was sent via an HTTP chunk. This is an advanced option, but can be very useful in some cases. For instance, if you have a server that supports file uploads and a client doesn't know how to chunk an upload (like every browser ever), your server is going to spin its CPU and waste memory buffering the entire file and passing it around as a huge array instead of dealing with it packet by packet. This is a great way to fake HTTP chunking in your server/client. http-body Accessor for the full HTTP body from the request/response (although storing of the body in the http object must be explicitely asked for by passing :store-body t into make-parser. http-request (class) extends http Holds values specific to an HTTP request (method, resource) http-method Accessor for the parsed HTTP request method as a keyword: :GET, :POST, etc. http-resource Accessor for the resource in the request. Parse with puri. http-response (class) extends http Holds values specific to an HTTP response (status, status text). http-status Accessor for the HTTP response status (integer). http-status-text Accessor for the HTTP response status string: OK, Insufficient Privileges, etc. make-parser (function) (defun make-parser (http &key header-callback body-callback multipart-callback finish-callback store-body)   => closure This is what you've all been waiting for, folks. This function initializes an HTTP parser (a closure) which can be fed binary data in sequence and will parse an HTTP request/response as it comes in. It accepts a class of http-request or http-response as its only required argument. It returns a closure which only has one argument: a byte array that contains pieces of an HTTP request/response. The pieces must be in order, but other than that, there is no restriction on how many times the parser can be called with new data until it is finished. In some cases (older HTTP versions), the end of an HTTP payload is marked by an EOF on the socket. If this occurs, you can pass :eof into the parser instead of a byte array to signal that it should finish up. The parser closure returns three values: the http object passed in, a boolean indicating if the headers are finished parsing, and a boolean indicating if the HTTP body has been fully parsed. make-parser accepts these callbacks: :header-callback, :body-callback, :multipart-callback, and :finish-callback. The header callback is fired when all the headers have been parsed. It takes one argument, a plist of finished headers. The body callback is called either when the entire body has been received (in the case of :content-length being present in the headers) or piece by piece as it is sent in (when the body is chunked). The multipart callback, if specified, is passed into a multipart parser, which is given chunks of the body as they come in. It decodes multipart form data such that the given callback is fired for each form field present in the data. If it encounters a field that is split into multiple chunks, it will fire the callback for each of the chunks, indicating in one of the arguments whether that is the final chunk or not. This makes it possible to stream the multipart data as it comes in (for instance, to a file). The finish-callback is a function with no args called when the parser has detected that the HTTP payload is completely parsed (headers, body, etc). The :store-body keyword specifies that the parser should store the body (as a byte array) into the given http object as it is parsed. Otherwise, the best way to get the body data is via the body-callback. ;; example. anything under my-app is not included. (let ((http (make-instance 'http-response))       (parser (make-parser http                            :header-callback (lambda (headers)                                               (my-app:got-headers!!! headers))                            :body-callback (lambda (bytes)                                               (my-app:got-body-piece bytes)))))   (loop for http-data = (my-app:get-http-data-from-request-i-sent-out-earlier) do     (multiple-value-bind (http headers-finished-p body-finished-p)         (funcall parser http-data)       (when body-finished-p         (my-app:close-http-stream))       ...))) Parser lambda definition (lambda (byte-array) ...)   => http, headers-finished-p, body-finished-p As noted, if an EOF happens on the socket the HTTP data is coming in on, you may indicate this to the parser by sending in :eof instead of the byte array. header-callback definition (lambda (header-plist) ...) Headers are in the form '(:host ""musio.com"" :content-type ""text/html"" ...). Headers are not reversed, they are passed in the order they occur in the HTTP payload. body-callback definition (lambda (byte-array last-chunk-p) ...) Byte-array is not cumulative, it is just the new data that has been parsed from the payload. If multiple chunks are parsed at once, their body data is sent in as one call to the body-callback. Incomplete chunks are not sent in until they are completed. last-chunk-p is true if the entire body has been processed (if a Content-Length was specified and all bytes accounted for, or if the body is chunked and the 0-byte chunk has been encountered). multipart-callback definition See multipart parser callback definition. finish-callback definition (lambda () ...) This callback is fired when the HTTP parser is finished parsing the request/response. make-multipart-parser (function) (defun make-multipart-parser (headers callback))   => closure Returns a parser closure to deal with multipart form data. Data is fed to the parser in as many chunks as needed (or all at once) and the given callback will be fired at least once for each form field present in the multipart form data. If data for a field is spread over multiple chunks, the callback is fired for each of the chunks, along with a second argument indicating whether the current chunk is that last for that field. headers are all the headers from a parsed HTTP payload, in plist form. NOTE: If make-multipart-parser detects that the data being decoded is not in multipart format (determined by reading the headers), it returns nil instead of a closure. multipart parser callback definition (lambda (field-name field-headers field-meta body-bytes body-complete-p) ...) This callback is fired for each form field encountered in a multipart request. The field-name arg is a string indicating the name of the form field. The field-headers arg is a plist containing the headers for that field (generally this is Content-Disposition and sometimes Content-Type for uploads). The field-meta arg is a plist of key/value pairs found in the Content-Disposition header for the field (this is where the field-name arg comes from, and is also used to specify the filename of uploaded files). body-bytes is a byte array containing all or a chunk of that field's data, and body-complete-p indicates whether or not the body-bytes being sent into the callback is the last bit of data for that field. Generally, this callback will be a closure that is able to track the current field it's operating on and be able to handle the case where body-bytes is spread over multiple calls if body-complete-p is nil. Tests Tests are under the http-parse-test package: (ql:quickload :http-parse-test) (http-parse-test:run-tests) Please report any bugs you find or failing tests to the issues list. License MIT Licensed. Enjoy. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/orthecreedence/http-parse"	"An HTTP parser in Common Lisp.."	"true"
"Network and Internet"	"humbler"	"https://github.com/Shinmera/humbler"	"A Tumblr API interface.."	"null"	"null"	"null"	"Artistic License 2.0"	"http://directory.fsf.org/wiki/License:ArtisticLicense2.0"	"null"	"null"	"6"	"3"	"2"	"GitHub - Shinmera/humbler: A Common Lisp Tumblr API interface Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 6 Fork 2 Shinmera/humbler Code Issues 0 Pull requests 0 Pulse Graphs A Common Lisp Tumblr API interface https://shinmera.github.io/humbler 80 commits 2 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. LICENSE README.md about.html auth.lisp blog.lisp deferring.lisp documentation.lisp generics.lisp humbler.asd object-bridge.lisp objects.lisp package.lisp post.lisp posts.lisp tagged.lisp toolkit.lisp user.lisp README.md About Humbler Humbler is a Tumblr API interface that attempts to make it as little of a pain to use as possible. oAuth login and signing is handled by South. How To Before you can use Tumblr's API you'll need an application. Copy both the consumer key and secret and plug them into South: (south:prepare  :api-key key  :api-secret secret)  Humbler should configure South automatically to use the correct oAuth URLs and provides a simple LOGIN function. (humbler:login)  This should return an URL if successful. Open this URL in your browser and allow the application access. It should redirect you to a localhost address, which then completes the authentication process automatically. It should also set up your local user object. humbler:*user* (humbler:name humbler:*user*)  Humbler offers an object-oriented interface that tries to take a lot of manual work off your hands and a lower-level API-mapping. Here's an example using both to create a text post: (humbler:blog/post-text ""my-blog"" ""Hey, testing this Common Lisp library called Humbler..."" :title ""Whoa nelly!"")  (humbler:save (make-instance 'humbler:text-post :body ""Nobody reads text posts anyway."" :title ""Welp.""))  While the low-level functions have some limitations and oddities about them (max 20 results on a listing every call, strange inconsistencies, partial objects) due to the way Tumblr's API is made, the high-level functions try to smoothen over these issues so you don't have to worry about them. If for some reason you hate automatisation or how this abstraction works, you are of course free to build your own on top of the bare API calls though. Humbler's symbols are split into three packages: HUMBLER-API which contains the API mapping functions, HUMBLER-OBJECTS containing the object and generic function interface, and finally HUMBLER-EXTRA with some functions to help deal with Tumblr (only programmatically, not mentally). Deferred Slots Tumblr's API doesn't always return complete objects; some calls only return a slice of the fields an object may exhibit. Humbler tries to take this annoying management off your hands by automatically augmenting your object with slot values from a fitting API call if you try to access it and it is not yet bound. If it fails to augment a slot, either because it does not know any API call to use to retrieve it or because something else went wrong, an error is signalled instead. Multiple Users, Multiple South Applications If you need to allow multiple users or south-using applications simultaneously, you'll need to handle the login and environment establishment yourself. Have a look at the South documentation for more information on how to go about this. This functionality is not included in Humbler directly as it is too complex to handle in a generic way. More Examples Post to all your blogs: (dolist (blog (my-blogs))   (repost (make-instance 'text-post :body ""Hi!"") blog))  Reblog the last 100 photos from a blog: (mapcar #'reblog (posts ""cool-photo-blog"" :type :photo :amount 100))  View the most recent text posts from a tag: (mapcar #'body (remove-if-not #'text-post-p (tag ""interesting-tag)))  Delete all your drafts: (mapcar #'destroy (my-drafts :amount T))  Interactively reply to all your asks: (dolist (sub (my-submissions :amount T))   (when (answer-post-p sub)     (format T ""~a: ~a~%"" (asking-name sub) (question sub))     (reply sub (read-line))))  Further Reading The symbol index. South, the oAuth library. Chirp, Humbler's sister library for Twitter. Tumblr's frankly abysmal API 'documentation'. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Shinmera/humbler"	"A Tumblr API interface.."	"true"
"Network and Internet"	"hunchentoot"	"http://weitz.de/hunchentoot/"	"A web server.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"null"	"null"	"null"	"Hunchentoot - The Common Lisp web server formerly known as TBNL Hunchentoot - The Common Lisp web server formerly known as TBNL Abstract Hunchentoot is a web server written in Common Lisp and at the same time a toolkit for building dynamic websites. As a stand-alone web server, Hunchentoot is capable of HTTP/1.1 chunking (both directions), persistent connections (keep-alive), and SSL. Hunchentoot provides facilities like automatic session handling (with and without cookies), logging, customizable error handling, and easy access to GET and POST parameters sent by the client. It does not include functionality to programmatically generate HTML output. For this task you can use any library you like, e.g. (shameless self-plug) CL-WHO or HTML-TEMPLATE. Hunchentoot talks with its front-end or with the client over TCP/IP sockets and optionally uses multiprocessing to handle several requests at the same time. Therefore, it cannot be implemented completely in portable Common Lisp. It currently works with LispWorks and all Lisps which are supported by the compatibility layers usocket and Bordeaux Threads. Hunchentoot comes with a BSD-style license so you can basically do with it whatever you want. Hunchentoot is (or was) for example used by QuickHoney, City Farming, Heike Stephan. Download shortcut: http://weitz.de/files/hunchentoot.tar.gz. Contents Abstract Contents Download and installation Running Hunchentoot on port 80 Hunchentoot behind a proxy Support Your own webserver (the easy teen-age New York version) Third party documentation and add-ons Function and variable reference Acceptors Customizing acceptor behaviour An example of how to subclass ACCEPTOR Taskmasters Request dispatch and handling Using the easy-handler framework Request objects Reply objects Sessions Customizing session behaviour Cookies Logging Conditions and error handling Miscellaneous Testing Debugging History Symbol index Acknowledgements Download and installation Hunchentoot depends on a couple of other Lisp libraries which you'll need to install first: Pierre R. Mai's MD5, Kevin Rosenberg's CL-BASE64, Janis Dzerins' RFC2388, Peter Seibel's CL-FAD, Gary King's trivial-backtrace, Erik Huelsmann's usocket (unless you're using LispWorks), Greg Pfeil's Bordeaux Threads (unless you're using LispWorks), David Lichteblau's CL+SSL (unless you're using LispWorks), and my own FLEXI-STREAMS (0.12.0 or higher), Chunga (1.0.0 or higher), and CL-PPCRE (plus CL-WHO for the example code and Drakma for the tests). Make sure to use the newest versions of all of these libraries (which might themselves depend on other libraries) - try the repository versions if you're in doubt. Note: You can compile Hunchentoot without SSL support - and thus without the need to have CL+SSL - if you add :HUNCHENTOOT-NO-SSL to *FEATURES* before you compile it. Hunchentoot will only work with Lisps where the character codes of all Latin-1 characters coincide with their Unicode code points (which is the case for all current implementations I know). Hunchentoot itself together with this documentation can be downloaded from http://weitz.de/files/hunchentoot.tar.gz. The current version is 1.2.35. The preferred method to compile and load Hunchentoot is via ASDF. If you want to avoid downloading and installing all the dependencies manually, give Zach Beane's excellent Quicklisp system a try. Hunchentoot and its dependencies can also be installed with clbuild. There's also a port for Gentoo Linux thanks to Matthew Kennedy. The current development version of Hunchentoot can be found at https://github.com/edicl/hunchentoot. If you want to send patches, please fork the github repository and send pull requests. Running Hunchentoot on port 80 Hunchentoot does not come with code to help with running it on a privileged port (i.e. port 80 or 443) on Unix-like operating systems. Modern Unix-like systems have specific, non-portable ways to allow non-root users to listen to privileged ports, so including such functionality in Hunchentoot was considered unnecessary. Please refer to online resources for help. At the time of this writing, the YAWS documentation has a comprehensive writeup on the topic. Hunchentoot behind a proxy If you're feeling unsecure about exposing Hunchentoot to the wild, wild Internet or if your Lisp web application is part of a larger website, you can hide it behind a proxy server. One approach that I have used several times is to employ Apache's mod_proxy module with a configuration that looks like this: ProxyPass /hunchentoot http://127.0.0.1:3000/hunchentoot ProxyPassReverse /hunchentoot http://127.0.0.1:3000/hunchentoot This will tunnel all requests where the URI path begins with ""/hunchentoot"" to a (Hunchentoot) server listening on port 3000 on the same machine. Of course, there are several other (more lightweight) web proxies that you could use instead of Apache. Support The development version of Hunchentoot can be found on github. Please use the github issue tracking system to submit bug reports. Patches are welcome, please use GitHub pull requests. If you want to make a change, please read this first. Your own webserver (the easy teen-age New York version) Starting your own web server is pretty easy. Do something like this: (hunchentoot:start (make-instance 'hunchentoot:easy-acceptor :port 4242)) That's it. Now you should be able to enter the address ""http://127.0.0.1:4242/"" in your browser and see something, albeit nothing very interesting for now. By default, Hunchentoot serves the files from the www/ directory in its source tree. In the distribution, that directory contains a HTML version of the documentation as well as the error templates. The location of the document root directory can be specified when creating a new ACCEPTOR instance by the way of the ACCEPTOR-DOCUMENT-ROOT. Likewise, the location of the error template directory can be specified by the ACCEPTOR-ERROR-TEMPLATE-DIRECTORY. Both ACCEPTOR-DOCUMENT-ROOT and ACCEPTOR-ERROR-TEMPLATE-DIRECTORY can be specified using a logical pathname, which will be translated once when the ACCEPTOR is instantiated. The EASY-ACCEPTOR class implements a framework for developing web applications. Handlers are defined using the DEFINE-EASY-HANDLER macro. Request dispatching is performed according to the list of dispatch functions in *DISPATCH-TABLE*. Each of the functions on that list is called to determine whether it wants to handle the request, provided as single argument. If a dispatcher function wants to handle the request, it returns another function to actually create the desired page. DEFINE-EASY-HANDLER is accompanied by a set of dispatcher creation functions that can be used to create dispatchers for standard tasks. These are documented in the subchapter on easy handlers Now be a bit more adventurous, try this (hunchentoot:define-easy-handler (say-yo :uri ""/yo"") (name)   (setf (hunchentoot:content-type*) ""text/plain"")   (format nil ""Hey~@[ ~A~]!"" name)) and see what happens at ""http://127.0.0.1:4242/yo"" or ""http://127.0.0.1:4242/yo?name=Dude"" . Hunchentoot comes with a little example website which you can use to see if it works and which should also demonstrate a couple of the things you can do with Hunchentoot. To start the example website, enter the following code into your listener: (asdf:oos 'asdf:load-op :hunchentoot-test) Now go to ""http://127.0.0.1:4242/hunchentoot/test"" and play a bit. Third party documentation and add-ons Adam Petersen has written a book called ""Lisp for the Web"" which explains how Hunchentoot and some other libraries can be used to build web sites. Here is some software which extends Hunchentoot or is based on it: Weblocks by Slava Akhmechet is a ""continuations-based web framework"" which is based on Hunchentoot. hunchentoot-cgi (by Cyrus Harmon) provides CGI handlers for Hunchentoot. CL-WEBDAV is a WebDAV server based on Hunchentoot. RESTAS is a web framework based on Hunchentoot. Function and variable reference Acceptors If you want Hunchentoot to actually do something, you have to create and start an acceptor. You can also run several acceptors in one image, each one listening on a different different port. [Standard class] acceptor To create a Hunchentoot webserver, you make an instance of this class or one of its subclasses and use the generic function START to start it (and STOP to stop it). Use the :port initarg if you don't want to listen on the default http port 80. There are other initargs most of which you probably won't need very often. They are explained in detail in the docstrings of the slot definitions for this class. Unless you are in a Lisp without MP capabilities, you can have several active instances of ACCEPTOR (listening on different ports) at the same time. [Standard class] ssl-acceptor Create and START an instance of this class (instead of ACCEPTOR) if you want an https server. There are two required initargs, :SSL-CERTIFICATE-FILE and :SSL-PRIVATEKEY-FILE, for pathname designators denoting the certificate file and the key file in PEM format. On LispWorks, you can have both in one file in which case the second initarg is optional. You can also use the :SSL-PRIVATEKEY-PASSWORD initarg to provide a password (as a string) for the key file (or NIL, the default, for no password). The default port for SSL-ACCEPTOR instances is 443 instead of 80 [Generic function] start acceptor => acceptor Starts acceptor so that it begins accepting connections. Returns the acceptor. [Generic function] stop acceptor &key soft => acceptor Stops the acceptor so that it no longer accepts requests. If soft is true, and there are any requests in progress, wait until all requests are fully processed, but meanwhile do not accept new requests. Note that soft must not be set when calling stop from within a request handler, as that will deadlock. [Special variable] *acceptor* The current ACCEPTOR object in the context of a request. [Generic function] acceptor-listen-backlog listen-backlog => number-of-pending-connections Number of pending connections allowed in the listen socket before the kernel rejects further incoming connections. Non-LispWorks only. [Generic readers] acceptor-address acceptor => address acceptor-port acceptor => port acceptor-read-timeout acceptor => read-timeout acceptor-ssl-certificate-file ssl-acceptor => ssl-certificate-file acceptor-ssl-privatekey-file ssl-acceptor => ssl-privatekey-file acceptor-ssl-privatekey-password ssl-acceptor => ssl-privatekey-password acceptor-write-timeout acceptor => write-timeout These are readers for various slots of ACCEPTOR objects (and some of them obviously only make sense for SSL-ACCEPTOR objects). See the docstrings of these slots for more information and note that there are corresponding initargs for all of them. [Generic accessors] acceptor-access-log-destination acceptor => (or pathname null) (setf (acceptor-access-log-destination acceptor ) new-value) acceptor-document-root acceptor => (or pathname null) (setf (acceptor-document-root acceptor ) new-value) acceptor-error-template-directory acceptor => (or pathname null) (setf (acceptor-error-template-directory acceptor ) new-value) acceptor-input-chunking-p acceptor => input-chunking-p (setf (acceptor-input-chunking-p acceptor ) new-value) acceptor-message-log-destination acceptor => (or pathname null) (setf (acceptor-message-log-destination acceptor ) new-value) acceptor-name acceptor => name (setf (acceptor-name acceptor ) new-value) acceptor-output-chunking-p acceptor => output-chunking-p (setf (acceptor-output-chunking-p acceptor ) new-value) acceptor-persistent-connections-p acceptor => persistent-connections-p (setf (acceptor-persistent-connections-p acceptor ) new-value) acceptor-reply-class acceptor => reply-class (setf (acceptor-reply-class acceptor ) new-value) acceptor-request-class acceptor => request-class (setf (acceptor-request-class acceptor ) new-value) These are accessors for various slots of ACCEPTOR objects. See the docstrings of these slots for more information and note that there are corresponding initargs for all of them. [Generic function] acceptor-ssl-p acceptor => generalized-boolean Returns a true value if acceptor uses SSL connections. The default is to unconditionally return NIL and subclasses of ACCEPTOR must specialize this method to signal that they're using secure connections - see the SSL-ACCEPTOR class. [Special variable] *default-connection-timeout* The default connection timeout used when an acceptor is reading from and writing to a socket stream. Note that some Lisps allow you to set different timeouts for reading and writing and you can specify both values via initargs when you create an acceptor. [Generic function] acceptor-remove-session acceptor session => | This function is called whenever a session in ACCEPTOR is being destroyed because of a session timout or an explicit REMOVE-SESSION call. Customizing acceptor behaviour If you want to modify what acceptors do, you should subclass ACCEPTOR (or SSL-ACCEPTOR) and specialize the generic functions that constitute their behaviour (see example below). The life of an acceptor looks like this: It is started with the function START which immediately calls START-LISTENING and then applies the function EXECUTE-ACCEPTOR to its taskmaster. This function will eventually call ACCEPT-CONNECTIONS which is responsible for setting things up to wait for clients to connect. For each incoming connection which comes in, HANDLE-INCOMING-CONNECTION is applied to the taskmaster which will either call PROCESS-CONNECTION directly, or will create a thread to call it. PROCESS-CONNECTION calls INITIALIZE-CONNECTION-STREAM before it does anything else, then it selects and calls a function which handles the request, and finally it sends the reply to the client before it calls RESET-CONNECTION-STREAM. If the connection is persistent, this procedure is repeated (except for the intialization step) in a loop until the connection is closed. The acceptor is stopped with STOP. If you just want to use the standard acceptors that come with Hunchentoot, you don't need to know anything about the functions listed in this section. [Generic function] start-listening acceptor => | Sets up a listen socket for the given acceptor and enables it to listen to incoming connections. This function is called from the thread that starts the acceptor initially and may return errors resulting from the listening operation (like 'address in use' or similar). [Generic function] accept-connections acceptor => nil In a loop, accepts a connection and hands it over to the acceptor's taskmaster for processing using HANDLE-INCOMING-CONNECTION. On LispWorks, this function returns immediately, on other Lisps it returns only once the acceptor has been stopped. [Generic function] process-connection acceptor socket => nil This function is called by the taskmaster when a new client connection has been established. Its arguments are the ACCEPTOR object and a LispWorks socket handle or a usocket socket stream object in socket. It reads the request headers, sets up the request and reply objects, and hands over to PROCESS-REQUEST which calls HANDLE-REQUEST to select and call a handler for the request and sends its reply to the client. This is done in a loop until the stream has to be closed or until a connection timeout occurs. It is probably not a good idea to re-implement this method until you really, really know what you're doing. Handlers may call to the DETACH-SOCKET generic function to indicate that no further requests should be handled on the connection by Hunchentoot, and that responsibility for the socket is assumed by third-party software. This can be used by specialized handlers that wish to hand over connection polling or processing to functions outside of Hunchentoot, i.e. for connection multiplexing or implementing specialized client protocols. Hunchentoot will finish processing the request and the PROCESS-CONNECTION function will return without closing the connection. At that point, the acceptor may interact with the socket in whatever fashion required. [Generic function] detach-socket acceptor => stream Indicate to Hunchentoot that it should stop serving requests on the current request's socket. Hunchentoot will finish processing the current request and then return from PROCESS-CONNECTION without closing the connection to the client. DETACH-SOCKET can only be called from within a request handler function. [Generic function] initialize-connection-stream acceptor stream => stream Can be used to modify the stream which is used to communicate between client and server before the request is read. The default method of ACCEPTOR does nothing, but see for example the method defined for SSL-ACCEPTOR. All methods of this generic function must return the stream to use. [Generic function] reset-connection-stream acceptor stream => stream Resets the stream which is used to communicate between client and server after one request has been served so that it can be used to process the next request. This generic function is called after a request has been processed and must return the stream. [Generic function] acceptor-log-access acceptor &key return-code Function to call to log access to the acceptor. The return-code keyword argument contains additional information about the request to log. In addition, it can use the standard request and reply accessor functions that are available to handler functions to find out more information about the request. [Generic function] acceptor-log-message acceptor log-level format-string &rest format-arguments Function to call to log messages by the acceptor. It must accept a severity level for the message, which will be one of :ERROR, :INFO, or :WARNING, a format string and an arbitary number of formatting arguments. [Generic function] acceptor-status-message acceptor http-return-code &key &allow-other-keys This function is called when a request's handler has been called but failed to provide content to send back to the client. It converts the HTTP-STATUS-CODE to some request contents, typically a human readable description of the status code to be displayed to the user. If an ERROR-TEMPLATE-DIRECTORY is set in the current acceptor and the directory contains a file corresponding to HTTP-STATUS-CODE named <code>.html, that file is sent to the client after variable substitution. Variables are referenced by ${<variable-name>}. Additional keyword arguments may be provided which are made available to the templating logic as substitution variables. These variables can be interpolated into error message templates in, which contains the current URL relative to the server and without GET parameters. In addition to the variables corresponding to keyword arguments, the script-name, lisp-implementation-type, lisp-implementation-version and hunchentoot-version variables are available. An example of how to subclass ACCEPTOR This example shows how to subclass ACCEPTOR in order to provide Hunchentoot with basic virtual host support.  It assumes Hunchentoot is sitting behind an Internet-facing reverse-proxy web server that maps the host (or domain) part of incoming HTTP requests to unique localhost ports. (asdf:load-system ""hunchentoot"") (asdf:load-system ""drakma"")  ;;; Subclass ACCEPTOR (defclass vhost (tbnl:acceptor)   ;; slots   ((dispatch-table     :initform '()     :accessor dispatch-table     :documentation ""List of dispatch functions""))   ;; options   (:default-initargs                    ; default-initargs must be used    :address ""127.0.0.1""))               ; because ACCEPTOR uses it  ;;; Specialise ACCEPTOR-DISPATCH-REQUEST for VHOSTs (defmethod tbnl:acceptor-dispatch-request ((vhost vhost) request)   ;; try REQUEST on each dispatcher in turn   (mapc (lambda (dispatcher) 	  (let ((handler (funcall dispatcher request))) 	    (when handler               ; Handler found. FUNCALL it and return result 	      (return-from tbnl:acceptor-dispatch-request (funcall handler))))) 	(dispatch-table vhost))   (call-next-method))  ;;; ====================================================================== ;;; Now all we need to do is test it  ;;; Instantiate VHOSTs (defvar vhost1 (make-instance 'vhost :port 50001)) (defvar vhost2 (make-instance 'vhost :port 50002))  ;;; Populate each dispatch table (push  (tbnl:create-prefix-dispatcher ""/foo"" 'foo1)  (dispatch-table vhost1)) (push  (tbnl:create-prefix-dispatcher ""/foo"" 'foo2)  (dispatch-table vhost2))  ;;; Define handlers (defun foo1 () ""Hello"") (defun foo2 () ""Goodbye"")  ;;; Start VHOSTs (tbnl:start vhost1) (tbnl:start vhost2)  ;;; Make some requests (drakma:http-request ""http://127.0.0.1:50001/foo"") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:39] ""GET /foo HTTP/1.1"" 200 5 ""-"" ""Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)"" ;;; => ;;; ""Hello"" ;;; 200 ;;; ((:CONTENT-LENGTH . ""5"") (:DATE . ""Fri, 08 Jun 2012 14:30:39 GMT"") ;;;  (:SERVER . ""Hunchentoot 1.2.3"") (:CONNECTION . ""Close"") ;;;  (:CONTENT-TYPE . ""text/html; charset=utf-8"")) ;;; #<PURI:URI http://127.0.0.1:50001/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CA90059}> ;;; T ;;; ""OK"" (drakma:http-request ""http://127.0.0.1:50002/foo"") ;;; =| ;;; 127.0.0.1 - [2012-06-08 14:30:47] ""GET /foo HTTP/1.1"" 200 7 ""-"" ""Drakma/1.2.6 (SBCL 1.0.56; Linux; 2.6.32-5-686; http://weitz.de/drakma/)"" ;;; => ;;; ""Goodbye"" ;;; 200 ;;; ((:CONTENT-LENGTH . ""7"") (:DATE . ""Fri, 08 Jun 2012 14:30:47 GMT"") ;;;  (:SERVER . ""Hunchentoot 1.2.3"") (:CONNECTION . ""Close"") ;;;  (:CONTENT-TYPE . ""text/html; charset=utf-8"")) ;;; #<PURI:URI http://127.0.0.1:50002/foo> ;;; #<FLEXI-STREAMS:FLEXI-IO-STREAM {CAE8059}> ;;; T ;;; ""OK"" How to make each VHOST write to separate access log streams (or files) is left as an exercise to the reader. Taskmasters As a ""normal"" Hunchentoot user, you can completely ignore taskmasters and skip this section. But if you're still reading, here are the dirty details: Each acceptor has a taskmaster associated with it at creation time. It is the taskmaster's job to distribute the work of accepting and handling incoming connections. The acceptor calls the taskmaster if appropriate and the taskmaster calls back into the acceptor. This is done using the generic functions described in this and the previous section. Hunchentoot comes with two standard taskmaster implementations - one (which is the default used on multi-threaded Lisps) which starts a new thread for each incoming connection and one which handles all requests sequentially. It should for example be relatively straightforward to create a taskmaster which allocates threads from a fixed pool instead of creating a new one for each connection. You can control the resources consumed by a threaded taskmaster via two initargs. :max-thread-count lets you set the maximum number of request threads that can be processes simultaneously. If this is nil, the is no thread limit imposed. :max-accept-count lets you set the maximum number of requests that can be outstanding (i.e. being processed or queued for processing). If :max-thread-count is supplied and :max-accept-count is NIL, then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated if there are more than the max-thread-count threads processing requests. If both :max-thread-count and :max-accept-count are supplied, then max-thread-count must be less than max-accept-count; if more than max-thread-count requests are being processed, then requests up to max-accept-count will be queued until a thread becomes available. If more than max-accept-count requests are outstanding, then a +HTTP-SERVICE-UNAVAILABLE+ error will be generated. In a load-balanced environment with multiple Hunchentoot servers, it's reasonable to provide :max-thread-count but leave :max-accept-count null. This will immediately result in +HTTP-SERVICE-UNAVAILABLE+ when one server is out of resources, so the load balancer can try to find another server. In an environment with a single Hunchentoot server, it's reasonable to provide both :max-thread-count and a somewhat larger value for :max-accept-count. This will cause a server that's almost out of resources to wait a bit; if the server is completely out of resources, then the reply will be +HTTP-SERVICE-UNAVAILABLE+. The default for these values is 100 and 120, respectively. If you want to implement your own taskmasters, you should subclass TASKMASTER or one of its subclasses, SINGLE-THREADED-TASKMASTER or ONE-THREAD-PER-CONNECTION-TASKMASTER, and specialize the generic functions in this section. [Standard class] taskmaster An instance of this class is responsible for distributing the work of handling requests for its acceptor. This is an ""abstract"" class in the sense that usually only instances of subclasses of TASKMASTER will be used. [Standard class] one-thread-per-connection-taskmaster A taskmaster that starts one thread for listening to incoming requests and one thread for each incoming connection. This is the default taskmaster implementation for multi-threaded Lisp implementations. [Standard class] single-threaded-taskmaster A taskmaster that runs synchronously in the thread where the START function was invoked (or in the case of LispWorks in the thread started by COMM:START-UP-SERVER). This is the simplest possible taskmaster implementation in that its methods do nothing but calling their acceptor ""sister"" methods - EXECUTE-ACCEPTOR calls ACCEPT-CONNECTIONS, HANDLE-INCOMING-CONNECTION calls PROCESS-CONNECTION. [Standard class] multi-threaded-taskmaster This is an abstract class for taskmasters that use multiple threads; it is not a concrete class and you should not instantiate it with MAKE-INSTANCE. Instead, you should instantiate its subclass ONE-THREAD-PER-CONNECTION-TASKMASTER described above. MULTI-THREADED-TASKMASTER is intended to be inherited from by extensions to Hunchentoot, such as quux-hunchentoot's THREAD-POOLING-TASKMASTER, though at the moment, doing so only inherits one slot and one method, on EXECUTE-ACCEPTOR, to have it start a new thread for the acceptor, then saved in said slot. [Generic function] execute-acceptor taskmaster => result This is a callback called by the acceptor once it has performed all initial processing to start listening for incoming connections (see START-LISTENING). It usually calls the ACCEPT-CONNECTIONS method of the acceptor, but depending on the taskmaster instance the method might be called from a new thread. [Generic function] handle-incoming-connection taskmaster socket => result This function is called by the acceptor to start processing of requests on a new incoming connection. socket is the usocket instance that represents the new connection (or a socket handle on LispWorks). The taskmaster starts processing requests on the incoming connection by calling the PROCESS-CONNECTION method of the acceptor instance. The socket argument is passed to PROCESS-CONNECTION as an argument. If the taskmaster is a multi-threaded taskmaster, HANDLE-INCOMING-THREAD will call CREATE-REQUEST-HANDLER-THREAD, which will call PROCESS-CONNECTION in a new thread. HANDLE-INCOMING-THREAD might issue a +HTTP-SERVICE-UNAVAILABLE+ error if there are too many request threads or it might block waiting for a request thread to finish. [Generic function] start-thread taskmaster thunk &key => thread This function is a callback that starts a new thread that will call the given thunk in the context of the proper taskmaster, with appropriate context-dependent keyword arguments. ONE-THREAD-PER-CONNECTION-TASKMASTER uses it in EXECUTE-ACCEPTOR and CREATE-REQUEST-HANDLER-THREAD, but specialized taskmasters may define more functions that use it. By default, it just creates a thread calling the thunk with a specified name keyword argument. Specialized taskmasters may wrap special bindings and condition handlers around the thunk call, register the thread in a management table, etc. [Generic function] create-request-handler-thread taskmaster socket => thread This function is called by HANDLE-INCOMING-THREAD to create a new thread which calls PROCESS-CONNECTION. If you specialize this function, you must be careful to have the thread call DECREMENT-TASKMASTER-REQUEST-COUNT before it exits. A typical method will look like this: (defmethod create-request-handler-thread ((taskmaster monitor-taskmaster) socket)   (bt:make-thread    (lambda ()      (with-monitor-error-handlers          (unwind-protect               (with-monitor-variable-bindings                   (process-connection (taskmaster-acceptor taskmaster) socket))            (decrement-taskmaster-request-count taskmaster)))))) [Generic function] shutdown taskmaster => taskmaster Shuts down the taskmaster, i.e. frees all resources that were set up by it. For example, a multi-threaded taskmaster might terminate all threads that are currently associated with it. This function is called by the acceptor's STOP method. [Generic accessor] taskmaster-acceptor taskmaster => acceptor (setf (taskmaster-acceptor taskmaster ) new-value) This is an accessor for the slot of a TASKMASTER object that links back to the acceptor it is associated with. Request dispatch and handling The main job of HANDLE-REQUEST is to select and call a function which handles the request, i.e. which looks at the data the client has sent and prepares an appropriate reply to send back. This is by default implemented as follows: The ACCEPTOR class defines a ACCEPTOR-DISPATCH-REQUEST generic function which is used to actually dispatch the request. This function is called by the default method of HANDLE-REQUEST. Each ACCEPTOR-DISPATCH-REQUEST method looks at the request object and depending on its contents decides to either handle the request or call the next method. In order to dispatch a request, Hunchentoot calls the ACCEPTOR-DISPATCH-REQUEST generic functions. The method for ACCEPTOR tries to serve a static file relative to it's ACCEPTOR-DOCUMENT-ROOT. Application specific acceptor subclasses will typically perform URL parsing and dispatching according to the policy that is required. The default method of HANDLE-REQUEST sets up standard logging and error handling before it calls the acceptor's request dispatcher. Request handlers do their work by modifying the reply object if necessary and by eventually returning the response body in the form of a string or a binary sequence. As an alternative, they can also call SEND-HEADERS and write directly to a stream. Using the easy-handler framework The EASY-ACCEPTOR class defines a method for ACCEPTOR-DISPATCH-REQUEST that walks through the list *DISPATCH-TABLE* which consists of dispatch functions. Each of these functions accepts the request object as its only argument and either returns a request handler to handle the request or NIL which means that the next dispatcher in the list will be tried. If all dispatch functions return NIL, the next ACCEPTOR-DISPATCH-REQUEST will be called. All functions and variables in this section are related to the easy request dispatch mechanism and are meaningless if you're using your own request dispatcher. [Standard class] easy-acceptor This class defines no additional slots with respect to ACCEPTOR. It only serves as an additional type for dispatching calls to ACCEPTOR-DISPATCH-REQUEST. In order to use the easy handler framework, acceptors of this class or one of its subclasses must be used. [Standard class] easy-ssl-acceptor This class mixes the SSL-ACCEPTOR and the EASY-ACCEPTOR classes. It is used when both ssl and the easy handler framework are required. [Special variable] *dispatch-table* A global list of dispatch functions. The initial value is a list consisting of the symbol DISPATCH-EASY-HANDLERS. [Function] create-prefix-dispatcher prefix handler => dispatch-fn A convenience function which will return a dispatcher that returns handler whenever the path part of the request URI starts with the string prefix. [Function] create-regex-dispatcher regex handler => dispatch-fn A convenience function which will return a dispatcher that returns handler whenever the path part of the request URI matches the CL-PPCRE regular expression regex (which can be a string, an s-expression, or a scanner). [Function] create-folder-dispatcher-and-handler uri-prefix base-path &optional content-type => dispatch-fn Creates and returns a dispatch function which will dispatch to a handler function which emits the file relative to base-path that is denoted by the URI of the request relative to uri-prefix. uri-prefix must be a string ending with a slash, base-path must be a pathname designator for an existing directory. Uses HANDLE-STATIC-FILE internally. If content-type is not NIL, it will be used as a the content type for all files in the folder. Otherwise (which is the default) the content type of each file will be determined as usual. [Function] create-static-file-dispatcher-and-handler uri path &optional content-type => result Creates and returns a request dispatch function which will dispatch to a handler function which emits the file denoted by the pathname designator PATH with content type CONTENT-TYPE if the SCRIPT-NAME of the request matches the string URI. If CONTENT-TYPE is NIL, tries to determine the content type via the file's suffix. [Macro] define-easy-handler description lambda-list [[declaration* | documentation]] form* Defines a handler as if by DEFUN and optionally registers it with a URI so that it will be found by DISPATCH-EASY-HANDLERS. description is either a symbol name or a list matching the destructuring lambda list (name &key uri acceptor-names default-parameter-type default-request-type). lambda-list is a list the elements of which are either a symbol var or a list matching the destructuring lambda list (var &key real-name parameter-type init-form request-type). The resulting handler will be a Lisp function with the name name and keyword parameters named by the var symbols. Each var will be bound to the value of the GET or POST parameter called real-name (a string) before the body of the function is executed. If real-name is not provided, it will be computed by downcasing the symbol name of var. If uri (which is evaluated) is provided, then it must be a string or a function designator for a unary function. In this case, the handler will be returned by DISPATCH-EASY-HANDLERS, if uri is a string and the script name of the current request is uri, or if uri designates a function and applying this function to the current REQUEST object returns a true value. acceptor-names (which is evaluated) can be a list of symbols which means that the handler will only be returned by DISPATCH-EASY-HANDLERS in acceptors which have one of these names (see ACCEPTOR-NAME). acceptor-names can also be the symbol T which means that the handler will be returned by DISPATCH-EASY-HANDLERS in every acceptor. Whether the GET or POST parameter (or both) will be taken into consideration, depends on request-type which can be :GET, :POST, :BOTH, or NIL. In the last case, the value of default-request-type (the default of which is :BOTH) will be used. The value of var will usually be a string (unless it resulted from a file upload in which case it won't be converted at all), but if parameter-type (which is evaluated) is provided, the string will be converted to another Lisp type by the following rules: If the corresponding GET or POST parameter wasn't provided by the client, var's value will be NIL. If parameter-type is 'STRING, var's value remains as is. If parameter-type is 'INTEGER and the parameter string consists solely of decimal digits, var's value will be the corresponding integer, otherwise NIL. If parameter-type is 'KEYWORD, var's value will be the keyword obtained by interning the upcased parameter string into the keyword package. If parameter-type is 'CHARACTER and the parameter string is of length one, var's value will be the single character of this string, otherwise NIL. If parameter-type is 'BOOLEAN, var's value will always be T (unless it is NIL by the first rule above, of course). If parameter-type is any other atom, it is supposed to be a function designator for a unary function which will be called to convert the string to something else. Those were the rules for simple parameter types, but parameter-type can also be a list starting with one of the symbols LIST, ARRAY, or HASH-TABLE. The second value of the list must always be a simple parameter type as in the last paragraph - we'll call it the inner type below. In the case of 'LIST, all GET/POST parameters called real-name will be collected, converted to the inner type as by the rules above, and assembled into a list which will be the value of var. In the case of 'ARRAY, all GET/POST parameters which have a name like the result of (format nil ""~A[~A]"" real-name n) where n is a non-negative integer, will be assembled into an array where the nth element will be set accordingly, after conversion to the inner type. The array, which will become the value of var, will be big enough to hold all matching parameters, but not bigger. Array elements not set as described above will be NIL. Note that VAR will always be bound to an array, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. The full form of a 'HASH-TABLE parameter type is (hash-table inner-type key-type test-function) but key-type and test-function can be left out in which case they default to 'STRING and 'EQUAL, respectively. For this parameter type, all GET/POST parameters which have a name like the result of (format nil ""~A{~A}"" real-name key) (where key is a string that doesn't contain curly brackets) will become the values (after conversion to inner-type) of a hash table with test function test-function where key (after conversion to key-type) will be the corresponding key. Note that var will always be bound to a hash table, which may be empty, so it will never be NIL, even if no appropriate GET/POST parameters are found. To make matters even more complicated, the three compound parameter types also have an abbreviated form - just one of the symbols LIST, ARRAY, or HASH-TABLE. In this case, the inner type will default to 'STRING. If parameter-type is not provided or NIL, default-parameter-type (the default of which is 'STRING) will be used instead. If the result of the computations above would be that var would be bound to NIL, then init-form (if provided) will be evaluated instead, and var will be bound to the result of this evaluation. Handlers built with this macro are constructed in such a way that the resulting Lisp function is useful even outside of Hunchentoot. Specifically, all the parameter computations above will only happen if *REQUEST* is bound, i.e. if we're within a Hunchentoot request. Otherwise, var will always be bound to the result of evaluating init-form unless a corresponding keyword argument is provided. The example code that comes with Hunchentoot contains an example which demonstrates some of the features of DEFINE-EASY-HANDLER. [Function] dispatch-easy-handlers request => result This is a dispatcher which returns the appropriate handler defined with DEFINE-EASY-HANDLER, if there is one. Request objects For each incoming request, the acceptor (in PROCESS-CONNECTION) creates a REQUEST object and makes it available to handlers via the special variable *REQUEST*. This object contains all relevant information about the request and this section collects the functions which can be used to query such an object. In all function where request is an optional or keyword parameter, the default is *REQUEST*. If you need more fine-grained control over the behaviour of request objects, you can subclass REQUEST and initialize the REQUEST-CLASS slot of the ACCEPTOR class accordingly. The acceptor will generate request objects of the class named by this slot. [Standard class] request Objects of this class hold all the information about an incoming request. They are created automatically by acceptors and can be accessed by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REQUEST in order to implement your own behaviour. See the REQUEST-CLASS slot of the ACCEPTOR class. [Special variable] *request* The current REQUEST object while in the context of a request. [Function] real-remote-addr &optional request => string{, list} Returns the 'X-Forwarded-For' incoming http header as the second value in the form of a list of IP addresses and the first element of this list as the first value if this header exists. Otherwise returns the value of REMOTE-ADDR as the only value. [Function] parameter name &optional request => string Returns the GET or the POST parameter with name name (a string) - or NIL if there is none. If both a GET and a POST parameter with the same name exist the GET parameter is returned. Search is case-sensitive. See also GET-PARAMETER and POST-PARAMETER. [Function] get-parameter name &optional request => string Returns the value of the GET parameter (as provided via the request URI) named by the string name as a string (or NIL if there ain't no GET parameter with this name). Note that only the first value will be returned if the client provided more than one GET parameter with the name name. See also GET-PARAMETERS*. [Function] post-parameter name &optional request => string Returns the value of the POST parameter (as provided in the request's body) named by the string name. Note that only the first value will be returned if the client provided more than one POST parameter with the name name. This value will usually be a string (or NIL if there ain't no POST parameter with this name). If, however, the browser sent a file through a multipart/form-data form, the value of this function is a three-element list (path file-name content-type) where path is a pathname denoting the place were the uploaded file was stored, file-name (a string) is the file name sent by the browser, and content-type (also a string) is the content type sent by the browser. The file denoted by path will be deleted after the request has been handled - you have to move or copy it somewhere else if you want to keep it. POST parameters will only be computed if the content type of the request body was multipart/form-data or application/x-www-form-urlencoded. Although this function is called POST-PARAMETER, you can instruct Hunchentoot to compute these parameters for other request methods by setting *METHODS-FOR-POST-PARAMETERS*. See also POST-PARAMETERS and *TMP-DIRECTORY*. [Function] get-parameters* &optional request => alist Returns an alist of all GET parameters (as provided via the request URI). The car of each element of this list is the parameter's name while the cdr is its value (as a string). The elements of this list are in the same order as they were within the request URI. See also GET-PARAMETER. [Function] post-parameters* &optional request => alist Returns an alist of all POST parameters (as provided via the request's body). The car of each element of this list is the parameter's name while the cdr is its value. The elements of this list are in the same order as they were within the request's body. See also POST-PARAMETER. [Special variable] *methods-for-post-parameters* A list of the request method types (as keywords) for which Hunchentoot will try to compute post-parameters. [Function] cookie-in name &optional request => string Returns the cookie with the name name (a string) as sent by the browser - or NIL if there is none. [Function] cookies-in* &optional request => alist Returns an alist of all cookies associated with the REQUEST object request. [Function] host &optional request => host Returns the 'Host' incoming http header value. [Function] query-string* &optional request => string Returns the query string of the REQUEST object request. That's the part behind the question mark (i.e. the GET parameters). [Function] referer &optional request => result Returns the 'Referer' (sic!) http header. [Function] request-method* &optional request => keyword Returns the request method as a Lisp keyword. [Function] request-uri* &optional request => uri Returns the request URI. [Function] server-protocol* &optional request => keyword Returns the request protocol as a Lisp keyword. [Function] user-agent &optional request => result Returns the 'User-Agent' http header. [Function] header-in* name &optional request => header Returns the incoming header with name name. name can be a keyword (recommended) or a string. [Function] headers-in* &optional request => alist Returns an alist of the incoming headers associated with the REQUEST object request. [Function] remote-addr* &optional request => address Returns the address the current request originated from. [Function] remote-port* &optional request => port Returns the port the current request originated from. [Function] local-addr* &optional request => address The IP address of the local system that the client connected to. [Function] local-port* &optional request => port The TCP port number of the local system that the client connected to. [Function] script-name* &optional request => script-name Returns the file name of the REQUEST object request. That's the requested URI without the query string (i.e the GET parameters). [Accessor] aux-request-value symbol &optional request => value, present-p (setf (aux-request-value symbol &optional request ) new-value) This accessor can be used to associate arbitrary data with the the symbol symbol in the REQUEST object request. present-p is true if such data was found, otherwise NIL. [Function] delete-aux-request-value symbol &optional request => | Removes the value associated with symbol from the REQUEST object request. [Function] authorization &optional request => result Returns as two values the user and password (if any) as encoded in the 'AUTHORIZATION' header. Returns NIL if there is no such header. [Special variable] *hunchentoot-default-external-format* The external format used to compute the REQUEST object. [Special variable] *file-upload-hook* If this is not NIL, it should be a unary function which will be called with a pathname for each file which is uploaded to Hunchentoot. The pathname denotes the temporary file to which the uploaded file is written. The hook is called directly before the file is created. At this point, *REQUEST* is already bound to the current REQUEST object, but obviously you can't access the post parameters yet. [Function] raw-post-data &key request external-format force-text force-binary want-stream => raw-body-or-stream Returns the content sent by the client in the request body if there was any (unless the content type was multipart/form-data in which case NIL is returned). By default, the result is a string if the type of the Content-Type media type is ""text"", and a vector of octets otherwise. In the case of a string, the external format to be used to decode the content will be determined from the charset parameter sent by the client (or otherwise *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT* will be used). You can also provide an external format explicitly (through external-format) in which case the result will unconditionally be a string. Likewise, you can provide a true value for force-text which will force Hunchentoot to act as if the type of the media type had been ""text"" (with external-format taking precedence if provided). Or you can provide a true value for force-binary which means that you want a vector of octets at any rate. (If both force-text and force-binary are true, an error will be signaled.) If, however, you provide a true value for want-stream, the other parameters are ignored and you'll get the content (flexi) stream to read from it yourself. It is then your responsibility to read the correct amount of data, because otherwise you won't be able to return a response to the client. The stream will have its octet position set to 0. If the client provided a Content-Length header, the stream will also have a corresponding bound, so no matter whether the client used chunked encoding or not, you can always read until EOF. If the content type of the request was multipart/form-data or application/x-www-form-urlencoded, the content has been read by Hunchentoot already and you can't read from the stream anymore. You can call RAW-POST-DATA more than once per request, but you can't mix calls which have different values for want-stream. Note that this function is slightly misnamed because a client can send content even if the request method is not POST. [Function] recompute-request-parameters &key request external-format => | Recomputes the GET and POST parameters for the REQUEST object request. This only makes sense if you're switching external formats during the request. [Generic function] process-request request => nil This function is called by PROCESS-CONNECTION after the incoming headers have been read. It calls HANDLE-REQUEST (and is more or less just a thin wrapper around it) to select and call a handler and send the output of this handler to the client. Note that PROCESS-CONNECTION is called once per connection and loops in case of a persistent connection while PROCESS-REQUEST is called anew for each request. The return value of this function is ignored. Like PROCESS-CONNECTION, this is another function the behaviour of which you should only modify if you really, really know what you're doing. [Generic function] handle-request acceptor request => content This function is called by PROCESS-REQUEST once the request has been read and a REQUEST object has been created. Its job is to actually handle the request, i.e. to return something to the client. The default method calls the acceptor's request dispatcher, but you can of course implement a different behaviour. The default method also sets up standard error handling for the handler. Might be a good place to bind or rebind special variables which can then be accessed by your handlers. [Generic function] acceptor-dispatch-request acceptor request => content This function is called to actually dispatch the request once the standard logging and error handling has been set up. ACCEPTOR subclasses implement methods for this function in order to perform their own request routing. If a method does not want to handle the request, it is supposed to invoke CALL-NEXT-METHOD so that the next ACCEPTOR in the inheritance chain gets a chance to handle the request. [Generic readers] cookies-in request => cookies get-parameters request => get-parameters header-in name request => result headers-in request => headers post-parameters request => post-parameters query-string request => query-string remote-addr request => address remote-port request => port local-addr request => address local-port request => port request-acceptor request => acceptor request-method request => method request-uri request => uri server-protocol request => protocol script-name request => result These are various generic readers which are used to read information about a REQUEST object. If you are writing a handler, you should not use these readers but instead utilize the corresponding functions with an asterisk at the end of their name, also listed in this section. These generic readers are only exported for users who want to create their own subclasses of REQUEST. Reply objects For each incoming request, the acceptor (in PROCESS-CONNECTION) creates a REPLY object and makes it available to handlers via the special variable *REPLY*. This object contains all relevant information (except for the content body) about the reply that will be sent to the client and this section collects the functions which can be used to query and modify such an object. In all function where reply is an optional or keyword parameter, the default is *REPLY*. If you need more fine-grained control over the behaviour of reply objects, you can subclass REPLY and initialize the REPLY-CLASS slot of the ACCEPTOR class accordingly. The acceptor will generate reply objects of the class named by this slot. [Standard class] reply Objects of this class hold all the information about an outgoing reply. They are created automatically by Hunchentoot and can be accessed and modified by the corresponding handler. You should not mess with the slots of these objects directly, but you can subclass REPLY in order to implement your own behaviour. See the :reply-class initarg of the ACCEPTOR class. [Special variable] *reply* The current REPLY object in the context of a request. [Accessor] header-out name &optional reply => string (setf (header-out name &optional reply ) new-value) HEADER-OUT returns the outgoing http header named by the keyword name if there is one, otherwise NIL. SETF of HEADER-OUT changes the current value of the header named name. If no header named name exists, it is created. For backwards compatibility, name can also be a string in which case the association between a header and its name is case-insensitive. Note that the header 'Set-Cookie' cannot be queried by HEADER-OUT and must not be set by SETF of HEADER-OUT. See also HEADERS-OUT*, CONTENT-TYPE*, CONTENT-LENGTH*, COOKIES-OUT*, and COOKIE-OUT. [Function] headers-out* &optional reply => alist Returns an alist of the outgoing headers associated with the REPLY object reply. See also HEADER-OUT. [Accessor] content-length* &optional reply => content-length (setf (content-length* &optional reply ) new-value) The outgoing 'Content-Length' http header of reply. [Accessor] content-type* &optional reply => content-type (setf (content-type* &optional reply ) new-value) The outgoing 'Content-Type' http header of reply. [Function] cookie-out name &optional reply => result Returns the current value of the outgoing cookie named name. Search is case-sensitive. [Accessor] cookies-out* &optional reply => alist (setf (cookies-out* &optional reply ) new-value) Returns or sets an alist of the outgoing cookies associated with the REPLY object reply. [Accessor] return-code* &optional reply => return-code (setf (return-code* &optional reply ) new-value) Gets or sets the http return code of reply. The return code of each REPLY object is initially set to +HTTP-OK+. [Function] send-headers => stream Sends the initial status line and all headers as determined by the REPLY object *REPLY*. Returns a binary stream to which the body of the reply can be written. Once this function has been called, further changes to *REPLY* don't have any effect. Also, automatic handling of errors (i.e. sending the corresponding status code to the browser, etc.) is turned off for this request and functions like REDIRECT or to ABORT-REQUEST-HANDLER won't have the desired effect once the headers are sent. If your handlers return the full body as a string or as an array of octets, you should not call this function. If a handler calls SEND-HEADERS , its return value is ignored. [Accessor] reply-external-format* &optional reply => external-format (setf (reply-external-format* &optional reply ) new-value) Gets or sets the external format of reply which is used for character output. [Special variable] *default-content-type* The default content-type header which is returned to the client. [Constants] +http-continue+ +http-switching-protocols+ +http-ok+ +http-created+ +http-accepted+ +http-non-authoritative-information+ +http-no-content+ +http-reset-content+ +http-partial-content+ +http-multi-status+ +http-multiple-choices+ +http-moved-permanently+ +http-moved-temporarily+ +http-see-other+ +http-not-modified+ +http-use-proxy+ +http-temporary-redirect+ +http-bad-request+ +http-authorization-required+ +http-payment-required+ +http-forbidden+ +http-not-found+ +http-method-not-allowed+ +http-not-acceptable+ +http-proxy-authentication-required+ +http-request-time-out+ +http-conflict+ +http-gone+ +http-length-required+ +http-precondition-failed+ +http-request-entity-too-large+ +http-request-uri-too-large+ +http-unsupported-media-type+ +http-requested-range-not-satisfiable+ +http-expectation-failed+ +http-failed-dependency+ +http-internal-server-error+ +http-not-implemented+ +http-bad-gateway+ +http-service-unavailable+ +http-gateway-time-out+ +http-version-not-supported+ The values of these constants are 100, 101, 200, 201, 202, 203, 204, 205, 206, 207, 300, 301, 302, 303, 304, 305, 307, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 424, 500, 501, 502, 503, 504, and 505. See RETURN-CODE. [Generic readers] content-length reply => content-length content-type reply => content-type headers-out reply => headers-out These are various generic readers which are used to read information about a REPLY object. If you are writing a handler, you should not use these readers but instead utilize the corresponding functions with an asterisk at the end of their name, also listed in this section. These generic readers are only exported for users who want to create their own subclasses of REPLY. [Generic accessors] cookies-out reply => result (setf (cookies-out reply ) new-value) return-code reply => result (setf (return-code reply ) new-value) reply-external-format reply => result (setf (reply-external-format reply ) new-value) These are various generic accessors which are used to query and modify a REPLY objects. If you are writing a handler, you should not use these accessors but instead utilize the corresponding functions with an asterisk at the end of their name, also listed in this section. These generic accessors are only exported for users who want to create their own subclasses of REPLY. Sessions Hunchentoot supports sessions: Once a request handler has called START-SESSION, Hunchentoot uses either cookies or (if the client doesn't send the cookies back) rewrites URLs to keep track of this client, i.e. to provide a kind of 'state' for the stateless http protocol. The session associated with the client is a CLOS object which can be used to store arbitrary data between requests. Hunchentoot makes some reasonable effort to prevent eavesdroppers from hijacking sessions (see below), but this should not be considered really secure. Don't store sensitive data in sessions and rely solely on the session mechanism as a safeguard against malicious users who want to get at this data! For each request there's one SESSION object which is accessible to the handler via the special variable *SESSION*. This object holds all the information available about the session and can be accessed with the functions described in this chapter. Note that the internal structure of SESSION objects should be considered opaque and may change in future releases of Hunchentoot. Sessions are automatically verified for validity and age when the REQUEST object is instantiated, i.e. if *SESSION* is not NIL then this session is valid (as far as Hunchentoot is concerned) and not too old. Old sessions are automatically removed. Hunchentoot also provides a SESSION-REGENERATE-COOKIE-VALUE function that creates a new cookie value. This helps to prevent against session fixation attacks, and should be used when a user logs in according to the application. [Standard class] session SESSION objects are automatically maintained by Hunchentoot. They should not be created explicitly with MAKE-INSTANCE but implicitly with START-SESSION and they should be treated as opaque objects. You can ignore Hunchentoot's SESSION objects and implement your own sessions if you provide corresponding methods for SESSION-COOKIE-VALUE and SESSION-VERIFY. [Function] start-session => session Returns the current SESSION object. If there is no current session, creates one and updates the corresponding data structures. In this case the function will also send a session cookie to the browser. [Accessor] session-value symbol &optional session => value, present-p (setf (session-value symbol &optional session ) new-value) This accessor can be used to associate arbitrary data with the the symbol symbol in the SESSION object session. present-p is true if such data was found, otherwise NIL. The default value for session is *SESSION*. If SETF of SESSION-VALUE is called with session being NIL then a session is automatically instantiated with START-SESSION. [Function] delete-session-value symbol &optional session => | Removes the value associated with symbol from session if there is one. [Special variable] *session* The current session while in the context of a request, or NIL. [Function] remove-session session => | Completely removes the SESSION object session from Hunchentoot's internal session database. [Function] reset-sessions &optional acceptor => | Removes all stored sessions of acceptor. The default for acceptor is *ACCEPTOR*. [Function] regenerate-session-cookie-value session => cookie Regenerates the session cookie value. This should be used when a user logs in according to the application to prevent against session fixation attacks. The cookie value being dependent on ID, USER-AGENT, REMOTE-ADDR, START, and *SESSION-SECRET*, the only value we can change is START to regenerate a new value. Since we're generating a new cookie, it makes sense to have the session being restarted, in time. That said, because of this fact, calling this function twice in the same second will regenerate twice the same value. [Special variable] *rewrite-for-session-urls* Whether HTML pages should possibly be rewritten for cookie-less session-management. [Special variable] *content-types-for-url-rewrite* The content types for which url-rewriting is OK. See *REWRITE-FOR-SESSION-URLS*. [Special variable] *use-remote-addr-for-sessions* Whether the client's remote IP (as returned by REAL-REMOTE-ADDR) should be encoded into the session string. If this value is true, a session will cease to be accessible if the client's remote IP changes. This might for example be an issue if the client uses a proxy server which doesn't send correct 'X-Forwarded-For' headers. [Generic function] session-remote-addr session => remote-addr The remote IP address of the client when this session was started (as returned by REAL-REMOTE-ADDR). [Special variable] *use-user-agent-for-sessions* Whether the 'User-Agent' header should be encoded into the session string. If this value is true, a session will cease to be accessible if the client sends a different 'User-Agent' header. [Generic function] session-user-agent session => user-agent The incoming 'User-Agent' header that was sent when this session was created. [Generic accessor] session-max-time session => max-time (setf (session-max-time session ) new-value) Gets or sets the time (in seconds) after which session expires if it's not used. [Special variable] *session-max-time* The default time (in seconds) after which a session times out. [Special variable] *session-gc-frequency* A session GC (see function SESSION-GC) will happen every *SESSION-GC-FREQUENCY* requests (counting only requests which create a new session) if this variable is not NIL. See SESSION-CREATED. [Function] session-gc => | Removes sessions from the current session database which are too old - see SESSION-TOO-OLD-P. [Function] session-too-old-p session => generalized-boolean Returns true if the SESSION object session has not been active in the last (session-max-time session) seconds. [Generic function] session-id session => session-id The unique ID (an INTEGER) of the session. [Generic function] session-start session => universal-time The time this session was started. Customizing session behaviour For everyday session usage, you will probably just use START-SESSION, SESSION-VALUE, and maybe DELETE-SESSION-VALUE and *SESSION*. However, there are two ways to customize the way Hunchentoot maintains sessions. One way is to mostly leave the session mechanism intact but to tweak it a bit: The publicly visible part of a session is encoded using a secret which you can set yourself. And it is stored using a cookie (or GET parameter) name that you can override. Each session receives a new ID when it is created and you can implement a more robust way to do that. You can arrange to be called whenever a session is created to trigger some action. You might also do this to invent your own session garbage collection. By default, all sessions are stored in a global alist in memory. You can't change the alist part, but you can distribute your sessions over different ""databases"". By default, every operation which modifies sessions or one of the session databases is guarded by a global lock, but you can arrange to provide different locks for this. The other way to customize Hunchentoot's sessions is to completely replace them. This is actually pretty easy: Create your own class to store state (which doesn't have to and probably shouldn't inherit from SESSION) and implement methods for SESSION-VERIFY and SESSION-COOKIE-VALUE - that's it. Hunchentoot will continue to use cookies and/or to rewrite URLs to keep track of session state and it will store ""the current session"" (whatever that is in your implementation) in *SESSION*. Everything else (like persisting sessions, GC, getting and setting values) you'll have to take care of yourself and the other session functions (like START-SESSION or SESSION-VALUE) won't work anymore. (Almost) total freedom, but a lot of responsibility as well... :) [Special variable] *session-secret* A random ASCII string that's used to encode the public session data. This variable is initially unbound and will be set (using RESET-SESSION-SECRET) the first time a session is created, if necessary. You can prevent this from happening if you set the value yourself before starting acceptors. [Function] reset-session-secret => secret Sets *SESSION-SECRET* to a new random value. All old sessions will cease to be valid. [Generic function] session-cookie-name acceptor => name Returns the name (a string) of the cookie (or the GET parameter) which is used to store a session on the client side. The default is to use the string ""hunchentoot-session"", but you can specialize this function if you want another name. [Generic function] session-created acceptor new-session => result This function is called whenever a new session has been created. There's a default method which might trigger a session GC based on the value of *SESSION-GC-FREQUENCY*. The return value is ignored. [Generic function] next-session-id acceptor => id Returns the next sequential session ID, an integer, which should be unique per session. The default method uses a simple global counter and isn't guarded by a lock. For a high-performance production environment you might consider using a more robust implementation. [Generic accessor] session-db acceptor => database (setf (session-db acceptor ) new-value) Returns the current session database which is an alist where each car is a session's ID and the cdr is the corresponding SESSION object itself. The default is to use a global list for all acceptors. [Generic function] session-db-lock acceptor &key whole-db-p => lock A function which returns a lock that will be used to prevent concurrent access to sessions. The first argument will be the acceptor that handles the current request, the second argument is true if the whole (current) session database is modified. If it is NIL, only one existing session in the database is modified. This function can return NIL which means that sessions or session databases will be modified without a lock held (for example for single-threaded environments). The default is to always return a global lock (ignoring the acceptor argument) for Lisps that support threads and NIL otherwise. [Generic function] session-verify request => session-or-nil Tries to get a session identifier from the cookies (or alternatively from the GET parameters) sent by the client (see SESSION-COOKIE-NAME and SESSION-COOKIE-VALUE). This identifier is then checked for validity against the REQUEST object request. On success the corresponding session object (if not too old) is returned (and updated). Otherwise NIL is returned. A default method is provided and you only need to write your own one if you want to maintain your own sessions. [Generic function] session-cookie-value session => string Returns a string which can be used to safely restore the session session if as session has already been established. This is used as the value stored in the session cookie or in the corresponding GET parameter and verified by SESSION-VERIFY. A default method is provided and there's no reason to change it unless you want to use your own session objects. Cookies Outgoing cookies are stored in the request's REPLY object (see COOKIE-OUT and COOKIES-OUT*). They are CLOS objects defined like this: (defclass cookie ()   ((name :initarg :name          :reader cookie-name          :type string          :documentation ""The name of the cookie - a string."")    (value :initarg :value           :accessor cookie-value           :initform """"           :documentation ""The value of the cookie. Will be URL-encoded when sent to the browser."")    (expires :initarg :expires             :initform nil             :accessor cookie-expires             :documentation ""The time (a universal time) when the cookie expires (or NIL)."")    (max-age :initarg :max-age             :initform nil             :accessor cookie-max-age             :documentation ""The time delta (in seconds) after which the cookie expires (or NIL)."")    (path :initarg :path          :initform nil          :accessor cookie-path          :documentation ""The path this cookie is valid for (or NIL)."")    (domain :initarg :domain            :initform nil            :accessor cookie-domain            :documentation ""The domain this cookie is valid for (or NIL)."")    (secure :initarg :secure            :initform nil            :accessor cookie-secure            :documentation ""A generalized boolean denoting whether this is a secure cookie."")    (http-only :initarg :http-only               :initform nil               :accessor cookie-http-only               :documentation ""A generalized boolean denoting whether this is a HttpOnly cookie."")))       The reader COOKIE-NAME and the accessors COOKIE-VALUE, COOKIE-EXPIRES, COOKIE-MAX-AGE, COOKIE-PATH, COOKIE-DOMAIN, COOKIE-SECURE, and COOKIE-HTTP-ONLY are all exported from the HUNCHENTOOT package. For now, the class name itself is not exported. [Function] set-cookie name &key value expires path domain secure http-only reply => cookie Creates a COOKIE object from the parameters provided to this function and adds it to the outgoing cookies of the REPLY object reply. If a cookie with the same name (case-sensitive) already exists, it is replaced. The default for reply is *REPLY*. The default for value is the empty string. [Function] set-cookie* cookie &optional reply => cookie Adds the COOKIE object cookie to the outgoing cookies of the REPLY object reply. If a cookie with the same name (case-sensitive) already exists, it is replaced. The default for reply is *REPLY*. Logging Hunchentoot can log accesses and diagnostic messages to two separate destinations, which can be either files in the file system or streams. Logging can also be disabled by setting the ACCESS-LOG-DESTINATION and MESSAGE-LOG-DESTINATION slots in the ACCEPTOR to NIL. The two slots can be initialized by providing the :ACCESS-LOG-DESTINATION and :MESSAGE-LOG-DESTINATION initialization arguments when creating the acceptor or set by setting the slots through its ACCEPTOR-MESSAGE-LOG-DESTINATION and ACCEPTOR-ACCESS-LOG-DESTINATION accessors. When the path for the message or accept log is set to a variable holding an output stream, hunchentoots writes corresponding log entries to that stream. By default, Hunchentoot logs to *STANDARD-ERROR*. Access logging is done in a format similar to what the Apache web server can write so that logfile analysis using standard tools is possible. Errors during request processing are logged to a separate file. The standard logging mechanism is deliberately simple and slow. The log files are opened for each log entry and closed again after writing, and access to them is protected by a global lock. Derived acceptor classes can implement methods for the ACCEPTOR-LOG-MESSAGE and ACCEPTOR-LOG-ACCESS generic functions in order to log differently (e.g. to a central logging server or in a different file format. Errors happening within a handler which are not caught by the handler itself are handled by Hunchentoot by logging them to the established ACCEPTOR-MESSAGE-LOG-DESTINATION. [Function] log-message* log-level format-string &rest format-arguments => result Convenience function which calls the message logger of the current acceptor (if there is one) with the same arguments it accepts. Returns NIL if there is no message logger or whatever the message logger returns. This is the function which Hunchentoot itself uses to log errors it catches during request processing. [Special variable] *log-lisp-errors-p* Whether Lisp errors in request handlers should be logged. [Special variable] *log-lisp-backtraces-p* Whether Lisp backtraces should be logged. Only has an effect if *LOG-LISP-ERRORS-P* is true as well. [Special variable] *log-lisp-warnings-p* Whether Lisp warnings in request handlers should be logged. [Special variable] *lisp-errors-log-level* Log level for Lisp errors. Should be one of :ERROR (the default), :WARNING, or :INFO. [Special variable] *lisp-warnings-log-level* Log level for Lisp warnings. Should be one of :ERROR, :WARNING (the default), or :INFO. Conditions and error handling This section describes how Hunchentoot deals with exceptional situations. See also the secion about logging. When an error occurs while processing a request, Hunchentoot's default behavior is to catch the error, log it and optionally display it to the client in the HTML response. This behavior can be customized through the values of a number of special variables, which are documented below. [Special variable] *catch-errors-p* If the value of this variable is NIL (the default is T), then errors which happen while a request is handled aren't caught as usual, but instead your Lisp's debugger is invoked. This variable should obviously always be set to a true value in a production environment. See MAYBE-INVOKE-DEBUGGER if you want to fine-tune this behaviour. [Special variable] *show-lisp-errors-p* Whether Lisp errors should be shown in HTML output. Note that this only affects canned responses generated by Lisp. If an error template is present for the ""internal server error"" status code, this special variable is not used (see acceptor-status-message). [Special variable] *show-lisp-backtraces-p* Whether Lisp backtraces should be shown in HTML output if *SHOW-LISP-ERRORS-P* is true and an error occurs. [Generic function] maybe-invoke-debugger condition => | This generic function is called whenever a condition condition is signaled in Hunchentoot. You might want to specialize it on specific condition classes for debugging purposes. The default method invokes the debugger with condition if *CATCH-ERRORS-P* is NIL. [Condition type] hunchentoot-condition Superclass for all conditions related to Hunchentoot. [Condition type] hunchentoot-error Superclass for all errors related to Hunchentoot and a subclass of HUNCHENTOOT-CONDITION. [Condition type] parameter-error Signalled if a function was called with incosistent or illegal parameters. A subclass of HUNCHENTOOT-ERROR. [Condition type] hunchentoot-warning Superclass for all warnings related to Hunchentoot and a subclass of HUNCHENTOOT-CONDITION. Miscellaneous Various functions and variables which didn't fit into one of the other categories. [Function] abort-request-handler &optional result => result This function can be called by a request handler at any time to immediately abort handling the request. This works as if the handler had returned result. See the source code of REDIRECT for an example. [Function] handle-if-modified-since time &optional request => | This function is designed to be used inside a handler. If the client has sent an 'If-Modified-Since' header (see RFC 2616, section 14.25) and the time specified matches the universal time time then the header +HTTP-NOT-MODIFIED+ with no content is immediately returned to the client. Note that for this function to be useful you should usually send 'Last-Modified' headers back to the client. See the code of CREATE-STATIC-FILE-DISPATCHER-AND-HANDLER for an example. [Function] handle-static-file path &optional content-type => nil Sends the file denoted by the pathname designator path with content type content-type to the client. Sets the necessary handlers. In particular the function employs HANDLE-IF-MODIFIED-SINCE. If content-type is NIL the function tries to determine the correct content type from the file's suffix or falls back to ""application/octet-stream"" as a last resort. Note that this function calls SEND-HEADERS internally, so after you've called it, the headers are sent and the return value of your handler is ignored. [Function] redirect target &key host port protocol add-session-id code => | Sends back appropriate headers to redirect the client to target (a string). If target is a full URL starting with a scheme, host, port, and protocol are ignored. Otherwise, target should denote the path part of a URL, protocol must be one of the keywords :HTTP or :HTTPS, and the URL to redirect to will be constructed from host, port, protocol, and target. code must be a 3xx HTTP redirection status code to send to the client. It defaults to 302 (""Found""). If host is not provided, the current host (see HOST) will be used. If protocol is the keyword :HTTPS, the client will be redirected to a https URL, if it's :HTTP it'll be sent to a http URL. If both host and protocol aren't provided, then the value of protocol will match the current request. [Function] require-authorization &optional realm => | Sends back appropriate headers to require basic HTTP authentication (see RFC 2617) for the realm realm. The default value for realm is ""Hunchentoot"". [Function] no-cache => | Adds appropriate headers to completely prevent caching on most browsers. [Function] ssl-p &optional acceptor => generalized-boolean Whether the current connection to the client is secure. See ACCEPTOR-SSL-P. [Function] reason-phrase return-code => string Returns a reason phrase for the HTTP return code return-code (which should be an integer) or NIL for return codes Hunchentoot doesn't know. [Function] rfc-1123-date &optional time => string Generates a time string according to RFC 1123. Default is current time. This can be used to send a 'Last-Modified' header - see HANDLE-IF-MODIFIED-SINCE. [Function] url-encode string &optional external-format => string URL-encodes a string using the external format external-format. The default for external-format is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. [Function] url-decode string &optional external-format => string Decodes a URL-encoded string which is assumed to be encoded using the external format external-format, i.e. this is the inverse of URL-ENCODE. It is assumed that you'll rarely need this function, if ever. But just in case - here it is. The default for external-format is the value of *HUNCHENTOOT-DEFAULT-EXTERNAL-FORMAT*. [Function] escape-for-html string => result Escapes the characters #\<, #\>, #\', #\"", and #\& for HTML output. [Function] http-token-p object => generalized-boolean This function tests whether object is a non-empty string which is a token according to RFC 2068 (i.e. whether it may be used for, say, cookie names). [Function] mime-type pathspec => result Given a pathname designator pathspec returns the MIME type (as a string) corresponding to the suffix of the file denoted by pathspec (or NIL). [Function] within-request-p => generalized-boolean Returns true if in the context of a request. Otherwise, NIL. [Special variable] *tmp-directory* This should be a pathname denoting a directory where temporary files can be stored. It is used for file uploads. [Special variable] *header-stream* If this variable is not NIL, it should be bound to a stream to which incoming and outgoing headers will be written for debugging purposes. [Special variable] *cleanup-function* A designator for a function without arguments which is called on a regular basis if *CLEANUP-INTERVAL* is not NIL. The initial value is the name of a function which invokes a garbage collection on 32-bit versions of LispWorks. This variable is only available on LispWorks. [Special variable] *cleanup-interval* Should be NIL or a positive integer. The system calls *CLEANUP-FUNCTION* whenever *CLEANUP-INTERVAL* new worker threads (counted globally across all acceptors) have been created unless the value is NIL. The initial value is 100. This variable is only available on LispWorks. Testing Hunchentoot comes with a test script which verifies that the example web server responds as expected. This test script uses the Drakma HTTP client library and thus shares a significant amount of its base code with Hunchentoot itself. Still, running the test script is a useful confidence test, and it is also possible to run the script across machines in order to verify a new Hunchentoot (or, for that matter Drakma) port. To run the confidence test, start the example web server. Then, in your Lisp listener, type (hunchentoot-test:test-hunchentoot ""http://localhost:4242"") You will see some diagnostic output and a summary line that reports whether any tests have failed. (You can also use the example certificate and key files in the test directory and start and test an https server instead.) [Function] hunchentoot-test:test-hunchentoot base-url &key => | Runs the built-in confidence test. base-url is the base URL to use for testing, it should not have a trailing slash. The keyword arguments accepted are for future extension and should not currently be used. The script expects the Hunchentoot example test server to be running at the given base-url and retrieves various pages from that server, expecting certain responses. Debugging By default, Hunchentoot intercepts all errors that occur while executing request handlers, logs them to the log file and displays a static error page to the user. While developing applications, you may want to change that behavior so that the debugger is invoked when an error occurs. You can set the *CATCH-ERRORS-P* to NIL to make that happen. Alternatively, you may want to have Hunchentoot display detailed error information in the error response page. You can set the *SHOW-LISP-ERRORS-P* to a true value to make that happen. If you don't want to see Lisp backtraces in these error pages, you can set *SHOW-LISP-BACKTRACES-P* to NIL. History Hunchentoot's predecessor TBNL (which is short for ""To Be Named Later"") grew over the years as a toolkit that I used for various commercial and private projects. In August 2003, Daniel Barlow started a review of web APIs on the lispweb mailing list and I described the API of my hitherto-unreleased bunch of code (and christened it ""TBNL""). It turned out that Jeff Caldwell had worked on something similar so he emailed me and proposed to join our efforts. As I had no immediate plans to release my code (which was poorly organized, undocumented, and mostly CMUCL-specific), I gave it to Jeff and he worked towards a release. He added docstrings, refactored, added some stuff, and based it on KMRCL to make it portable across several Lisp implementations. Unfortunately, Jeff is at least as busy as I am so he didn't find the time to finish a full release. But in spring 2004 I needed a documented version of the code for a client of mine who thought it would be good if the toolkit were publicly available under an open source license. So I took Jeff's code, refactored again (to sync with the changes I had done in the meantime), and added documentation. This resulted in TBNL 0.1.0 (which initially required mod_lisp as its front-end). In March 2005, Bob Hutchinson sent patches which enabled TBNL to use other front-ends than mod_lisp. This made me aware that TBNL was already almost a full web server, so eventually I wrote Hunchentoot which was a full web server, implemented as a wrapper around TBNL. Hunchentoot 0.1.0 was released at the end of 2005 and was originally LispWorks-only. Hunchentoot 0.4.0, released in October 2006, was the first release which also worked with other Common Lisp implementations. It is a major rewrite and also incorporates most of TBNL and replaces it completely. Hunchentoot 1.0.0, released in February 2009, is again a major rewrite and should be considered work in progress. It moved to using the usocket and Bordeaux Threads libraries for non-LispWorks Lisps, thereby removing most of the platform dependent code. Threading behaviour was made controllable through the introduction of taskmasters. mod_lisp support and several other things were removed in this release to simplify the code base (and partly due to the lack of interest). Several architectural changes (lots of them not backwards-compatible) were made to ease customization of Hunchentoot's behaviour. A significant part of the 1.0.0 redesign was done by Hans Hübner. Symbol index Here are all exported symbols of the HUNCHENTOOT package in alphabetical order linked to their corresponding documentation entries: *acceptor*Special variable *catch-errors-p*Special variable *cleanup-function*Special variable *cleanup-interval*Special variable *content-types-for-url-rewrite*Special variable *default-connection-timeout*Special variable *default-content-type*Special variable *dispatch-table*Special variable *file-upload-hook*Special variable *header-stream*Special variable *hunchentoot-default-external-format*Special variable *lisp-errors-log-level*Special variable *lisp-warnings-log-level*Special variable *log-lisp-backtraces-p*Special variable *log-lisp-errors-p*Special variable *log-lisp-warnings-p*Special variable *methods-for-post-parameters*Special variable *reply*Special variable *request*Special variable *rewrite-for-session-urls*Special variable *session*Special variable *session-gc-frequency*Special variable *session-max-time*Special variable *session-secret*Special variable *show-lisp-backtraces-p*Special variable *show-lisp-errors-p*Special variable *tmp-directory*Special variable *use-remote-addr-for-sessions*Special variable *use-user-agent-for-sessions*Special variable +http-accepted+Constant +http-authorization-required+Constant +http-bad-gateway+Constant +http-bad-request+Constant +http-conflict+Constant +http-continue+Constant +http-created+Constant +http-expectation-failed+Constant +http-failed-dependency+Constant +http-forbidden+Constant +http-gateway-time-out+Constant +http-gone+Constant +http-internal-server-error+Constant +http-length-required+Constant +http-method-not-allowed+Constant +http-moved-permanently+Constant +http-moved-temporarily+Constant +http-multi-status+Constant +http-multiple-choices+Constant +http-no-content+Constant +http-non-authoritative-information+Constant +http-not-acceptable+Constant +http-not-found+Constant +http-not-implemented+Constant +http-not-modified+Constant +http-ok+Constant +http-partial-content+Constant +http-payment-required+Constant +http-precondition-failed+Constant +http-proxy-authentication-required+Constant +http-request-entity-too-large+Constant +http-request-time-out+Constant +http-request-uri-too-large+Constant +http-requested-range-not-satisfiable+Constant +http-reset-content+Constant +http-see-other+Constant +http-service-unavailable+Constant +http-switching-protocols+Constant +http-temporary-redirect+Constant +http-unsupported-media-type+Constant +http-use-proxy+Constant +http-version-not-supported+Constant abort-request-handlerFunction accept-connectionsGeneric function acceptorStandard class acceptor-access-log-destinationGeneric accessor acceptor-addressGeneric reader acceptor-dispatch-requestGeneric function acceptor-document-rootGeneric accessor acceptor-error-template-directoryGeneric accessor acceptor-input-chunking-pGeneric accessor acceptor-listen-backlogGeneric function acceptor-log-accessGeneric function acceptor-log-messageGeneric function acceptor-message-log-destinationGeneric accessor acceptor-nameGeneric accessor acceptor-output-chunking-pGeneric accessor acceptor-persistent-connections-pGeneric accessor acceptor-portGeneric reader acceptor-read-timeoutGeneric reader acceptor-remove-sessionGeneric function acceptor-reply-classGeneric accessor acceptor-request-classGeneric accessor acceptor-ssl-certificate-fileGeneric reader acceptor-ssl-pGeneric function acceptor-ssl-privatekey-fileGeneric reader acceptor-ssl-privatekey-passwordGeneric reader acceptor-status-messageGeneric function acceptor-write-timeoutGeneric reader authorizationFunction aux-request-valueAccessor content-lengthGeneric reader content-length*Accessor content-typeGeneric reader content-type*Accessor cookie-inFunction cookie-outFunction cookies-inGeneric reader cookies-in*Function cookies-outGeneric accessor cookies-out*Accessor create-folder-dispatcher-and-handlerFunction create-prefix-dispatcherFunction create-regex-dispatcherFunction create-request-handler-threadGeneric function create-static-file-dispatcher-and-handlerFunction define-easy-handlerMacro delete-aux-request-valueFunction delete-session-valueFunction detach-socketGeneric function dispatch-easy-handlersFunction easy-acceptorStandard class easy-ssl-acceptorStandard class escape-for-htmlFunction execute-acceptorGeneric function get-parameterFunction get-parametersGeneric reader get-parameters*Function handle-if-modified-sinceFunction handle-incoming-connectionGeneric function handle-requestGeneric function handle-static-fileFunction header-inGeneric reader header-in*Function header-outAccessor headers-inGeneric reader headers-in*Function headers-outGeneric reader headers-out*Function hostFunction http-token-pFunction hunchentoot-conditionCondition type hunchentoot-errorCondition type hunchentoot-test:test-hunchentootFunction hunchentoot-warningCondition type initialize-connection-streamGeneric function local-addrGeneric reader local-addr*Function local-portGeneric reader local-port*Function log-message*Function maybe-invoke-debuggerGeneric function mime-typeFunction multi-threaded-taskmasterStandard class next-session-idGeneric function no-cacheFunction one-thread-per-connection-taskmasterStandard class parameterFunction parameter-errorCondition type post-parameterFunction post-parametersGeneric reader post-parameters*Function process-connectionGeneric function process-requestGeneric function query-stringGeneric reader query-string*Function raw-post-dataFunction real-remote-addrFunction reason-phraseFunction recompute-request-parametersFunction redirectFunction refererFunction regenerate-session-cookie-valueFunction remote-addrGeneric reader remote-addr*Function remote-portGeneric reader remote-port*Function remove-sessionFunction replyStandard class reply-external-formatGeneric accessor reply-external-format*Accessor requestStandard class request-acceptorGeneric reader request-methodGeneric reader request-method*Function request-uriGeneric reader request-uri*Function require-authorizationFunction reset-connection-streamGeneric function reset-session-secretFunction reset-sessionsFunction return-codeGeneric accessor return-code*Accessor rfc-1123-dateFunction script-nameGeneric reader script-name*Function send-headersFunction server-protocolGeneric reader server-protocol*Function sessionStandard class session-cookie-nameGeneric function session-cookie-valueGeneric function session-createdGeneric function session-dbGeneric accessor session-db-lockGeneric function session-gcFunction session-idGeneric function session-max-timeGeneric accessor session-remote-addrGeneric function session-startGeneric function session-too-old-pFunction session-user-agentGeneric function session-valueAccessor session-verifyGeneric function set-cookieFunction set-cookie*Function shutdownGeneric function single-threaded-taskmasterStandard class ssl-acceptorStandard class ssl-pFunction startGeneric function start-listeningGeneric function start-sessionFunction start-threadGeneric function stopGeneric function taskmasterStandard class taskmaster-acceptorGeneric accessor url-decodeFunction url-encodeFunction user-agentFunction within-request-pFunction Acknowledgements Thanks to Jeff Caldwell - TBNL would not have been released without his efforts. Thanks to Stefan Scholl and Travis Cross for various additions and fixes to TBNL, to Michael Weber for initial file upload code, and to Janis Dzerins for his RFC 2388 code. Thanks to Bob Hutchison for his code for multiple front-ends (which made me realize that TBNL was already pretty close to a ""real"" web server) and the initial UTF-8 example. Thanks to Hans Hübner for a lot of architectural and implementation enhancements for the 1.0.0 release and also for transferring the documentation to sane XHTML. Thanks to John Foderaro's AllegroServe for inspiration. Thanks to Uwe von Loh for the Hunchentoot logo. Hunchentoot originally used code from ACL-COMPAT, specifically the chunking code from Jochen Schmidt. (This has been replaced by Chunga.) When I ported Hunchentoot to other Lisps than LispWorks, I stole code from ACL-COMPAT, KMRCL, and trivial-sockets for implementation-dependent stuff like sockets and MP. (This has been replaced by Bordeaux Threads and usocket.) Parts of this documentation were prepared with DOCUMENTATION-TEMPLATE, no animals were harmed. BACK TO MY HOMEPAGE"	"null"	"null"	"A web server.."	"true"
"Network and Internet"	"lquery"	"https://github.com/Shinmera/lquery"	"A jQuery-like HTML/DOM manipulation library.."	"null"	"null"	"null"	"Artistic License 2.0"	"http://directory.fsf.org/wiki/License:ArtisticLicense2.0"	"null"	"null"	"18"	"4"	"0"	"GitHub - Shinmera/lquery: A Common Lisp library to allow jQuery-like HTML/DOM manipulation. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 4 Star 18 Fork 0 Shinmera/lquery Code Issues 0 Pull requests 0 Pulse Graphs A Common Lisp library to allow jQuery-like HTML/DOM manipulation. https://shinmera.github.io/lquery 208 commits 3 branches 3 releases Fetching contributors HTML 53.5% Common Lisp 46.5% HTML Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags 2.5 gh-pages master Nothing to show 3.1.0 3.0.0 2.0.6 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. LICENSE README.md about.html lquery-funcs.lisp lquery-logo.png lquery-macros.lisp lquery-test.asd lquery-test.lisp lquery.asd lquery.lisp package.lisp test.html toolkit.lisp README.md About lQuery lQuery is a DOM manipulation library written in Common Lisp, inspired by and based on the jQuery syntax and functions. It uses Plump and CLSS as DOM and selector engines. The main idea behind lQuery is to provide a simple interface for crawling and modifying HTML sites, as well as to allow for an alternative approach to templating. How To Load lQuery with ASDF or Quicklisp. (ql:quickload :lquery)  First, lQuery needs to be initialized with a document to work on: (defvar *doc* (lquery:$ (initialize (asdf:system-relative-pathname :lquery ""test.html""))))  After that, you can use the $ macro to select and manipulate the DOM: (lquery:$ *doc* ""article"") (lquery:$ *doc*    ""article""   (add-class ""fancy"")   (attr ""foo"" ""bar""))  To render the HTML to a string use SERIALIZE. If you want to save it to a file directly, there's also WRITE-TO-FILE. (lquery:$ *doc* (serialize)) (lquery:$ *doc* (write-to-file #p""~/plump-test.html""))  So a quick file manipulation could look something like this: (lquery:$ (initialize (asdf:system-relative-pathname :lquery ""test.html""))   ""article""   (append-to ""#target"")   (add-class ""foo"")   (root)   (write-to-file #p""~/plump-test.html""))  Aside from using selectors as the first step, it's also possible to use any other variable or list and operate on it. Since 2.0: Literal function calls need to be added with INLINE. Note that the result of the inline function will be used as if literally put in place. For example, an inlined function that evaluates to a string will result in a CSS-select. (lquery:$ (inline (list node-a node-b))   ""article""   (serialize))  Selectors can come at any point in the sequence of lQuery operations and will always act on the current set of elements. If an operation evaluates to a list, array, vector or a single node, the current set of elements is set to this result. (lquery:$ *doc*   ""a""   (text ""Link"")   (inline (lquery:$ *doc* ""p""))   (text ""Paragraph""))  This is equivalent to the following: (lquery:$ *doc*   ""a"" (text ""Link"")) (lquery:$ *doc*   ""p"" (text ""Paragraph""))  Functions in the argument list will be translated to a function invocation with the current list of elements as their argument. (lquery:$ *doc*   ""a"" #'(lambda (els) (aref els 0)))  lQuery2.0 also supports compile-time evaluation of forms, whose results are then put in place of their function calls: (lquery:$ *doc* (eval (format NIL ""~a"" *selector*)))  Keep in mind that the lexical environment is not the same at compile-time as at run-time. Often times you'll also want to retrieve multiple, different values from your current set of nodes. To make this more convenient, you can use the COMBINE form: (lquery:$ *doc*   ""a""   (combine (attr :href) (text))   (map-apply #'(lambda (url text) (format T ""[~a](~a)"" text url))))  lQuery uses vectors internally to modify and handle sets of nodes. These vectors are usually modified instead of copied to avoid unnecessary resource allocation. This however also means that lQuery functions are possibly side-effecting. If you pass an adjustable vector into lQuery through INLINE or similar, it will not be copied and therefore side-effects might occur. lQuery will automatically copy everything else that isn't an adjustable vector through ENSURE-PROPER-VECTOR. If you do want to pass in an adjustable vector, but make sure it doesn't affect it, use COPY-PROPER-VECTOR. Test Suite To ensure that functions are at least somewhat stable in their behaviour, lQuery includes a test suite. You can load this through Quicklisp/ASDF with (ql:quickload :lquery-test) (lquery-test:run)  The tests are rather loose, but should cover all functions to at least behave mostly according to expectation. Extending lQuery3.1 lQuery allows extension in a couple of ways. The most important of which are node functions themselves, which come in two flavours: lquery-funs and lquery-list-funs. Any lquery function resides in the package LQUERY-FUNCS, which is automatically scanned by the $ macro. The two macros responsible for defining new lquery functions automatically place the resulting operations in this package for you. (define-lquery-function name (node-name &rest arguments) &body body) (define-lquery-list-function name (vector-name &rest arguments) &body body)  Any function generated by these macros can be called either with a single node or a vector of nodes. In the case of a regular node operation, if it receives a vector of nodes, the function is called once for each node and the results are collected into a vector, which is then returned. If it receives a single node, only a single result is returned. In the case of a node list function, the return value can be either a vector or a single value, depending on what the goal of the operation is. It is expected that node list functions will modify the given vector directly in order to avoid unnecessary copying. Some constructs would be very cumbersome to write as functions, or would simply be more suited in the form of a macro. To allow for this, lQuery3.1 includes a mechanism of $ local macros. The previously mentioned forms like INLINE are handled through this system. Just like lquery functions, lquery macros reside in their own package LQUERY-MACROS. The responsible macro for defining new lquery macros will automatically place it in there for you. (define-lquery-macro name (previous-form &rest arguments) &body body)  The $ macro itself can be extended as well by providing additional argument- or value-handlers. The following two macros make this possible: (define-argument-handler type (argument-name operator-name) &body body)  Argument handlers transform the arguments at compile-time. For example, this would allow an extension to turn literal arrays into lists so they can be processed as well. (define-value-handler type (variable-name operator-name) &body body)  Value handlers on the other hand determine the action at run-time. This is mostly useful for defining special actions on certain variable values. What's New 3.1.0 Renamed DEFINE-NODE-\* macros into more sensible DEFINE-LQUERY-*. Added macro system, new standard COMBINE macro. 3.0.0 Complete rewrite of everything. This version is compatibility breaking. While the node functions themselves perform just the same as before (with one or two exceptions), lQuery now uses vectors instead of lists internally. If you ever relied on lQuery return values, this version will most likely break your code. Effort has been made to keep upgrading as simple as possible though; passing lists into an lQuery chain automatically transforms it for example. Thanks to the change to Plump, lQuery is now also able to parse almost any kind of X/HT/ML document, which was not well possible previously. And thanks to switching to CLSS, lQuery is now much faster at selecting nodes from the DOM. 2.0.0 Added extension system and INLINE, EVAL handling. Revamped base macros to be more stable and simple. Further Reading lQuery's symbol index. Plump, the HTML parser and DOM library lQuery is based on. CLSS, the CSS-selector DOM traversal engine. Clip, a templating system based on lQuery. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Shinmera/lquery"	"A jQuery-like HTML/DOM manipulation library.."	"true"
"Network and Internet"	"ningle"	"https://github.com/fukamachi/ningle"	"A super-micro web framework.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"103"	"19"	"14"	"GitHub - fukamachi/ningle: Super micro framework for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 19 Star 103 Fork 14 fukamachi/ningle Code Issues 3 Pull requests 0 Pulse Graphs Super micro framework for Common Lisp http://8arrow.org/ningle/ 60 commits 5 branches 0 releases 4 contributors Common Lisp 98.2% HTML 1.8% Common Lisp HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags change-headers clack-v2 fix-session-key gh-pages master Nothing to show Nothing to show New pull request Latest commit aebb94b Feb 17, 2016 fukamachi Merge pull request #15 from dan-passaro/master … Use symbols for URL params in README Permalink Failed to load latest commit information. src Add support for delayed reponses. Oct 12, 2015 t add test for identity check of app-requirements. Jul 17, 2015 .travis.yml Use the latest Lack. Jun 5, 2015 README.markdown Use symbols for URL params in README Feb 16, 2016 ningle-test.asd Use Clack v2 APIs. Jun 3, 2015 ningle.asd Tweak. Jun 5, 2015 README.markdown ningle ""ningle"" is a lightweight web application framework for Common Lisp. Usage (defvar *app* (make-instance 'ningle:<app>))  (setf (ningle:route *app* ""/"")       ""Welcome to ningle!"")  (setf (ningle:route *app* ""/login"" :method :POST)       #'(lambda (params)           (if (authorize (cdr (assoc ""username"" params :test #'string=))                          (cdr (assoc ""password"" params :test #'string=)))               ""Authorized!""               ""Failed...Try again."")))  (clack:clackup *app*) Now you can access to http://localhost:5000/ and then ningle should show you ""Welcome to ningle!"". Installation (ql:quickload :ningle)  Description ningle is a fork project of Caveman. ningle doesn't require you to generate a project skeleton. As this is a thin framework, you need to have subtle knowledge about Clack. It is a server interface ningle bases on. Getting started Routing ningle has the Sinatra-like routing system. ;; GET request (default) (setf (ningle:route *app* ""/"" :method :GET) ...)  ;; POST request (setf (ningle:route *app* ""/"" :method :POST) ...)  ;; PUT request (setf (ningle:route *app* ""/"" :method :PUT) ...)  ;; DELETE request (setf (ningle:route *app* ""/"" :method :DELETE) ...)  ;; OPTIONS request (setf (ningle:route *app* ""/"" :method :OPTIONS) ...) Route pattern may contain ""keyword"" to put the value into the argument. (setf (ningle:route *app* ""/hello/:name"")       #'(lambda (params)           (format nil ""Hello, ~A"" (cdr (assoc :name params))))) The above controller will be invoked when you access to ""/hello/Eitaro"" or ""/hello/Tomohiro"", and then (cdr (assoc :name params)) will be ""Eitaro"" and ""Tomohiro"". Route patterns may also contain ""wildcard"" parameters. They are accessible by (assoc :splat params). (setf (ningle:route *app* ""/say/*/to/*"")       #'(lambda (params)           ; matches /say/hello/to/world           (cdr (assoc :splat params)) ;=> (""hello"" ""world"")           ))  (setf (ningle:route *app* ""/download/*.*"")       #'(lambda (params)           ; matches /download/path/to/file.xml           (cdr (assoc :splat params)) ;=> (""path/to/file"" ""xml"")           )) Route matching with Regular Expressions: (setf (ningle:route *app* ""/hello/([\\w]+)"" :regexp t)       #'(lambda (params)           (format nil ""Hello, ~A!"" (first (cdr (assoc :captures params)))))) Requirements Routes may include a variety of matching conditions, such as the Accept: (setf (ningle:route *app* ""/"" :accept '(""text/html"" ""text/xml""))       #'(lambda (params)           (declare (ignore params))           ""<html><body>Hello, World!</body></html>""))  (setf (ningle:route *app* ""/"" :accept ""text/plain"")       #'(lambda (params)           (declare (ignore params))           ""Hello, World!"")) You can easily define your own conditions: (setf (ningle:requirement *app* :probability)       #'(lambda (value)           (<= (random 100) value)))  (setf (ningle:route *app* ""/win_a_car"" :probability 10)       #'(lambda (params)           (declare (ignore params))           ""You won!""))  (setf (ningle:route *app* ""/win_a_car"")       #'(lambda (params)           (declare (ignore params))           ""Sorry, you lost."")) Request & Response ningle provides two special variables named *request* and *response*. They will be bound to an instance Lack.Request and Lack.Response for each request. For example, by using them, you can change the response status code, Content-Type or something like that in each controllers. Context ningle provides an useful function named context. It is an accessor to an internal hash table. (setf (context :database)       (dbi:connect :mysql                    :database-name ""test-db""                    :username ""nobody""                    :password ""nobody""))  (context :database) ;;=> #<DBD.MYSQL:<DBD-MYSQL-CONNECTION> #x3020013D1C6D> Using Session ningle doesn't provide Session system in the core, but recommends to use Lack.Middleware.Session with Lack.Builder. (import 'lack.builder:builder)  (clack:clackup   (builder     :session     *app*)) Of course, you can use other Lack Middlewares with ningle. See Also Clack Lack Author Eitaro Fukamachi (e.arrows@gmail.com) Copyright Copyright (c) 2012-2014 Eitaro Fukamachi (e.arrows@gmail.com) License Licensed under the LLGPL License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/ningle"	"A super-micro web framework.."	"true"
"Network and Internet"	"Postmaster"	"https://github.com/eudoxia0/postmaster"	"A simple, easy-to-use SMTP/IMAP library.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"1"	"2"	"0"	"GitHub - eudoxia0/postmaster: Email for humans Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 1 Fork 0 eudoxia0/postmaster Code Issues 0 Pull requests 0 Pulse Graphs Email for humans 35 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src .gitignore README.md postmaster.asd README.md Postmaster - Email for humans Postmaster is a simple, easy to use SMTP/IMAP library with an API inspired by NodeMailer. Usage Services Postmaster maintains a list of common and well-known services, so you don't have to worry about hosts and ports, and can just send email to addresses. (in-package :postmaster.services)  ;; You can find services by name (find-service-by-name ""gmail"")  ;; ... Or by domain name (find-service-by-domain ""gmail.com"")  ;; Failing that, you can define your own (defparameter *service*   (make-instance '<service>                  :name ""GMail""                  :domains (list ""gmail.com"" ""googlemail.com"")                  :smtp-server (make-instance '<smtp-server>                                              :host ""smtp.gmail.com""                                              :ssl :tls))) Class defaults (SSL, ports) are safe and sane. Accounts Once you have a service, you log in: (in-package :postmaster.services)  (defparameter *account*   (make-instance '<account>                  :service *service*                  :username ""me@gmail.com""                  :password ""A really long, safe dictionary password. Right?"")) Sending Email (defparameter *email*   (make-instance 'postmaster.email:<email>                  :from ""me@gmail.com""                  :to ""friend@initech.com""                  :subject ""Why you should rewrite all your startup's code in CL""                  :body ""Paul Graham. Speed. Macros. CLOS. Done""))  (postmaster.smtp:send *account* *email*) Extensions Postmaster Mock This library provides a mock Email service that stores all messages it gets in an internal store. Accounts can be registered to the service and the stored emails inspected. This is useful for testing a Postmaster-based application. License Copyright (c) 2014 Fernando Borretti (eudoxiahp@gmail.com) Licensed under the MIT License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/eudoxia0/postmaster"	"A simple, easy-to-use SMTP/IMAP library.."	"true"
"Network and Internet"	"radiance"	"https://github.com/Shirakumo/radiance"	"An extensible framework library and multi-application CMS.."	"null"	"null"	"null"	"Artistic License 2.0"	"http://directory.fsf.org/wiki/License:ArtisticLicense2.0"	"null"	"null"	"13"	"4"	"0"	"GitHub - Shirakumo/radiance: A Common Lisp web-application environment Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 4 Star 13 Fork 0 Shirakumo/radiance Code Issues 2 Pull requests 0 Pulse Graphs A Common Lisp web-application environment http://tymoon.eu 1,136 commits 1 branch 0 releases Fetching contributors NewLisp 35.3% HTML 33.2% CSS 19.2% Common Lisp 12.3% NewLisp HTML CSS Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit 8ee2a96 Apr 9, 2015 Shinmera Update README.md Permalink Failed to load latest commit information. data .gitignore LICENSE README.md Update README.md Apr 9, 2015 radiance.asd Update for new core lib merge Oct 19, 2014 radiance.uc.lisp README.md About Radiance An explanation about what exactly Radiance is will be here as soon as I figure out how to explain it quickly enough. In the most basic of words, it is a very featureful web-framework written in Common Lisp. Radiance is currently lacking in completeness, soundness, and specification to be advocated as a ready-to-use framework. Please be patient until the remaining issues have been cleaned up. It is however already being used in a production setting for TymoonNET. See the remaining Shirakumo projects for examples of applications built using Radiance. Getting It Radiance and associated modules and applications are distributed via Quicklisp in a separate dist. To install Radiance, do: (ql-dist:install-dist ""http://dist.tymoon.eu/shirakumo.txt"") (ql:quickload :radiance)  From there on out you should be able to load and use any kind of Radiance module directly via Quicklisp's quickload. You will most likely want to set up a virtual host on your machine to test and develop Radiance, in order to circumvent the issue of blocked cookies on localhost. To do this, add an entry like 127.0.0.1 radiance.test to your hosts file. Radiance is by default set up to recognise radiance.test as a server host. Using It This section too will be done once all issues have been cleaned up. For now you can have a preview peek at how things are (most likely) going to be, as well as read information on the progress of the project, in the associated radiance articles. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Shirakumo/radiance"	"An extensible framework library and multi-application CMS.."	"true"
"Network and Internet"	"saluto"	"https://github.com/dmitrys99/saluto"	"OAuth 2.0 module for the RESTAS web framework. Not available on Quicklisp.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"3"	"5"	"2"	"GitHub - dmitrys99/saluto: Authentication (OAuth 2.0, local password) module for RESTAS Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 3 Fork 2 dmitrys99/saluto Code Issues 0 Pull requests 0 Pulse Graphs Authentication (OAuth 2.0, local password) module for RESTAS 81 commits 2 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master no-ht-sessions Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. providers README.md example.lisp license.txt package.lisp provider.lisp routes.lisp saluto.asd utils.lisp README.md Saluto Authentication (OAuth 2.0) module for RESTAS Saluto is a submodule for RESTAS web-framework, which allow web-site users to be authorized with OAuth 2.0 protocol. Source code: https://github.com/dmitrys99/saluto Currently implemented OAuth 2.0 providers: Facebook VK.com OK.ru Github.com Google.com Mail.ru Example usage:  (defun do-init-site ()   (init-cache)   (init-db)    (restas:mount-module saluto (#:saluto)                        (:url ""auth/"")                        (:inherit-parent-context t)                        (saluto:*providers* (list                                             (make-instance 'saluto:oauth2-facebook.com                                                            :name ""facebook.com""                                                            :app-id ""app-id""                                                            :app-private-key ""app-key"")                                             (make-instance 'saluto:oauth2-vk.com                                                            :name ""vk.com""                                                            :app-id ""app-id""                                                            :app-private-key ""app-key"")                                             (make-instance 'saluto:oauth2-ok.ru                                                            :name ""odnoklassniki.ru""                                                            :app-id ""app-id""                                                            :app-public-key ""app-key""                                                            :app-private-key ""app-private"")))                        (saluto:*store-userinfo-fun*                         (lambda (info)                           (when info                             ;; Process user info, returned by OAuth provider, like this:                             ;; (maybe-save-user info :cache-user t :session (session-identifier))                             ;;                             ;; Structure of user info:                             ;; '(:first-name ""first name""                             ;;   :last-name ""last-name""                             ;;   :email ""email""                             ;;   :uid ""user id at provider level""                             ;;   :avatar ""user avatar URI""                             ;;   :provider ""provider name"")                             )))                        (saluto:*logged-in-p-fun*                         ;; function, called to check if user logged or not                         (lambda ()))                        (saluto:*logout-fun*                         ;; function, called on logout                         (lambda (session)                           ;;                           ;; (delete-userauth-from-cache session)                           ))))  To start login process point user to URI /auth/goto/provider, ex.: http://localhost:8080/auth/goto/vk.com/ For full example usage see example.lisp. Many thanks to https://github.com/Menschenkindlein for Lispy improvements. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/dmitrys99/saluto"	"OAuth 2.0 module for the RESTAS web framework. Not available on Quicklisp.."	"true"
"Network and Internet"	"sytes"	"https://github.com/mishoo/sytes"	"A library for making simple websites quickly. Not available on Quicklisp. No license specified."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"25"	"7"	"5"	"GitHub - mishoo/sytes: A Common Lisp library for making simple websites quickly Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 25 Fork 5 mishoo/sytes Code Issues 0 Pull requests 0 Pulse Graphs A Common Lisp library for making simple websites quickly http://lisperator.net/sytes/ 67 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. template README.txt json-validation.lisp json.lisp package.lisp sytes+json.asd sytes.asd sytes.lisp utils.lisp README.txt Sytes -- a library for making quick websites with Common Lisp =============================================================  Sytes implements a Lispy template language, as well as Hunchentoot handlers for easily mapping HTTP requests to templates on disk. Templates may “inherit” from other templates, or process other templates.  The language available in templates is a Scheme-like mini-language providing very few primitive operations.  More info at http://lisperator.net/sytes/  License -------  Copyright 2012-2014 (c) Mihai Bazon <mihai.bazon@gmail.com>  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:      * Redistributions of source code must retain the above       copyright notice, this list of conditions and the following       disclaimer.      * Redistributions in binary form must reproduce the above       copyright notice, this list of conditions and the following       disclaimer in the documentation and/or other materials       provided with the distribution.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/mishoo/sytes"	"A library for making simple websites quickly. Not available on Quicklisp. No license specified."	"true"
"Network and Internet"	"usocket"	"https://github.com/usocket/usocket"	"A portable TCP and UDP socket interface.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"34"	"10"	"11"	"GitHub - usocket/usocket: Universal socket library for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 10 Star 34 Fork 11 usocket/usocket Code Issues 8 Pull requests 0 Wiki Pulse Graphs Universal socket library for Common Lisp https://common-lisp.net/project/usocket/ 436 commits 12 branches 30 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags 0.2.x 0.2.4 0.3.x 0.4.x 0.5.x 0.6.x experimental-udp hans ipv6 master new-readme new-wfi Nothing to show 0.6.4.1 0.6.4 0.6.3.2 0.6.3 0.6.1 0.6.0.1 0.6.0 0.5.5 0.5.4 0.5.3 0.5.2 0.5.1 0.5.0 0.4.1 0.4.0 0.3.7 0.3.6 0.3.5 0.3.4 0.3.3 0.3.2 0.3.1 0.3.0 0.2.5 0.2.4 0.2.3 0.2.2 0.2.1 0.2.0 0.1.0 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. backend doc notes test vendor CHANGES LICENSE README.md TODO condition.lisp option.lisp package.lisp server.lisp usocket-test.asd usocket.asd usocket.lisp README.md Introduction This is the usocket Common Lisp sockets library: a library to bring sockets access to the broadest of common lisp implementations as possible. The library currently supports: SBCL CMUCL ArmedBear Common Lisp GNU CLISP Allegro Common Lisp LispWorks Clozure CL ECL Scieneer Common Lisp Macintosh Common Lisp MOCL If your favorite common lisp misses in the list above, please contact usocket-devel@common-lisp.net and submit a request. Please include references to available sockets functions in your lisp implementation. The library has been ASDF (http://cliki.net/ASDF) enabled, meaning that you can tar up a checkout and use that to ASDF-INSTALL:INSTALL the package in your system package site. (Or use your usual ASDF tricks to use the checkout directly.) Remarks on licensing Even though the source code has an MIT style license attached to it, when compiling this code with some of the supported lisp implementations you may not end up with an MIT style binary version due to the licensing of the implementations themselves. ECL is such an example and - when it will become supported - GCL is like that too. Non-support of :external-format Because of its definition in the hyperspec, there's no common external-format between lisp implementations: every vendor has chosen a different way to solve the problem of newline translation or character set recoding. Because there's no way to avoid platform specific code in the application when using external-format, the purpose of a portability layer gets defeated. So, for now, usocket doesn't support external-format. The workaround to get reasonably portable external-format support is to layer a flexi-stream (from flexi-streams) on top of a usocket stream. API definition usocket (class) stream-usocket (class; usocket derivative) stream-server-usocket (class; usocket derivative) socket-connect (function) [ to create an active/connected socket ] socket-connect host port &key element-type where `host' is a vectorized ip or a string representation of a dotted ip address or a hostname for lookup in the DNS system socket-listen (function) [ to create a passive/listening socket ] socket-listen host port &key reuseaddress backlog element-type where `host' has the same definition as above socket-accept (method) [ to create an active/connected socket ] socket-accept socket &key element-type returns (server side) a connected socket derived from a listening/passive socket. socket-close (method) socket-close socket where socket a previously returned socket socket (usocket slot accessor), the internal/implementation defined socket representation socket-stream (usocket slot accessor), socket-stream socket the return value of which satisfies the normal stream interface socket-shutdown Errors: address-in-use-error address-not-available-error bad-file-descriptor-error connection-refused-error connection-aborted-error connection-reset-error invalid-argument-error no-buffers-error operation-not-supported-error operation-not-permitted-error protocol-not-supported-error socket-type-not-supported-error network-unreachable-error network-down-error network-reset-error host-down-error host-unreachable-error shutdown-error timeout-error unkown-error Non-fatal conditions: interrupted-condition unkown-condition (for a description of the API methods and functions see http://common-lisp.net/project/usocket/api-docs.shtml.) Test suite The test suite unfortunately isn't mature enough yet to run without some manual configuration. Several elements are required which are hard to programatically detect. Please adjust the test file before running the tests, for these variables: +non-existing-host+: The stringified IP address of a host on the same subnet. No physical host may be present. +unused-local-port+: A port number of a port not in use on the machine the tests run on. +common-lisp-net+: A vector with 4 integer elements which make up an IP address. This must be the IP ""common-lisp.net"" resolves to. Known problems CMUCL error reporting wrt sockets raises only simple-errors meaning there's no way to tell different error conditions apart. All errors are mapped to unknown-error on CMUCL. The ArmedBear backend doesn't do any error mapping (yet). Java defines exceptions at the wrong level (IMO), since the exception reported bares a relation to the function failing, not the actual error that occurred: for example 'Address already in use' (when creating a passive socket) is reported as a BindException with an error text of 'Address already in use'. There's no way to sanely map 'BindException' to a meaningfull error in usocket. [This does not mean the backend should not at least map to 'unknown-error'!] When using the library with ECL, you need the C compiler installed to be able to compile and load the Foreign Function Interface. Not all ECL targets support DFFI yet, so on some targets this would be the case anyway. By depending on this technique, usocket can reuse the FFI code on all platforms (including Windows). This benefit currently outweighs the additional requirement. (hey, it's Embeddable Common Lisp, so, you probably wanted to embed it all along, right?) Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/usocket/usocket"	"A portable TCP and UDP socket interface.."	"true"
"Network and Internet"	"weblocks"	"http://weblocks-framework.info/"	"An advanced web framework."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Welcome - Weblocks web application framework Welcome Features Installation Documentation Community Welcome to Weblocks Weblocks is an advanced web framework written in Common Lisp. It is designed to make Agile web application development as effective and simple as possible. Is it usable? Can I see some demos? Public applications running Weblocks include http://aulapolska.pl/ https://bountyoss.com/ Weblocks demo applications include http://media-library.olexiy.info/ - a copy of code used in production (login: test@spamavert.com password: test) http://weblocks-demo.olexiy.info/ - an application used for testing Weblocks with Selenium. Actually, there are 3 applications, examples of using Weblocks with Prototype, jQuery and jQuery + Twitter Bootstrap theme Projects used Weblocks but not working now LAMSIGHT2, repository is here - https://github.com/eslick/cl-registry Thanandar, it seems project moved to other platform Why yet another web framework? This is not your ordinary run-of-the-mill web framework in PHP, Python or Ruby. Weblocks uses powerful Lisp features like multiple dispatch, the metaobject protocol, lexical closures, keyword arguments, and macros to build abstractions that make web development easy, intuitive, and free of boilerplate. In addition, control flow is easily expressed using continuations. Things that are hard or mundane in other frameworks become easy and fun in Weblocks. In Common Lisp? Common Lisp is a powerful standardized language with high-performance implementations. Weblocks makes use of several advanced features that cannot be found in most other programming languages. Moreover, Common Lisp itself is ideally suited to modern pragmatic and Agile programming.  "	"null"	"null"	"An advanced web framework."	"true"
"Network and Internet"	"wookie"	"https://github.com/orthecreedence/wookie"	"Asynchronous HTTP server.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"121"	"21"	"16"	"GitHub - orthecreedence/wookie: Asynchronous HTTP server in common lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 21 Star 121 Fork 16 orthecreedence/wookie Code Issues 8 Pull requests 0 Pulse Graphs Asynchronous HTTP server in common lisp 296 commits 1 branch 2 releases 7 contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show pre-remove-error-handling pre-fast-http Nothing to show New pull request Latest commit 288d108 Jun 25, 2016 orthecreedence committed on GitHub Merge pull request #75 from mtstickney/allow_null_bodies … Don't ignore explicitly-passed NIL response bodies. Permalink Failed to load latest commit information. core-plugins add json to list for directory router Aug 27, 2015 upload-tmp adding upload-tmp folder with gitignore Mar 28, 2013 .gitignore Added .gitignore. Dec 26, 2014 LICENSE adding license (dual, wookie-mit and mit), removing examples, adding … Jun 15, 2013 README.md futzing with img again Sep 2, 2013 config.lisp adding *max-body-size*, which tells wookie to send an error to the cl… Jan 15, 2015 error.lisp merging in ivans chnages Jan 30, 2015 helper.lisp new helper: serve-html5-app. acts like a static-server, but routes al… May 22, 2015 hook.lisp Hook/parser updates May 7, 2015 listener-ssl.lisp making startup a :notice instead of :info, also implementing new :eve… Jan 15, 2015 listener.lisp making startup a :notice instead of :info, also implementing new :eve… Jan 16, 2015 package.lisp exporting response-request May 25, 2015 parser.lisp implementing start/end keywords in chunking callback (with fallback t… Sep 2, 2015 plugin.lisp shadowing some *debug-on-error* stuff, also converting log4cl calls t… Dec 30, 2014 request-response.lisp Don't ignore explicitly-passed NIL response bodies. Jun 25, 2016 route.lisp getting rid of force-chunking, formatting the defroute defnition a bit May 22, 2015 state.lisp Added route priorities. Jan 10, 2015 util.lisp work around url encoded new lines Jul 28, 2015 wookie.asd version bump for some of nick's changes. Sep 8, 2015 README.md Wookie Wookie is an asynchronous HTTP server written in common lisp. It is in beta at the moment. Wookie is named after my dog who is extremely tempermental, image-conscious, and makes sounds like a wookie when you squeeze him. He views himself as royalty, and we are all forever in his debt for his invaluable gift of existing on the same planet as us. This project is dedicated to him. Originally, the goal was to port Hunchentoot to async, but Wookie took a divergent turn and is now its own project. Documentation I finally decided to get the Wookie doc site up and running. Not only does it document Wookie, but it's built on top of Wookie and can be used for reference by browsing the source. License Wookie is dual-licensed under Wookie-MIT (MIT under the terms that you swear unconditional compliance and servitude to the dog, Wookie, and accept him as your king) and vanilla MIT (see the LICENSE file). Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/orthecreedence/wookie"	"Asynchronous HTTP server.."	"true"
"Numerical and Scientific"	"cl-spark"	"https://github.com/tkych/cl-spark"	"Generates sparkline strings for lists of numbers.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"48"	"7"	"3"	"GitHub - tkych/cl-spark: (spark '(1 1 2 3 5 8)) => ""▁▁▂▃▅▇"" Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 48 Fork 3 tkych/cl-spark Code Issues 1 Pull requests 1 Pulse Graphs (spark '(1 1 2 3 5 8)) => ""▁▁▂▃▅▇"" 29 commits 2 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master portable-scale Nothing to show Nothing to show New pull request Latest commit 4e34bce Jun 11, 2015 tkych Add: description for Quicklisp Permalink Failed to load latest commit information. .travis.yml Enable travis-ci Jul 16, 2014 CHANGELOG Update: -> ver. 0.1.13 Jun 15, 2014 LICENSE Initial release. Sep 10, 2013 README.md Add travis-ci build status Jul 16, 2014 cl-spark-test.asd Add: description for Quicklisp Jun 11, 2015 cl-spark.asd Update: -> ver. 0.1.13 Jun 15, 2014 run-tests.lisp Fix: loading quicklisp.lisp Jul 16, 2014 spark-test.lisp RUN-TESTS return value: NIL -> T or NIL. Jul 16, 2014 spark.lisp Remove unnecessary conses. Jul 16, 2014 test.lisp Update: -> ver. 0.1.13 Jun 15, 2014 README.md ver.0.1.13 cl-spark cl-spark generates a sparkline string for a list of numbers. It is a common lisp implementation of Zach Holman's spark and Gil Gonçalves' vspark with little extension. The goal of cl-spark is quick data visualization for: quick-and-dirty tasks (e.g. check the number of http-requests, github-commits, temperature, etc.), deciding whether the data is worth to real data mining (e.g. monitoring Fukushima Nuclear Power Station), grasping the secret aesthetic beauty (e.g. visualizing the fibonacci sequence, you can feel the golden ratio). Note: The character encoding of cl-spark must be utf-8. If your lisp is clozure, you need command-line option $ ccl -K utf-8 when you start lisp on the shell. Depends-on NIL Installation cl-test-grid results: http://common-lisp.net/project/cl-test-grid/library/cl-spark.html Auto: CL-REPL> (ql:quickload :cl-spark) Manual: SHELL$ git clone https://github.com/tkych/cl-spark CL-REPL> (push #p""/path-to-cl-spark/cl-spark/"" asdf:*central-registry*) CL-REPL> (ql:quickload :cl-spark) or (asdf:load-system :cl-spark) Examples ;;; Spark  (spark '(1 1 2 3 5 8)) => ""▁▁▂▃▅█""  ;; float, minus (spark '(1 0 1 0))    => ""█▁█▁"" (spark '(1 0 1 0 .5)) => ""█▁█▁▄"" (spark '(1 0 1 0 -1)) => ""█▄█▄▁""  ;; min, max (spark '(0 30 55 80 33 150))                 => ""▁▂▃▅▂█"" (spark '(0 30 55 80 33 150) :min -100)       => ""▃▄▅▆▄█"" (spark '(0 30 55 80 33 150) :max 50)         => ""▁▅██▅█"" (spark '(0 30 55 80 33 150) :min 30 :max 80) => ""▁▁▄█▁█""  ;; key (spark '(0 1 2 3 4 5 6 7 8) :key (lambda (x) (sin (* x pi 1/4)))) => ""▄▆█▆▄▂▁▂▄"" (spark '(0 1 2 3 4 5 6 7 8) :key (lambda (x) (cos (* x pi 1/4)))) => ""█▆▄▂▁▂▄▆█""  ;; in function (defun look-bits (n)   (spark (map 'list #'digit-char-p (write-to-string n :base 2))))  (look-bits 42) => ""█▁█▁█▁"" (look-bits 43) => ""█▁█▁██"" (look-bits 44) => ""█▁██▁▁"" (look-bits 45) => ""█▁██▁█""  ;; *ticks* (defvar ternary '(-1 0 1 -1 1 0 -1 1 -1))  (spark ternary)              => ""▁▄█▁█▄▁█▁""  (let ((*ticks* #(#\_ #\- #\¯)))   (spark ternary))           => ""_-¯_¯-_¯_""  (let ((*ticks* #(#\▄ #\⎯ #\▀)))   (spark ternary))           => ""▄⎯▀▄▀⎯▄▀▄""   ;;; Vspark  ;; Life expectancy by WHO region, 2011, bothsexes ;; see. http://apps.who.int/gho/data/view.main.690 (defvar life-expectancies '((""Africa"" 56)                             (""Americans"" 76)                             (""South-East Asia"" 67)                             (""Europe"" 76)                             (""Eastern Mediterranean"" 68)                             (""Western Pacific"" 76)                             (""Global"" 70)))  (vspark life-expectancies :key #'second) => "" 56                      66                      76 ˫-----------------------+------------------------˧ ▏ ██████████████████████████████████████████████████ ███████████████████████████▌ ██████████████████████████████████████████████████ ██████████████████████████████▏ ██████████████████████████████████████████████████ ███████████████████████████████████▏ ""  (vspark life-expectancies :key #'second                           :min 50 :max 80                           :labels (mapcar #'first life-expectancies)                           :title ""Life Expectancy"") => ""                  Life Expectancy                                         50           65           80                       ˫------------+-------------˧                Africa █████▋             Americans ████████████████████████▎       South-East Asia ███████████████▉                Europe ████████████████████████▎ Eastern Mediterranean ████████████████▊       Western Pacific ████████████████████████▎                Global ██████████████████▋ ""  ;; labels, size (vspark '(1 0 .5) :labels '(""on"" ""off"" ""unknown"") :size 1) => ""      on █     off ▏ unknown ▌ ""  (vspark '(1 0 .5) :labels '(""on"" ""off"") :size 1) => ""  on █ off ▏     ▌ ""  (vspark '(1 0) :labels '(""on"" ""off"" ""unknown"") :size 1) => ""  on █ off ▏ ""  ;; auto-scale (vspark '(0 1 2 3 4 5 6 7 8) :key (lambda (x) (sin (* x pi 1/4)))                              :size 20) => "" -1.0     0.0     1.0 ˫--------+---------˧ ██████████▏ █████████████████▏ ████████████████████ █████████████████▏ ██████████▏ ██▉ ▏ ██▉ █████████▉ ""  (vspark '(0 1 2 3 4 5 6 7 8) :key (lambda (x) (sin (* x pi 1/4)))                              :size 10) => "" -1.0   1.0 ˫--------˧ █████▏ ████████▏ ██████████ ████████▏ █████▏ █▏ ▏ █▏ ████▏ "" (vspark '(0 1 2 3 4 5 6 7 8) :key (lambda (x) (sin (* x pi 1/4)))                              :size 7) => "" ███▌ █████▉ ███████ █████▉ ███▌ █▏ ▏ █▏ ███▌ ""  For more examples, see cl-spark/test.lisp Referece Manual [Function] SPARK numbers &key min max key Generates a sparkline string for a list of real numbers. numbers is a data, list of real-numbers. min is lower bound of output, either nil or real-number (default is NIL, the minimum value of the data). max is upper bound of output, either nil or real-number (default is NIL, the maximum value of the data). key is a function for preparing data. [Special Variable] *TICKS* A simple-vector of characters for representation of sparklines. Default is #(#\▁ #\▂ #\▃ #\▄ #\▅ #\▆ #\▇ #\█). [Function] VSPARK numbers &key min max key (size 50) title labels (scale? t) (newline? t) Generates a vartical sparkline string for a list of real numbers. numbers is a data, list of real-numbers. min is lower bound of output, either nil or real-number (default is NIL, the minimum value of the data). max is upper bound of output, either nil or real-number (default is NIL, the maximum value of the data). key is a function for preparing data. size is a maximum number of output columns (contains label), integer (default is 50). title is a title for data, string or nil. If title is too big for size, then not print. labels is a labels for data, list. scale? is a boolean (default is T). If T, output graph with scale for easy to see. If string length of min and max is too big for size, then not print scale. newline? is a boolean (default is T). If T, output graph with newlines for easy to see. [Special Variable] *VTICKS* A simple-vector of characters for representation of vartical sparklines. Default is #(#\▏ #\▎ #\▍ #\▌ #\▋ #\▊ #\▉ #\█). Author, License, Copyright Takaya OCHIAI <#.(reverse ""moc.liamg@lper.hcykt"")> MIT License Copyright (C) 2013 Takaya OCHIAI Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/tkych/cl-spark"	"Generates sparkline strings for lists of numbers.."	"true"
"Numerical and Scientific"	"GSLL"	"https://common-lisp.net/project/gsll/"	"GNU Scientific Library for Lisp; allows the use of the GSL from Common Lisp.."	"null"	"null"	"null"	"GNU LGPL2.1"	"http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html"	"null"	"null"	"null"	"null"	"null"	"GSLL, the GNU Scientific Library for Lisp  GNU Scientific Library for Lisp GSLL   About Examples Requirements Download Documentation Status Contact About The GNU Scientific Library for Lisp (GSLL) allows you to use the GNU Scientific Library (GSL) from Common Lisp. This library provides a full range of common mathematical operations useful to scientific and engineering applications. The design of the GSLL interface is such that access to most of the GSL library is possible in a Lisp-natural way; the intent is that the user not be hampered by the restrictions of the C language in which GSL has been written. GSLL thus provides interactive use of GSL for getting quick answers, even for someone not intending to program in Lisp. Topics include: polynomials, special functions, vectors and matrices, permutations, sorting, linear algebra including BLAS, eigensystems, fast Fourier transforms (FFT), quadrature, random numbers, quasi-random sequences, random distributions, statistics, histograms, N-tuples, Monte Carlo integration, simulated annealing, ordinary differential equations, interpolation, numerical integration, numerical differentiation, Chebyshev approximation, series acceleration, discrete Hankel transforms, root-finding, minimization, least-squares fitting, IEEE floating-point, discrete wavelet transforms, basis splines, physical constants. See missing-features.text on the status of some incomplete topics. Examples The Jacobian elliptic functions sn, cn, and dn are special functions (Chapter 7):  (jacobian-elliptic-functions 0.2d0 0.81d0) 0.19762082367187703d0 0.9802785369736752d0 0.9840560289645665d0  which returns as multiple values the three function values. The functions are defined only if the second argument m is not greater than 1, so an error is signalled if this parameter is out of range:  (jacobian-elliptic-functions 0.61802d0 1.5d0) Input domain error |m| > 1.0 in elljac.c at line 46    [Condition of type INPUT-DOMAIN]  This is an ordinary Lisp error which may be handled with standard definitions available in Lisp. To take the complex conjugate scalar product of two complex vectors of length 3:  (cdot #2m(#c(-34.5d0 8.24d0) #c(3.29d0 -8.93d0) #c(34.12d0 -6.15d0))       #2m(#c(49.27d0 -13.49d0) #c(32.5d0 42.73d0) #c(-17.24d0 43.31d0))) #C(-2940.2118d0 1861.9380999999998d0)  There are over 1500 examples available from within GSLL with the function examples. There is also a suite of over 4000 tests; many of the examples also serve as tests, and most others are ported from GSL's tests. Download and Install Download Use quicklisp and follow the instructions. You will need to make sure that the libraries and header files associated with GNU Scientific Library (GSL) and libffi are installed; your distribution may name these libgsl0-dev and libffi-dev. Once they are installed and you have loaded the quicklisp file:     (ql:quickload ""gsll"") To test your installation:     (asdf:test-system :gsll) The result should look something like:  Unit Test Summary  | 3997 assertions total  | 3992 passed  | 5 failed  | 6 execution errors  | 0 missing tests  You may see more failures; if you are not on a 64 bit platform you will see fewer assertions. License This software is distributed under the GPL ; see the file COPYING. There is absolutely no warranty. Documentation General Advice The following techniques for using the API are advised: Find the appropriate function(s) in the GSL documentation. Use the GSLL function gsl-lookup to find the equivalent GSLL function, for example  (gsl-lookup ""gsl_sf_elljac_e"") JACOBIAN-ELLIPTIC-FUNCTIONS T  to find that the Lisp function name is #'jacobian-elliptic-functions. Look at the documentation for that Lisp function, e.g. (documentation #'jacobian-elliptic-functions 'function) ""The Jacobian elliptic functions sn(u|m),   cn(u|m), dn(u|m) computed by descending Landen transformations.""    to get an explanation of the arguments etc. Use the function (examples) without an argument to get a list of example categories. Then use the function with a category name as the argument to get a list of examples under that category, for example (examples 'higher-moments). The result will be a list of forms, each providing an example of usage in the relevant topic. If the GSL documentation provides an example, there will usually be the same or similar example provided in GSLL. Note: Some of the examples are intentionally designed to signal an error, because the examples also serve as a regression (unit) test suite for GSLL. Some examples are not yet present in, or are too complicated for, the function #'examples. In this case, you need to look in the relevant source file; they are in either a separate file of examples, or at the end of the file of definitions. It is advisable to look at the examples first for calculations that require more complex setup (generally, the later chapters in the GSL manual). Arrays GSLL has many functions that work on vectors (one-dimensional arrays) and matrices (two-dimensional arrays). Foreign arrays are defined and manipulated using the Antik which defines generic operations on array-like objects; see the Antik documentation for more information. GSLL supports all array element types that are supported by CFFI, the CL implementation, GSL, and the platform. This list is available in the variable grid:*array-element-types*. Passing functions Functions that are passed to GSL functions (known as callbacks in C) are specified with a function designator for the CL function, that is, either the function object itself or a symbol denoting the function. There is usually an option scalarsp for functions that take or return arrays that, if true, will send the user function the argument element by element, and expect the return values to be the individual elements. GSL objects There are a number of GSL objects other than arrays that can be created:  acceleration interpolation levin levin-truncated spline nonlinear-ffit nonlinear-fdffit one-dimensional-root-solver-f one-dimensional-root-solver-fdf multi-dimensional-minimizer-f multi-dimensional-minimizer-fdf fit-workspace one-dimensional-minimizer multi-dimensional-root-solver-f multi-dimensional-root-solver-fdf histogram histogram2d histogram-pdf histogram2d-pdf basis-spline chebyshev hankel wavelet wavelet-workspace random-number-generator quasi-random-number-generator discrete-random polynomial-complex-workspace integration-workspace qaws-table qawo-table eigen-symm eigen-symmv eigen-herm eigen-hermv eigen-nonsymm eigen-nonsymmv eigen-gensymm eigen-gensymmv eigen-gen eigen-genv monte-carlo-plain monte-carlo-miser monte-carlo-vegas ode-stepper ode-evolution standard-control y-control yp-control scaled-control fft-real-wavetable-double-float fft-real-wavetable-single-float fft-real-workspace-double-float fft-real-workspace-single-float fft-complex-wavetable-double-float fft-complex-wavetable-single-float fft-complex-workspace-double-float fft-complex-workspace-single-float fft-half-complex-wavetable-double-float fft-half-complex-wavetable-single-float  An instance may be created with a function whose name is ""make-"" followed by the class name, e.g. make-histogram. The arguments that the function takes depends on the class. Additional definitions Some definitions are provided because of their usefulness, even though GSL doesn't have them. invert-matrix finds the inverse of a matrix and uses GSL's LU decomposition functions. IEEE floating point number analysis. fft-frequency-vector returns a vector where the sample frequencies are contained. If you perform an FFT on a vector of a given size and :sample-size, this vector will contain the sample frequencies in order. If the :shifted keyword is T, then the frequencies are ordered in ascending order. fft-shift returns a copy of a vector where the zero frequency has been shifted to the center; the frequency components will be sorted according to their frequency, in ascending order. Optionally, a :stride can be provided. fft-inverse-shift performs the inverse action of fft-shift; the zero and positive frequency components are shifted to the beginning, so that the resulting vector is suitable for an inverse FFT. Optionally, a :stride can be provided. Status GSLL is largely complete and usable, with functioning interfaces to most of GSL. Some functionality is not yet ported; see missing-features.text for more details. Known bugs are documented in status.text. Work is ongoing to both remedy those deficiencies and to simplify the user interface by changing more required arguments into optional or key arguments with useful default values. Typically, these arguments bind GSL objects and arrays used internally or for function return. Contact There is a mailing list for all aspects of this project, including bug reports. See also the archives. In addition, I am frequently on #lisp IRC channel as LiamH. For bug reports, please use the mailing list. The development site for GSLL has the git repository. If you have patch(es), please commit your changes and do: git format-patch origin This will produce one or more files whose names start with a four-digit number; please attach them all to your email. Liam Healy Time-stamp: <2015-12-05 22:02:12EST index.html>"	"null"	"null"	"GNU Scientific Library for Lisp; allows the use of the GSL from Common Lisp.."	"true"
"Numerical and Scientific"	"common-lisp-stat"	"https://github.com/blindglobe/common-lisp-stat/"	"Common Lisp statistics library.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"124"	"24"	"14"	"GitHub - blindglobe/common-lisp-stat: Common Lisp Statistics -- based on LispStat (Tierney) but updated for Common Lisp and incorporating lessons from R (http://www.r-project.org/).  See the google group for lisp stat / common lisp statistics for a mailing list. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 24 Star 124 Fork 14 blindglobe/common-lisp-stat Code Issues 1 Pull requests 0 Wiki Pulse Graphs Common Lisp Statistics -- based on LispStat (Tierney) but updated for Common Lisp and incorporating lessons from R (http://www.r-project.org/). See the google group for lisp stat / common lisp statistics for a mailing list. https://groups.google.com/d/forum/lisp-stat 1,057 commits 8 branches 0 releases 3 contributors Common Lisp 82.1% TeX 17.4% Other 0.5% Common Lisp TeX Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages local master mob testmaster tony2 tonylocal tonyr Nothing to show Nothing to show New pull request Latest commit 28a983c Apr 20, 2015 blindglobe Merge pull request #5 from hjstein/master … rseq fix & some optimization Permalink Failed to load latest commit information. Data sum needs to be defined and exported. Include in the statistics.lisp … Oct 21, 2013 Doc StatComp 2014, Schloss Reisensburg. Talks, demo, and small edits. Jul 22, 2014 bin various changes Oct 29, 2012 bugs data refactoring -- creation and activities related to package restru… Jul 18, 2009 examples StatComp 2014, Schloss Reisensburg. Talks, demo, and small edits. Jul 22, 2014 src Fixed rseq & optimized iseq. Apr 17, 2015 .gitignore better choice of ignored files (LaTeX droppings). Oct 20, 2009 .gitmodules various changes Oct 29, 2012 Externals.org more external clean up, moved info into docs Oct 4, 2012 LICENSE.mit started to clean up LICENSING. Need to consider whether to use MIT or… Sep 24, 2009 Makefile Ignore local ASDF files to allow for custom setups, add make target t… Nov 11, 2007 README.org added development libraries needed for the various packages, at least… Apr 8, 2014 TODO.org version fixed Jan 28, 2013 cls.asd experimenting with Tamas' cl-data-frame Apr 7, 2014 lift-standard.config Use the right name. Apr 2, 2009 test-style.css updated LIFT unit test structure, fixed rename errors. Sep 17, 2008 version.lisp-expr version fixed Jan 28, 2013 README.org Time-stamp: <2014-04-07 16:28:57 tony> Current Status: IMPROVING but we are rebuilding it. Fast Start Here’s a general fast start approach for using this. Get access to a Common Lisp implementation on your platform. Make sure you have BLAS, LAPACK, and their corresponding development environments on your system. For example, on a recent debian (testing), one may need: libffi6 libblas liblapack libgsl libRmath  and the corresponding -dev packages. if needed, install quicklisp (http://www.quicklisp.org) if wanted, install git (http://www.git-scm.org/) Use git to fetch common-lisp-statistics from the repository: git://github.com/blindglobe/common-lisp-stat.git and put it into your quicklisp local-projects directory (you will need to put a few more projects there as well), OR make sure you have an internet connection and go to step 5 and fetch a not-so-bleeding-edge version from QuickLisp. We suggest something like: mkdir ~/quicklisp/ mkdir ~/quicklisp/local-projects cd ~/quicklisp/local-projects git clone git://github.com/blindglobe/common-lisp-stat.git git clone git://github.com/blindglobe/lisp-matrix.git (with the 5th and on lines representing stuff undergoing rapid change, so possibly out of date on QUICKLISP). You might need to grab XARRAY as well, and if behind a firewall, might need to use HTTP or similar alternative transport. Start up the Common Lisp implementation, and: (ql:register-local-projects) (ql:quickload :antik) (ql:quickload :cls) TODO: Unfortunately, it looks like ANTIK needs to be preloaded, or it gets confused. I don’t yet know why. get coffee, tea, water, beer, or a glass of wine, review the Common Lisp Statistics mailing list, chat with friends, etc, until it is done compiling and loading. Report success/failure back to the news group ( https://groups.google.com/forum/?fromgroups#!forum/lisp-stat ) or directly to Tony Rossini mail, i.e. ( mailto:blindglobe@gmail.com ) if you don’t want to be public about it. Start trying it out. The examples/ directory is a good place to start evaluating the files, one at a time. Preferrably in order! More details can be fond in the subsequent sections. Common Lisp Current requirements are basically that you have a Common Lisp implementation such as SBCL or CCL (though CLISP might work) and BLAS/LAPACK on your system. SBCL and CCL are in active use by developers. We are interested in finding out details regarding successes with other distributions and would be pleased to add such information here. Microsoft Windows Currently, LispCabinet would be the simplest way to get started, with either SBCL or CCL as the Lisp Implementation. Need experiences from others using http://lispcabinet.sourceforge.net/ Linux Most distributions contain SBCL or CLISP. The instructions for getting and installing CCL are relatively straightforward. MacOSX Both CCL and SBCL have been remarked to work. CCL seems to be preferred on this platform? Configuring BLAS/LAPACK libraries locations Currently this is a manual operation, which will change in a later version. Edit the file external/cl-blapack/load-blapack-libs.lisp Search for the following 3 parameters gfortran-lib blas-lib lapack-lib You need to check that your dynamic library path has been properly set up in the shell, by setting up your .bashrc (or equivalent shell init file, or equivalent environment variable settings). [#A] Setting up BLAS/LAPACK on Microsoft OS i.e. compilation environment and tools, if needed, on Microsoft Windows? For windows, we recommend you use cygwin to get straightforward access. I’ll document the steps if there is a demand. Linux Get lapack-dev, blas-dev from your Linux distribution. i.e., something like: sudo apt-get install libblas sudo apt-get install liblapack For Linux, if installed in a weird place, you need to make sure the loader looks for it. set LD_LIBRARY_PATH=$LD_LIBRARY_PATH:??? and need to replace the ??? SBCL is known to work (0.58+, 1.1.1+) CCL is thought to work (CMUCL and CLISP may work, but not tested) MacOSX For Mac OSX set export DYLD_FALLBACK-LIBRARY_PATH=$DYLD_FALLBACK_LIBRARY_PATH:/opt/local/lib FIXME: Tony has no clue, please fill this in since most mailing list folks use Macs. CCL is thought to work SBCL is known to work For OS X: change the parameters as suggested in the file. Both BLAS and LAPACK are pre installed on Mac OSX. Install Quicklisp LispCabinet has it preinstalled, and you can use that version to upgrade Debian/Ubuntu also allow you access to a (possibly outdated) version. Not sure about upgrade potential. On Linux and MacOSX, I would recommend using the instructions at the QuickLisp www site (http://www.quicklisp.org). Install Git Unfortunately, as much as we really would like to get rid of this PITA stage, we are pre-alpha, and that means no chance, unless you want to fix your own bugs and copy/paste fixes, etc. Much simpler to figure out a small bit of git. Hopefully, your distribution (Linux) has it, and instructions for getting it, along with tutorials and documentation, can be found for MacOSX and Microsoft Windows on http://www.git-scm.org/ GitHub also has a Microsoft Windows application that might be useful for fetching and working with GitHub repositories (including this one). for mac osx sudo port install git for linux Using Debian, Ubuntu, or other apt-get based distributions as an example: sudo apt-get install git Using git to fetch Common Lisp Statistics At this stage, we need to identify where you will put the D/L’d package. If you are have an existing, highly tuned quicklisp setup, please figure it out and jump to the next stage, but basically you need to pull common-lisp-stat from Blindglobe’s repository, along with a few others. cd ~/quicklisp/local-projects/ git clone https://github.com/blindglobe/common-lisp-stat.git Regarding the “few others”, all of them are currently part of QuickLisp, so you only need them if you want to develop with them. Which isn’t entirely a bad idea. These would include: lisp-matrix CLS generic interface to BLAS and LAPACK using matrix like API cl-blapack lisp-matrix BLAS / LAPACK FFI fnv lisp-matrix foriegn-numeric-vectors, C-storage for lisp-matrix ffa lisp-matrix foriegn-??-arrays, LISP storage for lisp-matrix lift CLS unit-testing listoflist CLS list as an array data structure xarray Compile and load dependencies. Start up your Common Lisp implementation and type in: (ql:register-local-projects) (ql:quickload :cls) Retire for a well earned coffee and upon your return you should find the package completely installed. Obviously, potential errors can creep in with spelling the filenames correctly, so be careful. And now, everything should be working. This is the case for at least one person, so data on failures is very welcome. Start trying it out Now, load into your IDE or lisp, the files in the examples directory, such as: 00-loadingData.lisp 02-DSVloading.lisp 04-dataManipulation.lisp 10-basicEDA.lisp 20-visual-2d-cairo2.lisp 50-TTestExample.lisp 60-regressionExamples.lisp linear-regression.lisp ls-demo.lisp ls-demo-ls1.lisp XX-readMe.lisp And more Example Usage steps Load the example lisp files change directory into the CommonLispStat working directory. This is just for directory convenience, not for any real reason. cd ~/quicklisp/local-projects start your lisp sbcl or CCL follow the commands in the ls-demo.lisp (need to add link) file, i.e. (ql:quickload :cls)  (in-package :cls) Initially we will work in the cls package as all the basic functions we would need are present For serious work we would create our own workspace and save it in a separate package, but for now we will take this short cut. (normal-rand 20) (setf mytest (normal-rand 20)) and see if they work (basic CFFI functionality for external C library, LIFT package for unit-testing framework to ensure run time stability). Setup a place to work In Common Lisp, you need to select and setup namespace to store data and functions. There is a scratch user-package, or sandbox, for CLS, cls-user , which you can select via: (in-package :cls-user) and this has some basic modules from CLS instantiated (dataframes, probability calculus, numerical linear algebra, basic summaries (numerical and visual displays). However, it can be better is to create a package to work in, which pulls in only desired functionality: (in-package :cl-user) (defpackage :my-package-user   (:documentation ""demo of how to put serious work should be placed in     a similar package elsewhere for reproducibility.  This hints as to     what needs to be done for a user- or analysis-package."")   (:nicknames :my-clswork-user)   (:use :common-lisp ; always needed for user playgrounds!         :lisp-matrix ; we only need the packages that we need...         :common-lisp-statistics         :cl-variates         :lisp-stat-data-examples) ;; this ensures access to a data package   (:shadowing-import-from :lisp-stat       ;; This is needed temporarily until we resolve the dependency and call structure.        call-method call-next-method        expt + - * / ** mod rem abs 1+ 1- log exp sqrt sin cos tan       asin acos atan sinh cosh tanh asinh acosh atanh float random       truncate floor ceiling round minusp zerop plusp evenp oddp        < <= = /= >= > > ;; complex       conjugate realpart imagpart phase       min max logand logior logxor lognot ffloor fceiling       ftruncate fround signum cis        <= float imagpart)    (:export summarize-data summarize-results this-data this-report))  (in-package :my-clswork-user) ;; or :my-package-user  (setf my-data       (let ((var1 )) )) We need to pull in the packages with data or functions that we need; just because the data/function is pulled in by another package, in that package’s namespace, does NOT mean it is available in this name space. However, the common-lisp-statistics package will ensure that fundamental objects and functions are always available. Get to work [0/3] Pull in or create data Summarize results Save work and results for knowledge building and reuse One can build a package, or save an image (CL implementation dependent), or save text files. Inform moi of problems or successes mailto:blindglobe@gmail.com if there is anything wrong, or even if something happens to work. Current beliefs: SBCL is target platform. CCL and CMUCL should be similar. CLISP is finicky regarding the problems that we have with CFFI conversation. In particular that we can not really do typing that we need to take care of. I think this is my (Tony’s) problem, not someone elses, and specifically, not CLISP’s Need to test ECL. Introduction Core Philosophy “Languages shape how we …” Need to get and insert this quote that Duncan Temple-Lang found. The API should distinguish between the realization and the statistical interpretation. Goal is to teach statisticians how to think “systems-computationally”, and programmers, comp-sci types, informaticists and other “data scientists” how to think “statistically”, in order to get a jump on the competition. The goal of this system is to promote a change in thinking, to move the data analysis approach, currently stuck in a mix of 70s-early 90s approaches, into a new generation/level. Design Philosophy The approach we are taking is one where we provide a general method, and some fundamental building blocks, but don’t force users into approaches in order to allow for experimentation. DSL’s should be built on top of the core packages, as needed or wanted. (TonyR:) The DSL I want to build is a verbose statistically precise computing language, but we need quality code underneathe (which others could use for specialized terse DSL’s). DSL: domain specific language. History See files in file:Doc/ for history, design considerations, and random, sometimes false and misleading, musings. XLispStat ViSta ARC Common LispStat Initial development, 1989 time frame, partially developed during a visit by Luke Tierney to Bell Labs. Common Lisp Statistics This system. Local modifications, Development, Contributions Since this project is git clone git://github.com/blindglobe/common-lisp-stat.git  cd common-lisp-stat will pull the whole repository, and create a “master” branch to work on. If you are making edits, which I’d like, you don’t want to use the master branch, but more to use a topic-centric branch, so you might: git checkout -b myTopicBranch and then work on myTopicBranch, pulling back to the master branch when needed by git checkout master git pull . myTopicBranch (or git rebase myTopicBranch ) BETTER DOCUMENTATION EXAMPLES EXIST ON-LINE (on the git WWW site mentioned above)!! PLEASE READ THEM, THE ABOVE IS SPARSE AND MIGHT BE OUTDATED! Contributing through GitHub Alternatively, one can work on the github repositories as well. They are a bit differently organized, and require one to get a github account and work from there. basically, fork the repository on github on the WWW interface, then make a branch (as below), push back the branch to github, and notify the main repository that there is something to be pulled. And we’ll pull it back in. Commiting with the MOB on repo.or.cz of course, perhaps you want to contribute to the mob branch. For that, after cloning the repository as above, you would: git checkout -b mob remotes/origin/mob (work, work, work… through a cycle of        <edit> 	 git add <files just edited> 	 git commit -m ""what I just did"" ad-nauseum. When ready to commit, then just: git push git+ssh://mob@repo.or.cz/srv/git/CommonLispStat.git mob:mob ) and it’ll be put on the mob branch, as a proposal for merging. Another approach would be to pull from the topic branch into the mob branch before uploading. Will work on a formal example soon. (the basic principle is that instead of the edit cycle on mob, do something like: git checkout mob git pull . myTopicBranch    git push git+ssh://mob@repo.or.cz/srv/git/CommonLispStat.git mob:mob ) Licensing We currently are using and recommend the MIT style license approach. Footnotes [fn:1] I´m not including instructions for Emacs or git, as the former is dealt with other places and the latter was required for you to get this. Since disk space is cheap, I´m intentionally forcing git to be part of this system. Sorry if you hate it. Org-mode, org-babel, and org-babel-lisp, and hypo are useful for making this file a literate and interactively executable piece of work. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/blindglobe/common-lisp-stat/"	"Common Lisp statistics library.."	"true"
"Numerical and Scientific"	"lisp-matrix"	"https://github.com/blindglobe/lisp-matrix"	"A matrix package.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"40"	"6"	"11"	"GitHub - blindglobe/lisp-matrix: A matrix package for common lisp building on work by Mark Hoemmen, Evan Monroig, Tamas Papp and Rif. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 6 Star 40 Fork 11 blindglobe/lisp-matrix Code Issues 2 Pull requests 0 Wiki Pulse Graphs A matrix package for common lisp building on work by Mark Hoemmen, Evan Monroig, Tamas Papp and Rif. 376 commits 6 branches 0 releases 3 contributors Common Lisp 99.7% Other 0.3% Common Lisp Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags clean evan local master mob tonylocal Nothing to show Nothing to show New pull request Latest commit f9c88da Apr 20, 2015 blindglobe Merge pull request #4 from hjstein/master … Fixed incorrect quote character. Permalink Failed to load latest commit information. bugs including xarray as a general indexing scheme. Recall that we are alr… Jun 23, 2009 examples docs and whitespace, nothing more. Feb 16, 2014 src Fixed incorrect quote character. Apr 19, 2015 .gitignore ignore auto-gen'd HTML. Mar 15, 2009 ChangeLog * tests.lisp (transposed-p): fixed matrix size - cannot be 1 Jun 13, 2008 License.BSD License. Basic MIT/BSD. In the spirit of Mark H and others. Dec 26, 2013 README.org start of a quickstart example. Need to do more! And point to Examples… Feb 16, 2014 bugs.lisp start of a quickstart example. Need to do more! And point to Examples… Feb 16, 2014 lisp-matrix.asd clean up of unittesting and compilation and partial copyright (more t… Feb 16, 2014 lispMatrixTests.R verification of results, using R. This is the place for it. Feb 21, 2009 README.org LICENSE: BSD sans advertising (Mark H) QuickStart Use QuickLisp to load (ql:quickload :lisp-matrix) and create some data (in-package :lisp-matrix-user)  (M* (ones 2 2 :implementation :foreign-array)     (ones 2 2 :implementation :foreign-array))  (M* (ones 2 2 :implementation :lisp-array)     (ones 2 2 :implementation :lisp-array))  (M* (ones 2 2 :implementation :lisp-array)     (ones 2 2 :implementation :foriegn-array))  Introduction Lisp-Matrix intends to be a reasonably modern, flexible system for numeric algebra in Lisp. Rif, Tamas Papp, and Mark H contributed various critical pieces (code, design, code, testing, code, benchmarks, code, and more code). Some of them continued on other projects and left this behind, a gem in the rough, so I took this one on. I’m just a dwarf standing on the shoulders of giants. Design Basic approach: Storage can be done at the lisp or external level. Selection is user-specific, since you might have various people doing one or either, depending oupon the nature of the computations that are required. For example, large LAPACK-ish computations are required to be done externally whereas stuff which is more lisp-centric culd be done internally. We avoid deep copying whenever possible. current scablability of storage is not nearly as great as the storgeage required to do interesting things with biomedical data or economic data. Whoops. This means that we spend time on structures when copying is optional, done when needed to break the connection from the initial data storage. We, of course, means “them”. Requirements: Common Lisp Systems Currently being developed under SBCL [#A] compiles and runs with SBCL State “DONE” from “CURR” [2010-10-09 Sat 14:48] verified a while back. State “CURR” from “TODO” [2010-10-09 Sat 14:48] State “TODO” from “” [2010-10-09 Sat 14:46] CURR [#B] compiles and runs with CLISP State “CURR” from “TODO” [2010-10-09 Sat 14:48] in progress, Tony checking it from time to time. State “TODO” from “” [2010-10-09 Sat 14:46] [#C] compiles and runs with CMUCL State “TODO” from “” [2010-10-09 Sat 14:46] Definitely of interest, of slightly less interest only because SBCL is supported and CMUCL is closely related (unlike CCL). [#B] compiles and runs with ClozureCL State “TODO” from “” [2010-10-09 Sat 14:46] Definitely of interest [#B] compiles and runs with Franz Lisp State “TODO” from “” [2010-10-09 Sat 14:46] Definitely of interest [#B] compiles and runs with Allegro CL State “TODO” from “” [2010-10-09 Sat 14:46] Definitely of interest Packages: From Rif: org.middleangle.cl-blapack This covers the overall BLAS and LAPACK integration. org.middleangle.foreign-numeric-vector This provides a data store for C/FORTRAN code that can be accessed by common-lisp. From Tomas: ffa This provides lisp stored matrices array-operations general actions for these matrices. From Mark: lisp-matrix integration (also found in ffa and cl-blapack). Mark initially put it all together. From Others These are dependencies that arise from the original authors. cffi (depends on babel, alexandria ) cl-utilities iterate metabang-bind asdf-system-connections lift (depends on trivial-timeout) Am not sure that this is still the case (trivial-timeout dependency) Others (AJR?) lift (unit testing) lift has become the canonical unit-testing framework for this system. There could also be an argument for lisp-unit, which is more popular. xarray (generic array-like accessors) This is not so much a dependency as an enhancer. It provides a single common API for access of elements in array-like objects. Documentation API matrix-foreign-array (defgeneric make-fa-matrix (nrows ncols fnv-type matrix (defgeneric nrows (matrix) (defgeneric ncols (matrix) (defgeneric data (matrix) (defgeneric nelts (matrix) (defgeneric matrix-dimension (matrix axis-number) (defgeneric matrix-dimensions (matrix) (defgeneric orientation (matrix) (defgeneric flatten-matrix-indices (matrix i j) (defgeneric mref (matrix i j) (defgeneric (setf mref) (value matrix i j) (defgeneric matview-p (matrix) (defgeneric parent (matrix) (defgeneric ancestor (matrix) (defgeneric real-nrows (matrix) (defgeneric real-ncols (matrix) (defgeneric transposed-p (matrix) (defgeneric zero-offset-p (matrix) (defgeneric offset (matrix) (defgeneric unit-strides-p (matrix) (defgeneric make-matrix* (nrows (defgeneric implementation (matrix) (defgeneric element-type (matrix) (defgeneric element-type-size (matrix) (defgeneric transpose-class (matrix) (defgeneric window-class (matrix) (defgeneric stride-class (matrix) (defgeneric transpose-matrix (matrix) (defgeneric window (matrix &key nrows ncols row-offset col-offset) (defgeneric strides (matrix &key nrows ncols row-offset col-offset row-stride (defgeneric copy! (a b) (defgeneric copy* (matrix implementation) (defgeneric fill-matrix (matrix fill-element) (defgeneric m= (a b) matrix-operations (defgeneric m* (a b) (defgeneric m+ (a b) (defgeneric m- (a b) (defgeneric sum (matrix) (defgeneric bind2 (m1 m2 &key by) (defgeneric cross-product (mata matb)) (defgeneric outer-product (mata matb &optional op) (defgeneric m.+ (mata matb) (defgeneric m.- (mata matb) (defgeneric m.* (mata matb) (defgeneric m./ (mata matb) ;; (defgeneric map-matrix (withfn mat &key iterator result-type) numerical-linear-algebra (defgeneric factorized-matrix (a) (defgeneric factorize (a &key by) (defgeneric invert (a &optional by) (defgeneric least-squares (y x &key w) (defgeneric eigensystems (x) (defgeneric optimize (f data params &key method maximize-p) (defgeneric root-find (f data params &key method) vector (defgeneric vector-dimension (vector) (defgeneric vector-orientation (vector) (defgeneric col-vector-p (matrix) (defgeneric row-vector-p (matrix) (defgeneric check-invariant (vector) (defgeneric vref (vector i) (defgeneric (setf vref) (value vector i) (defgeneric vecview-p (vector) (defgeneric real-nelts (matrix) (defgeneric diagonal! (mat &key type) (defgeneric real-stride (vector) (defgeneric slice-class (matrix) (defgeneric slice (matrix &key offset stride nelts type) (defgeneric row (matrix i) (defgeneric col (matrix j) (defgeneric v= (x y) (defgeneric v=2 (&rest args) (defgeneric v+ (x y &optional return-type) (defgeneric v- (x y &optional return-type) (defgeneric v* (x y &optional return-type) (defgeneric v/ (x y &optional return-type) (defgeneric v`op (x y &optional return-type) Usage (ql:quickload :lisp-matrix) Demo (getting started) (in-package :cl-user) (asdf:oos 'asdf:load-op :lisp-matrix) Demo (more working things) ;;; This file illustrates some common actions in the course of working ;;; with matrices using lisp-matrix.  It is important to note that ;;; there are better ways to do this, that this are to help introduce ;;; usage, not describe best practices for using this system.  ;;; = Precursor systems ;;  (asdf:oos 'asdf:compile-op 'ffa :force t) ;;  (asdf:oos 'asdf:compile-op 'org.middleangle.foreign-numeric-vector :force t) ;;  (asdf:oos 'asdf:compile-op 'org.middleangle.cl-blapack :force t)  ;;; = The maing thing... ;; (asdf:oos 'asdf:compile-op 'lisp-matrix :force t) ;; (asdf:oos 'asdf:compile-op 'lisp-matrix)  ;;; And the only thing that ought to be required; (asdf:oos 'asdf:load-op 'lisp-matrix)  ;;; Check status of the installation...  (in-package :lisp-matrix-unittests) (run-lisp-matrix-tests)  ;; if the above describes errors, here is how we figure out what bug ;; report to write...  (describe  (run-lisp-matrix-tests))  ;;; Now we can use it, either by importing the symbols into the ;;; current package by:  ;; (use-package :lisp-matrix)  ;;; or by trying it out in the -user package, before implementing for ;;; production usage.  (in-package :lisp-matrix-user)  ;; (lisp-matrix-unittests:run-lisp-matrix-tests) ;; (describe (lisp-matrix-unittests:run-lisp-matrix-tests))  ;;; We wrap these up into a progn for simple overall evaluation, but ;;; stepping through them is fine as well.  (progn       ;; make some matrices   (defparameter *m1* (make-matrix 2 5 			:implementation :lisp-array  ;; :foreign-array 			:element-type 'double-float)     ""placeholder 1"")      ;; works, as it should.  Indexing is zero-based, so we get the first   ;; element by...   (mref *m1* 0 0)   (mref *m1* 1 3)   (setf (mref *m1* 1 3) 1.2d0)   *m1*     ;; increase complexity    (defparameter *m2* (make-matrix 2 5 			:implementation :lisp-array  ;; :foreign-array 			:element-type 'integer ; 'double-float 			;; :initial-contents (list 1 2 3 4 5 6 7 8 9 10) 			:initial-contents #2A(( 1 2 3 4 5) 					      ( 6 7 8 9 10)))     ""placeholder 2"")    (defparameter *m2a*     (make-matrix 2 5 		 :implementation :lisp-array  ;; :foreign-array 		 :element-type 'integer ; 'double-float 		 :initial-contents '((1 2 3 4 5) 				     (6 7 8 9 10)))     ""placeholder..."")    ;; Currently we can make a foriegn matrix of doubles, but not a   ;; foreign matrix of integers.  If we are working with smaller   ;; matrices and are not doing a great deal of matrix algebra, then   ;; we probably prefer :lisp-array rather than :foreign-array.   (defvar *m2b*     (make-matrix 2 5 		 :implementation :foreign-array  		 :element-type 'double-float 		 :initial-contents #2A(( 1d0 2d0 3d0 4d0 5d0) 				       ( 6d0 7d0 8d0 9d0 10d0)))     ""placeholder 2"")   *m2b*    (mref *m2b* 0 2) ;; => 3   *m2b*   (transpose *m2b*)    ;; simple subsetting is simple   (m= (row *m2b* 0)       (col (transpose *m2b*) 0)) ; => nil, orientation   (v= (row *m2b* 0)       (col (transpose *m2b*) 0)) ; => T, no orientation worries    (m= (col *m2b* 0)       (row (transpose *m2b*) 0))   (v= (col *m2b* 0)       (row (transpose *m2b*) 0))     (defvar *m3*     (make-matrix 6 5 :initial-contents '((1d0 2d0 3d0 4d0 5d0) 					 (6d0  7d0  8d0  9d0  10d0) 					 (11d0 12d0 13d0 14d0 15d0) 					 (16d0 17d0 18d0 19d0 20d0) 					 (21d0 22d0 23d0 24d0 25d0) 					 (26d0 27d0 28d0 29d0 30d0)))     ""placeholder 3"")    (row *m3* 2)   (col *m3* 1)     (= (mref *m3* 0 1)      (mref (transpose *m3*) 1 0))    (=  (mref *m3* 2 2)       (mref (transpose *m3*) 2 2))    *m3*   (transpose *m3*)    ;;; Now we play with striding and slicing subsets.  These work well   ;;; for simple subsetting which can be done by counting/enumeration   ;;; on some form of regular scale.    ;;; In addition, equality is somewhat important for numerical   ;;; issues.  Right.  Anyway, for matrices it is mostly clear what to   ;;; do, but for vectors, which are inheriting from matrices, we have   ;;; 2 issues.  The first is the obvious, the numerical values, and   ;;; the second is not quite obvious, which is the metadata   ;;; surrounding the difference between an MxN and NxM matrix.  For   ;;; the first, think about v= and for the second, m= is the right   ;;; function.    (defvar *m4* (strides *m3* :nrows 2 :row-stride 2)     ""yet another placeholder."")   *m4*   (m= (row *m4* 0)       (make-matrix 1 5 :initial-contents '((1d0 2d0 3d0 4d0 5d0))))   (m= (row *m4* 1)       (make-matrix 1 5 :initial-contents '((11d0 12d0 13d0 14d0 15d0))))   ;; note the redoing for the columns -- different!   (m= (col *m4* 0)       (make-matrix 2 1 :initial-contents '((1d0) (11d0))))   (m= (col *m4* 1)       (make-matrix 2 1 :initial-contents '((2d0) (12d0))))    (v= (row *m4* 0) (col (transpose *m4*) 0))   (v= (col *m4* 0) (row (transpose *m4*) 0))    *m4*   (row *m4* 0)   (col *m4* 4)     (let* ((*default-element-type* '(complex double-float)) 	 (m1 (axpy #C(1.0d0 0.0d0) 		   (ones 2 2) 		   (scal #C(1.5d0 0.0d0) 			 (ones 2 2)))) 	 (m2 (scal #C(2.5d0 0.0d0) (ones 2 2))) 	 (m3 (axpy #C(-1.0d0 0.0d0) 		   (ones 2 2) 		   (scal #C(1.5d0 0.0d0) (ones 2 2)))) 	 (m4 (scal #C(0.5d0 0.0d0) (ones 2 2))))     (format t ""~A ~A ~%"" 	    (m= m1 m2) 	    (m= m3 m4)))    (m+ (row m3 1) (row m3 2))   (m- (row m3 1) (row m3 2))    )    ;;; EXAMPLES TO DEMONSTRATE   ;;; consider the following matrix: ;;; n1= 11 12 13 ;;;     21 22 23 (defparameter *n1*   (make-matrix 2 3 	       :implementation :lisp-array 	       :element-type 'double-float 	       :initial-contents #2A ((11d0 12d0 13d0) 				      (21d0 22d0 23d0)))) *n1* ;;; then storage in row-major orientation would be a sequence ;;;     11 12 13 21 22 23 ;;; while in column-major orientation it would be ;;;     11 21 12 22 13 23  ;;; At this point, consider the following.  Suppose we have a matview ;;; with dims 1x3, row/col offset 1,0: ;;; n2= 21 22 23 (defparameter *n2*   (window *n1* 	  :nrows 1 :ncols 3 	  :row-offset 1 :col-offset 0)) *n2* ;;; or alternatively dims 2x2, row/col offset 0,1: ;;; n3= 12 13 ;;;     22 23 (defparameter *n3*   (window *n1* 	  :nrows 2 :ncols 2 	  :row-offset 0 :col-offset 1)) *n3* ;;; ;;; for the first, we see that, by orientation, we have the following: ;;;     .. .. .. 21 22 23   (row-major) ;;;     .. 21 .. 22 .. 23   (column-major) ;;;  ;;; so we see that for ;;; row-major:    index=3 (ncols), stride=1 ;;; column-major: index=1 (ncols), stride=2 (nrows) ;;;  ;;; for the second, by orientation, we have: ;;;     .. 12 13 .. 22 23  (row-major) ;;;     .. 12 22 .. 13 23  (column-major) ;;;  ;;; so we see that for ;;; row-major:    index=1 (ncols), stride=2 (ncols) ;;; column-major: index=1,(nrows), stride=3 (nrows) ;;;  ;;; Consider a more complex matrix: ;;;  ;;; o1= 11 12 13 14 15 ;;;     21 22 23 24 25 ;;;     31 32 33 34 35 ;;;     41 42 43 44 45 (defparameter *o1*   (make-matrix 4 5 	       :implementation :lisp-array 	       :element-type 'double-float 	       :initial-contents #2A ((11d0 12d0 13d0 14d0 15d0) 				      (21d0 22d0 23d0 24d0 25d0) 				      (31d0 32d0 33d0 34d0 35d0) 				      (41d0 42d0 43d0 44d0 45d0)))) *o1* ;;; row-major: ;;;    o1= 11 12 13 14 15 21 22 23 24 25 31 32 33 34 35 41 42 43 44 45 ;;; col-major:  ;;;    o1= 11 21 31 41 12 22 32 42 13 23 33 43 14 24 34 44 15 25 35 45 ;;; ;;; ;;; Then a matview, dims 3, offset 2,1 : ;;; ;;; o2= 32 33 34 ;;;     42 43 44 (defparameter *o2*   (window *o1* 	  :nrows 2 :ncols 3 	  :row-offset 2 :col-offset 1)) *o2* ;;; ;;; and a strided matview, indexed, could be (offset 2,3; row-stride 2) ;;; ;;; o3= 23 24 25 ;;;     43 44 45 (defparameter *o3*   (strides *o1* 	   :nrows 2 :ncols 3 	   :row-offset 1 :col-offset 2 	   :row-stride 2 :col-stride 1)) *o3* ;;; and for where this sits in the original matrix... ;;; ;;; and now to pull out the rows and columns via slicing on a strided ;;; matrix, we have the following approaches, for the zero-th column: ;;;     23 ;;;     43 (slice *o3* :offset 0 :stride 1 :nelts (nrows *o3*) :type :column) (parent *o3*) ;;; and for the 2nd column (3rd, since we are zero counting). ;;;     25 ;;;     45 (slice *o3* :offset 4 :stride 1 :nelts (nrows *o3*) :type :column) ;;; and for the 1st row (2nd, again zero-counting): ;;;     43 44 45 (slice *o3* :offset 1 :stride 2 :nelts (ncols *o3*) :type :row) ;;;  (orientation *o3*)  ;; convert between foriegn-array and lisp-array.  ;; operate ()  ;; do some blas/lapack  ;; output  ;; Windowing -- simple, works! (m= (col *c* 0)     (make-matrix 3 1 :initial-contents '((16d0) (21d0) (26d0)))) (m= (col *c* 1)      (make-matrix 3 1 :initial-contents '((17d0) (22d0) (27d0)))) (m= (col *c* 2)     (make-matrix 3 1 :initial-contents '((18d0) (23d0) (28d0)))) (m= (col *c* 3)     (make-matrix 3 1 :initial-contents '((19d0) (24d0) (29d0)))) (m= (col *c* 4)     (make-matrix 3 1 :initial-contents '((20d0) (25d0) (30d0))))  (m= (col *d* 0)     (make-matrix 3 1 :initial-contents '((18d0) (23d0) (28d0)))) (m= (col *d* 1)      (make-matrix 3 1 :initial-contents '((19d0) (24d0) (29d0))))  ;; do we want this as part of the API? Currently fails. ;; (m= (col *c* 4) ;;     (col *c* 4) ;;     (make-matrix 3 1 :initial-contents '((20d0) (25d0) (30d0))))   ;;;;;;;;   ;; strided matrix col access m01b (orientation m01b) (unit-strides-p m01b) ;; false, it's explicitly strided (parent m01b) (orientation  (parent m01b)) (unit-strides-p (parent m01b)) ;; true, it's the original...  ;; Windowed matrix (orientation m01c) (row m01c 0) ; Y (row m01c 1) ; Y (col m01c 0) ; Y (col m01c 1) ; Y (col m01c 2) ; Y  ;; slice matrix access to rows (row m01b 0) ; Y (row m01b 1) ; Y (orientation m01b) (offset m01b) (row-offset m01b) (col-offset m01b) (col m01b 0) ; N (col m01b 1) ; N... (col m01b 2) (col m01b 3)  (slice m01b :offset 0 :stride 2 :nelts (ncols m01b) :type :row) (slice (parent m01b) ; equiv on parent        :offset 1        :stride 2        :nelts (ncols m01b)        :type :row) ;;  (slice m01b :offset 1 :stride 2 :nelts (ncols m01b) :type :row) (slice (parent m01b) ; equiv on parent        :offset 1        :stride 2        :nelts (ncols m01b)        :type :row)  ;; slice matrix access to columns (slice m01b :offset 0 :stride 1 :nelts (nrows m01b) :type :column) (col m01b 0) (slice m01b :offset 2 :stride 1 :nelts (nrows m01b) :type :column) (col m01b 1) (slice m01b :offset 4 :stride 1 :nelts (nrows m01b) :type :column) (col m01b 2) (slice m01b :offset 6 :stride 1 :nelts (nrows m01b) :type :column) (col m01b 3) (offset m01b) (row-stride m01b) ; => 2 (col-stride m01b) ; => 1    (m= (col m01b 0)       (make-matrix 2 1 :initial-contents '((11d0) (31d0))))   (m= (col m01b 1)       (make-matrix 2 1 :initial-contents '((12d0) (32d0))))   (m= (col m01b 2)       (make-matrix 2 1 :initial-contents '((13d0) (33d0))))   (m= (col m01b 3)       (make-matrix 2 1 :initial-contents '((14d0) (34d0))))   (m= (col m01b 4)       (make-matrix 2 1 :initial-contents '((15d0) (35d0))))   (row m01b 0)   (row m01b 1)   (col m01b 0)   (col m01b 1)       ;; FIXME: there are bugs in slicing/striding with transposed   ;; matrices.     ;; the following are correct, but..   (row m01 0)   (row m01 1)   (row m01 2)   (row m01 3)    (col m01 0)   (col m01 1)   (col m01 2)   (col m01 3)    m01   (transpose m01)   (row (transpose m01) 0)   (row (transpose m01) 1) ; wrong: grab bad column, AND by 1 (pushed up)   (row (transpose m01) 2) ; ditto, wrong by 2   (row (transpose m01) 3) ; etc...wrong by 3    (row (transpose m01) 0)   (transpose (row (transpose m01) 0))    m01   (transpose m01)   (col (transpose m01) 0)   (col (transpose m01) 1) ; last rather than first   (col (transpose m01) 2) ;   (col (transpose m01) 3) ; ditto above     (v= (row m01 0)       (col (transpose m01) 0)) ;; works      (m= (row m01 0)       (col (transpose m01) 0)) ;; fails, since dims unequal      m01   (transpose m01)   ;; given the above...   ;; FIXME: Big Barf!   (v= (row m01 1)       (col (transpose m01) 1) ) ;; fails badly.  Real badly.      (v= (col m01 1)       (row (transpose m01) 1) ) ;; fails, but closer...      (col m01 1)   (col (transpose m01) 1) ;; this is the problem, indexing issue...         ;; and the same problem.   m3    (transpose m3)   (v= (col m3 1) (row (transpose m3) 1))   (v= (row m3 1) (col (transpose m3) 1)) 	     ;; Striding and Slicing issues:   ;; Strides provide matrix sections; slicing provides vector'd sections.    ;; STRIDING   m01   (strides m01 :nrows 2 :row-stride 2)  ;; view just rows 1 and 3 from m01   (strides m01 :nrows 3) ;; first 3 rows   (strides m01 :ncols 3 :col-stride 2) ;; cols 1, 3 ,5   (strides m01 :ncols 2) ;; first 2 cols   m01    ;; SLICING   m01   (slice m01 :offset 5 :stride  2 :nelts 3 :type :row)   ;; col 2    (slice m01 :offset 5 :stride  2 :nelts 3 :type :row)     (slice (transpose m01) :offset 5 :stride  2 :nelts 3 :type :row)   (slice m01 	 :offset 5 	 :stride  2 	 :nelts 3 	 :type :row)   (slice (transpose m01) :offset 5 :stride  2 :nelts 3 :type :row)    ;; slicing isn't affected by transposition -- doesn't affect the   ;; counting.  Would have suggested that column-major or row-major.   ;; Should this be the case?  (need to migrate to unit-tests).    (v=  (slice m01 :offset 5 :stride  2 :nelts 3 :type :row)        (slice (transpose m01) :offset 5 :stride  2 :nelts 3 :type :row))   (v=  (slice m01 :offset 5 :stride  2 :nelts 3 :type :row)        (slice (transpose m01) :offset 5 :stride  2 :nelts 3 :type :column))   ;; and note the above -- vector equality doesn't depend on orientation...    (slice m01 :offset 1 :stride  2 :nelts 3 :type :column)   (slice m01 :offset 1 :stride  0 :nelts 3 :type :column)   ;; :type   : provides the form to provide output for   ;; :offset : number of observations (in ""col/row major""   ;;           matrix-dependent order) to skip over before starting   ;;           extraction   ;; :stride : 0 = repeat same value; 1, as ordered, 2 every other,    ;;           etc...      ;; Alternative approach for slicing, via Tamas's AFFI package:   (defparameter *my-idx* (affi:make-affi '(5 6))) ; -> generator   (affi:calculate-index *my-idx* #(1 1)) ; -> 7       ;; FIXME: need to get the foriegn-friendly arrays package involved   ;; to create integer matrices.  Or do we just throw an error that   ;; says to use lisp-arrays?   (make-matrix 2 5 	       :implementation :foreign-array  	       :element-type 'integer  	       :initial-contents #2A(( 1 2 3 4 5) 				     ( 6 7 8 9 10)))     ;; FIXME -- indexing with mref not checked against dims, doesn't   ;; barf correctly.  (now is checked, but badly/poorly -- this FIXME   ;; is about better optimization, NOT about it failing to work, which   ;; was the original problem).   m01   (assert-valid-matrix-index m01 1 8)   (assert-valid-matrix-index m01 8 1)   (mref m01 1 8) ; good -- we throw an error... but   (mref m01 8 1) ; BAD! barfs, not protecting against first index...   (setf (mref m01 7 7) 1.2d0)   m01         ;; FIXME: the following has no applicable method -- only for   ;; doubles, not integers.     (m* m2 (transpose m2))   ;; but we can multiple doubles, but...   (m* m01 (transpose m01))       (progn    (defparameter *a*     (make-matrix 6 5 :initial-contents '((1d0 2d0 3d0 4d0 5d0) 					 (6d0  7d0  8d0  9d0  10d0) 					 (11d0 12d0 13d0 14d0 15d0) 					 (16d0 17d0 18d0 19d0 20d0) 					 (21d0 22d0 23d0 24d0 25d0) 					 (26d0 27d0 28d0 29d0 30d0))))   (defparameter *b* (strides *a* :nrows 3 :row-stride 2))   (defparameter *b1* (strides *a* :nrows 2 :ncols 3 :row-stride 2 :col-stride 1))   (defparameter *c* (window *a* :nrows 3 :row-offset 3))   (defparameter *d* (window *a* :nrows 3 :ncols 2 :row-offset 3 :col-offset 2))   (format nil ""Data initialized""))  (orientation *b*)  ;; Striding (typep *b* 'lisp-matrix::strided-matview) (typep *b* 'lisp-matrix::window-matview) (typep *b* 'strided-matview) (typep *b* 'window-matview)  (parent *b*) (offset *b*) (offset *a*) (row-offset *a*) (col-offset *a*) (row-offset *b*) (col-offset *b*) (row-offset *c*) (row-offset *c*) (col-stride *b*)  (row-stride *b*) (nrows (parent *b*))  (equal  (data *a*) 	(data *b*)) ;; col 0 =  1  3  5 indicies; currently getting  1 13 25  (+ 12, not + 2) ;; col 1 =  7  9 11 indicies ;; (m= (princ  (col *b* 0))     (princ  (make-matrix 3 1 :initial-contents '((1d0) (11d0) (21d0))))) (m= (col *b* 1)      (make-matrix 3 1 :initial-contents '((2d0) (12d0) (22d0)))) (m= (col *b* 2)     (make-matrix 3 1 :initial-contents '((3d0) (13d0) (23d0)))) (m= (col *b* 3)     (make-matrix 3 1 :initial-contents '((4d0) (14d0) (24d0)))) (m= (col *b* 4)     (make-matrix 3 1 :initial-contents '((5d0) (15d0) (25d0))))  Demo (broken things) ;;; Precursor systems (in-package :cl-user) ;; (asdf:oos 'asdf:compile-op 'ffa :force t) ;; (asdf:oos 'asdf:compile-op 'array-operations :force t)  ;; (asdf:oos 'asdf:compile-op 'org.middleangle.foreign-numeric-vector :force t) ;; (asdf:oos 'asdf:compile-op 'org.middleangle.cl-blapack :force t) ;  :force t  ;;; The main thing... ;; (delete-package 'lisp-matrix) ;; fails, but we need to cleanup a bit more.  ;; (asdf:oos 'asdf:compile-op 'lisp-matrix :force t) ;; (asdf:oos 'asdf:compile-op 'lisp-matrix) ;; (asdf:oos 'asdf:load-op 'lisp-matrix)  ;; (asdf:oos 'asdf:compile-op 'cffi :force t)  (in-package :lisp-matrix-unittests) ;; Tests = 69, Failures = 0, Errors = 12 ;; 26.2.2009 (run-tests :suite 'lisp-matrix-ut) (describe (run-tests :suite 'lisp-matrix-ut)) ;; or simply... (run-lisp-matrix-tests) (describe  (run-lisp-matrix-tests))  ;; failures:  ;; Note that when unit tests fail in m*- tests, it seems to do with a ;; ""macro vs defun"" problem, related to compile-time vs. run-time ;; evaluation that I (tony) am not quite understanding, causing a ;; possible increase in the number of errors beyond the number ;; reported above. ;; ;; The current two errors are:   ;; * foreign arrays with integer values are not supported. ;; * mixed CL-BLAPACK calls are not yet supported (lisp/foreign stored ;;   matrix-like calls). ;; I'm sure there will be more.  (in-package :lisp-matrix-user)  ;; (lisp-matrix-unittests:run-lisp-matrix-tests) ;; (describe (lisp-matrix-unittests:run-lisp-matrix-tests))  (describe   (lift::run-test   :test-case  'lisp-matrix-unittests::strided-matrix-column-access   :suite 'lisp-matrix-ut-vectors))   ;; Here is what we need to fix, based on the above: ;; #  creation of foreign-array matrices which are integer valued ;;    fails.   ;; Just a reminder: ;; (typep -1 '(integer 0 *))   ;=> nil ;; (typep  2 '(integer 0 *))   ;=> T ;; (typep  3 '(integer -1 2))  ;=> nil ;; (typep  2 '(integer -1 2))  ;=> T  ;;; FIXME FOLLOWING ERRORS: MIGRATE INTO UNITTESTS...  (progn  ;;#FIXME: writing out R matrices -- as strings and via RCLG    (defparameter *x-temp*     (make-matrix 4 5 		 :implementation :lisp-array 		 :element-type 'double-float 		 :initial-contents #2A((11d0 12d0 13d0 14d0 15d0) 				       (21d0 22d0 23d0 24d0 25d0) 				       (31d0 32d0 33d0 34d0 35d0) 				       (41d0 42d0 43d0 44d0 45d0))))    ;; bad:  (min (values (list 4d0 2d0 3d0 5d0 3d0)))   (reduce #'min (list 4d0 2d0 3d0 5d0 3d0))   (reduce #'min (list 2d0 4d0 3d0 5d0 3d0))   (reduce #'min (list 4d0 3d0 5d0 3d0 2d0))    (reduce #'(lambda (x y) (concatenate 'string x y)) 	  ""test"" 	  "" "" 	  (list ""a2"" "" s3 "" ""asdf"") 	  ""end."")    (defun lispmatrix2r (m &key (rvarname ""my.mat""))     ""Write out a string that can be used to read in the matrix into R. Used for creating verfication scripts and test cases.""     (check-type m matrix-like)     (apply       #'concatenate 'string      (format nil ""~%~s <- matrix ( data = c("" rvarname)      (let ((result (list))) 		    (dotimes (i (matrix-dimension m 0)) 		      (dotimes (j (matrix-dimension m 1)) 			(cons (format nil ""~d,"" (mref m i j)) result))) 		    (reverse result))      (list  (format nil ""), nrows=~d, ncols=~d, by.row=TRUE)"" 	     (matrix-dimension m 0) 	     (matrix-dimension m 1)))))    (lispmatrix2R *x-temp*)     (let ((result (make-array (list 3 5) :element-type 'string)))     (dotimes (i 3)       (dotimes (j 5) 	(format t ""~s ~s ~%"" i j) 	(setf (aref result i j) (format t ""(~d ~d),"" i j))))     (reverse result))    )   #+nil  (progn   ;; QR decomp    (let* ((state1 (make-random-state)) 	 (state2 (make-random-state state1)))     (m= (rand 2 3 :state state1) 	(rand 2 3 :state state2)))    ;;; Problems here...   (geqrf (make-matrix 2 2 :initial-contents #2A(( 1d0 2d0 ) (2d0 1d0))))   (geqrf (make-matrix 2 2 :initial-contents '(( 1d0 2d0 ) (2d0 1d0))))   ;;  (make-vector 2 :type :column :initial-contents '((1d0)(1d0))))    )   #+nil (progn ;; FIXME: R's apply across array indicies    ;; Thought 1 (currently not planned for implementation)   ;; consider using affi as a general iterator/walker generator.   ;; So, R has a notion of apply, sapply, tapply, lapply -- what we   ;; should do is something like   ;;   ;;     (map-matrix with-fn this-matrix   ;;                 :by iterator   ;;                 :result-type 'list)   ;;   ;; silly or for later:        :computation-type [:parallel|:serial]   ;;   ;; or similar, where :result-type is something that can be coerced to   ;; from a sequence, and computation-type might drive whether there are   ;; dependencies or not.   (this last is probably too premature).    ;; The basic idea is to use vector functions (taking a vector, and   ;; returning a object) and use them to provide an object that can be   ;; part of a list (or generally, a sequence of homogeneous objects).    ;; Reviewing Tamas Papp's affi package provides one approach to this   ;; challenge.  He suggests that an obvious approach would be to   ;; break up the 2 actions needed for selection consist of describing   ;; the mapping from array to structure, and then walking the   ;; structure to extract (for copy or use).  For our needs, we need a   ;; means of doing this to partition the space, and then   ;; post-partition, deciding which partitions need to be considered   ;; for further processing, and which ones get discarded.    ;; So to clarify how this might work:    ;; 1. we need a function which takes a matrix and creates a list of   ;; matrix-like or vector-like elements.   ;; 2. we have functions which operate in general on matrix-like or   ;; vector-like objects.   ;; 3. we use mapcar or similar to create the results.     ;; 3a. multi-value return could be used to create multiple lists of   ;; vector-like or matrix-like objects, for example to get a complex   ;; computation using inner-products.   So for instance:   ;;   list1: v1a v2a v3a   ;;   list2: m1  m2  m3   ;;   list3: v1b v2b v3b   ;; and we compute   ;;   (list-of (IP v#a m1 v#b ))    ;; via   ;;   (mapcar #'IP (list-of-vector-matrix-vector M))    ;; We would need such an ""extractor"" to make things work out right.     #+nil(mapcar #'function-on-matrix (make-list-of-matrices original-matrix))      (list->vector-like (list 1d0 2d0 3d0) :orientation :row)    (make-vector 3 :type :column  	       :initial-contents 	       (mapcar #'(lambda (x) (list (coerce x 'double-float))) 		       (list 1d0 2d0 3d0)))    (make-vector 3 :type :row  	       :initial-contents 	       (list (mapcar  #'(lambda (x) (coerce x 'double-float)) 			      (list 1d0 2d0 3d0))))    ;; The following approach would be required to do a proper map-back.   #+nil(list->vector-like (map 'list #'function-of-2-args (list1) (list2)) :type :row) ; or :column   ;; this would take a list and create an appropriate vector-like of   ;; the appropriate type.    ;; Thought 2, the current immediate approach:   ;; What we currently do is break it out into components.    (defparameter *m1-app* (ones 2 3))   (let ((col-list (list-of-columns *m1-app*)))     (dotimes (i (length col-list)) 	  (princ (v= (nth i col-list) 		      (ones 2 1)))))    (list-of-columns *m1-app*)   (list-of-rows *m1-app*)      (mapcar #'princ (list-of-columns *m1-app*))    (format nil ""R-Apply approach""))   #+nil (progn   ;; Studies in Class inheritance    (subtypep 'LA-SIMPLE-VECTOR-DOUBLE 'VECTOR-LIKE)   (subtypep 'LA-SLICE-VECVIEW-DOUBLE 'VECTOR-LIKE)   (subtypep 'LA-SIMPLE-VECTOR-DOUBLE 'LA-SLICE-VECVIEW-DOUBLE)   (subtypep  'LA-SLICE-VECVIEW-DOUBLE 'LA-SIMPLE-VECTOR-DOUBLE)    (subtypep 'FA-SIMPLE-VECTOR-DOUBLE 'MATRIX-LIKE)    ;;; weird!   (m- (make-vector 2 :initial-contents '((1d0 1d0)))       (make-vector 2 :initial-contents '((1d0 1d0))))    (let ((*default-implementation* :foreign-array))     (m- (make-vector 2 :initial-contents '((1d0 1d0))) 	(make-vector 2 :initial-contents '((1d0 1d0)))))    (let ((*default-implementation* :lisp-array))     (m- (make-vector 2 :initial-contents '((1d0 1d0))) 	(make-vector 2 :initial-contents '((1d0 1d0)))))    (m- (make-vector 2 		   :implementation :lisp-array 		   :initial-contents '((1d0 1d0)))       (make-vector 2 		   :implementation :foreign-array 		   :initial-contents '((1d0 1d0))))    (typep  (first *lm-result*) 'vector-like)   (typep  (first *lm-result*) 'matrix-like)   (typep  (second *lm-result*) 'vector-like)   (typep  (second *lm-result*) 'matrix-like)   (typep *x-temp* 'vector-like)   (typep *x-temp* 'matrix-like) ; => T ,rest of this paragraph are false.    (m- *x-temp* *x-temp*))  Examples (asdf:oos 'asdf:load-op :lisp-matrix) ;; (ql:quickload :lisp-matrix) Need to autogenerate approach for documenting what we can do with this. Until then, simple reference. Instantiates a supported matrix type: lisp/foreign single/double/complex-single/complex-double/integer (TODO: need to consider normal or mmap’d structures as well) by: (make-matrix  ) right now, we are being numerical analysts, and only allow for a single modality, i.e. lisp-integer, foriegn-doubleFloat, etc. A different package, based on this, should manage mixed-data type typed matrices/arrays. Referencing elements is done using the xarray system, so that needs to be a dependency of this. (one can use the native system, but it would be so much better to have a uniform table-access and manipulation API, xarray or grid or affi or…) (xref mat   x    y       :return-as 'matrix)               ; for a single mat[x,y] value (xref mat       (rows x1 x2 x3)       (columns y1 y2 y3))               ; for a 3x3 matrix restricted                                         ; to the appropriate rows and                                         ; columns.  A better approach                                         ; might be to use a                                         ; cross-product API, or                                         ; serial-list-then-row-or-column-major-fill-to-spec-d-format  (xref mat       (except-for-rows x1 x2 x3)       (except-for-columns x1 x2 x3))  ;; 1-d 1x4 array (xref mat       (shaped-return (list (list x1 y1) (list x2 y2) (list x3 y3) (list x4 y4))))   ;; 2-d 2x2 array (xref mat       (shaped-return (list (list (list x1 y1) (list x2 y2))                            (list (list x3 y3) (list x4 y4))))) And then there is the older stuff. (mref mat x y) get/set (bind2 mat1 mat2 :by [:row|:column] ) (diagonal mat) (m* mat1 mat2) => selection of the correct ZYYmm type (gemm for general mat mult) (m+ mat1 mat2) (m- mat1 mat3) (axpy a mat1 mat2) => (scalar * matrix) + matrix which we need to consider, perhaps through some sort of macro package? Tasks [1/4] [#B] Migrate DITZ issues into this file. State “TODO” from “” [2010-06-07 Mon 16:53] [#B] Refactor src into “lisp-matrix”, “support”, etc. State “TODO” from “” [2010-06-07 Mon 16:39] [#B] fix and illustrate the use of the class structure for “transpose” [#B] Lisp-matrix in own package State “DONE” from “CURR” [2010-06-07 Mon 16:39] Finished a while back. State “CURR” from “TODO” [2010-06-07 Mon 16:39] State “TODO” from “” [2010-06-07 Mon 16:39] supports a lisp-matrix-user playground. Disserata say what. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/blindglobe/lisp-matrix"	"A matrix package.."	"true"
"Numerical and Scientific"	"maxima"	"http://maxima.sourceforge.net/"	"Computer algebra system. Not available on Quicklisp.."	"null"	"null"	"null"	"GNU GPL3"	"http://www.gnu.org/copyleft/gpl.html"	"null"	"null"	"null"	"null"	"null"	"Maxima, a Computer Algebra System Skip to main content Downloads Documentation Project Page Top Previous Next   In other languages:   Deutsch  • Español  • Nederlands  • Português  • Русский  • Türkçe Maxima, a Computer Algebra System Maxima is a system for the manipulation of symbolic and numerical expressions, including differentiation, integration, Taylor series, Laplace transforms, ordinary differential equations, systems of linear equations, polynomials, sets, lists, vectors, matrices and tensors. Maxima yields high precision numerical results by using exact fractions, arbitrary-precision integers and variable-precision floating-point numbers. Maxima can plot functions and data in two and three dimensions. The Maxima source code can be compiled on many systems, including Windows, Linux, and MacOS X. The source code for all systems and precompiled binaries for Windows and Linux are available at the SourceForge file manager. Maxima is a descendant of Macsyma, the legendary computer algebra system developed in the late 1960s at the Massachusetts Institute of Technology. It is the only system based on that effort still publicly available and with an active user community, thanks to its open source nature. Macsyma was revolutionary in its day, and many later systems, such as Maple and Mathematica, were inspired by it. The Maxima branch of Macsyma was maintained by William Schelter from 1982 until he passed away in 2001. In 1998 he obtained permission to release the source code under the GNU General Public License (GPL). It was his efforts and skill which have made the survival of Maxima possible, and we are very grateful to him for volunteering his time and expert knowledge to keep the original DOE Macsyma code alive and well. Since his death, a group of users and developers has formed to bring Maxima to a wider audience. Maxima is updated very frequently, to fix bugs and improve the code and the documentation. We welcome suggestions and contributions from the community of Maxima users. Most discussion is conducted on the Maxima mailing list. Recent Releases Click on a version number to see the list of main changes. 5.38.1: May 12, 2016 5.38.0: April 03, 2016 5.37.3: November 10, 2015 5.37.2: September, 09, 2015 5.37.1: August 31, 2015 5.37.0: August 17, 2015 5.36.1: May 1, 2015 5.36.0: April 15, 2015 Home Documentation Maxima Documentation FAQ Computer Algebra Systems Lisp Links Project Maxima project Third Party Code Related Projects Download Mailing Lists Questions about Maxima or this site: mailing list Hosted at Sourceforge ×Close DOE-MACSYMA Authorization Letter Energy Science and Technology Software Center P.O. Box 1020 Oak Ridge TN 37831 TEL (423) 576-2606 FAX (423) 576-6436 October 6, 1998 William F. Schelter Dept. of Mathematics University of Texas Austin TX, 78712 Dear Dr. Schelter: RE: DOE-MACSYMA This is in reply to your request of September 17, 1998, requesting a license to prepare and distribute derivative works from the copy of DOE-MACSYMA software obtained from the NESC. The ESTSC assumed the DOE Centralized Software Management Facility responsibility in January 1991. The following statement of the Department of Energy's (DOE) position is provided as the ESTSC response to your request. “It has been the DOE practice (where the case permits) to encourage private companies or individuals to modify, enhance, or make derivative works of unrestricted software sponsored or supported by DOE for the purpose of commercialization or distribution of such modifications, enhancements, and/or derivative works. Accordingly, William F. Schelter may consider he has a nonexclusive, world-wide, royalty-free license to make derivative works (modifications or enhancements) from the copy of DOE-MACSYMA obtained from NESC, and to copy, license and/or distribute those derivative works for use, modification and enhancement, and further sublicensing and distribution. Distribution of such derivative works is subject to the U.S. Export Administration Regulations (Title 15 CFR 768-799), which implements the Export Administration Act of 1979, as amended, and/or the International Traffic in Arms Regulation, of 12-6-84, (Title 22 CFR 121-130), which implements the Arms Export Control Act (22 U.S.C. 2728) and may require license for export.” We have enclosed a current list of the countries which are considered sensitive and require approval through DOE Headquarters. Should you have requests from such countries, please contact the ESTSC for approval. If you intend to make your derivative work(s) available under the GPL (gnu public license) via the Internet, the previous paragraph should be included in the GPL and should accompany other modifications, enhancements or derivative works of your program. The derivative versions of DOE-MACSYMA which you develop for commercialization purposes may be of interest to DOE organizations which ESTSC supports. We would appreciate getting copies of such derivatives and would adhere to the dissemination limitation markings which you define. If you have questions or comments, please call me at 423/576-2606. Sincerely, Delores F. Brabson, Program Manager Energy Science and Technology Software Center Close"	"null"	"null"	"Computer algebra system. Not available on Quicklisp.."	"true"
"Parallelism and Concurrency"	"BordeauxThreads"	"https://common-lisp.net/project/bordeaux-threads/"	"Portable, shared-state concurrency.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"23"	"3"	"18"	"GitHub - sionescu/bordeaux-threads: Portable shared-state concurrency for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 23 Fork 18 sionescu/bordeaux-threads Code Issues 0 Pull requests 2 Pulse Graphs Portable shared-state concurrency for Common Lisp http://common-lisp.net/projects/bordeaux-threads/ 207 commits 2 branches 27 releases Fetching contributors Common Lisp 95.7% HTML 2.5% CSS 1.8% Common Lisp HTML CSS Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags context master Nothing to show version-0_5_1 version-0_5_0 version-0_5 version-0_4_0 version-0_4 version-0_3_0 version-0_3 version-0_2_2 version-0_2_1 version-0_2_0 version-0_2 version-0_1_4 version-0_1_3 version-0_1_2 version-0_1_1 version-0_1_0 version-0_1 version-0_0_2 version-0 v0.8.5 v0.8.4 v0.8.3 v0.8.2 v0.8.1 v0.8.0 Version_0_7_0 0_0_2 Nothing to show New pull request Latest commit 92e6a89 Jun 25, 2016 sionescu Add version.sexp as static file … This ensures it is copied by bundle-op Permalink Failed to load latest commit information. site src test Move tests to main .asd Jul 20, 2015 .travis.yml CONTRIBUTORS LICENSE README bordeaux-threads.asd version.sexp README You can find API documentation on the project's wiki: 	http://trac.common-lisp.net/bordeaux-threads/wiki/ApiDocumentation  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/sionescu/bordeaux-threads"	"Portable, shared-state concurrency.."	"true"
"Parallelism and Concurrency"	"chanl"	"https://github.com/zkat/chanl"	"Portable, channel-based concurrency. with parts under."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"84"	"15"	"9"	"GitHub - zkat/chanl: Portable channel-based concurrency for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 15 Star 84 Fork 9 zkat/chanl Code Issues 3 Pull requests 0 Pulse Graphs Portable channel-based concurrency for Common Lisp 460 commits 1 branch 8 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v0.4.1 v0.4 v0.3 v0.2.3 v0.2.2 v0.2.1 v0.2 v0.1 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. examples src tests .mailmap .travis.yml COPYRIGHT Frobbing the file headers Sep 29, 2009 README.mkdn TODO.org chanl.asd README.mkdn What is ChanL? ""Wh-what you have to understand is that-that ChanL is not a big blob of state. When you have a lot of global state with lots of threads, you need to, you need to lock it down. It's like a truck, and if too many people try to use that truck, you, you get problems. ChanL is not a big truck. It's a series--it's a series of tubes."" Sen. Ted Stevens In a nutshell, you create various threads sequentially executing tasks you need done, and use channel objects to communicate and synchronize the state of these threads. You can read more about what that means here: http://swtch.com/~rsc/thread/ http://www.usingcsp.com/cspbook.pdf Loading ChanL ChanL uses asdf for compiling/loading, so in order to load it, you must first make chanl.asd visible to your lisp, then simply    (asdf:oos 'asdf:load-op 'chanl)  The included examples can be loaded by doing    (asdf:oos 'asdf:load-op 'chanl.examples)  at the REPL after the main .asd has been loaded. Compatibility ChanL uses a subset of Bordeaux-threads for all its operations. All other code is written in ANSI CL, so any lisp with a BT-compatible thread library should be able to use this library. ChanL is mainly developed on Clozure CL and SBCL, although it's been casually tested on other lisps. You can run the test suite to see how well it works on yours:    (asdf:oos 'asdf:test-op 'chanl)  Note that the test-suite depends on 5AM, which can be found at http://github.com/sionescu/fiveam Channel API [generic function] make-instance class &rest initargs &key &allow-other-keys [method] make-instance (class channel) &rest initargs Returns a new channel object. [method] make-instance (class unbounded-channel) &rest initargs Returns a new buffered channel with a FIFO buffer with no maximum length. [method] make-instance (class bounded-channel) &key (size 1) &rest initargs Creates a new buffered channel object with a limited buffer size. The buffer has a maximum size of SIZE. Bounded channel buffers are FIFO. When the buffer is full, SEND will block until something is RECVd from the channel. SIZE must be positive and less than +maximum-buffer-size+, and defaults to 1. [method] make-instance (class stack-channel) &rest initargs Returns a new buffered channel with a LIFO buffer with no maximum length. [constant] +maximum-buffer-size+ This constant has an implementation-dependant value, fixed when ChanL is loaded. It is the exclusive upper bound to the size of a bounded-channel's buffer. Note that this value might be further limited by memory constraints. [generic function] send channel value &key [method] send (channel channel) value &key (blockp t) Tries to send VALUE into CHANNEL. If the channel is unbufferd or buffered but full, this operation will block until RECV is called on the channel. Returns the channel that the value was sent into. If blockp is NIL, NIL is returned immediately instead of a channel if attempting to send would block. [method] send (channels sequence) value &key (blockp t) SEND may be used on a sequence of channels. SEND will linearly attempt to send VALUE into one of the channels in the sequence. It will return immediately as soon as it is able to send VALUE into one channel. If BLOCKP is T (default), SEND will continue to block until one operation succeeds, otherwise, it will return NIL when the sequence has been exhausted. [generic function] recv channel &key [method] recv (channel channel) &key (blockp t) Tries to receive a value from CHANNEL. If the channel is unbuffered, or buffered but empty, this operation will block until SEND is called on the channel. Returns two values: 1. The value received through the channel, and 2. The channel the value was sent into. If BLOCKP is nil, this operation will not block, and will return (values NIL NIL) if attempting it would block. [method] recv (channel sequence) &key (blockp t) RECV may be used on a sequence of channels. RECV will linearly attempt to receive a value from one of the channels in teh sequence. It will return immediately as soon as one channel has a value available. As with the method for CHANNEL, this will return the value received, as well as the channel the value was received from. If BLOCKP is NIL, and operating on all channels in sequence would block, (values NIL NIL) is returned instead of blocking. [macro] select &body clauses* Non-deterministically select a non-blocking clause to execute. The syntax is:   select clause*       clause ::= (op form*)       op ::= (recv c &optional variable channel-var) | (send c value &optional channel-var)              | else | otherwise | t       c ::= An evaluated form representing a channel, or a sequence of channels.       variable ::= an unevaluated symbol RECV's return value is to be bound to.       value ::= An evaluated form representing a value to send into the channel.       channel-var ::= An unevaluated symbol that will be bound to the channel the SEND/RECV                       operation succeeded on.  SELECT will first attempt to find a clause with a non-blocking op, and execute it. Execution of the check-if-blocks-and-do-it part is atomic, but execution of the clause's body once the SEND/RECV clause executes is NOT atomic. If all channel clauses would block, and no else clause is provided, SELECT will block until one of the clauses is available for execution. SELECT's non-determinism is, in fact, very non-deterministic. Clauses are chosen at random, not in the order they are written. It's worth noting that SEND/RECV, when used on sequences of channels, are still linear in the way they go through the sequence -- the random selection is reserved for individual SELECT clauses. Please note that currently, the form for the channel in the RECV and SEND clauses and for the value in the SEND clause might be evaluated multiple times in an unspecified order. It is thus undesirable to place forms with side-effects in these places. This is a bug and will be fixed in a future version of ChanL. Thread API [special variable] *default-special-bindings* An alist of bindings new threads should have. The format is: '((var1 'value) (var2 'value2)). [function] pcall function &key initial-bindings name PCALL, a mnemonic for Parallel Call, calls FUNCTION in a new thread. FUNCTION must be a function of zero arguments. INITIAL-BINDINGS, if provided, should be an alist with the same format as default-special-bindings representing dynamic variable bindings that FUNCTION is to be executed with. The default value for INITIAL-BINDINGS is DEFAULT-SPECIAL-BINDINGS. PCALL returns a task object representing this task. This object is intended for interactive use (ie for debugging), and contains a bit of metadata about the execution. The NAME argument can be used to initialize the name slot of the task object. [macro] pexec (&key (initial-bindings *default-special-bindings*)) &body body Executes BODY in parallel. INITIAL-BINDINGS, if provided, should be an alist representing dynamic variable bindings that BODY is to be executed with, as if with default-special-bindings. NAME can be used to initialize the name slot of the returned task object. PEXEC also returns a task. Thread Introspection ChanL includes portable support for lisp threads through bordeaux-threads, and adds some sugar on top, such as a built-in thread pool. None of the thread functions here should be used in user code, since they are meant exclusively for development purposes. Most thread-related matters are automatically handled by the thread pool already. In fact, not a single one of these should be expected to work properly when you use them, so do so at your own risk. [class] task Tasks represent the bits of work carried out by threads. Task objects should be treated as read- only debugging aids. The functions TASK-NAME, TASK-THREAD, and TASK-STATUS return metadata about the task. Since this is an experimental feature, its API is likely to change -- the current behavior can be checked in src/threads.lisp. [function] current-thread Returns the current thread [function] thread-alive-p thread T if THREAD is still alive [function] threadp maybe-thread T if maybe-thread is, in fact, a thread. [function] thread-name thread Returns the name of the thread. [function] kill thread Kills thread dead. [function] all-threads Returns a list of all threads currently running in the lisp image. [function] pooled-threads Returns a list of all threads currently managed by ChanL's thread pool. [function] pooled-tasks Returns a list of all tasks pending or live in ChanL's thread pool. [symbol-macro] %thread-pool-soft-limit This is a SETFable place. It may be used to inspect and change the soft limit for how many threads the thread pool keeps around. Note that the total number of threads will exceed this limit if threads continue to be spawned while others are still running. This only refers to the number of threads kept alive for later use. The default value is 1000. Writing your own channels Currently, ChanL provides a very early API for writing your own channels easily. [class] abstract-channel This class is the ancestral superclass of all channels. CHANNELP returns T for any instances of this class or its subclasses. Direct subclasses of abstract-channel will have to define their own SEND/RECV methods, which should meet the API requirements in order to be compatible with ChanL. [class] channel This is the main unbuffered class used in ChanL. Unless you wish to write a new synchronization algorithm for your custom channels, you should subclass CHANNEL, since you then get to reuse ChanL's build-in algorithm (which relies on locks and condition variables). Subclasses of the CHANNEL class are able to extend behavior in a fairly flexible way by simply writing methods for the following 4 generic functions: [generic function] send-blocks-p channel This function returns, as a generalized boolean, whether SEND should block on this channel. [generic function] recv-blocks-p channel Like send-blocks-p, but for RECV. Please note that the consequences of calling send-blocks-p and recv-blocks-p in user code are undefined -- these functions are called from specific points within the carefully instrumented algorithms of the SEND and RECV methods specialized on the CHANNEL class. [generic function] channel-insert-value channel value Methods on this function define what actions are taken to insert a value into a channel. Methods should be specialized only on the first argument. This function's return values are ignored. [generic function] channel-grab-value channel Methods on this function define how to retrieve a value from a channel. This function must return at least one value, the object retrieved from the channel, which will then be returned by RECV. Additionally, ChanL uses and exports a number of abstract and concrete classes to implement its buffered channels: [abstract class] buffered-channel Abstract class for channels using various buffering styles. [abstract class] queue-channel Abstract class for channels whose buffer works like a queue. [class] bounded-channel Class used by ChanL's bounded channels (queue channels that block when the queue reaches a certain length). [class] unbounded-channel Class used by ChanL's unbounded channels, which are queues of unlimited length (SEND never blocks) [class] stack-channel Class used by ChanL's stack channels. These channels' buffers are unbounded LIFO stack structures. Examples Create a channel:  (defvar *c* (make-instance 'channel))  Create a buffered channel with a buffer size of 5. Buffered channels do not block on send until their buffer is full, or on recv until their buffer is empty.  (defvar *c* (make-instance 'bounded-channel :size 5))  Read a value from a channel (blocks if channel is empty)  (recv *c*)  Write a value to a channel (blocks if channel is full, always blocks on unbuffered channels)  (send *c* 99)  Wait for any of a number of things to occur:  (select    ((recv c d)     (format t ""got ~a from c~%"" d))    ((send e val)     (print ""sent val on e~%""))    ((recv *lots-of-channels* value channel)     (format t ""Got ~A from ~C~%"" value channel))    (otherwise     (print ""would have blocked~%"")))  Create a new thread continually reading values and printing them:  (pexec ()    (loop (format t ""~a~%"" (recv *c*))))  Create a new thread that runs a function:  (pcall #'my-function)  Please refer to the examples/ directory for examples of how ChanL can be used, including a parallel prime sieve algorithm translated from Newsqueak and an implementation of future-based concurrency. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/zkat/chanl"	"Portable, channel-based concurrency. with parts under."	"true"
"Parallelism and Concurrency"	"cl-async"	"https://github.com/orthecreedence/cl-async"	"A library for general-purpose, non-blocking programming.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"133"	"22"	"14"	"GitHub - orthecreedence/cl-async: Asynchronous IO library for Common Lisp. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 22 Star 133 Fork 14 orthecreedence/cl-async Code Issues 20 Pull requests 0 Wiki Pulse Graphs Asynchronous IO library for Common Lisp. 768 commits 4 branches 1 release 10 contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master optimize uv Nothing to show pre-merge-uv Nothing to show New pull request Latest commit cc5c94a Jun 16, 2016 orthecreedence committed on GitHub Merge pull request #140 from l04m33/pointer_data_mem_leak … Pointer data mem leak Permalink Failed to load latest commit information. examples Remove (handler-case ... (t ...)) usage from examples. Dec 22, 2014 src Merge pull request #140 from l04m33/pointer_data_mem_leak Jun 16, 2016 test Tests for DNS request mem leaks Jun 11, 2016 .gitignore Added .gitignore. Dec 18, 2014 LICENSE adding license Sep 23, 2012 README.md ""licenced"" -> ""licensed"" (been bugging me for a while) Nov 29, 2014 cl-async-repl.asd a push would be nice!! issue #116 Jan 12, 2015 cl-async-ssl.asd pointing cl-async-ssl to correct files, oops Jan 11, 2015 cl-async-test.asd merging in latest, disabling no-overlap test Feb 27, 2015 cl-async.asd version bump for timeout/ssl fixes Jun 22, 2015 README.md cl-async - Asynchronous operations for Common Lisp Cl-async is a library for general purpose, non-blocking programming in Common Lisp. Cl-async uses libuv as the backend, which is a fast, stable, portable library for asynchronous IO (used as the backend library in Node.js). The main goal is to provide an experience that makes general asynchronous programming in lisp natural, and to also provide a number of drivers on top of cl-async. NOTE: cl-async uses the v1.x branch of libuv, so make sure to grab that version of it (not the v0.10.x branch). Documentation Please see the cl-async website for full documentation, examples, etc. Quick links: Documentation Base system Timers Signal handling DNS TCP TCP stream TCP SSL Pollers Idlers Notifiers Futures Threading Stats Event callbacks and error handling Examples Benchmarks Implementation notes Drivers Install (ql:quickload :cl-async) Please be aware that until cl-async v0.6.x is in quicklisp, you might want to git clone the master branch into quicklisp/local-projects/. Tests There is a fairly complete suite of tests in the cl-async-test package: (ql:quickload :cl-async-test) (cl-async-test:run-tests) (cl-async-test:run-tests :ssl t) (cl-async-test:run-tests :threading t) License As always, my code is MIT licensed. Do whatever the hell you want with it. Enjoy! Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/orthecreedence/cl-async"	"A library for general-purpose, non-blocking programming.."	"true"
"Parallelism and Concurrency"	"lesque"	"https://github.com/fukamachi/lesque"	"A clone of Resque. Not available on Quicklisp.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"12"	"3"	"0"	"GitHub - fukamachi/lesque: A Resque clone in Common Lisp. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 12 Fork 0 fukamachi/lesque Code Issues 0 Pull requests 0 Pulse Graphs A Resque clone in Common Lisp. 1 commit 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src t .gitignore LICENSE README.markdown lesque-test.asd lesque-worker.asd lesque.asd README.markdown Lesque Redis-backed library for creating background jobs, placing them on multiple queues, and processing them later. Lesque is highly inspired Resque in Ruby. Usage (defvar *lesque* (lesque:connect :host ""localhost"" :port 6379))  (defun deferred-job (&rest args)   ;; blah blah blah   )  (lesque:enqueue *lesque*                 ""my-queue""                 '(deferred-job ""arg1"" ""arg2""))  (lesque.worker:run ""my-queue"")  TODO Web interface Author Eitarow Fukamachi (e.arrows@gmail.com) Copyright Copyright (c) 2014 Eitarow Fukamachi (e.arrows@gmail.com) License Licensed under the MIT License. See LICENSE file. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/lesque"	"A clone of Resque. Not available on Quicklisp.."	"true"
"Parallelism and Concurrency"	"lparallel"	"https://github.com/lmj/lparallel"	"A library for parallel programming.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"101"	"20"	"9"	"GitHub - lmj/lparallel: Parallelism for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 20 Star 101 Fork 9 lmj/lparallel Code Issues 2 Pull requests 1 Pulse Graphs Parallelism for Common Lisp http://lparallel.org 579 commits 1 branch 76 releases Fetching contributors Common Lisp 99.8% Shell 0.2% Common Lisp Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show lparallel-2.8.3 lparallel-2.8.2 lparallel-2.8.1 lparallel-2.8.0 lparallel-2.7.5 lparallel-2.7.4 lparallel-2.7.3 lparallel-2.7.2 lparallel-2.7.1 lparallel-2.7.0 lparallel-2.6.2 lparallel-2.6.1 lparallel-2.6.0 lparallel-2.4.4 lparallel-2.4.3 lparallel-2.4.2 lparallel-2.4.1 lparallel-2.4.0 lparallel-2.3.7 lparallel-2.3.6 lparallel-2.3.5 lparallel-2.3.4 lparallel-2.3.3 lparallel-2.3.2 lparallel-2.3.1 lparallel-2.3.0 lparallel-2.2.1 lparallel-2.2.0 lparallel-2.1.4 lparallel-2.1.3 lparallel-2.1.2 lparallel-2.1.1 lparallel-2.1.0 lparallel-2.0.2 lparallel-2.0.1 lparallel-2.0.0 lparallel-1.7.1 lparallel-1.7.0 lparallel-1.6.3 lparallel-1.6.2 lparallel-1.6.1 lparallel-1.6.0 lparallel-1.5.5 lparallel-1.5.4 lparallel-1.5.3 lparallel-1.5.2 lparallel-1.5.1 lparallel-1.5.0 lparallel-1.4.5 lparallel-1.4.4 lparallel-1.4.3 lparallel-1.4.2 lparallel-1.4.1 lparallel-1.4.0 lparallel-1.3.3 lparallel-1.3.2 lparallel-1.3.1 lparallel-1.3.0 lparallel-1.2.3 lparallel-1.2.2 lparallel-1.2.1 lparallel-1.2.0 lparallel-1.1.0 lparallel-1.0.12 lparallel-1.0.11 lparallel-1.0.10 lparallel-1.0.9 lparallel-1.0.8 lparallel-1.0.7 lparallel-1.0.6 lparallel-1.0.5 lparallel-1.0.4 lparallel-1.0.3 lparallel-1.0.2 lparallel-1.0.1 lparallel-1.0.0 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. bench src test CHANGES version 2.8.3 Dec 30, 2015 LICENSE update copyright year Mar 23, 2012 README.md update readme and convert to markdown Feb 2, 2013 lparallel-bench.asd lparallel-test.asd lparallel.asd README.md lparallel lparallel is a library for parallel programming in Common Lisp, featuring a simple model of task submission with receiving queue constructs for expressing fine-grained parallelism asynchronous condition handling across thread boundaries parallel versions of map, reduce, sort, remove, and many others promises, futures, and delayed evaluation constructs computation trees for parallelizing interconnected tasks bounded and unbounded FIFO queues high and low priority tasks task killing by category integrated timeouts See http://lparallel.org for documentation and examples. Running lparallel should run on any Common Lisp implementation supported by bordeaux-threads. The following implementations successfully pass the test suite: ABCL Allegro Clozure LispWorks SBCL To run tests, load lparallel-test.asd and call (lparallel-test:execute). To run benchmarks, load lparallel-bench.asd and call (lparallel-bench:execute N) where N is the number of worker threads. Author James M. Lawrence llmjjmll@gmail.com Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/lmj/lparallel"	"A library for parallel programming.."	"true"
"Parallelism and Concurrency"	"Xecto"	"https://github.com/pkhuong/Xecto"	"A library for regular array parallelism.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"30"	"2"	"1"	"GitHub - pkhuong/Xecto: 80% xectors Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 30 Fork 1 pkhuong/Xecto Code Issues 0 Pull requests 0 Pulse Graphs 80% xectors 117 commits 1 branch 0 releases 1 contributor Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit 5eb5651 Nov 15, 2015 pkhuong xecto.asd: more metadata for quicklisp (and an explicit LICENSE file) Permalink Failed to load latest commit information. .gitignore .gitignore Nov 15, 2015 LICENSE xecto.asd: more metadata for quicklisp (and an explicit LICENSE file) Nov 15, 2015 README.md Overview and design notes Dec 12, 2011 affine-arrays.lisp Initial commit of prototype Dec 12, 2011 futures.lisp Factor status/slow status code out Dec 18, 2011 loop-nest-transpose.lisp Document loop-nest-tranpose and add minimal-trip-count logic Dec 17, 2011 mpsc-queue.lisp Less mutation in shared memory, and help the GC by breaking potential… Dec 18, 2011 parallel-futures.lisp Fix a couple bugs and perf regression issues (?) Dec 24, 2011 parallel-primitives.lisp Fix a couple bugs and perf regression issues (?) Dec 24, 2011 status.lisp Simpler status downgrade-protection logic Dec 19, 2011 thread-pool.lisp Fix a couple bugs and perf regression issues (?) Dec 24, 2011 vector-futures.lisp Weak pointer to vector in finalizer for vector-futures Dec 18, 2011 work-stack.lisp Fix a couple bugs and perf regression issues (?) Dec 24, 2011 work-units.lisp Fix a couple bugs and perf regression issues (?) Dec 24, 2011 xecto-impl-map.lisp More parallel-for-friendly work-stack interface; adapt code and skip … Dec 18, 2011 xecto-impl-reduce.lisp More parallel-for-friendly work-stack interface; adapt code and skip … Dec 18, 2011 xecto-impl-reshape.lisp Split it up, .asd Dec 15, 2011 xecto-impl-scan.lisp More parallel-for-friendly work-stack interface; adapt code and skip … Dec 18, 2011 xecto-impl.lisp Fix a couple bugs and perf regression issues (?) Dec 24, 2011 xecto.asd xecto.asd: more metadata for quicklisp (and an explicit LICENSE file) Nov 16, 2015 README.md Xecto: 80% of xectors This is a library for regular array parallelism in CL. It's also an ""80%"" library: the goal isn't to extract all the performance there is, but to allow programmers to easily express computations with a decent overhead compared to hand-written loops, in common cases. Uncommon cases should either be handled specially, or rewritten to better fit Xecto's simplistic (and simple) approach. Overview: Structured data Typed arrays Views (later) Reshaping Bulk operations Copy on write Parallelism SIMD Thread-level Structured data Very lazily sketched out; this looks more like an interface design issue Xecto provides homogeneously, but dynamically-typed bulk structured data. Arrays of structures are actually always structures of specialised, homogeneous arrays. [more stuff, when it's better thought out] Think data frames: it's not just a bunch of vectors, there's a level of semantic typing. Upgrading rules?? Typed arrays Prototyped; just more of the same Arrays in Xecto are typed: currently, we only have arrays of double floats, but we'll also have arrays of single floats, machine integers, etc. What's the stance on T arrays? No clue. Arrays can be of arbitrary rank and size; plans include allocating them from the foreign heap (or directly via mmap). Reshaping Prototyped As with many similar libraries, each array is represented as a flat data vector and shape information; shape information includes the dimensions, and an affine transformation from the coordinates to an index in the data vector. Data vectors are immutable, but reference counted to help with copy-on-write. However, arrays themselves are mutable: the copying (if any) is transparent, and references to data vectors are updated as needed. This means that operations like slicing or transposition are nearly free and do not directly entail copying or allocation. Bulk operations Half prototyped Usual stuff: map, reduce, scan. Some amount of recycling rule: single element is replicated as needed, but nothing more. Reduce and scan work on the first dimension of the single input; the reduced/scanned function is then applied, map-like on the remaining dimensions. Copy on write Not yet, but it's a SMOP Mention ! variants (foo-into). Expresses partial writing, but also storage reuse. mmap and tmpfs for TLB-level copying. Parallelism The library is ""just"" a minimally smart interpreter; the upside is that the primitives are chosen so they execute efficiently. Rather than working with scalars, the primitives compute on strided spans of vectors (for inputs and outputs), much like level 1 BLAS operations. This allows for SIMD-level parallelism This also means that each operation boils down to a large number of specialized primitive calls; that's where thread-level parallelism comes in. SIMD Hard part done Each map operation boils down to a perfect nest of for-loops. The nesting is reordered for locality: we attempt to get monotonous address sequences as much as possible, especially in the result vector. Loops are also merged when possible to increase trip counts and reduce nesting depth. Finally, we attempt to ensure a trip count in the innermost loop, to better exploit the primitives. Primitives are pre-compiled and specialised for some key trip count and stride values. That's how we get SIMD. Execution then proceeds by first finding the primitive corresponding to the operation and the inner loop's stride and trip count, and interprets the remainder of the loop nest. TLP Half-designed As shown earlier, each operation is executed as a perfect loop nest that gives rise to a number of primitive operations. The key to exploiting threads is that operations are implemented as futures (with a thread pool and task stealing). Each outer loop is executed a couple times to yield a small number of tasks. Tasks then note dependencies, which gives us pipelining. -> Note: probably want early dealloc. Futures are triggered via a stack and task stealing, so we get locality for free. NUMA awareness via hashing on middle bits of written addresses. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/pkhuong/Xecto"	"A library for regular array parallelism.."	"true"
"Regex"	"cl-ppcre"	"http://weitz.de/cl-ppcre/"	"Portable, Perl-compatible regular expressions.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"101"	"13"	"13"	"GitHub - edicl/cl-ppcre: Common Lisp regular expression library Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 13 Star 101 Fork 13 edicl/cl-ppcre Code Issues 6 Pull requests 1 Pulse Graphs Common Lisp regular expression library http://weitz.de/cl-ppcre/ 52 commits 1 branch 8 releases Fetching contributors Common Lisp 99.2% Perl 0.8% Common Lisp Perl Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v2.0.11 v2.0.10 v2.0.9 v2.0.8 v2.0.7 v2.0.6 v2.0.5 v2.0.4 Nothing to show New pull request Latest commit 0f6fe80 Apr 28, 2016 attila-lendvai committed with stassats Remove (safety 0) from the default optimization. … It's a very bad default that has already wasted countless programmer hours. Permalink Failed to load latest commit information. cl-ppcre-unicode Update to 2.0.2 Sep 17, 2009 doc Fix from Martin Simmons for LW7 Aug 26, 2015 test CHANGELOG Fix from Martin Simmons for LW7 Aug 26, 2015 README.md api.lisp Fix compiler-macro interaction with LOAD-TIME-VALUE and CONSTANTP. Apr 1, 2016 charmap.lisp charset.lisp chartest.lisp Update to 2.0.2 Sep 17, 2009 cl-ppcre-unicode.asd Add :author/:license/:description fields to .asd files May 28, 2015 cl-ppcre.asd closures.lisp Update to 2.0.2 Sep 17, 2009 convert.lisp Specialize parse-tree method argument to suppress unused argument war… Jan 5, 2014 errors.lisp lexer.lisp Move inlined definitions before they are used. Dec 30, 2014 optimize.lisp packages.lisp Update to 2.0.2 Sep 17, 2009 parser.lisp Rewrite SEQ without using recursion. Feb 13, 2013 regex-class-util.lisp regex-class.lisp Add print-object methods for some regex classes. Apr 11, 2013 repetition-closures.lisp scanner.lisp specials.lisp Remove (safety 0) from the default optimization. Apr 28, 2016 util.lisp Update to 2.0.3 Oct 29, 2009 README.md CL-PPCRE - Portable Perl-compatible regular expressions for Common Lisp Abstract CL-PPCRE is a portable regular expression library for Common Lisp which has the following features: It is compatible with Perl (especially when used in conjunction with cl-interpol, to allow compatible parsing of regexp strings). It is pretty fast. It is portable between ANSI-compliant Common Lisp implementations. It is thread-safe. In addition to specifying regular expressions as strings like in Perl you can also use S-expressions. It comes with a BSD-style license so you can basically do with it whatever you want. CL-PPCRE has been used successfully in various applications like BioBike, clutu, LoGS, CafeSpot, Eboy, or The Regex Coach. Further documentation can be found in doc/index.html, or on the cl-ppcre homepage. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/edicl/cl-ppcre"	"Portable, Perl-compatible regular expressions.."	"true"
"Emacs"	"SLIME"	"https://github.com/slime/slime"	"Superior Lisp Interaction Mode for Emacs; a full-blown environment for Common Lisp inside of Emacs. Public domain."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"623"	"104"	"150"	"GitHub - slime/slime: The Superior Lisp Interaction Mode for Emacs Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 104 Star 623 Fork 150 slime/slime Code Issues 82 Pull requests 34 Pulse Graphs The Superior Lisp Interaction Mode for Emacs http://common-lisp.net/project/slime/ 5,494 commits 12 branches 21 releases 42 contributors Common Lisp 48.6% Emacs Lisp 45.2% Scheme 5.2% Standard ML 0.4% Ruby 0.3% Makefile 0.3% Common Lisp Emacs Lisp Scheme Standard ML Ruby Makefile Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags backhackattack-1 choose-swank-loading-method common-lisp-net-cvs contrib gh-pages interface-method-combination makefile-cleanup master origin/master package-split slime-2.4 stateless-emacs Nothing to show v2.18 v2.17 v2.16 v2.15 v2.14 v2.13 v2.12 v2.11 v2.10.1 v2.10 v2.9 v2.8 v2.7 v2.6 v2.5 v2.4 v2.3.2 v2.3.1 cl-net-cvs-import SLIME_2 FAIRLY_STABLE Nothing to show New pull request Latest commit a8a3dd8 Jul 4, 2016 luismbo slime-repl: bind TAB to self-insert-command … Otherwise it'd trigger a SWANK event while in slime-repl-read-mode which would block indefinitely.  Fixes issue #329. Permalink Failed to load latest commit information. contrib slime-repl: bind TAB to self-insert-command Jul 4, 2016 doc Remove ChangeLog files Jun 12, 2016 lib Fix #288 by implementing glossary term lookup. Mar 3, 2016 swank sbcl: Record the package active during C-c C-c. Jun 24, 2016 .gitattributes Ignore certain files when exporting with git-archive. Jan 12, 2014 .gitignore Make SLIME more MELPA friendly Nov 14, 2014 .gitref Ignore certain files when exporting with git-archive. Jan 12, 2014 .travis.yml Disable CMUCL tests Aug 14, 2015 CONTRIBUTING.md CONTRIBUTING.md: add note about commit messages Jun 12, 2016 Makefile Derive SWANK protocol version from slime-version Jun 12, 2016 NEWS Release 2.18 May 21, 2016 PROBLEMS Mention problem with CLISP Windows filenames. Dec 3, 2011 README.md Make calling slime-setup unnecessary Jun 14, 2016 metering.lisp Unbreak CCL and CLISP and cleanup ChangeLog. Apr 12, 2014 nregex.lisp Released into the public domain by Lawrence E. Freil. Sep 19, 2005 packages.lisp swank: add BOOLEAN-TO-FEATURE-EXPRESSION Mar 21, 2016 sbcl-pprint-patch.lisp New file, adds the annotations feature to the SBCL pretty printer. Feb 17, 2006 slime-autoloads.el fix autoload spec of the ‘hyperspec-lookup’ function Jul 18, 2015 slime-tests.el Start using completion-at-point. Jul 17, 2015 slime.el Extend load-path with contribs sooner Jul 4, 2016 start-swank.lisp Remove stale commentaries. Dec 5, 2011 swank-loader.lisp Derive SWANK protocol version from slime-version Jun 12, 2016 swank.asd Revert previous swank.asd change until proper ASDF support is built in. Feb 6, 2014 swank.lisp * swank.lisp (xref-doit): translate :sets to who-sets. Mar 4, 2016 xref.lisp Even more long line breaking. Apr 7, 2012 README.md Overview SLIME is the Superior Lisp Interaction Mode for Emacs. SLIME extends Emacs with support for interactive programming in Common Lisp. The features are centered around slime-mode, an Emacs minor-mode that complements the standard lisp-mode. While lisp-mode supports editing Lisp source files, slime-mode adds support for interacting with a running Common Lisp process for compilation, debugging, documentation lookup, and so on. For much more information, consult the manual. Quick setup instructions Set up the MELPA repository, if you haven't already, and install SLIME using M-x package-install RET slime RET. Add the following lines to your ~/.emacs file, filling in in the appropriate filenames:  ;; Set your lisp system and, optionally, some contribs  (setq inferior-lisp-program ""/opt/sbcl/bin/sbcl"")  (setq slime-contribs '(slime-fancy)) Use M-x slime to fire up and connect to an inferior Lisp. SLIME will now automatically be available in your Lisp source buffers. If you'd like to contribute to SLIME, you will want to instead follow the manual's instructions on how to install SLIME via Git. Contribs SLIME comes with additional contributed packages or ""contribs"". Contribs can be selected via the slime-contribs list. The most-often used contrib is slime-fancy, which primarily installs a popular set of other contributed packages. It includes a better REPL, and many more nice features. License SLIME is free software. All files, unless explicitly stated otherwise, are public domain. Contact If you have problems, first have a look at the list of known issues and workarounds. Questions and comments are best directed to the mailing list at slime-devel@common-lisp.net, but you have to subscribe first. The mailing list archive is also available on Gmane. See the CONTRIBUTING.md file for instructions on how to contribute. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/slime/slime"	"Superior Lisp Interaction Mode for Emacs; a full-blown environment for Common Lisp inside of Emacs. Public domain."	"true"
"Vim"	"SLIMV"	"https://github.com/kovisoft/slimv"	"Superior Lisp Interaction Mode for Vim; a full-blown environment for Common Lisp inside of Vim. No license specified."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"179"	"8"	"28"	"GitHub - kovisoft/slimv: Official mirror of Slimv versions released on vim.org Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 8 Star 179 Fork 28 kovisoft/slimv Code Issues 8 Pull requests 3 Pulse Graphs Official mirror of Slimv versions released on vim.org 1,150 commits 1 branch 50 releases Fetching contributors Common Lisp 55.6% VimL 30.6% Scheme 6.0% Clojure 5.4% Python 2.4% Common Lisp VimL Scheme Clojure Python Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show 0.9.12 0.9.11 0.9.10 0.9.9 0.9.8 0.9.7 0.9.6 0.9.5 0.9.4 0.9.3 0.9.2 0.9.1 0.9.0 0.8.6 0.8.5 0.8.4 0.8.3 0.8.2 0.8.1 0.8.0 0.7.7 0.7.6 0.7.5 0.7.4 0.7.3 0.7.2 0.7.1 0.7.0 0.6.3 0.6.2 0.6.1 0.6.0 0.5.6 0.5.5 0.5.4 0.5.3 0.5.2 0.5.1 0.5.0 0.4.1 0.4.0 0.3.0 0.2.2 0.2.1 0.2.0 0.1.4 0.1.3 0.1.2 0.1.1 0.1 Nothing to show New pull request Latest commit 1de8da9 Jun 11, 2016 kovisoft Store package in register when SlimvEvalTestDefun() is called with an … output register passed. This is needed when the test form is in a different package and evaluated together with the current form. Permalink Failed to load latest commit information. doc Added command 'Quit REPL' mapped to <Leader>Q Nov 1, 2015 ftdetect Identify .cljs files as Clojure type (no ClojureScript swank server i… Mar 13, 2012 ftplugin Store package in register when SlimvEvalTestDefun() is called with an Jun 11, 2016 indent Do not load indent for a filetype that is disabled Feb 21, 2012 plugin Fix Paredit burfing (by moving parens left or right) when there are s… Sep 5, 2015 slime Removed ""com"" extension from the scheme swank server when loading com… Apr 10, 2016 swank-clojure Added swank-clojure Apr 10, 2011 syntax Define rainbow parens for clojure when Vim's new built-in syntax/cloj… Jun 10, 2013 .hgtags Added tag 0.9.12 for changeset 638686453739 Dec 29, 2013 README.txt Add GNU screen g:slimv_swank_cmd example. Sep 15, 2015 README.txt -------------------------------------------------------------------------------- slimv.vim --------------------------------------------------------------------------------  Superior Lisp Interaction Mode for Vim (""SLIME for Vim"")  Vim script  created by Tamas Kovacs   -------------------------------------------------------------------------------- Description --------------------------------------------------------------------------------  Slimv is a SWANK client for Vim, similarly to SLIME for Emacs. SWANK is a TCP server for Emacs, which runs a Common Lisp, Clojure or Scheme REPL and provides a socket interface for evaluating, compiling, debugging, profiling lisp code. The SWANK server is embedded in Slimv, but you can also use your own SWANK installation.  Slimv opens the lisp REPL (Read-Eval-Print Loop) inside a Vim buffer. Lisp commands may be entered and executed in the REPL buffer, just as in a regular REPL.  Slimv supports SLIME's debugger, inspector, profiler, cross reference, arglist, indentation, symbol name completion functions. The script also has a Common Lisp Hyperspec lookup feature and it is able to lookup symbols in the Clojure API, as well as in JavaDoc.  Slimv comes with Paredit Mode, which is similar to the functionality of paredit.el in Emacs. Paredit Mode tries to maintain the balanced state of matched characters (parenthesis marks, square and curly braces, double quotes). Matched characters are inserted and removed in pairs, also when working with a block of text (well, mostly). Slimv also implements many paredit.el s-expression handling functions, like Split/Join/Wrap/Splice/Raise. Slurpage and Barfage known from Emacs is also possible but in a different fashion: you don't move the list element in or out of the list, rather you move the opening or closing parenthesis over the element or sub-list.  Please visit the Slimv Tutorial for a more complete introduction: http://kovisoft.bitbucket.org/tutorial.html  Please find the most recent development version in the repository: https://bitbucket.org/kovisoft/slimv  Here follows a list of Slimv commands, any similarity with SLIME's menu is not coincidental. :)  Edit commands:     *  Close Form     *  Complete Symbol     *  Function Arglist     *  Paredit Toggle  Evaluation commands:     *  Eval Defun     *  Eval Current Expression     *  Eval Region     *  Eval Buffer     *  Interactive Eval     *  Undefine Function  Debug commands:     *  Macroexpand-1     *  Macroexpand All     *  Toggle Trace     *  Untrace All     *  Disassemble     *  Set Breakpoint     *  Break on Exception     *  Inspect     *  Abort     *  Quit to Toplevel     *  Continue     *  Restart Frame     *  List Threads     *  Kill Thread     *  Debug Thread  Compile commands:     *  Compile Defun     *  Compile and Load File     *  Compile File     *  Compile Region  Cross Reference commands     *  Who Calls     *  Who References     *  Who Sets     *  Who Binds     *  Who Macroexpands     *  Who Specializes     *  List Callers     *  List Callees  Profile commands:     *  Toggle Profile     *  Profile by Substring     *  Unprofile All     *  Show Profiled     *  Profile Report     *  Profile Reset  Documentation commands:     *  Describe Symbol     *  Apropos     *  Hyperspec     *  Generate Tags  REPL commands:     *  Connect to Server     *  Interrupt Lisp Process     *  Send Input     *  Close and Send Input     *  Set Package     *  Previous Input     *  Next Input     *  Clear REPL  For more information see the included documentation.   --------------------------------------------------------------------------------------------- Installation details ---------------------------------------------------------------------------------------------  Extract the zip archive into your vimfiles or runtime directory.  Slimv works on Windows, Linux and Mac OS X (via Terminal.app), Cygwin is supported. The script requires the following programs installed on your system:     *  Vim with Python feature enabled     *  Python (must be the same Python version that was Vim compiled against)     *  Lisp (any Common Lisp with SLIME support) or Clojure or MIT Scheme (Linux only)  Vim's Python version can be identified with the :ver command, look for the -DDYNAMIC_PYTHON_DLL=\""pythonXX\"" string (if you have it). Another way of determining Vim's Python version:  :python import sys; print(sys.version)  Slimv tries to autodetect your Lisp/Clojure/Slime installation directories. If it fails to determine the correct directories, then you need to enter the command to start the SWANK server into your vimrc file.  Linux example:     let g:slimv_swank_cmd = '! xterm -e sbcl --load /usr/share/common-lisp/source/slime/start-swank.lisp &'  Windows example:     let g:slimv_swank_cmd = '!start ""c:/Program Files/Lisp Cabinet/bin/ccl/wx86cl.exe"" -l ""c:/Program Files/Lisp Cabinet/site/lisp/slime/start-swank.lisp""'  Mac OS X example:     let g:slimv_swank_cmd = '!osascript -e ""tell application \""Terminal\"" to do script \""sbcl --load ~/.vim/slime/start-swank.lisp\""""'  For Clojure use the g:slimv_swank_clojure option, e.g.:     let g:slimv_swank_clojure = '! xterm -e lein swank &'    - For pure text-based console without XTerm  If you only have `SSH` and can not use `XTerm`, you can use `tmux` or `screen` instead.  Linux example with `tmux`:     let g:slimv_swank_cmd = '! tmux new-window -d -n REPL-SBCL ""sbcl --load ~/.vim/bundle/slimv/slime/start-swank.lisp""'  Linux example with `screen`:     let g:slimv_swank_cmd = '! screen -d -m -t REPL-SBCL sbcl --load ~/.vim/bundle/slimv/slime/start-swank.lisp'  Mac OS X example with `tmux`:     let g:slimv_swank_cmd = '!osascript -e ""! tmux new-window -d -n REPL-SBCL ""sbcl --load ~/.vim/bundle/slimv/slime/start-swank.lisp""'   See the included documentation for more complete installation and customization instructions.   vim:et:wrap:  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/kovisoft/slimv"	"Superior Lisp Interaction Mode for Vim; a full-blown environment for Common Lisp inside of Vim. No license specified."	"true"
"Tools"	"quickapp-cli"	"https://github.com/triclops200/quickapp-cli"	"as a command-line utility.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"2"	"2"	"0"	"GitHub - triclops200/quickapp-cli: Client for quickapp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 2 Fork 0 triclops200/quickapp-cli Code Issues 0 Pull requests 0 Pulse Graphs Client for quickapp 19 commits 2 branches 0 releases Fetching contributors Common Lisp 73.2% Makefile 26.8% Common Lisp Makefile Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master patch-add-license-1 Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. .gitignore License.txt Makefile README.md package.lisp quickapp-cli.asd quickapp-cli.lisp slime.lisp README.md quickapp-cli Client for quickapp This is a unix-style wrapper for quickapp so that one can create sbcl buildapp apps from the command line. Example Usage:  quickapp testproject \    -d""(:sdl2 :cl-opengl)"" \    --author=cluser See https://github.com/triclops200/quickapp for more options and examples. License Licensed under Modified BSD License. See License.txt for more details. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/triclops200/quickapp-cli"	"as a command-line utility.."	"true"
"Utilities"	"quickapp"	"https://github.com/triclops200/quickapp"	"A project for generating template projects with SBCL and buildapp. Also includes a command-line argparser.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"25"	"6"	"2"	"GitHub - triclops200/quickapp: A common lisp project for generating template projects that use sbcl and buildapp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 6 Star 25 Fork 2 triclops200/quickapp Code Issues 2 Pull requests 0 Pulse Graphs A common lisp project for generating template projects that use sbcl and buildapp 39 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. .gitignore License.txt Makefile.template README.md app-utils.lisp.template argument-parsing.lisp package.lisp project.asd.template project.lisp.template quickapp.asd quickapp.lisp slime.lisp slime.lisp.template README.md quickapp A common lisp project for generating template projects that use sbcl and buildapp See https://github.com/triclops200/quickapp-cli for the command line standalone utility. Example usage (ql:quickload :quickapp) (quickapp:quickapp           ""src/lisp/test-project""           :project-name ""test-project""            :executable-name ""test.out""            :project-description ""This is a sample test project""            :project-author ""YOUR NAME HERE""            :dependencies '(:sdl2 :cl-openal)) This creates the needed files and Makefile as well as a template project. For easy interactive development in slime, just do (assuming one is in their generated project directory): (load ""slime.lisp"") (in-package :<YOUR PACKAGE NAME>) Arg parsing utilities This library also contains two functions for dealing with argument handling for the generated application: (quickapp:parse-args) and (quickapp:generate-flag-string). An example usage is shown below (defun -main (&optional args)   ""Entry point""   (let* ((arg-defs '((""h"" ""help"" ""Display this help menu"")               (""d"" ""dependencies"" ""(:dep1 [:dep2 ...])"" ""The dependencies"")               (""p"" ""project-name"" ""NAME"" ""The project name"")               (""a"" ""project-author"" ""NAME"" ""The name of the author"")               (""s"" ""project-description"" ""DESCRIPTION"" ""The project description"")               (""e"" ""executable-name"" ""NAME"" ""The executable name"")))          (parsed-args (quickapp:parse-args arg-defs (cdr args))))       (if (or (/= (length (first parsed-args)) 1)               (assoc ""help"" (second parsed-args) :test #'string=))           (progn (format t ""Usage: ~a PROJECT-PATH [OPTIONS]~%OPTIONS:~%~a~%~a~%~a~a~%~a~%~a~%""                    (first args)                    (quickapp:generate-flag-string arg-defs)                    ""Example Usage: "" (first args) "" test-project \\""                    ""  -d\""(:sdl2 :cl-opengl)\"" \\""                    ""  --project-author=cluser""))           (format t ""~a~%"" parsed-args)))) Running that application with the --help flag results in: Usage: ./quickapp PROJECT-PATH [OPTIONS] OPTIONS:   -h  --help                              Display this help menu   -d  --dependencies=(:dep1 [:dep2 ...])  The dependencies   -p  --project-name=NAME                 The project name   -a  --project-author=NAME               The name of the author   -s  --project-description=DESCRIPTION   The project description   -e  --executable-name=NAME              The executable name  Example Usage:  ./quickapp test-project \   -d""(:sdl2 :cl-opengl)"" \   --project-author=cluser  Running this command: ./quickapp test-project -d""(:sdl2 :cl-opengl)"" --project-author=cluser results in this list returned as parsed-args ((""test-project"")  ((""project-author"" . ""cluser"") (""dependencies"" . ""(:sdl2 :cl-opengl)""))) License Licensed under Modified BSD License. See License.txt for more details. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/triclops200/quickapp"	"A project for generating template projects with SBCL and buildapp. Also includes a command-line argparser.."	"true"
"Tools"	"SWIG"	"http://www.swig.org/"	"A tool for generating FFI code from C/C++ header files.."	"null"	"null"	"null"	"GNU GPL3"	"http://www.gnu.org/copyleft/gpl.html"	"null"	"null"	"null"	"null"	"null"	"Simplified Wrapper and Interface Generator   Home Github Development Mailing Lists Bugs and Patches Information What is SWIG? Compatibility Features Tutorial Documentation News The Bleeding Edge History Guilty Parties Projects Legal Department Links Download SwigWiki Donate Affiliations Our Generous Host Exits AllegroCL C# - Mono C# - MS .NET CFFI CHICKEN CLISP D Go language Guile Java Javascript - Node.js Javascript - V8 Javascript - WebKit Lua MzScheme/Racket Ocaml Octave Perl PHP Python R Ruby Scilab Tcl/Tk Welcome to SWIG [ Chinese ] SWIG is a software development tool that connects programs written in C and C++ with a variety of high-level programming languages. SWIG is used with different types of target languages including common scripting languages such as Javascript, Perl, PHP, Python, Tcl and Ruby. The list of supported languages also includes non-scripting languages such as C#, Common Lisp (CLISP, Allegro CL, CFFI, UFFI), D, Go language, Java including Android, Lua, Modula-3, OCAML, Octave, Scilab and R. Also several interpreted and compiled Scheme implementations (Guile, MzScheme/Racket, Chicken) are supported. SWIG is most commonly used to create high-level interpreted or compiled programming environments, user interfaces, and as a tool for testing and prototyping C/C++ software. SWIG is typically used to parse C/C++ interfaces and generate the 'glue code' required for the above target languages to call into the C/C++ code. SWIG can also export its parse tree in the form of XML and Lisp s-expressions. SWIG is free software and the code that SWIG generates is compatible with both commercial and non-commercial projects. Download the latest version. Documentation, papers, and presentations Features. Mailing Lists Bug tracking SwigWiki! Recent News 2016/06/12 - SWIG-3.0.10 released This release fixes a couple of important regressions in SWIG-3.0.9 for smart pointers and importing Python modules. 2016/05/29 - SWIG-3.0.9 released Summary of changes in SWIG-3.0.9 Add support for Python's implicit namespace packages. Fixes to support Go 1.6. C++11 std::array support added for Java. Improved C++ multiple inheritance support for Java/C# wrappers. Various other minor fixes and improvements for C#, D, Go, Java, Javascript, Lua, Python, R, Ruby, Scilab. 2015/12/31 - SWIG-3.0.8 released SWIG-3.0.8 summary: - pdf documentation enhancements. - Various Python 3.5 issues fixed. - std::array support added for Ruby and Python. - shared_ptr support added for Ruby. - Minor improvements for CFFI, Go, Java, Perl, Python, Ruby. 2015/08/03 - SWIG-3.0.7 released SWIG-3.0.7 release summary: Add support for Octave-4.0.0. Remove potential Android security exploit in generated Java classes. * Minor new features and bug fixes. 2015/07/05 - SWIG-3.0.6 released SWIG-3.0.6 is mostly a stability release. Release summary: - Stability and regression fixes. - Fixed parsing of C++ corner cases. - Language improvements and bug fixes for C#, Go, Java, Lua, Python, R. 2015/03/07 - Defending the GPL SWIG is a proud member of the Software Freedom Conservancy who has recently announced that they will be supporting a lawsuit to defend an alleged violation of the GNU General Public License (GPL). Ensuring this software license, the same one that protects the SWIG source code, is not abused and is actively defended in a court of law is important for everyone using the license. Conservancy is supporting Christoph Hellwig's lawsuit against VMware over GPL violations on Linux. VMware have stated that they would not comply with the GPL after many patient years of negotiations by Christoph and the Conservancy. More information is in the Conservancy's FAQ on the lawsuit. If you have benefited or enjoyed the fruits of SWIG, it is because the SWIG developer's chose to use a software license to ensure it remains freely available. Please consider supporting Christoph and Conservancy including their fund raising appeal to defend our license. William Fulton SWIG lead maintainer 2015/02/01 - SWIG-3.0.5 released We are pleased to announce SWIG-3.0.5 has been released with the addition of support for Scilab. This version also contains: An important Python fix for a regression in SWIG-3.0.3 when wrapping C++ default arguments. Minor improvements for C#, Go, Octave, PHP and Python. SWIG-3.0.4 was also released recently and contained part of the Python fix for the regression mentioned above. Python users should definitely rather use 3.0.5. 2014/12/31 - SWIG-3.0.3 released SWIG-3.0.3 release summary: - Add support for C++11 strongly typed enumerations. - Numerous bug fixes and minor enhancements for C#, D, Go, Java, Javascript, PHP, Perl and Python wrappers. More detailed release notes can be seen at http://swig.org/release.html 2014/06/04 - SWIG-3.0.2 released This release has been made to fix a bug during installation, but it also includes a couple of other rather minor changes. 2014/05/27 - SWIG-3.0.1 released SWIG-3.0.1 is another milestone release as it is the first version to contain support for Javascript. Release summary: Javascript module added. This supports JavascriptCore (Safari/Webkit), v8 (Chromium) and node.js currently. A few notable regressions introduced in 3.0.0 have been fixed - in Lua, nested classes and parsing of operator <<. The usual round of bug fixes and minor improvements for C#, GCJ, Go, Java, Lua, PHP and Python. More news Feedback and questions concerning this site should be posted to the swig-devel mailing list. Last modified : Sun May 29 15:22:36 2016"	"null"	"null"	"A tool for generating FFI code from C/C++ header files.."	"true"
"Unit Testing"	"FiveAM"	"https://github.com/sionescu/fiveam"	"Simple regression testing framework.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"68"	"7"	"18"	"GitHub - sionescu/fiveam: Common Lisp regression testing framework Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 68 Fork 18 sionescu/fiveam Code Issues 4 Pull requests 1 Pulse Graphs Common Lisp regression testing framework 155 commits 2 branches 4 releases 13 contributors Common Lisp 97.6% CSS 2.4% Common Lisp CSS Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master v1.2 Nothing to show v1.3 v1.2 v1.1 v1.0 Nothing to show New pull request Latest commit 6192036 Jul 9, 2016 sionescu Fix lack of hygiene in expansion of FINISHES … Bug reported by Javier Olaechea Permalink Failed to load latest commit information. docs Platform-independent pathnames in make-qbook Aug 21, 2006 src Fix lack of hygiene in expansion of FINISHES Jul 9, 2016 t Implement function RUN-ALL-TESTS Apr 6, 2016 .boring Escape { and } chars in baring regexps Nov 5, 2005 .travis.yml Switch to sionescu/cl-travis Jul 22, 2015 COPYING Update copyright notices to 2006 Jan 23, 2006 README Replace mailing-list address with the new one Apr 21, 2012 fiveam.asd Print a backtrace on error or test failure May 20, 2016 version.sexp Release 1.3 May 20, 2016 README This is FiveAM, a common lisp testing framework.  The documentation can be found in the docstrings, start with the package :it.bese.fiveam (nicknamed 5AM).  The mailing list for FiveAM is fiveam-devel@common-lisp.net  All the code is Copyright (C) 2002-2006 Edward Marco Baringer.  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/sionescu/fiveam"	"Simple regression testing framework.."	"true"
"Unit Testing"	"CLUnit"	"https://github.com/tgutu/clunit"	"A unit testing library.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"15"	"3"	"4"	"GitHub - tgutu/clunit: CLUnit: A Common Lisp Unit Testing Framework. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 15 Fork 4 tgutu/clunit Code Issues 3 Pull requests 0 Pulse Graphs CLUnit: A Common Lisp Unit Testing Framework. http://tgutu.github.com/clunit 39 commits 3 branches 4 releases Fetching contributors Common Lisp 89.0% XML 11.0% Common Lisp XML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags develop gh-pages master Nothing to show 0.2.1 0.2.0 0.1.1 0.1.0 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. documentation/api src LICENSE README.md TODO changelog clunit.asd README.md CLUnit CLUnit is a Common Lisp unit testing framework. It is designed to be easy to use so that you can quickly start testing. CLUnit provides a rich set of features aimed at improving your unit testing experience: Multiple inheritance for test suites allows you to group tests into hierarchies. Composes the test results of each test run into a single report. Allows redefinition of inline functions and macros without having to redefine your tests. Supports composable test suite fixtures. Allows for an interactive testing process which gives you access to the test environment. Provides visual feeback of the unit test progress. Extensible test reporting. Builtin support for default reporting and TAP output. Check out the comprehensive CLUnit Tutorial. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/tgutu/clunit"	"A unit testing library.."	"true"
"Unit Testing"	"Lift"	"https://github.com/gwkkwg/lift"	"Another testing framework.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"19"	"3"	"6"	"GitHub - gwkkwg/lift: LIsp Framework for Testing Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 19 Fork 6 gwkkwg/lift Code Issues 0 Pull requests 1 Pulse Graphs LIsp Framework for Testing http://common-lisp.net/project/lift/ 557 commits 2 branches 0 releases Fetching contributors Common Lisp 97.2% CSS 2.7% Shell 0.1% Common Lisp CSS Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master merge Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. compare data dev docs examples make resources test timeout Update the newlinify macro to not externalize its environment Mar 2, 2013 website .boring .gitignore COPYING README.md RELNOTES lift-documentation.asd lift-standard.config lift-test.asd lift.asd README.md LIFT - the LIsp Framework for Testing Introduction The LIsp Framework for Testing (LIFT) is a unit and system test tool for LISP. Though inspired by [SUnit][] and [JUnit][], it's built with Lisp in mind. In LIFT, [testcases][] are organized into hierarchical [testsuites][] each of which can have its own [fixture][]. When run, a testcase can succeed, fail, or error. LIFT supports randomized testing, benchmarking, profiling, and reporting. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/gwkkwg/lift"	"Another testing framework.."	"true"
"Unit Testing"	"A range of licenses, all free"	"https://github.com/gwkkwg/lift/blob/master/COPYING"	"Another testing framework.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"19"	"3"	"6"	"lift/COPYING at master · gwkkwg/lift · GitHub Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 19 Fork 6 gwkkwg/lift Code Issues 0 Pull requests 1 Pulse Graphs Permalink Branch: master Switch branches/tags Branches Tags master merge Nothing to show Nothing to show Find file Copy path lift/COPYING Fetching contributors… Cannot retrieve contributors at this time Raw Blame History 83 lines (65 sloc) 3.97 KB Copyright (c) 2002-2010 Gary Warren King (gwking@metabang.com) Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Portions ;;; Copyright (c) 2004-2007, Dr. Edmund Weitz. All rights reserved. ;;; Redistribution and use in source and binary forms, with or without ;;; modification, are permitted provided that the following conditions ;;; are met: ;;; * Redistributions of source code must retain the above copyright ;;; notice, this list of conditions and the following disclaimer. ;;; * Redistributions in binary form must reproduce the above ;;; copyright notice, this list of conditions and the following ;;; disclaimer in the documentation and/or other materials ;;; provided with the distribution. ;;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR 'AS IS' AND ANY EXPRESSED ;;; OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ;;; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ;;; ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY ;;; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ;;; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE ;;; GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS ;;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, ;;; WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING ;;; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ;;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ;;; ----------------------------------------------------------------------- Copyright (c) 1994-2004 University of Massachusetts Department of Computer Science Experimental Knowledge Systems Laboratory Professor Paul Cohen, Director. All rights reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ""Software""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: EKSL makes no representation about the suitability of this software for any purposes. It is provided ""AS IS"", without express or implied warranties including (but not limited to) all implied warranties of merchantability and fitness for a particular purpose, and notwithstanding any other provision contained herein. In no event shall EKSL be liable for any special, indirect or consequential damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortuous action, arising out of or in connection with the use or performance of this software, even if EKSL is advised of the possibility of such damages. Thanks to Marc Atkin, Brendan Burns, Andrew Hannon, Anuan Gao, Brent Heeringa, Joshua Moody, Tim Oates, Michael O'Neil, Rob St. Amant, Charles Sutton, Louis Theran, David Westbrook, and other former students and staff of EKSL. Jump to Line Go Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/gwkkwg/lift/blob/master/COPYING"	"Another testing framework.."	"true"
"Unit Testing"	"Stefil"	"http://dwim.hu/project/hu.dwim.stefil?_x=BGZm&_f=SnpbobKv"	"A test framework that aims to be transparent. Public domain."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"A test framework that aims to be transparent. Public domain."	"false"
"Unit Testing"	"Prove"	"https://github.com/fukamachi/prove"	"Yet another unit testing framework."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"95"	"15"	"8"	"GitHub - fukamachi/prove: Yet another unit testing framework for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 15 Star 95 Fork 8 fukamachi/prove Code Issues 11 Pull requests 2 Pulse Graphs Yet another unit testing framework for Common Lisp 145 commits 5 branches 1 release 5 contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags fix-run-test-system gh-pages improve-subtest master v2.0.0 Nothing to show 1.0.0 Nothing to show New pull request Latest commit eb2cfff Jul 11, 2016 fukamachi Add an example to set up for SLIME. Permalink Failed to load latest commit information. images Replace screenshots. Sep 30, 2014 roswell Fix run-prove.ros. Jun 16, 2015 src Reset system test files before run-test-system. Nov 19, 2015 t Rename *report-style* -> *default-reporter*. And make prove:run allow… Sep 30, 2014 .gitignore supported Clozure CL Oct 31, 2010 README.markdown Add an example to set up for SLIME. Jul 11, 2016 cl-test-more.asd Rename to 'prove'. Sep 30, 2014 prove-asdf.asd Rename to 'prove'. Sep 30, 2014 prove.asd Enable colors on ABCL. Aug 19, 2015 README.markdown prove This project was originally called 'CL-TEST-MORE'. 'prove' is yet another unit testing framework for Common Lisp. The advantages of 'prove' are: Various simple functions for testing and informative error messages ASDF integration Extensible test reporters Colorizes the report if it's available (note for SLIME) Reports test durations Quickstart 1. Writing a test file (in-package :cl-user) (defpackage my-test   (:use :cl         :prove)) (in-package :my-test)  (plan 3)  (ok (not (find 4 '(1 2 3)))) (is 4 4) (isnt 1 #\1)  (finalize) 2. Run a test file (prove:run #P""myapp/tests/my-test.lisp"") (prove:run #P""myapp/tests/my-test.lisp"" :reporter :list) See also: ASDF integration, Reporters 3. Get a report Installation You can install 'prove' via Quicklisp. (ql:quickload :prove) Testing functions (ok test &optional desc) Checks if test is true (non-NIL). (ok 1) ;->  ✓ 1 is expected to be T (is got expected &rest test-args) Checks if got is equivalent to expected. (is 1 1) ;->  ✓ 1 is expected to be 1  (is #(1 2 3) #(1 2 3)) ;->  × #(1 2 3) is expected to be #(1 2 3)  (is #(1 2 3) #(1 2 3) :test #'equalp) ;->  ✓ #(1 2 3) is expected to be #(1 2 3)  ;; with description (is 1 #\1 ""Integer = Character ?"") ;->  × Integer = Character ? (isnt got expected &rest test-args) Checks if got is not equivalent to expected. (isnt 1 1) ;->  × 1 is not expected to be 1  (isnt #(1 2 3) #(1 2 3)) ;->  ✓ #(1 2 3) is not expected to be #(1 2 3) (is-values got expected &rest test-args) Checks if the multiple values of got is equivalent to expected. This is same to (is (multiple-value-list got) expected). (defvar *person* (make-hash-table))  (is-values (gethash :name *person*) '(""Eitaro"" T)) ;->  × (NIL NIL) is expected to be (""Eitaro"" T)  (setf (gethash :name *person*) ""Eitaro"")  (is-values (gethash :name *person*) '(""Eitaro"" T)) ;->  ✓ (""Eitaro"" T) is expected to be (""Eitaro"" T) (is-type got expected-type &optional desc) Checks if got is a type of expected-type. (is-type #(1 2 3) 'simple-vector) ;->  ✓ #(1 2 3) is expected to be a type of SIMPLE-VECTOR (got (SIMPLE-VECTOR 3))  (is-type (make-array 0 :adjustable t) 'simple-vector) ;->  × #() is expected to be a type of SIMPLE-VECTOR (got (VECTOR T 0)) (like got regex &optional desc) Checks if got matches a regular expression regex. (like ""Hatsune 39"" ""\\d"") ;->  ✓ ""Hatsune 39"" is expected to be like ""\\d""  (like ""初音ミク"" ""\\d"") ;->  × ""初音ミク"" is expected to be like ""\\d"" (is-print got expected &optional desc) Checks if got outputs expected to *standard-output* (is-print (princ ""Hi, there"") ""Hi, there"") ;->  ✓ (PRINC ""Hi, there"") is expected to output ""Hi, there"" (got ""Hi, there"") (is-error form condition &optional desc) Checks if form raises a condition and that is a subtype of condition. (is-error (error ""Something wrong"") 'simple-error) ;->  ✓ (ERROR ""Something wrong"") is expected to raise a condition SIMPLE-ERROR (got #<SIMPLE-ERROR ""Something wrong"" {100628FE53}>)  (define-condition my-error (simple-error) ())  (is-error (error ""Something wrong"") 'my-error) ;->  × (ERROR ""Something wrong"") is expected to raise a condition MY-ERROR (got #<SIMPLE-ERROR ""Something wrong"" {100648E553}>) (is-expand got expected &optional desc) Checks if got will be macroexpanded to expected. (is-expand (when T (princ ""Hi"")) (if T (progn (princ ""Hi"")))) ;->  ✓ (WHEN T (PRINC ""Hi"")) is expected to be expanded to (IF T ;                                                          (PROGN (PRINC ""Hi""))) (got (IF T ;                                                                                         (PROGN ;                                                                                          (PRINC ;                                                                                           ""Hi"")) ;                                                                                         NIL)) If a symbol that starts with ""$"" is contained, it will be treated as a gensym. (pass desc) This will always be passed. This is convenient if the test case is complicated and hard to test with ok. (pass ""Looks good"") ;->  ✓ Looks good (fail desc) This will always be failed. This is convenient if the test case is complicated and hard to test with ok. (fail ""Hopeless"") ;->  × Hopeless (skip how-many why) Skip a number of how-many tests and mark them passed. (skip 3 ""No need to test these on Mac OS X"") ;->  ✓ No need to test these on Mac OS X (Skipped) ;    ✓ No need to test these on Mac OS X (Skipped) ;    ✓ No need to test these on Mac OS X (Skipped) (subtest desc &body body) Run tests of body in a new sub test suite. (subtest ""Testing integers""   (is 1 1)   (is-type 1 'bit)   (is-type 10 'fixnum)) ;->      ✓ 1 is expected to be 1 ;        ✓ 1 is expected to be a type of BIT (got BIT) ;        ✓ 10 is expected to be a type of FIXNUM (got (INTEGER 0 4611686018427387903)) ;->  ✓ Testing integers Other functions (diag desc) Outputs desc to a *test-result-output*. (diag ""Gonna run tests"") ;-> # Gonna run tests (plan num) Declares a number of num tests are going to run. If finalize is called with no plan, a warning message will be output. num is allows to be NIL if you have no plan yet. (finalize) Finalizes the current test suite and outputs the test reports. (slow-threshold milliseconds) Set the threshold of slow test durations for the current test suite. The default threshold value is prove:*default-slow-threshold*. (slow-threshold 150) Reporters You can change the test report formats by setting prove:*default-reporter* to :list, :dot, :tap or :fiveam. The default value is :list. prove:run also takes a keyword argument :reporter. List (Default) The :list repoter outputs test results list as test cases pass or fail. Dot The :dot reporter outputs a series of dots that represent test cases, failures highlight in red, skipping in cyan. FiveAM The :fiveam reporter outputs test results like FiveAM does. TAP The :tap reporter outputs in Test Anything Protocol format. Tips Debugging with CL debugger Set prove:*debug-on-error* T for invoking CL debugger whenever getting an error during running tests. Colorize test reports on SLIME SLIME doesn't support to color with ANSI colors in the REPL buffer officially. You can add the feature by using slime-repl-ansi-color.el. After installing it, set prove:*enable-colors* to T before running tests. ;; A part of my ~/.sbclrc (ql:quickload :prove) (setf prove:*enable-colors* t) The following snippet is a little bit complicated, however it would be better if you don't like to load prove in all sessions. (defmethod asdf:perform :after ((op asdf:load-op) (c (eql (asdf:find-system :prove))))   (setf (symbol-value (intern (string :*enable-colors*) :prove)) t)) ASDF integration Add :defsystem-depends-on (:prove-asdf) to your testing ASDF system to enable :test-file in the :components. :test-file is same as :file except it will be loaded only when asdf:test-system. ;; Main ASDF system (defsystem my-app    ;; ...    :in-order-to ((test-op (test-op my-app-test))))  ;; Testing ASDF system (defsystem my-app-test   :depends-on (:my-app                :prove)   :defsystem-depends-on (:prove-asdf)   :components   ((:test-file ""my-app""))   :perform (test-op :after (op c)                     (funcall (intern #.(string :run) :prove) c))) To run tests, execute asdf:test-system or prove:run in your REPL. (asdf:test-system :my-app) (asdf:test-system :my-app-test)  ;; Same as 'asdf:test-system' except it returns T or NIL as the result of tests. (prove:run :my-app-test) Changing default test function Test functions like is uses prove:*default-test-function* for testing if no :test argument is specified. The default value is #'equal. Changing output stream Test reports will be output to prove:*test-result-output*. The default value is T, which means *standard-output*. Running tests on Travis CI Although Common Lisp isn't supported by Travis CI officially, you can run tests by using cl-travis. Here's a list of .travis.yml from projects using prove on Travis CI: Clack CL-DBI Woo fast-http defclass-std Bugs Please report any bugs to e.arrows@gmail.com, or post an issue to GitHub. License Copyright (c) 2010-2014 Eitaro Fukamachi <e.arrows@gmail.com> 'prove' and CL-TEST-MORE is freely distributable under the MIT License (http://www.opensource.org/licenses/mit-license). Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/prove"	"Yet another unit testing framework."	"true"
"Utilities"	"alexandria"	"https://common-lisp.net/project/alexandria/"	"A general-purpose utility library. Public domain."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Alexandria  Alexandria Alexandria is a project and a library. As a project Alexandria's goal is to reduce duplication of effort and improve portability of Common Lisp code according to its own idiosyncratic and rather conservative aesthetic. What this actually means is open to debate, but each project member has a veto on all project activities, so a degree of conservativism is inevitable. As a library Alexandria is one of the means by which the project strives for its goals. Alexandria is a collection of portable public domain utilities that meet the following constraints: Utilities, not extensions: Alexandria will not contain conceptual extensions to Common Lisp, instead limiting itself to tools and utilities that fit well within the framework of standard ANSI Common Lisp. Test-frameworks, system definitions, logging facilities, serialization layers, etc. are all outside the scope of Alexandria as a library, though well within the scope of Alexandria as a project. Conservative: Alexandria limits itself to what project members consider conservative utilities. Alexandria does not and will not include anaphoric constructs, loop-like binding macros, etc. Portable: Alexandria limits itself to portable parts of Common Lisp. Even apparently conservative and usefull functions remain outside the scope of Alexandria if they cannot be implemented portably. Portability is here defined as portable within a conforming implementation: implementation bugs are not considered portability issues. Team player: Alexandria will not (initially, at least) subsume or provide functionality for which good-quality special-purpose packages exist, like split-sequence. Instead, third party packages such as that may be ""blessed"". Initial release of the Alexandria library is yet to happen, but draft documention exists and current sources are available: git clone git://common-lisp.net/projects/alexandria/alexandria.git Note: As of 2010-03-09 the project switched from Darcs to Git. The old Darcs repo http://common-lisp.net/project/alexandria/darcs/alexandria is still available, but remains frozen. Discussions on Alexandria take place on alexandria-devel mailing list -- and also #lisp on irc.freenode.net. Automated commit messages for the Git repository are sent to the alexandria-cvs mailing list. (Yeah, -cvs, really. Historical reasons.) Current members of Alexandria are: Marco Baringer, Attila Lendvai, Nikodemus Siivola, and Robert Strandh. Valid XHTML 1.0 Strict"	"null"	"null"	"A general-purpose utility library. Public domain."	"true"
"Utilities"	"anaphora"	"https://common-lisp.net/project/anaphora/"	"A collection of anaphoric macros. Public domain."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"9"	"2"	"1"	"GitHub - tokenrove/anaphora: The anaphoric macro collection from Hell Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 9 Fork 1 tokenrove/anaphora Code Issues 3 Pull requests 0 Pulse Graphs The anaphoric macro collection from Hell https://common-lisp.net/project/anaphora/ 16 commits 3 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags add-travis-yml master public_html Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. .travis.yml LICENSE README.md anaphora.asd anaphora.lisp early.lisp packages.lisp symbolic.lisp tests.lisp README.md Anaphora Anaphora is the anaphoric macro collection from Hell: it includes many new fiends in addition to old friends like AIF and AWHEN. Anaphora has been placed in Public Domain by the author, Nikodemus Siivola. Installation Use quicklisp, and simply: CL-USER(1): (ql:quickload ""anaphora"")  Documentation Anaphoric macros provide implicit bindings for various operations. Extensive use of anaphoric macros is not good style, and probably makes you go blind as well — there's a reason why Anaphora claims to be from Hell. Anaphora provides two families of anaphoric macros, which can be identified by their names and packages (both families are also exported from the package ANAPHORA). The implicitly-bound symbol ANAPHORA:IT is also exported from all three packages. Basic anaphora Exported from package ANAPHORA-BASIC These bind their first argument to IT via LET. In case of COND all clauses have their test-values bound to IT. Variants: AAND, ALET, APROG1, AIF, ACOND, AWHEN, ACASE, ACCASE, AECASE, ATYPECASE, ACTYPECASE, and AETYPECASE. Symbol-macro anaphora Exported from package ANAPHORA-SYMBOL These bind their first argument (unevaluated) to IT via SYMBOL-MACROLET. Variants: SOR, SLET, SIF, SCOND, SUNLESS, SWHEN, SCASE, SCCASE, SECASE, STYPECASE, SCTYPECASE, SETYPECASE. Also: ASIF, which binds via LET for the then-clause, and SYMBOL-MACROLET for the else-clause. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/tokenrove/anaphora"	"A collection of anaphoric macros. Public domain."	"true"
"Utilities"	"babel"	"https://github.com/cl-babel/babel"	"A charset encoding/decoding library.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"40"	"9"	"13"	"GitHub - cl-babel/babel: Babel is a charset encoding/decoding library, not unlike GNU libiconv, written in pure Common Lisp. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 9 Star 40 Fork 13 cl-babel/babel Code Issues 7 Pull requests 5 Pulse Graphs Babel is a charset encoding/decoding library, not unlike GNU libiconv, written in pure Common Lisp. http://common-lisp.net/project/babel 160 commits 1 branch 2 releases Fetching contributors Common Lisp 99.8% Shell 0.2% Common Lisp Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v0.5.0 v0.4.0 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. doc scripts src tests .travis.yml COPYRIGHT HEADER NOTES README.md babel-streams.asd babel-tests.asd babel.asd README.md Babel is a charset encoding/decoding library, not unlike GNU libiconv, but completely written in Common Lisp. It strives to achieve decent performance. To that effect, we use OpenMCL's approach of calculating the destination buffer size in advance. Most of the encoding/decoding algorithms have been adapted from OpenMCL's source. Another important goal is reusability. Similarly to SBCL, we define an interface wherein the algorithms can be reused between a variety of data types so long we're dealing with conversions between octets and unicode code points. Babel comes with converters between strings and (unsigned-byte 8) vectors but can be easily extended to deal with, e.g., strings and foreign memory, vectors and Closure's runes, etc... Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/cl-babel/babel"	"A charset encoding/decoding library.."	"true"
"Utilities"	"chipz"	"https://github.com/froydnj/chipz"	"A decompression library.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"9"	"3"	"5"	"GitHub - froydnj/chipz: A Common Lisp library for decompressing deflate, zlib, gzip, and bzip2 data Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 9 Fork 5 froydnj/chipz Code Issues 2 Pull requests 0 Pulse Graphs A Common Lisp library for decompressing deflate, zlib, gzip, and bzip2 data http://method-combination.net/lisp/chipz/ 29 commits 2 branches 1 release Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags lispworks-less-consing master Nothing to show v0.8 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. doc .gitignore LICENSE NEWS TODO adler32.lisp bzip2.lisp chipz.asd conditions.lisp constants.lisp crc32.lisp decompress.lisp dstate.lisp gzip.lisp inflate-state.lisp inflate.lisp package.lisp stream-fallback.lisp stream.lisp tests.lisp types-and-tables.lisp zlib.lisp Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/froydnj/chipz"	"A decompression library.."	"true"
"Utilities"	"cl-2dsyntax"	"http://www.cliki.net/cl-2dsyntax"	"An indentation-sensitive reader system. Not available on Quicklisp. No license specified."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"CLiki: cl-2dsyntax CLiki - cl-2dsyntax cl-2dsyntax cl-2dsyntax is an indentation-sensitive syntax system like Python (the programming language, not the CMUCL/SBCL compiler) does. The homepage of project is http://lisp.hyperprostor.unas.cz/cl-2dsyntax/ and its mirror is http://lisp.hyperprostor.g6.cz/cl-2dsyntax/. Installation The installation is provided by my own Quicklisp's dist. (ql-dist:install-dist ""http://ql.hyperprostor.unas.cz/goheecus.txt"") (ql:quickload :cl-2dsyntax) Usage Enable the syntax by: (cl-2dsyntax:enable-syntax) Topics: language extension Current version History Backlinks Edit Create Home Recent Changes About Text Formatting Tools Search CLiki CLiki the common lisp wiki Account name Password register"	"null"	"null"	"An indentation-sensitive reader system. Not available on Quicklisp. No license specified."	"true"
"Utilities"	"optima"	"https://bitbucket.org/tarballs_are_good/cl-algebraic-data-type"	"Optimized pattern-matching library.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"tarballs_are_good / cl-algebraic-data-type   — Bitbucket  Bitbucket Features Pricing owner/repository English English 日本語 Sign up Log in cl-algebraic-data-type Actions Clone Compare Fork Navigation Overview Source Commits Branches Pull requests 4 Issues Wiki Downloads Settings HTTPS HTTPS SSH Need help cloning? Learn how to clone a repository. Clone in SourceTree Atlassian SourceTree is a free Git and Mercurial client for Windows. Atlassian SourceTree is a free Git and Mercurial client for Mac. Robert Smith cl-algebraic-data-type Overview Clone in SourceTree Clone in SourceTree Atlassian SourceTree is a free Git and Mercurial client for Windows. Atlassian SourceTree is a free Git and Mercurial client for Mac. HTTPS HTTPS SSH Last updated 2014-10-10 Language Common Lisp Access level Read 1 Branch 1 Tag 2 Forks 5 Watchers                         CL-ALGEBRAIC-DATA-TYPE                         ======================                                                       Robert Smith  CL-ALGEBRAIC-DATA-TYPE, or ADT, is a library for defining algebraic data types in a similar spirit to Haskell or Standard ML, as well as for operating on them.  We can define ADTs using DEFDATA:  (adt:defdata maybe   (just t)   nothing)  which will define a new type MAYBE, with a unary constructor JUST, and a nullary constructor (a simple symbol) NOTHING. The T represents the data type of that field.  > (just 5) (JUST 5) > nothing NOTHING  We can define our own version of a list via  (adt:defdata liszt   (kons t liszt)   knil)  which defines the binary constructor KONS and the nullary constructor KNIL.  > (kons 1 (kons 2 knil)) (KONS 1 (KONS 2 KNIL))  At the end we will define KAR and KDR.  For efficiency, we might specify the types more exactly. For a POINT type that supports rectangular and polar coordinates, which is also mutable, we might have:  (adt:defdata (point :mutable t)   (rectangular float float)   (polar float float))  The :MUTABLE keyword signifies that the data is mutable.  When we have constructed a value, we can extract data out of it using MATCH:  > (let ((pt (rectangular 1.0 2.0)))     (adt:match point pt       ((rectangular x y) (+ x y))       ((polar _ _) nil)))  => 3.0        If we did not include the POLAR case, we would get a warning.  > (let ((pt (rectangular 1.0 2.0)))     (adt:match point pt       ((rectangular x y) (+ x y)))) ; caught WARNING: ;   Non-exhaustive match. Missing cases: (POLAR) => 3.0  We can also specify a fall-through:  > (let ((pt (rectangular 1.0 2.0)))     (adt:match point pt       ((rectangular x y) (+ x y))       (_ nil)))  => 3.0  Since POINT is mutable, we can efficiently modify its fields using SET-DATA.  > (defun mirror-point! (pt)     (adt:with-data (rectangular x y) pt       (adt:set-data pt (rectangular y x))))  > (let ((pt (rectangular 1.0 2.0)))    (mirror-point! pt)    (adt:match point pt      ((rectangular x y) (format t ""point is (~A, ~A)"" x y))      (_ nil))  will print ""point is (2.0, 1.0)"".  See examples.txt for examples.   Frequently Asked Questions --------------------------  Q. How do we define KAR and KDR for LISZT?  A. Easy.  (defun kar (l)   (adt:match liszt l     ((kons a _) a)     (knil knil)))  (defun kdr (l)   (adt:match liszt l     ((kons _ b) b)     (knil knil)))   Q. Can we do parametric ADTs like I can in Haskell?  A. Not unless you want things to be inefficient.   Q. Why doesn't deeper pattern matching work?  A. It's not implemented, and it would be hard to implement.   Q. Can I get the constructors dynamically for a particular ADT?  A. Yes. You can get the constructors and associated arity by calling the GET-CONSTRUCTORS function, which will return a list of (constructor arity) pairs. For example, given the LISZT example above, we have  CL-USER> (adt:get-constructors 'liszt) ((KONS 2) (KNIL 0)) T  The T represents the fact that the ADT is known and exists. Unlimited private and public hosted repositories. Free for small teams! Sign up for free Close Recent activity Optima pattern match definitions? Issue #4 commented on in tarballs_are_good/cl-algebraic-data-type Brian Levy · Optima pattern match definitions? Issue #4 commented on in tarballs_are_good/cl-algebraic-data-type Brian Levy · Optima pattern match definitions? Issue #4 commented on in tarballs_are_good/cl-algebraic-data-type Brian Levy · Optima pattern match definitions? Issue #4 commented on in tarballs_are_good/cl-algebraic-data-type Robert Smith · Optima pattern match definitions? Issue #4 commented on in tarballs_are_good/cl-algebraic-data-type Robert Smith · Optima pattern match definitions? Issue #4 created in tarballs_are_good/cl-algebraic-data-type Brian Levy · Want union types... Issue #1 commented on in tarballs_are_good/cl-algebraic-data-type Robert Smith · 1 commit Pushed to tarballs_are_good/cl-algebraic-data-type 7c409a8 Fix examples.txt Robert Smith · 1 commit Pushed to tarballs_are_good/cl-algebraic-data-type 7c4eb49 Add ALGEBRAIC-DATA-VALUE-P to test if something is from an ADT. Robert Smith · 1 commit Pushed to tarballs_are_good/cl-algebraic-data-type 8b764df State data type being compared against in non-exhuastive warning. Robert Smith · Redefinition of symbols is silent, even across types Issue #3 created in tarballs_are_good/cl-algebraic-data-type Robert Smith · Blog Support Plans & pricing Documentation API Site status Version info Terms of service Privacy policy English Git 2.7.4.1.g5468f9e Mercurial 3.6.3 Django 1.7.11 Python 2.7.3 b7520e3d05e9 / b7520e3d05e9 @ app-104 JIRA Software Confluence Bamboo SourceTree HipChat Atlassian Help Online help Learn Git Keyboard shortcuts Latest features Bitbucket tutorials Site status Support"	"null"	"null"	"Optimized pattern-matching library.."	"true"
"Utilities"	"cl-annot"	"https://github.com/m2ym/cl-annot"	"Python-like annotations for Common Lisp.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"77"	"12"	"4"	"GitHub - m2ym/cl-annot: Python-like Annotation Syntax for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 12 Star 77 Fork 4 m2ym/cl-annot Code Issues 12 Pull requests 0 Pulse Graphs Python-like Annotation Syntax for Common Lisp 60 commits 2 branches 0 releases Fetching contributors Common Lisp 95.5% Emacs Lisp 4.5% Common Lisp Emacs Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags defstruct-long-form master Nothing to show Nothing to show New pull request Latest commit c99e69c Jun 6, 2015 fukamachi Merge pull request #22 from fukamachi/in-package-cl-user … Add '(in-package :cl-user)' at the top of CL files Permalink Failed to load latest commit information. misc Add file header for ELPA compatibility Dec 30, 2013 src Add '(in-package :cl-user)' at the top of CL files. Jun 6, 2015 t Added `plan' to a test file. Sep 3, 2013 .gitignore Forget to commit. Apr 1, 2011 README.markdown Remove needless spaces. Sep 3, 2013 cl-annot-test.asd Added class annotations and fixed slot annotations. Apr 1, 2011 cl-annot.asd added :description. Dec 2, 2011 README.markdown cl-annot cl-annot is an general annotation library for Common Lisp. cl-annot is tested under the following implementations: Allegro CL v8.2 SBCL v1.0.45 CMU CL v20b Clozure CL v1.6 ECL v11.1.1 GNU CLISP v2.48 Overview Annotations is a special syntax for annotating and transforming forms. Annotations look like Python's decorator: @annot (defun foobar ()   ...)  Any functions and macros can be annotations which takes one argument by default. For example, if you define the following function, (defun trace (object)   (print object)   object)  you can use the function as an annotation like: @trace (+ 1 2)  This expression prints 3 and returns 3. Internally, this expression will be regarded as (trace (+ 1 2)). Standard annotation export exports the symbol of the given definition. For example, @export (defun foobar ()   ...)  defines a function foobar and exports the symbol foobar. This equivalents to: (progn   (export 'foobar)   (defun foobar ()     ...))  Annotations help you to write the simple and declarative codes. Usage Just write the following code at the header of each files: (annot:enable-annot-syntax)  After this code, @... syntax can be used. Emacs Configuration If you use Emacs, it is recommended to install misc/slime-annot.el which contains some features of annotations. After locating misc/slime-annot.el into your loadpath, write the following code into your .emacs. (require 'slime-annot)  Standard Annotations Package: annot.std This package contains very basic and useful annotations. You don't need to use-package this package. Annotation: export @export DEFINITION-FORM  export is a macro which adds an export form of the definition form. For example, @export (defun f () ...)  is equivalent to (progn   (export 'f)   (defun f () ...))  Annotation: ignore @ignore VARIABLES  ignore is a macro which is equivalent to (declare (ignore ...)) form. For example, @ignore v  is equivalent to (declare (ignore v))  ignore can take a list of variables like: @ignore (a b c)  Annotation: ignorable @ignorable VARIABLES  Same as ignore annotation except that this is equivalent to (declare (ignorable v))  Annotation: type @type TYPESPEC NAME  type is a macro which is equivalent to (declare (type ...)) form. For example, @type integer v  is equivalent to (declare (type integer v))  Annotation: optimize @optimize QUALITY  optimize is a macro which is equivalent to (declare (optimize ...)) form. For example, @optimize (speed 3)  is equivalent to (declare (optimize (speed 3)))  Annotation: inline @inline NAME  inline is a macro which is equivalent to (proclaim (inline ...)) or (declare (inline ...)) form. If NAME is just a symbol, declaration will be used. If NAME is a definition form, proclamation will be used. For example, @inline f  is equivalent to (declare (inline f))  And @inline (defun f () ...)  is equivalent to (proclam (inline f)) (defun f () ...)  Package: annot.eval-when This package contains annotations eval-when special form. Annotation: eval-when-compile @eval-when-compile FORM  eval-when-compile is a macro which is equivalent to (eval-when (:compile-toplevel) ...). For example, @eval-when-compile (defun macro-util () ...)  is equivalent to (eval-when-compile (:compile-toplevel)   (defun macro-util () ...))  Annotation: eval-when-load @eval-when-load FORM  Same as eval-when-compile except that this is equivalent to (eval-when (:load-toplevel) ...). Annotation: eval-when-execute @eval-when-execute FORM  Same as eval-when-compile except that this is equivalent to (eval-when (:execute) ...). Annotation: eval-always @eval-always FORM  eval-always is a macro which is equivalent to (eval-when (:compile-toplevel :load-toplevel :execute) ...). Package: annot.doc This package contains documentation annotations. Annotation: doc @doc DOCSTRING DEFINITION-FORM  doc is a macro which inserts documentation string into the definition form. For example, @doc ""docstring"" (defun f () ...)  is equivalent to (defun f ()   ""docstring""   ...)  Mixture of export annotation and doc annotation is allowed, means @export @doc ""docstring"" (defun f () ...)  works as you expected. Package: annot.class This package contains annotations about classes. Annotation: metaclass @metaclass METACLASS CLASS-DEFINITION-FORM  metaclass embeds (:metaclsas METACLASS) into class-options of CLASS-DEFINITION-FORM. For example, @metaclass persistent-class (defclass foo ()      ())  is equivalent to (defclass foo ()      ()   (:metaclass persistent-class))  Annotation: export-slots @export-slots CLASS-DEFINITION-FORM  export-slots adds (export ...) form for slots of CLASS-DEFINITION-FORM. For example, @export-slots (defclass foo ()      (bar baz))  is equivalent to (progn   (export '(bar baz))   (defclass foo ()      (bar baz)))  It can also be used with defstruct as of the commit 9043a74815a028a7db664f2fd77a8b009c736df9 (8/31,2013). Annotation: export-accessors @export-accessors CLASS-DEFINITION-FORM  export-accessors adds (export ...) form for accessors (i.e. readers, writers and accessors) of CLASS-DEFINITION-FORM. For example, @export-accessors (defclass foo ()      ((bar :reader bar-of)       (bax :writer bax-of)       (baz :accessor baz-of)))  is equivalent to (progn   (export '(bar-of bax-of baz-of))   (defclass foo ()      ((bar :reader bar-of)       (bax :writer bax-of)       (baz :accessor baz-of))))  It can also be used with defstruct as of the commit 9043a74815a028a7db664f2fd77a8b009c736df9 (8/31,2013). Annotation: export-constructors It can be used as of the commit 9043a74815a028a7db664f2fd77a8b009c736df9 (8/31,2013). According to the {CLHS: Macro DEFSTRUCT}[http://www.lispworks.com/documentation/HyperSpec/Body/m_defstr.htm], defstruct can define more than one constructor, for example: @export-constructors (defstruct (s (:constructor abya a c)               (:constructor abya2 a b c))   a b c)  is equivalent to (progn   (export '(abya abya2))   (defstruct (s (:constructor abya a c)                 (:constructor abya2 a b c)) a b c))  and it might have no constructor like this. (defstruct (s (:constructor nil)) a b c)  Annotation: export-class and export-structure export-class combines export, export-slots and export-accessors. export-structure also combines export-constructors in addition. Package: annot.slot This package contains annotations about slots. Annotation: optional @optional INITFORM SLOT-SPECIFIER  optional embeds :initarg SLOT-NAME and :initform INITFORM into SLOT-SPECIFIER. For example, (defclass c ()      (@optional nil       foo))  is equivalent to (defclass c ()      ((foo :initarg :foo            :initform nil)))  Annotation: required @required SLOT-SPECIFIER  required embeds :initarg SLOT-NAME and :initform (annot.slot:required-argument SLOT-NAME) into SLOT-SPECIFIER so that MAKE-INSTANCE will raise errors when no argument for the slot given. For example, (defclass c ()      (@required       foo))  is equivalent to (defclass c ()      ((foo :initarg :foo            :initform (annot.slot:required-argument :foo))))  Writing Annotations As I mentioned, any functions and macros can be annotations. Basically, if you have a function or a macro named annot, the following code @annot (+ 1 2)  will be expanded like (annot (+ 1 2))  Aliasing You may use an alias for specifying annotations. This is useful when you want to use more general names as annotation names. Actually, annot.std uses this technique to overriding the meanings of symbols in common-lisp package. Here is how to alias: (setf (annotation-real 'do) 'long-long-name)  Now you can use do as meaning long-long-name at annotations like: @do ...  Multiple Arguments By default, annotations can take only one argument. If you want to write an annotation taking two or more arguments, you need to specify a number of arguments into the annotation symbol like: (use-package :annot.core)  (defun my-annot (x y) (+ x y)) (setf (annotation-arity 'my-annot) 2)  Now you can use this annotation like: @my-annot 2 3 ;; => 5  Inlining In some cases, you want annotations to be expanded at read-time. You can do it by: (setf (annotation-inline-p 'annot) t)  Be caseful to use feature. Macro: defannotation defannotation NAME LAMBDA-LIST (:alias ALIAS :arity ARITY :inline INLINE) &body BODY  defannotation is an utility macro for creating annotations. Here is an example: (defannotation my-annot (x y)     (:arity 2 :inline t)   `(+ ,x ,y))  Annotation: annotation annotation (:alias ALIAS :arity ARITY :inline INLINE) FUNCTION-DEFINITION-FORM  annotation is an annotation for creating annotations in a way of defannotation. Here is an example: @annotation (:arity 2 :inline t) (defmacro my-annot (x y)   `(+ ,x ,y))  Copyright (C) 2011 Tomohiro Matsuyama <tomo@cx4a.org> Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/m2ym/cl-annot"	"Python-like annotations for Common Lisp.."	"true"
"Utilities"	"cl-csv"	"https://github.com/AccelerationNet/cl-csv"	"A library for parsing CSV files.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"42"	"10"	"10"	"GitHub - AccelerationNet/cl-csv: A common lisp library providing easy csv reading and writing Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 10 Star 42 Fork 10 AccelerationNet/cl-csv Code Issues 1 Pull requests 0 Pulse Graphs A common lisp library providing easy csv reading and writing 119 commits 4 branches 0 releases Fetching contributors Common Lisp 99.1% NewLisp 0.9% Common Lisp NewLisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master read-csv-row-performance-testing read-into-buffer-until read-until Nothing to show Nothing to show New pull request Latest commit c68e0d0 May 26, 2015 bobbysmith007 Documentation / ASD updates Permalink Failed to load latest commit information. tests .gitignore DOCUMENTATION.md LICENSE README.md cl-csv-clsql.asd Documentation / ASD updates May 26, 2015 cl-csv-data-table.asd cl-csv.asd clsql.lisp csv.lisp data-table.lisp packages.lisp Replaced read-line with a read-until implementation to allow arbitrary Jan 15, 2014 read-until.lisp simplified read-until stuff so there was less index passing and flags Feb 4, 2014 vars.lisp README.md cl-csv This library aims to simplify working with csvs to the bare minimum of tedium reads/writes csvs from/to strings, streams and files support streaming reads (allowing processing very large csvs, through read-csv's row-fn paramter) supports custom data formating settable quote, separator and quote-escapes supports multiline quoted data A test suite Rationale I had many scattered, not well tested, not easily runable pieces of csv code. I was unhappy with this situation then decided to refactor all of this into a single location. I wrote tests for it and had a library so I thought I might release it. This project started as extensions and bugfixes on arnesi's CSV. I then looked around and saw there are other csv libs out there that probably mostly accomplished what I had set out to do. However, I already had code that was tested and had an easier license (BSD) so, I figured why not just release it anyway. Other Available CSV libs http://members.optusnet.com.au/apicard/csv-parser.lisp http://www.cliki.net/fare-csv Escaping and quotes There are two modes for escaping currently :quote - by default cl-csv treats """" as an escape for a single double-quote :following - read the character after the escape sequence verbatim, commonly the *quote-escape* will be set to #\\ when the escape mode is following. Signals and Restarts *enable-signals* will cause a csv-data-read or csv-row-read to be signaled for each piece of data and row read. There is a filter restart available which will cause the filter value to be used instead. Enabling signals is ~2xs as slow as not, so by default they are not enabled. in-csv iterate clause and read-csv support continue and filter restarts for errors occuring during read-csv-row Library Integration data-table - functions for building data-tables from csv's, must (asdf:load-system :cl-csv-data-table) clsql must (asdf:load-system :cl-csv-clsql) import-from-csv serial-import-from-csv iterate - provides an in-csv driver clause for iterating over a CSV Examples ;; read a file into a list of lists (cl-csv:read-csv #P""file.csv"") => ((""1"" ""2"" ""3"") (""4"" ""5"" ""6""))  ;; read a file that's tab delimited (cl-csv:read-csv #P""file.tab"" :separator #\Tab)  ;; read a file and return a list of objects created from each row (cl-csv:read-csv #P""file.csv""                  :map-fn #'(lambda (row)                              (make-instance 'object                                             :foo (nth 0 row)                                             :baz (nth 2 row)))) ;; read csv from a string (streams also supported) (cl-csv:read-csv ""1,2,3 4,5,6"") => ((""1"" ""2"" ""3"") (""4"" ""5"" ""6""))  ;; loop over a CSV for effect (let ((sum 0))   (cl-csv:do-csv (row #P""file.csv"")     (incf sum (parse-integer (nth 0 row))))   sum)   ;; loop over a CSV using iterate (iter (for (foo bar baz) in-csv #P""file.csv"")   (collect (make-instance 'object :foo foo :baz baz))) Authors Acceleration.net Russ Tyndall Nathan Bird Ryan Davis ;; Copyright (c) 2011 Russ Tyndall , Acceleration.net http://www.acceleration.net ;; Copyright (c) 2002-2006, Edward Marco Baringer ;; All rights reserved. ;; ;; Redistribution and use in source and binary forms, with or without ;; modification, are permitted provided that the following conditions are ;; met: ;; ;;  - Redistributions of source code must retain the above copyright ;;    notice, this list of conditions and the following disclaimer. ;; ;;  - Redistributions in binary form must reproduce the above copyright ;;    notice, this list of conditions and the following disclaimer in the ;;    documentation and/or other materials provided with the distribution. ;; ;;  - Neither the name of Edward Marco Baringer, nor BESE, nor the names ;;    of its contributors may be used to endorse or promote products ;;    derived from this software without specific prior written permission. ;; ;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ;; ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT ;; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR ;; A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT ;; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, ;; SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT ;; LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ;; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/AccelerationNet/cl-csv"	"A library for parsing CSV files.."	"true"
"Utilities"	"cl-cuda"	"https://github.com/takagi/cl-cuda"	"A library to use NVIDIA CUDA in Common Lisp programs.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"90"	"19"	"11"	"GitHub - takagi/cl-cuda: Cl-cuda is a library to use NVIDIA CUDA in Common Lisp programs. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 19 Star 90 Fork 11 takagi/cl-cuda Code Issues 17 Pull requests 0 Pulse Graphs Cl-cuda is a library to use NVIDIA CUDA in Common Lisp programs. 579 commits 16 branches 0 releases 2 contributors Common Lisp 94.5% C 5.5% Common Lisp C Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags issue/39 issue/41 issue/44 issue/46 issue/48 issue/49.constant-memory issue/49.symbol-macro issue/49 issue/51 issue/53 issue/54 issue/58 issue/60 issue/61 master revert-sdk-not-found Nothing to show Nothing to show New pull request Latest commit 8352cb6 Jun 27, 2016 takagi Fix test for compound literals. Permalink Failed to load latest commit information. examples Add SPH example of CPU version. Mar 27, 2016 include Use compound literal to make instances of vector types, now possible … Mar 11, 2016 interop modify to make cl-cuda finish compiled without any conditions when CU… Dec 27, 2014 misc refactor to divide into sub-packages without changing interface May 28, 2014 src Get kernel entries in their defined order. Mar 13, 2016 t Fix test for compound literals. Jun 27, 2016 .gitignore Ignore *~ Nov 21, 2015 LICENSE Add LICENSE file Nov 21, 2015 README.markdown Write working around on loading CFFI-GROVEL on README. Mar 31, 2016 cl-cuda-examples.asd Add SPH example of CPU version. Mar 27, 2016 cl-cuda-interop-examples.asd modify to make another ASDF system for OpenGL interoperability Jun 17, 2014 cl-cuda-interop-test.asd modify to refactor test for OpenGL interoperability Jun 24, 2014 cl-cuda-interop.asd Add library descriptions to .asd files Jan 3, 2015 cl-cuda-misc.asd modify to use cl-emb to generate cl-cuda-error-string.lisp Nov 23, 2012 cl-cuda-test.asd modify to rename compile-type-of.lisp to type-of-expression.lisp Jun 16, 2014 cl-cuda.asd Load CFFI-GROVEL in CL-USER package. Mar 31, 2016 README.markdown Cl-Cuda Cl-cuda is a library to use NVIDIA CUDA in Common Lisp programs. It provides not only FFI binding to CUDA driver API but the kernel description language with which users can define CUDA kernel functions in S-expression. The kernel description language also provides facilities to define kernel macros and kernel symbol macros in addition to kernel functions. Cl-cuda's kernel macro and kernel symbol macro offer powerful abstraction that CUDA C itself does not have and provide enormous advantage in resource-limited GPU programming. Kernel functions defined with the kernel description language can be launched as almost same as ordinal Common Lisp functions except that they must be launched in a CUDA context and followed with grid and block sizes. Kernel functions are compiled and loaded automatically and lazily when they are to be launched for the first time. This process is as following. First, they are compiled into a CUDA C code (.cu file) by cl-cuda. The compiled CUDA C code, then, is compiled into a CUDA kernel module (.ptx file) by NVCC - NVIDIA CUDA Compiler Driver. The obtained kernel module is automatically loaded via CUDA driver API and finally the kernel functions are launched with properly constructed arguments to be passed to CUDA device. Since this process is autonomously managed by the kernel manager, users do not need to handle it for themselves. About the kernel manager, see Kernel manager section. Memory management is also one of the most important things in GPU programming. Cl-cuda provides memory block data structure which abstract host memory and device memory. With memory block, users do not need to manage host memory and device memory individually for themselves. It lightens their burden on memory management, prevents bugs and keeps code simple. Besides memory block that provides high level abstraction on host and device memory, cl-cuda also offers low level interfaces to handle CFFI pointers and CUDA device pointers directly. With these primitive interfaces, users can choose to gain more flexible memory control than using memory block if needed. Cl-cuda is verified on several environments. For detail, see Verification environments section. Example Following code is a part of vector addition example using cl-cuda based on CUDA SDK's ""vectorAdd"" sample. You can define vec-add-kernel kernel function using defkernel macro. In the definition, aref is to refer values stored in an array. set is to store values into an array. block-dim-x, block-idx-x and thread-idx-x have their counterparts in CUDA C's built-in variables and are used to specify the array index to be operated in each CUDA thread. Once the kernel function is defined, you can launch it as if it is an ordinal Common Lisp function except that it requires to be in a CUDA context and followed by :gird-dim and :block-dim keyword parameters which specify the dimensions of grid and block. To keep a CUDA context, you can use with-cuda macro which has responsibility on initializing CUDA and managing a CUDA context. with-memory-blocks manages memory blocks which abstract host memory area and device memory area, then sync-memory-block copies data stored in a memory block between host and device. For the whole code, please see examples/vector-add.lisp. (defkernel vec-add-kernel (void ((a float*) (b float*) (c float*) (n int)))   (let ((i (+ (* block-dim-x block-idx-x) thread-idx-x)))     (if (< i n)         (set (aref c i)              (+ (aref a i) (aref b i))))))  (defun main ()   (let* ((dev-id 0)          (n 1024)          (threads-per-block 256)          (blocks-per-grid (/ n threads-per-block)))     (with-cuda (dev-id)       (with-memory-blocks ((a 'float n)                            (b 'float n)                            (c 'float n))         (random-init a n)         (random-init b n)         (sync-memory-block a :host-to-device)         (sync-memory-block b :host-to-device)         (vec-add-kernel a b c n                         :grid-dim  (list blocks-per-grid 1 1)                         :block-dim (list threads-per-block 1 1))         (sync-memory-block c :device-to-host)         (verify-result a b c n)))))  Installation Since cl-cuda is not available in Quicklisp distribution because of its testing policy (see #514 in quicklisp-projects), please use its local-projects feature. $ cd ~/quicklisp/local-projects $ git clone git://github.com/takagi/cl-cuda.git  Then (ql:quickload :cl-cuda) from REPL to load it. You may encounter the following error, please install CFFI explicitly (ql:quickload :cffi) before loading cl-cuda. Just once is enough. Component CFFI-GROVEL not found    [Condition of type ASDF/FIND-SYSTEM:MISSING-COMPONENT]  Requirements Cl-cuda requires following: NVIDIA CUDA-enabled GPU CUDA Toolkit, CUDA Drivers and CUDA SDK need to be installed Verification environments Cl-cuda is verified to work in following environments: Environment 1 Mac OS X 10.6.8 (MacBookPro) GeForce 9400M CUDA 4 SBCL 1.0.55 32-bit All tests pass, all examples work Environment2 Amazon Linux x86_64 (Amazon EC2) Tesla M2050 CUDA 4 SBCL 1.1.7 64-bit All tests pass, all examples which are verified work (others not tried yet) (setf *nvcc-options* (list ""-arch=sm_20"" ""-m32"")) needed Environment3 (Thanks to Viktor Cerovski) Linux 3.5.0-32-generic Ubuntu SMP x86_64 GeFroce 9800 GT CUDA 5 SBCL 1.1.7 64-bit All tests pass, all examples work Environment4 (Thanks to wvxvw) Fedra18 x86_64 GeForce GTX 560M CUDA 5.5 SBCL 1.1.2-1.fc18 vector-add example works (didn't try the rest yet) Further information: (setf *nvcc-options* (list ""-arch=sm_20"" ""-m32"")) needed using video drivers from rpmfusion instead of the ones in cuda package see issue #1 Environment5 (Thanks to Atabey Kaygun) Linux 3.11-2-686-pae SMP Debian 3.11.8-1 (2013-11-13) i686 GNU/Linux NVIDIA Corporation GK106 GeForce GTX 660 CUDA 5.5 SBCL 1.1.12 All tests pass, all examples work API Here explain some APIs commonly used. [Macro] with-cuda WITH-CUDA (dev-id) &body body  Initializes CUDA and keeps a CUDA context during body. dev-id are passed to get-cuda-device function and the device handler returned is passed to create-cuda-context function to create a CUDA context in the expanded form. The results of get-cuda-device and create-cuda-context functions are bound to *cuda-device* and *cuda-context* special variables respectively. The kernel manager unloads before with-cuda exits. [Function] synchronize-context SYNCHRONIZE-CONTEXT  Blocks until a CUDA context has completed all preceding requested tasks. [Function] alloc-memory-block ALLOC-MEMORY-BLOCK type size  Allocates a memory block to hold size elements of type type and returns it. Actually, linear memory areas are allocated on both host and device memory and a memory block holds pointers to them. [Function] free-memory-block FREE-MEMORY-BLOCK memory-block  Frees memory-block previously allocated by alloc-memory-block. Freeing a memory block twice should cause an error. [Macro] with-memory-block, with-memory-blocks WITH-MEMORY-BLOCK (var type size) &body body WITH-MEMORY-BLOCKS ({(var type size)}*) &body body  Binds var to a memory block allocated using alloc-memory-block applied to the given type and size during body. The memory block is freed using free-memory-block when with-memory-block exits. with-memory-blocks is a plural form of with-memory-block. [Function] sync-memory-block SYNC-MEMORY-BLOCK memory-block direction  Copies stored data between host memory and device memory for memory-block. direction is either :host-to-device or :device-to-host which specifies the direction of copying. [Accessor] memory-block-aref MEMORY-BLOCK-AREF memory-block index  Accesses memory-block's element specified by index. Note that the accessed memory area is that on host memory. Use sync-memory-block to synchronize stored data between host memory and device memory. [Macro] defglobal DEFGLOBAL name type &optional expression qualifiers  Defines a global variable. name is a symbol which is the name of the variable. type is the type of the variable. Optional expression is an expression which initializes the variable. Optional qualifiers is one of or a list of keywords: :device, :constant, :shared, :managed and :restrict, which are corresponding to CUDA C's __device__, __constant__, __shared__, __managed__ and __restrict__ variable qualifiers. If not given, :device is used. (defglobal pi float 3.14159 :constant)  [Accessor] global-ref Accesses a global variable's value on device from host with automatically copying its value from/to device. (defglobal x :device int 0) (global-ref x)                 ; => 0 (setf (global-ref x) 42) (global-ref x)                 ; => 42  [Special Variable] *tmp-path* Specifies the temporary directory in which cl-cuda generates files such as .cu file and .ptx file. The default is ""/tmp/"". (setf *tmp-path* ""/path/to/tmp/"")  [Special Variable] *nvcc-options* Specifies additional command line options passed to nvcc command that cl-cuda calls internally. The default is nil. If -arch=sm_XX option is not specified here, it is automatically inserted with cuDeviceComputeCapability driver API. (setf *nvcc-options* (list ""-arch=sm_20"" ""-m32""))  [Special Variable] *nvcc-binary* Specifies the path to nvcc command so that cl-cuda can call internally. The default is just nvcc. (setf *nvcc-binary* ""/path/to/nvcc"")  [Special Variable] *show-messages* Specifies whether to let cl-cuda show operational messages or not. The default is t. (setf *show-messages* nil)  [Special Variable] *sdk-not-found* Readonly. The value is t if cl-cuda could not find CUDA SDK or at least it failed to load libcuda for some reason, otherwise nil. *sdk-not-found*    ; => nil  Kernel Description Language Types not documented yet. IF statement IF test-form then-form [else-form]  if allows the execution of a form to be dependent on a single test-form. First test-form is evaluated. If the result is true, then then-form is selected; otherwise else-form is selected. Whichever form is selected is then evaluated. If else-form is not provided, does nothing when else-form is selected. Example: (if (= a 0)     (return 0)     (return 1))  Compiled: if (a == 0) {   return 0; } else {   return 1; }  LET statement LET ({(var init-form)}*) statement*  let declares new variable bindings and set corresponding init-forms to them and execute a series of statements that use these bindings. let performs the bindings in parallel. For sequentially, use let* kernel macro instead. Example: (let ((i 0))   (return i))  Compiled: {   int i = 0;   return i; }  SYMBOL-MACROLET statement SYMBOL-MACROLET ({(symbol expansion)}*) statement*  symbol-macrolet establishes symbol expansion rules in the variable environment and execute a series of statements that use these rules. In cl-cuda's compilation process, the symbol macros found in a form are replaces by corresponding expansions. Example: (symbol-macrolet ((x 1.0))   (return x))  Compiled: {   return 1.0; }  DO statement DO ({(var init-form step-form)}*) (test-form) statement*  do iterates over a group of statements while test-form holds. do accepts an arbitrary number of iteration vars and their initial values are supplied by init-forms. step-forms supply how the vars should be updated on succeeding iterations through the loop. Example: (do ((a 0 (+ a 1))      (b 0 (+ b 1)))     ((> a 15))   (do-some-statement))  Compiled: for ( int a = 0, int b = 0; ! (a > 15); a = a + 1, b = b + 1 ) {   do_some_statement(); }  WITH-SHARED-MEMORY statement WITH-SHARED-MEMORY ({(var type size*)}*) statement*  with-shared-memory declares new variable bindings on shared memory by adding __shared__ variable specifiers. It allows to declare array variables if dimensions are provided. A series of statements are executed with these bindings. Example: (with-shared-memory ((a int 16)                      (b float 16 16))   (return))  Compiled: {   __shared__ int a[16];   __shared__ float b[16][16];   return; }  SET statement SET reference expression  set provides simple variable assignment. It accepts one of variable, structure and array references as reference. Example: (set x 1.0) (set (float4-x y 1.0) (set (aref z 0) 1.0)  Compiled: x = 1.0; y.x = 1.0; z[0] = 1.0;  PROGN statement PROGN statement*  progn evaluates statements, in the order in which they are given. Example: (progn   (do-some-statements)   (do-more-statements))  Compiled: do_some_statements(); do_more_statements();  RETURN statement RETURN [return-form]  return returns control, with return-form if supplied, from a kernel function. Example: (return 0)  Compiled: return 0;  Architecture The following figure illustrates cl-cuda's overall architecture.                    +---------------------------------+-----------+-----------+                    | defkernel                       | memory    | context   |        cl-cuda.api +---------------------------------+           |           |                    | kernel-manager                  |           |           |                    +---------------------------------+-----------+-----------+                    +----------------------------+----------------------------+       cl-cuda.lang | Kernel description lang.   | the Compiler               |                    +----------------------------+----------------------------+                    +---------------------------------------------------------+ cl-cuda.driver-api | driver-api                                              |                    +---------------------------------------------------------+                    +---------------------------------------------------------+               CUDA | CUDA driver API                                         |                    +---------------------------------------------------------+  Cl-cuda consists of three subpackages: api, lang and driver-api. driver-api subpackage is a FFI binding to CUDA driver API. api subpackage invokes CUDA driver API via this binding internally. lang subpackage provides the kernel description language. It provides the language's syntax, type, built-in functions and the compiler to CUDA C. api subpackage calls this compiler. api subpackage provides API for cl-cuda users. It further consists of context, memory, kernel-manager and defkernel subpackages. context subpackage has responsibility on initializing CUDA and managing CUDA contexts. memory subpackage offers memory management, providing high level API for memory block data structure and low level API for handling host memory and device memory directly. kernel-manager subpackage manages the entire process from compiling the kernel description language to loading/unloading obtained kernel module autonomously. Since it is wrapped by defkernel subpackage which provides the interface to define kernel functions, cl-cuda's users usually do not need to use it for themselves. Kernel manager The kernel manager is a module which manages defining kernel functions, compiling them into a CUDA kernel module, loading it and unloading it. I show you its work as a finite state machine here. To begin with, the kernel manager has four states. I   initial state II  compiled state III module-loaded state IV  function-loaded state  The initial state is its entry point. The compiled state is a state where kernel functions defined with the kernel descrpition language have been compiled into a CUDA kernel module (.ptx file). The obtained kernel module has been loaded in the module-loaded state. In the function-loaded state, each kernel function in the kernel module has been loaded. Following illustrates the kernel manager's state transfer. 　    compile-module        load-module            load-function 　  =================>    =================>     =================> 　I                    II                    III                    IV 　  <=================    <================= 　    define-function     <======================================== 　    define-macro          unload 　    define-symbol-macro       define-global  kernel-manager-compile-module function compiles defined kernel functions into a CUDA kernel module. kernel-manager-load-module function loads the obtained kernel module. kernel-manager-load-function function loads each kernel function in the kernel module. In the module-loaded state and function-loaded state, kernel-manager-unload function unloads the kernel module and turn the kernel manager's state back to the compiled state. kernel-manager-define-function, kernel-manager-define-macro, kernel-manager-define-symbol-macro and kernel-manager-define-global functions, which are wrapped as defkernel, defkernelmacro, defkernel-symbol-macro and defglobal macros respectively, change its state back into the initial state and make it require compilation again. The kernel manager is stored in *kernel-manager* special variable when cl-cuda is loaded and keeps alive during the Common Lisp process. Usually, you do not need to manage it explicitly. How cl-cuda works when CUDA SDK is not installed This section is for cl-cuda users who develop an application or a library which has alternative sub system other than cl-cuda and may run on environments CUDA SDK is not installed. Compile and load time Cl-cuda is compiled and loaded without causing any conditions on environments CUDA SDK is not installed. Since cl-cuda API 's symbols are interned, user programs can use them normally. Run time At the time cl-cuda's API is called, an error that tells CUDA SDK is not found should occur. With *sdk-not-found* special variable, user programs can get if cl-cuda has found CUDA SDK or not. How cl-cuda determines CUDA SDK is installed or not is that if it has successfully loaded libuda dynamic library with cffi:user-foreign-library function. Streams The low level interface works with multiple streams. With the async stuff it's possible to overlap copy and computation with two streams. Cl-cuda provides *cuda-stream* special variable, to which bound stream is used in kernel function calls. The following is for working with streams in mgl-mat: (defmacro with-cuda-stream ((stream) &body body)   (alexandria:with-gensyms (stream-pointer)     `(cffi:with-foreign-objects          ((,stream-pointer 'cl-cuda.driver-api:cu-stream))        (cl-cuda.driver-api:cu-stream-create ,stream-pointer 0)        (let ((,stream (cffi:mem-ref ,stream-pointer                                     'cl-cuda.driver-api:cu-stream)))          (unwind-protect               (locally ,@body)            (cl-cuda.driver-api:cu-stream-destroy ,stream))))))  then, call a kernel function with binding a stream to *cuda-stream*: (with-cuda-stream (*cuda-stream*)   (call-kernel-function))  Author Masayuki Takagi (kamonama@gmail.com) Copyright Copyright (c) 2012 Masayuki Takagi (kamonama@gmail.com) License Licensed under the LLGPL License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/takagi/cl-cuda"	"A library to use NVIDIA CUDA in Common Lisp programs.."	"true"
"Utilities"	"cl-fad"	"http://weitz.de/cl-fad/"	"A portable pathname library.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"27"	"4"	"6"	"GitHub - edicl/cl-fad: Portable pathname library for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 4 Star 27 Fork 6 edicl/cl-fad Code Issues 3 Pull requests 1 Pulse Graphs Portable pathname library for Common Lisp http://weitz.de/cl-fad/ 29 commits 1 branch 5 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v0.7.4 v0.7.3 v0.7.2 v0.7.1 v0.7.0 Nothing to show New pull request Latest commit 2e3b957 Jul 10, 2016 Hans Huebner release 0.7.4 Permalink Failed to load latest commit information. doc update support information Nov 28, 2014 CHANGELOG release 0.7.4 Jul 10, 2016 LICENSE Added LICENSE file Nov 21, 2012 README more version number removals Apr 12, 2009 cl-fad.asd cl-fad.system more version number removals Apr 12, 2009 corman.lisp For 0.6.4 release Nov 18, 2010 fad.lisp Make copy-stream work for CMUCL Gray Streams Jul 10, 2016 fad.test.lisp load.lisp For 0.6.4 release Nov 18, 2010 openmcl.lisp packages.lisp Moved the cl-fad-test package definition into its own file. Nov 21, 2012 packages.test.lisp Moved the cl-fad-test package definition into its own file. Nov 21, 2012 path.lisp Removed function pathname-sans-directory-pathname since it's a duplic… Nov 20, 2012 temporary-files.lisp Fix for LispWorks (less specific handler-case) (fixes #5) Feb 18, 2013 temporary-files.test.lisp Merge in code (and tests and docs) from temporary-files Nov 21, 2012 README Complete documentation for CL-FAD can be found in the 'doc' directory.  CL-FAD also supports Nikodemus Siivola's HYPERDOC, see <http://common-lisp.net/project/hyperdoc/> and <http://www.cliki.net/hyperdoc>.  1. Installation  1.1. Probably the easiest way is         (load ""/path/to/cl-fad/load.lisp"")       This should compile and load CL-FAD on most Common Lisp      implementations.  1.2. With MK:DEFSYSTEM you can make a symbolic link from      'cl-fad.system' and 'cl-fad-test.system' to your central registry      (which by default is in '/usr/local/lisp/Registry/') and then issue      the command         (mk:compile-system ""cl-fad"")       Note that this relies on TRUENAME returning the original file a      symbolic link is pointing to. This will only work with AllegroCL      6.2 if you've applied all patches with (SYS:UPDATE-ALLEGRO).  1.3. You can also use ASDF instead of MK:DEFSYSTEM in a similar way      (use the .asd files instead of the .system files).  2. Test  CL-FAD comes with a small test suite.  To start it just load the file ""test.lisp"" and evaluate (CL-FAD-TEST:TEST).  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/edicl/cl-fad"	"A portable pathname library.."	"true"
"Utilities"	"cl-interpol"	"http://www.cliki.net/cl-interpol"	"A set of reader modifications to allow string interpolation. No license specified."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"CLiki: cl-interpol CLiki - cl-interpol cl-interpol CL-INTERPOL modifies the reader so that you can have interpolation of strings similar to Perl or Unix Shell scripts. It is a text processing convenience library. It also provides various ways to insert arbitrary characters into literal strings even if your editor/IDE doesn't support them. Here's an example:  * (let ((a 42))     #?""foo: \xC4\N{Latin capital letter U with diaeresis}\nbar: ${a}"") ""foo: ÄÜ bar: 42""  It was written by Edi Weitz and can be found at http://weitz.de/cl-interpol/. CL-INTERPOL can also be used for HTML templating: http://paste.lisp.org/display/146518 ASDF-install package (obsolete) http://weitz.de/files/cl-interpol.tar.gz Current version History Backlinks Edit Create Home Recent Changes About Text Formatting Tools Search CLiki CLiki the common lisp wiki Account name Password register"	"null"	"null"	"A set of reader modifications to allow string interpolation. No license specified."	"true"
"Utilities"	"CL-JavaScript"	"http://marijnhaverbeke.nl/cl-javascript/"	"A translator from Javascript to Common Lisp. Not available on Quicklisp.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"null"	"null"	"null"	"CL-JavaScript CL-JavaScript JavaScript is the new BASIC—a universal scripting language. CL-JavaScript allows you to add user scripting to your Common Lisp application without requiring your poor users to learn Common Lisp. It is a JavaScript to Common Lisp translator, runtime, and standard library. We are ECMAScript 3 compatible, with some of the ECMAScript 5 extensions. By using the Lisp compiler to compile JavaScript (and by using some clever tricks for the things that Lisp normally isn't good at), this implementation manages to be faster than most of the 2009 generation of JavaScript engines. The new generation (V8, Jägermonkey) beats it by, depending on the benchmark, a factor 4 or so. Contents News Code Dependencies Support Quickstart Reference Running Code JavaScript Values Exceptions The Environment Utilities Library Definition Provided Libraries News 14-03-2012: Version 0.12.03: Fix CLISP incompatibility. 09-01-2012: Version 0.12.01: Follow changes in parse-js, add Function.prototype.bind, getter/setter support, small fixes. 08-12-2010: Version 0.10.12: Implements ECMA5-style array, string, and Object constructor methods, as well as a JSON object. Rough support for CommonJS modules. Adds correct length (arity) properties to function objects. 15-11-2010: Version 0.10.11: The first release on the new project page. Our API can be considered more or less stable now, and there are no serious gaps left in our ECMAScript 3 support. 15-11-2010: It seems I have finally documented this library. Code CL-JavaScript was created by Alan Pavičić, Iva Jurišić, and Marijn Haverbeke. It is released under a MIT-style licence. Development takes place on github. Any releases we make are listed under News. The latest release is always linked from cl-javascript.tgz. Dependencies CL-JavaScript depends on parse-js, CL-PPCRE, and optionally local-time (you won't have a Date object if your ASDF can not find local-time). Because emulating IEEE 754 floating point special values (NaN, Infinity) in software is painfully inefficient, CL-JavaScript includes some non-portable code to directly use machine floats in SBCL and Allegro Common Lisp. There is fallback code present for other implementations, but since the developers don't develop on those, that might not be very well tested. It is recommended, if you really want to use the system on another implementation, to try and add native float support for that implementation. Support When you have a problem, please either open an issue on github, or send the maintainer an e-mail. Quickstart First, load the system: cl-user> (asdf:oos 'asdf:load-op :cl-js) cl-user> (use-package :cl-js) We can start a JavaScript REPL to convince ourselves that yes, we really do have JavaScript in our Common Lisp. cl-user> (js-repl) JS repl (#q to quit) > 1 + 1 2 > function fac(x) { return x <= 1 ? x : x * fac(x - 1); } [object Object] > fac(10) 3628800 > #q cl-user> Well, that seems to work. Next up: defining our own library. cl-user> (defparameter *mylib* (empty-lib)) cl-user> (add-to-lib *mylib*            (.func ""plusOne"" (x) (1+ (to-number x)))            (.object ""numbers""              (.value ""one"" 1)              (.value ""two"" ""2""))) cl-user> (with-js-env (*mylib*)            (run-js ""plusOne(numbers.two)"")) 3 Note the to-number call. This will invoke JavaScripts number-conversion. For a library like this, you are, of course, better off just doing something like this: cl-user> (run-js ""   function plusOne(x){return x + 1;}   var numbers = {one: 1, two: '2'};"") But, in general, what you want to do is write glue code, providing a JavaScript API for your application. For this, the library does its best to provide a practical interface for defining JavaScript environments. Reference Running Code function run-js (code &key (compile t) wrap-parse-errors optimize) Runs the given code. code can be a string or a stream. compile and optimize determine whether the code should be compiled, and if, whether it should be optimized, before it is run. When wrap-parse-errors is given, parse errors are wrapped in js-condition objects, and can be caught by JavaScript catch forms. function run-js-file (file &key (compile t) wrap-parse-errors optimize external-format) Runs the code from the given file. The keyword arguments are passed through to run-js, except for external-format, which is passed to open. function js-repl (&key (handle-errors t)) Starts an interactive JavaScript REPL. If handle-errors is t, all errors will be caught and printed. If it is nil, all errors are let through. If it has any other value, only errors of type js-condition are handled and printed. JavaScript Values Values in a JavaScript environment are represented as follows: null and undefined are the Lisp keywords :null and :undefined. The type js-null is provided, which includes both these values. js-null is also a predicate function (shortcut for (typep x 'js-null)). Booleans are Lisp booleans (nil and t). Numbers are represented as Lisp numbers (integers and double-floats). On implementations where no support for representing NaN and Infinity as floats has been added, these are represented by the values :NaN, :Inf, and :-Inf. The js-number type helps abstract this—matching only numbers on those implementations where no keywords are needed, and both numbers and these three keywords on others. The macros nan, infinity, and -infinity are provided to create special number values. The predicate is-nan can be used to check whether a value is NaN. Strings are plain Lisp strings. Objects are a custom struct type—js-obj. The js-func and js-array types are subtypes of this. function js-obj (&optional prototype type) Creates a JavaScript object. Optionally, a prototype id (more about that later) or prototype object, and a type (as in define-js-obj) can be given. function js-prop (obj propname) Retrieves a property from an object. A setf variant is provided for setting properties. function js-array (vector) Creates a new JavaScript array. vector must be an adjustable vector with a fill pointer. function js-array-length (array) Retrieve the length of a JavaScript array. function js-aref (array index) Access an element in an array. There is a setf variant as well. macro js-call (func this &rest args) Call a JavaScript function value. macro js-method (object name &rest args) Call a method in a JavaScript object. macro js-func (args &body body) Creates a JavaScript function object from a lambda-like specification. Inside the body this will be bound, in addition to the specified arguments. The argument list is mangled to conform to JavaScript calling conventions—each paramter will become optional, with an implicit default of :undefined, unless you specify your own default. A &rest clause is allowed, but &key and &optional can't be used. Exceptions JavaScript exceptions are raised as Lisp conditions of the js-condition type. A JavaScript catch block will catch these (and only these). method js-condition-value (condition) Returns the JavaScript value associated with the given condition. function js-error (type message &rest args) Raises a JavaScript error (value of type Error) . type must be prototype id (:error, :type-error, :syntax-error, :range-error, :uri-error, and :eval-error are provided by the standard lib). message can be a format string into which args will be interpolated. The Environment variable *env* The variable that holds the current environment. Starts out unbound (though run-js and js-repl will give it a default value automatically when they find it unbound). macro with-js-env ((&rest libraries) &body body) Runs body with *env* bound to a fresh environment, which was created by loading the standard library plus the given libraries. function create-env (&rest libraries) Creates a new environment, loading the given libraries. function add-to-env (env &rest libraries) Extends env with the given libraries, then returns it. Utilities macro void (&body body) Executes the body, returns :undefined. function to-string (value) function to-number (value) function to-integer (value) function to-boolean (value) Invokes the standard JavaScript type conversion algorithm on the given value. Library Definition CL-JavaScript works with first-class libraries. These are specifications of a set of variables, prototypes, and constructors that can be instantiated into an environment to make their definitions available there. function empty-lib (&optional name) Returns a fresh, empty library specification object. The name is only used for the printed representation of the object. macro add-to-lib (lib &body body) Add the definitions found in body to the given library. Defining the content of a library is done with a family of macros starting with a period. These all take a &body in which lists starting with a keyword can be used to set options. For example: (.object ""Math""   (:slot-default :noenum)   (.value ""E"" (exp 1))) Here, the :slot-default option is given, causing all slots defined in the Math object to not be enumerable. All defining forms that allow slots to be defined inside of them accept the :slot-default option. All forms that define slots accept the :slot option. Both of these expect a list of keywords (:enum, :noenum, :ro, :rw, :del, :nodel) which specify slot properties (enumerabe, read-only, and deletable). Properties that are not specified are inherited from the context (as an under-the-covers special variable). By default, properties are enumerable, read-write, and deletable, except in prototypes, where they are not enumerable. macro .prototype (id &body body) Creates a new prototype and associates it with the given ID. All non-option forms appearing in the body are evaluated, and can add properties to the prototpe. A :parent option (which should hold a prototype-id) can be used to make this prototype inherit from another prototype. macro .constructor (name args &body body) Declares a constructor with the given argument list (interpreted as in js-func) and body. A :prototype option may appear in the body, and is used to determine what prototype objects created with this constructor should get. If it holds a keyword, that is the ID of the prototype to use, if it holds a list of slot definitions, a new prototype object is created and given those slots. If this constructor should not create regular objects, you can give it a :type option containing the name of a type defined with define-js-obj. When the constructor is invoked with new, you will then get an object of that type as this variable, rather than a plain object. Finally, a :properties option can be passed, within which properties for the constructor itself can be defined (as in String.fromCharCode). macro .value (name &body value) Defines a simple value property. When this appears at the top level, it defines a global variable. When it appears inside another form, it adds a property to that definition. macro .object (name &body body) This defines an object property. The body contains property definitons for this object, and optionally a :parent option, as in .prototype, to give the object a specific prototype. macro .func (name args &body body) Adds a function (top-level) or method. args is an argument list as in js-func. The given body becomes the body of the function. A :properties option can be used to give the function object itself properties. macro .active (name &body body) This macro is used to add 'active' properties to objects. Active properties are things that can be approached like regular properties, but execute some function when read or written. The :read and :write options can be used to specify the bodies of the functions, like this: (.active ""preciousProperty""   (:read () ""my precious!"")   (:write (value) (js-error :error ""How dare you touch my precious!""))) (The argument lists are compulsory, even though they are always the same.) macro .active-r (name &body body) This is a shortcut for an .active property with only a :read entry (meaning writes to the slot will be ignored). The following two macros should not be used inside library definitions, but at the top level (they are global in their effect). macro define-js-obj (name &body slots) Defines a struct type fit for holding JavaScript object values. The way to use this is to specify the type name you use here as the :type option of a .constructor form, and then fill in your custom slots in this constructor. macro integrate-type (specializer &body options) A type defined by define-js-obj is a 'real' JavaScript object, to which clients can add properties. Sometimes, it is preferable to use Lisp objects 'as they are', because wrapping is too expensive. This macro allows you to do that. To be able to use a value as a JavaScript value, a bunch of methods have to specialized on it, so that JavaScript operations (typeof, String(x)) will know what to do with it. specializer should be a valid method specializer that can be used to recognize the type you want to integrate. All options appearing under this macro can take either the form of a single value, or an argument list (of a single symbol) and then a body. The :string option determines how the type is converted to string (default is ""[object Object]""). The :number option converts to numbers (default NaN). The :boolean option to booleans (default true). typeof is used to determine the string returned by the typeof operator (default ""foreign""). When a :proto-id form is given, it is used to locate a prototype in which properties for these values are looked up. An example: (integrate-type complex   (:number (val) (realpart val))   (:string (val) (format nil ""~a+~ai"" (realpart val) (imagpart val)))   (:typeof ""complex"")   (:proto-id :number)) ;; or add a custom prototype  /* ... and in your library ... */ (.func ""complex"" (real imag)   (complex (to-number real) (to-number imag))) Provided Libraries variable *printlib* A tiny library value containing only a print function, which will write its arguments to *standard-output*. function requirelib (hook) When called, returns a library object that implements the CommonJS-style require operator. hook should be a funcallable object which, given a string, verifies that string as a module specifier, and returns a pathname under which the module text can be found. Or, if you need modules that aren't simply files, it can return two values—a canonical module identifier (must be comparable with equal) and a function that, given this identifier, returns either a stream or a string containing the module's text. A trivial hook (without error-checking or safety) could simply do (merge-pathnames spec ""/my/script/dir/x.js""). If you do want to do error-checking, use js-error to complain when a specifier is not acceptable. Note that CL-JavaScript's implementation of CommonJS modules does not sandbox the modules in any serious way—it simply wraps them in a function. This means that direct, var-less assignments will create top-level variables, and the module can mangle existing values (say, Object.prototype) all it wants. For well-behaved modules, this shouldn't be an issue."	"null"	"null"	"A translator from Javascript to Common Lisp. Not available on Quicklisp.."	"true"
"Utilities"	"cl-locale"	"https://github.com/fukamachi/cl-locale"	"A simple i18n library.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"13"	"5"	"1"	"GitHub - fukamachi/cl-locale: Simple i18n library for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 13 Fork 1 fukamachi/cl-locale Code Issues 0 Pull requests 0 Pulse Graphs Simple i18n library for Common Lisp 48 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src t .gitignore .travis.yml README.markdown cl-locale-syntax.asd cl-locale-test.asd cl-locale.asd README.markdown CL-Locale - Simple i18n library for Common Lisp Usage (cl-locale:enable-locale-syntax)  (define-dictionary schedule   (:ja-JP #p""i18n/ja_JP/message.lisp"")   (:fr-FR #p""i18n/fr_FR/message.lisp""))  (define-dictionary lisp   (:ja-JP #p""i18n/ja_JP/message.lisp""))  (setf (current-dictionary) :schedule)  #i""Schedule"" ;=> ""Schedule""  (i18n ""Schedule"" :locale :ja-JP) ;=> ""予定""  (let ((*locale* :fr-FR))   #i""Schedule"") ;=> ""Calendrier""  #i(""Comments: ~A"" 10) ;=> ""コメント: 10個""  What the difference cl-i18n: Does nit support loading multiple locales at the same time. cl-l10n: No reader macro predefined. No tools to automatically generate localizable files / language files. Dictionary Resource ; ja_JP/message.lisp ((""Schedule"" . ""予定"")  (""Lisping"" . ""舌足らず""))  ; fr_FR/message.lisp ((""Schedule"" . ""Calendrier""))  License Copyright (c) 2011 Eitarow Fukamachi Licensed under the LLGPL License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/cl-locale"	"A simple i18n library.."	"true"
"Utilities"	"cl-project"	"https://github.com/fukamachi/cl-project"	"General modern project skeletons.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"68"	"10"	"16"	"GitHub - fukamachi/cl-project: Generate modern project skeletons Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 10 Star 68 Fork 16 fukamachi/cl-project Code Issues 2 Pull requests 2 Pulse Graphs Generate modern project skeletons 72 commits 4 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master test-caveman2 travis v0.2 Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. roswell renamed directory bin/ to roswell/ for roswell compat May 27, 2016 skeleton src t .gitignore .travis.yml README.markdown Tweak README. Dec 17, 2015 cl-project-test.asd cl-project.asd README.markdown CL-Project - Generate modern project skeletons Usage (cl-project:make-project #p""lib/cl-sample/""   :author ""Eitaro Fukamachi""   :email ""e.arrows@gmail.com""   :license ""LLGPL""   :depends-on '(:clack :cl-annot)) ;-> writing /Users/fukamachi/Programs/lib/cl-sample/.gitignore ;   writing /Users/fukamachi/Programs/lib/cl-sample/README.markdown ;   writing /Users/fukamachi/Programs/lib/cl-sample/cl-sample-test.asd ;   writing /Users/fukamachi/Programs/lib/cl-sample/cl-sample.asd ;   writing /Users/fukamachi/Programs/lib/cl-sample/src/hogehoge.lisp ;   writing /Users/fukamachi/Programs/lib/cl-sample/t/hogehoge.lisp ;=> T What's the difference from other generators? 1. Flexible templates CL-Project supports more parameters to embed, by using CL-EMB to represent the skeleton files (See ""cl-project/skeleton/""). 2. One package per file style (Modern) A modern CL project should be in accordance with some rules. For instance, one file must have one package in it. 3. Recommends unit testing Modern projects should have some unit tests. CL-Project generates a system for unit testing, so you can begin writing unit tests as soon as the project is generated. Parameters All parameters are optional. :name: Project name. If this key isn't specified, the directory name will be used. :description: Short description for the new project. :author: Your name. :email: Your e-mail address. :license: License of the new project. :depends-on: A list of dependencies. Author Eitaro Fukamachi (e.arrows@gmail.com) Copyright Copyright (c) 2011 Eitaro Fukamachi (e.arrows@gmail.com) License Licensed under the LLGPL License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/cl-project"	"General modern project skeletons.."	"true"
"Utilities"	"cl-syntax"	"https://github.com/m2ym/cl-syntax"	"Reader syntax conventions.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"27"	"4"	"7"	"GitHub - m2ym/cl-syntax: Reader Syntax Coventions for Common Lisp and SLIME Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 4 Star 27 Fork 7 m2ym/cl-syntax Code Issues 4 Pull requests 1 Pulse Graphs Reader Syntax Coventions for Common Lisp and SLIME 26 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit 03f0c32 Mar 15, 2015 m2ym Update copyright Permalink Failed to load latest commit information. contrib src .gitignore README.markdown cl-syntax-annot.asd cl-syntax-anonfun.asd cl-syntax-clsql.asd cl-syntax-fare-quasiquote.asd cl-syntax-interpol.asd cl-syntax-markup.asd cl-syntax.asd added :description. Dec 2, 2011 README.markdown CL-SYNTAX CL-SYNTAX provides Reader Syntax Coventions for Common Lisp and SLIME. Overview The well-known problem about reader macros is that SLIME can't handle these reader macros correctly. Consider the following code: (defpackage foo   (:use :cl)) (in-package :foo) (cl-interpol:enable-interpol-syntax)  (list #?""Current Time: ${(get-universal-time)}"")  By calling cl-interpol:enable-interpol-syntax, we can use a reader macro #?. However, actually, when we try to evaluate the last line, SLIME reports an error there is no such the reader macro #?. This error might be raised on most of Common Lisp implementations except SBCL. The goal of CL-SYNTAX is to solve these problems. Instead of using procedurally defined functions such like enable-something-syntax, we introduce syntactically and declaratively defined syntax data structure. With this data structure, we can handle *readtable* correctly and readtables of swank server. Usage Macro: defsyntax defsyntax name &body options  defsyntax defines a new syntax. name is a symbol and options is a list of option. If option formed (:macro-character char fn &optional non-terminating-p), the syntax engine will call set-macro-character with the arguments when enabling the syntax. If option formed (:dispatch-macro-character disp-ch sub-ch fn), the syntax engine will call set-dispatch-macro-character with the arguments when enabling the syntax. Here is an example: ;; Define cl-interpol syntax (defsyntax interpol-syntax   (:dispatch-macro-character #\# #\? #'cl-interpol::interpol-reader))  This code is equivalent to: (defvar interpol-syntax     `((:dispatch-macro-character #\# #\? ,#'cl-interpol::interpol-reader)))  If you don't want to use defsyntax in some reasons, use this code instead. Macro: use-syntax use-syntax syntax-to-use  use-syntax enables the syntax specified by syntax-to-use. syntax-to-use is a symbol which is defined by defsyntax. Here is an example: ;; use cl-interpol syntax defined before (use-syntax interpol-syntax)  Copyright (C) 2011-2015 Tomohiro Matsuyama <m2ym.pub@gmail.com> Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/m2ym/cl-syntax"	"Reader syntax conventions.."	"true"
"Utilities"	"cl21"	"https://github.com/cl21/cl21"	"An experimental project to move Common Lisp into the 21st century.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"559"	"91"	"26"	"GitHub - cl21/cl21: Common Lisp in the 21st Century. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 91 Star 559 Fork 26 cl21/cl21 Code Issues 49 Pull requests 4 Wiki Pulse Graphs Common Lisp in the 21st Century. http://cl21.org 316 commits 5 branches 0 releases 7 contributors Common Lisp 99.8% Emacs Lisp 0.2% Common Lisp Emacs Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags bit-array guicho271828-master hash-table-literal master process Nothing to show Nothing to show New pull request Latest commit c36644f Jan 5, 2016 fukamachi Merge pull request #87 from jackcarrozzo/master … re-split: add standard-char to etypecase with convenience wrapper Permalink Failed to load latest commit information. doc Drop 'w' from my name. Jul 21, 2014 src re-split: add standard-char to etypecase with convenience wrapper Jan 4, 2016 t Delete 'ed', 'room' and 'dribble' because they look useless. Aug 26, 2014 tools Don't update CHANGES_AUTO.markdown when loading CL21. Jul 21, 2014 .gitignore Add cl21-mode.el. Mar 6, 2014 CHANGES_AUTO.markdown Don't update CHANGES_AUTO.markdown when loading CL21. Jul 21, 2014 LICENSE (refs #51) Change the license from MIT to Public Domain. Aug 6, 2014 README.markdown Change the URL of the dist. Aug 25, 2014 cl21-mode.el (refs #54, #25) Change `let1` form and rename `if-let`, `when-let` an… Mar 6, 2014 cl21-test.asd (refs #51) Change the license from MIT to Public Domain. Aug 6, 2014 cl21.asd Move cl21.core.util -> cl21.internal.util. Aug 26, 2014 shlyfile.lisp Change the URL of the dist. Aug 25, 2014 README.markdown CL21 - Common Lisp in the 21st Century. This is an experimental project aiming at redesigning a new successor of Common Lisp. Discussion is highly welcome, join the issues thread and post some ideas! (However, please read the older posts before you actually post something!) Philosophy and Features Trying to be the true successor -- Cooperate with existing Common Lisp applications/libraries Clean names and clean packages -- Symbols are re-considered and re-organized CLOS-based functions and MOP -- write fast, tune later Brought more functional facilities. -- Lazyness, etc. Aggressive use of reader-macros. Regexp literals. Hash-table literals. String Interpolation (once deleted, but is going to appear again in the other form) Includes Gray streams, CLtL2 Environment, etc Package local nicknames. (experimental) Usage ;; Installation (ql-dist:install-dist ""http://dists.cl21.org/cl21.txt"") (ql:quickload :cl21)  (in-package :cl21-user) (defpackage myapp (:use :cl21)) (in-package :myapp)  ;; Hello, World!  (princ ""Hello, World!\n"") ;-> Hello, World! ;=> ""Hello, World! ;   ""  ;; Hash Table  --  consistent interface!  (defvar *hash* #H()) (getf *hash* :name)                            ;=> NIL (setf (getf *hash* :name) ""Eitaro Fukamachi"") ;=> ""Eitaro Fukamachi"" (setf (getf *hash* :living) ""Japan"")           ;=> ""Japan"" (getf *hash* :name)                            ;=> ""Eitaro Fukamachi"" (coerce *hash* 'plist)                         ;=> (:LIVING ""Japan"" :NAME ""Eitaro Fukamachi"")  ;; Vector      --  consistent interface again!  (defvar *vector* #()) (push 1 *vector*) (elt *vector* 0)   ;=> 1 (push 3 *vector*) (elt *vector* 1)   ;=> 3 (pop *vector*)     ;=> 3 (pop *vector*)     ;=> 1  ;; Iteration -- `doeach` is similar to `dolist`, but it can be used with all sequences.  (doeach (x '(""al"" ""bob"" ""joe""))   (when (> (length x) 2)     (princ #""${x}\n""))) ;-> bob ;   joe   ;; Functional programming  (map (compose #'sin #'1+) '(1 2 3)) ;=> (0.9092974 0.14112 -0.7568025)  ;; remove-if-not -> keep-if (keep-if (conjoin #'integerp #'evenp) '(1 2 3 2.0 4))  ;=> (2 4) (keep-if (disjoin #'oddp #'zerop) (0.. 10))            ;=> (0 1 3 5 7 9)  ;; Useful Shapsign-Quote reader macro (keep-if #'(and integerp evenp) '(1 2 3 2.0 4))        ;=> (2 4) (keep-if #'(and integerp (or oddp zerop)) (0.. 10))    ;=> (0 1 3 5 7 9)   ;; Regular Expression (based on cl-ppcre)  (use-package :cl21.re)   ; in/use-package are redefined so that they                          ; load the associated syntax at the same time  (re-match #/^Hello, (.+?)!$/ ""Hello, World!"") ;=> ""Hello, World!"" ;   #(""World"")  ;; Regular expressions are ... functions!  (#/^(\d{4})-(\d{2})-(\d{2})$/ ""2014-01-23"") ;=> ""2014-01-23"" ;   #(""2014"" ""01"" ""23"")  (re-replace #/a/g ""Eitaro Fukamachi"" ""α"") ;=> ""Eitαrow Fukαmαchi"" ;   T   ;; Running external programs (cl21.process)  (use-package :cl21.process)  (run-process '(""ls"" ""-l"" ""/Users"")) ;-> total 0 ;   drwxrwxrwt    5 root         wheel   170 Nov  1 18:00 Shared ;   drwxr-xr-x+ 174 nitro_idiot  staff  5916 Mar  5 21:41 nitro_idiot ;=> #<PROCESS /bin/sh -c ls -l /Users (76468) EXITED 0>  #`ls -l /Users` ;=> ""total 0 ;   drwxrwxrwt    5 root         wheel   170 Nov  1 18:00 Shared ;   drwxr-xr-x+ 174 nitro_idiot  staff  5916 Mar  5 21:41 nitro_idiot ;   "" ;   """" ;   0   ;; Lazy Sequence  (use-package :cl21.lazy)  (defun fib-seq ()   (labels ((rec (a b)              (lazy-sequence (cons a (rec b (+ a b))))))     (rec 0 1)))  (take 20 (fib-seq)) ;=> #<LAZY-SEQUENCE {1009F7A893}> (coerce * 'list) ;=> (0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181)  (take 3 (drop-while ^(< % 500) (fib-seq))) ;=> #<LAZY-SEQUENCE {1009F33693}> (coerce * 'list) ;=> (610 987 1597)   ;; package-local-nickname  CL21-USER> (defpackage mypack (:use :cl21))           ; -> #<PACKAGE ""MYPACK""> CL21-USER> (in-package :mypack)                       ; -> #<PACKAGE ""MYPACK""> MYPACK> (defun *2 (x) (* x x))                        ; -> *2 MYPACK> (export '*2)                                  ; -> T MYPACK> (in-package :cl21-user)                       ; -> #<PACKAGE ""CL21-USER""> CL21-USER> (add-package-local-nickname :mp :mypack)   ; -> #<PACKAGE ""CL21-USER""> CL21-USER> (mp:*2 5)                                  ; -> 25 Deferred List Multi-Threading and Multi-Processing. POSIX interactions. Requirements CL21 is written in pure Common Lisp and intended to run on a Common Lisp implementation. It is tested on the latest version of SBCL, Clozure CL, GNU CLISP and Allegro CL. Installation (ql-dist:install-dist ""http://dists.cl21.org/cl21.txt"") (ql:quickload :cl21) List of major changes from standard CL We have a list about differences between CL and CL21 at CHANGES_AUTO.markdown which is automatically generated by a script. Updating to the latest version CL21 is continuously released at 1:00 JST (= 16:00 UTC). You can update to the HEAD version by this command. (ql:update-dist ""cl21"") How to use in your project CL21 is written in Common Lisp and works as a Common Lisp library. Not only you can write your application whole in CL21, but you can write only one file of your application in CL21. If you're going to write your application whole in CL21, add :class to asdf:defsystem form. (defsystem myapp   :defsystem-depends-on (:cl21)   :class :cl21-system   :components ((:file ""src/myapp""))) If you wanna write some files in CL21, use :cl21-source-file instead of :file. (defsystem myapp   :defsystem-depends-on (:cl21)   :components ((:file ""src/myapp"")                (:cl21-source-file ""src/myapp-written-in-cl21""))) If you're going to write a CL21 script, not big enough to use ASDF, ensure you're in CL21-USER package first. #!/usr/bin/env sbcl --script  (ql:quickload :cl21) (cl21:in-package :cl21-user)  ;; Start your code from here. Make an executable of CL21 $ sbcl --noinform --no-sysinit --no-userinit --eval '(load #P""~/quicklisp/setup.lisp"")' --eval '(ql:quickload :cl21)' --eval '(cl21:in-package :cl21-user)' --eval '(sb-ext:save-lisp-and-die #P""cl21"" :executable t)'  Setting the startup package of SLIME Add the following code 1) to your Lisp init file. (ql:quickload :cl21) 2) and, to your .emacs.el . (add-hook 'slime-connected-hook (lambda ()                                   (when (slime-eval `(cl:if (cl:find-package :cl21-user) t))                                     (slime-repl-set-package :cl21-user)                                     (slime-repl-eval-string ""(cl21:enable-cl21-syntax)""))) t) See Also Closer MOP Trivial Types trivial-gray-streams Alexandria Split-Sequence REPL-Utilities Credits fukamachi guicho271828 m-n snmsts EuAndreh KeenS License CL21 is free and unencumbered software released into the public domain. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/cl21/cl21"	"An experimental project to move Common Lisp into the 21st century.."	"true"
"Utilities"	"closer-mop"	"http://cliki.net/closer-mop"	"A compatibility layer that rectifies many absent or incorrect MOP features.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"null"	"null"	"null"	"CLiki: closer-mop CLiki - closer-mop closer-mop Closer to MOP is a compatibility layer that rectifies many of the absent or incorrect MOP features as detected by MOP Feature Tests. This page keeps ASDF-Install happy. See Closer to MOP for details. ASDF-install package (obsolete) http://common-lisp.net/project/closer/ftp/closer-mop_latest.tar.gz Current version History Backlinks Edit Create Home Recent Changes About Text Formatting Tools Search CLiki CLiki the common lisp wiki Account name Password register"	"null"	"null"	"A compatibility layer that rectifies many absent or incorrect MOP features.."	"true"
"Utilities"	"envy"	"https://github.com/fukamachi/envy"	"Configuration switcher.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"20"	"8"	"0"	"GitHub - fukamachi/envy: Configuration switcher by an environment variable inspired by Config::ENV. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 8 Star 20 Fork 0 fukamachi/envy Code Issues 0 Pull requests 0 Pulse Graphs Configuration switcher by an environment variable inspired by Config::ENV. 10 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src t .gitignore LICENSE README.markdown envy-test.asd envy.asd README.markdown Envy Configuration switcher by an environment variable inspired by Perl's Config::ENV. Usage (defpackage :myapp.config   (:use :cl         :envy)) (in-package :myapp.config)  (setf (config-env-var) ""APP_ENV"")  (defconfig :common   `(:application-root ,(asdf:component-pathname (asdf:find-system :myapp))))  (defconfig |development|   '(:debug T     :database-type :sqlite3     :database-connection-spec (:database-name ""sqlite3.db"")))  (defconfig |production|   '(:database-type :mysql     :database-connection-spec (:database-name ""test""                                :usename ""whoami""                                :password ""1234"")))  (defconfig |staging|   `(:debug T     ,@|production|)) (defpackage :myapp   (:use :cl)   (:import-from :envy                 :config) (in-package :myapp)  (getf (config :myapp.config) :database-type) Description Envy is a configuration manager for various applications. Envy uses an environment variable to determine a configuration to use. I'm not sure this is ideal even for Common Lisp applications, but this can separate configuration system from an implementation. Configurations Normal configurations ENVY:DEFCONFIG is a macro for defining a named configuration. Don't forget to set (ENVY:CONFIG-ENV-VAR) which is a name of environment variable to determine a configuration. (setf (config-env-var) ""APP_ENV"")  ;; Use SQLite3 for development (defconfig |development|   '(:server :hunchentoot     :database-type :sqlite3     :database-connection-spec (:database-name ""sqlite3.db"")))  ;; Use MySQL in production environment (defconfig |production|   '(:server :fcgi     :database-type :mysql     :database-connection-spec (:database-name ""test""                                :usename ""whoami""                                :password ""1234""))) Merging Each configurations are represented as property lists. It means you can merge them by the default way of merging lists -- cons, append or/and splicing unquote. (defconfig |staging|   `(:server :hunchentoot     ,@|production|)) Common configurations You can also define a common configuration which will be merged into every configurations. (defconfig :common   `(:application-root ,(asdf:component-pathname (asdf:find-system :myapp)))) Accessing to configuration ENVY:CONFIG is an accessor to get the current configuration. (config :<configuration-package-name>)  (config :myapp.config) ;=> '(:server :hunchentoot       :database-type :sqlite3       :database-connection-spec (:database-name ""sqlite3.db"")       :application-root #P""/path/to/application/"")  (getf (config :myapp.config) :database-type) ;=> :sqlite3 Tips (defpackage myapp.config   (:use :cl         :envy)   (:shadow :envy            :config)   (:export :config)) (in-package :myapp.config)  (defconfig :common   ...)  ;; ;; ... Configurations ... ;;  (defun config ()   (envy:config #.(package-name *package*))) See Also Thank cho45 for the great product. I feel envy to you :) Config::ENV Author Eitarow Fukamachi (e.arrows@gmail.com) Copyright Copyright (c) 2013 Eitarow Fukamachi (e.arrows@gmail.com) License Licensed under the BSD 2-Clause License. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/fukamachi/envy"	"Configuration switcher.."	"true"
"Utilities"	"esrap"	"https://github.com/nikodemus/esrap"	"Packrat parser.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"65"	"12"	"12"	"GitHub - nikodemus/esrap: Common Lisp packrat parser Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 12 Star 65 Fork 12 nikodemus/esrap Code Issues 2 Pull requests 2 Pulse Graphs Common Lisp packrat parser http://nikodemus.github.com/esrap/ 58 commits 3 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags custom-terminals-sketch gh-pages master Nothing to show Nothing to show New pull request Latest commit 133be8b Jun 22, 2013 nikodemus fix broken test. how did that happen? Permalink Failed to load latest commit information. doc tools web Makefile README TODO.org esrap.asd esrap.lisp example-sexp.lisp example-symbol-table.lisp tests.lisp README ESRAP -- a packrat parser for Common Lisp  In addition to regular Packrat / Parsing Grammar / TDPL features ESRAP supports:   - dynamic redefinition of nonterminals  - inline grammars  - semantic predicates  - introspective facilities (describing grammars, tracing, setting breaks)  Homepage & Documentation:    http://nikodemus.github.com/esrap/  References:    * Bryan Ford, 2002, ""Packrat Parsing: a Practical Linear Time     Algorithm with Backtracking"".      http://pdos.csail.mit.edu/~baford/packrat/thesis/  Licence:   Copyright (c) 2007-2013 Nikodemus Siivola <nikodemus@random-state.net.net>   Permission is hereby granted, free of charge, to any person  obtaining a copy of this software and associated documentation files  (the ""Software""), to deal in the Software without restriction,  including without limitation the rights to use, copy, modify, merge,  publish, distribute, sublicense, and/or sell copies of the Software,  and to permit persons to whom the Software is furnished to do so,  subject to the following conditions:   THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  Syntax overview:   <literal>                 -- case-sensitive terminal  (~ <literal>)             -- case-insensitive terminal  character                 -- any single character  (string length)           -- any string of length  (not expression)          -- complement of expression  (character-ranges ranges) -- character ranges  (and &rest sequence)  (or &rest ordered-choices)  (* greedy-repetition)  (+ greedy-positive-repetition)  (? optional)  (& followed-by)           -- does not consume  (! not-followed-by)       -- does not consume  (<predicate> expr)        -- semantic parsing   See file example-sexp.lisp for a complete sample grammar and usage,  and example-symbol-table.lisp for a grammar with lexical scope.  Trivial examples:   ;; Parse takes a expression  (parse '(or ""foo"" ""bar"") ""foo"")         => ""foo"", NIL   ;; New rules can be added.  ;;  ;; Normally you'd use the declarative DEFRULE interface to define new  ;; rules, but everything it does can be done directly by building  ;; instances of the RULE class and using ADD-RULE to activate them.  (add-rule 'foo+ (make-instance 'rule :expression '(+ ""foo""))) => FOO+   (parse 'foo+ ""foofoofoo"")               => (""foo"" ""foo"" ""foo""), NIL   ;; Rules can transform their matches.  (add-rule 'decimal            (make-instance 'rule             :expression '(+ (or ""0"" ""1"" ""2"" ""3"" ""4"" ""5"" ""6"" ""7"" ""8"" ""9""))             :transform (lambda (list start end)                          (declare (ignore start end))                          (parse-integer (format nil ""~{~A~}"" list)))))   => DECIMAL   ;; Any lisp function can be used as a semantic predicate.  (parse '(oddp decimal) ""123"")                  => 123   (parse '(evenp decimal) ""123"" :junk-allowed t) => NIL, 0  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/nikodemus/esrap"	"Packrat parser.."	"true"
"Utilities"	"fast-io"	"https://github.com/rpav/fast-io"	"Fast octet-vector/stream I/O.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"74"	"13"	"6"	"GitHub - rpav/fast-io: Fast octet-vector/stream I/O for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 13 Star 74 Fork 6 rpav/fast-io Code Issues 3 Pull requests 0 Pulse Graphs Fast octet-vector/stream I/O for Common Lisp 32 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Latest commit 22fb5cb Jun 9, 2016 rpav Fix new write8; alias old 1-byte -be/-le for testing/compatibility Permalink Failed to load latest commit information. src Fix new write8; alias old 1-byte -be/-le for testing/compatibility Jun 9, 2016 t Move benchmark defs to a separate file Dec 4, 2012 .gitignore Documentation Nov 11, 2014 README.md Also note :static Nov 11, 2014 fast-io-test.asd Move benchmark defs to a separate file Dec 4, 2012 fast-io.asd pushnew *features*, not push Sep 11, 2014 README.md fast-io Now with static-vectors support! (deftype octet '(unsigned-byte 8)) (deftype octet-vector '(simple-array octet (*))) Fast-io is about improving performance to octet-vectors and octet streams (though primarily the former, while wrapping the latter). Imagine we're creating messages for the network. If we try and fill an octet-vector with 50 bytes, 50000 times, here are the results (SBCL 1.0.57): vector-push-extend: flexi-streams: fast-io: Time: 0.767s 2.545s 0.090s Bytes consed: 104,778,352 274,452,768 18,373,904 (See t/benchmarks.lisp for the exact code used.) It should be surprising that it takes a nontrivial effort to achieve relatively decent performance to octet-vectors, but probably isn't. However, fast-io provides a relatively straightforward interface for reading and writing either a stream or a vector: ;;; Write a byte or sequence, optionally to a stream:  (with-fast-output (buffer [STREAM | :vector | :static])   (fast-write-byte BYTE buffer))  (with-fast-output (buffer [STREAM | :vector | :static])   (fast-write-sequence OCTET-VECTOR buffer [START [END]]))  ;;; Read from a vector or stream:  (with-fast-input (buffer VECTOR [STREAM])   (fast-read-byte buffer))  (with-fast-input (buffer VECTOR [STREAM])   (let ((vec (make-octet-vector N)))     (fast-read-sequence vec buffer [START [END]]))) Multi-byte and Endianness Fast-io provides a host of read and write functions for big- and little-endian reads. See the Dictionary below. Static Vectors You may now specify :static instead of a stream to WITH-OUTPUT-BUFFER. This returns an octet-vector created with static-vectors, which means that passing the buffered data directly to a foreign function is now that much more efficient: (let ((data (with-fast-output (buffer :static)               (buffer-some-data buffer))))   (foreign-send (static-vectors:static-vector-pointer data))   (static-vectors:free-static-vector data)) Note that the restriction for manually freeing the result remains. This avoids multiple inefficient (i.e., byte-by-byte) copies to foreign memory. Streams Obviously, the above API isn't built around Lisp streams, or even gray-streams. However, fast-io provides a small wrapper using trivial-gray-streams, and supports {WRITE,READ}-SEQUENCE: (let ((stream (make-instance 'fast-io:fast-output-stream)))   (write-sequence (fast-io:octets-from '(1 2 3 4)) stream)) Both fast-input-stream and fast-output-stream support backing a stream, much like using the plain fast-io buffers. However, using the gray-streams interface is a 3-4x as slow as using the buffers alone. Simple benchmarks show the gray-streams interface writing 1M 50-byte vectors in about 1.7s, whereas simply using buffers is about 0.8s. Consing remains similar between the two. Dictionary Octets Most functions operate on or require octet-vectors, i.e., (deftype octet () '(unsigned-byte 8)) (deftype octet-vector '(simple-array octet (*))) Which is exactly what is defined and exported from fast-io. Also: make-octet-vector LEN Make an octet-vector of length LEN. octets-from SEQUENCE Make an octet-vector from the contents of SEQUENCE. Buffers make-input-buffer &key VECTOR STREAM POS Create an input buffer for use with input functions. :vector specifies the vector to be read from. :stream specifies the stream to read from. :pos specifies the offset to start reading into VECTOR. make-output-buffer &key OUTPUT Create an output buffer for use with output functions. :output specifies an output stream. If :output :static is specified, and static-vectors is supported, output will be to a static-vector. finish-output-buffer BUFFER Finish the output and return the complete octet-vector. buffer-position BUFFER Return the current read/write position for BUFFER. with-fast-input (BUFFER VECTOR &optional STREAM (OFFSET 0)) &body body Create an input buffer called BUFFER, optionally reading from VECTOR, followed by reading from STREAM. If OFFSET is specified, start reading from this position in VECTOR. with-fast-output (BUFFER &optional OUTPUT) &body BODY Create an output buffer named BUFFER, optionally writing to the stream OUTPUT. This will automatically FINISH-OUTPUT-BUFFER on BUFFER. Thus the with-fast-output form evaluates to the completed octet-vector. Reading and Writing fast-read-byte INPUT-BUFFER &optional (EOF-ERROR-P t) EOF-VALUE Read a byte from INPUT-BUFFER. If EOF-ERROR-P is t, reading past the end-of-file will signal CL:END-OF-FILE. Otherwise, it will return EOF-VALUE instead. fast-write-byte BYTE OUTPUT-BUFFER Write a byte to OUTPUT-BUFFER. fast-read-sequence SEQUENCE INPUT-BUFFER &optional (START 0) END Read from INPUT-BUFFER into SEQUENCE. Values will be written starting at position START and, if END is specified, ending at END. Otherwise values will be written until the length of the sequence, or until the input is exhausted. fast-write-sequence SEQUENCE OUTPUT-BUFFER &optional (START 0) END Write SEQUENCE to OUTPUT-BUFFER, starting at position START in SEQUENCE. If END is specified, values will be written until END; otherwise, values will be written for the length of the sequence. For multi-byte reads and writes requiring endianness, fast-io provides functions in the following forms: write[u]{8,16,32,64,128}{-be,-le}: E.g., (write32-be VALUE BUFFER) will write the specified 32-bit value to the specified buffer with a big-endian layout. Likewise, (writeu16-le VALUE BUFFER) will write an unsigned 16-bit value in little-endian layout. read[u]{8,16,32,64,128}{-be,-le}: Similarly, (read64-le BUFFER) will read a 64-bit value from the buffer with little-endian layout. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/rpav/fast-io"	"Fast octet-vector/stream I/O.."	"true"
"Utilities"	"FSet"	"http://quickdocs.org/fset/"	"A functional, set-theoretic collections data structure library.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"42"	"5"	"4"	"GitHub - slburson/fset: FSet, the functional collections library for Common Lisp. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 5 Star 42 Fork 4 slburson/fset Code Issues 4 Pull requests 2 Pulse Graphs FSet, the functional collections library for Common Lisp. 29 commits 2 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags dev master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. Code .gitignore LICENSE.md README.md fset.asd README.md Introduction FSet is a functional set-theoretic collections library. Functional means that all update operations return a new collection rather than modifying an existing one in place. Set-theoretic means that collections may be nested arbitrarily with no additional programmer effort; for instance, sets may contain sets, maps may be keyed by sets, etc. The FSet home page explains why I chose functional semantics for FSet. To get started using FSet, check out the FSet Tutorial. Once you've gone through that, I recommend the FSet/CL page, which explains how FSet is integrated into Common Lisp. For more details, see the FSet project page. There might be some useful information on the FSet CLiki page. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/slburson/fset"	"A functional, set-theoretic collections data structure library.."	"true"
"Utilities"	"glyphs"	"https://github.com/ahungry/glyphs/"	"A library for cutting down the verboseness of Common Lisp in places.."	"null"	"null"	"null"	"GNU GPL3"	"http://www.gnu.org/copyleft/gpl.html"	"null"	"null"	"13"	"2"	"0"	"GitHub - ahungry/glyphs: Glyphs - Reducing Common Lisp verbosity Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 13 Fork 0 ahungry/glyphs Code Issues 0 Pull requests 0 Pulse Graphs Glyphs - Reducing Common Lisp verbosity 4 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. tests LICENSE.md README.md glyphs-test.asd glyphs.asd glyphs.lisp package.lisp README.md glyphs A little experiment in reducing verbosity in Common Lisp, inspired by BODOL (https://github.com/bodil/BODOL - no affiliation). To try it out in your REPL you can use (ql:quickload :glyphs) if you have added to your ASDF load path in local projects. Update: Now that it's in quicklisp, simply: (ql:quickload :glyphs) Examples Factorial example with glyphs function macro: glyphs: (ƒ factorial    0 → 1    α → (* α (factorial (1- α)))) vs.: (defun factorial (x)   (cond ((equal x 0) 1)         (x (* x (factorial (1- x)))))) result: (factorial 8) 40320 Type safety with factorial (ƒ factorial   0 → 1   (and (numberp α) (> α 0)) → (* α (factorial (1- α)))   α → (error ""Non-numbers (or negatives) don't work real well with factorials!"")) vs.: (defun factorial (x)   (cond ((equal x 0) 1)         ((and (numberp x) (> x 0)) (* x (factorial (1- x))))         (t (error ""Non-numbers (or negatives) don't work real well with factorials!"")))) Built in type safety with factorial (ƒ→ factorial (integer → integer)   0 → 1   α → (* α (factorial (1- α)))) Reverse a list glyphs: (ƒ reverse*   (cdr α) → (append (reverse* (cdr α)) `(,(car α)))   α → α) Map with glyphs lambda macro to compare strings and do a side effect glyphs: (mapcar (λ ""cat"" → (print ""Cats rock"")            ""dog"" → (print ""Dogs do too!"")) '(""cat"" ""dog"" ""mouse"")) vs.: (mapcar (lambda (x)           (cond ((equal x ""cat"") (print ""Cats rock""))                 ((equal x ""dog"") (print ""Dogs do too!"")) '(""cat"" ""dog"" ""mouse"")))) result: ""Cats rock"" ""Dogs do too!"" NIL Comparison based on passed in conditionals glyphs: (ƒ double-odds-half-evens   (oddp α) → (* x 2)   (evenp α) → (/ x 2)) vs.: (defun double-odds-half-evens (x)   (cond ((oddp x) (* x 2))         ((evenp x) (/ x 2)))) result: (double-odds-half-evens 4) 2 (double-odds-half-evens 3) 6 Using multiple values by including special variables in the statement You can use multiple values by prefixing a variable in the statement portion of the code with either a 'α' or an '?'. glyphs: (mapcar (λ α → (+ α αb αc)) '(1 2 3) '(4 5 6) '(7 8 9)) vs.: (mapcar (lambda (a b c) (+ a b c)) '(1 2 3) '(4 5 6) '(7 8 9)) result: (12 15 18) Fast matching based on regex strings Make sure to use the readtable that comes with it first: (in-readtable glyphs:syntax) Or these little readtable shortcuts will not work. glyphs: (ƒ any-cats?   ~""cat""~ → (print ""yes!"")) vs.: (defun any-cats? (x)   (when (cl-ppcre:scan ""cat"" x)     (print ""yes!""))) result: (any-cats? ""I see some cats"") ""yes!"" Easy regex replaces on matching strings glyphs: (ƒ no-cats   ~""(were|cat)""~ → |""dog""|) vs.: (defun no-cats (x)   (let ((regex ""(were|cat)""))        (when (cl-ppcre:scan regex x)          (cl-ppcre:regex-replace-all regex x ""dog"")))) result: (no-cats ""there were dogs and there were cats"") ""there dog dogs and there dog dogs"" Currently used glyphs and bindings for them (more to come) Emacs bindings Add to `.emacs' ;; Keybindings for glyphs (global-set-key (kbd ""M-l"") (lambda () (interactive) (insert ""\u03bb""))) ; λ lambda (global-set-key (kbd ""M-f"") (lambda () (interactive) (insert ""\u0192""))) ; ƒ function (global-set-key (kbd ""M--"") (lambda () (interactive) (insert ""\u2192""))) ; → right arrow (global-set-key (kbd ""M-a"") (lambda () (interactive) (insert ""\u03b1""))) ; α alpha (global-set-key (kbd ""M-y"") (lambda () (interactive) (insert ""\u03c8""))) ; ψ psi Vim bindings Add to `.vimrc' "" Keybindings for glyphs :inoremap <A-l> <C-v>u3bb<Space>   ; λ lambda :inoremap <A-f> <C-v>u192<Space>   ; ƒ function :inoremap <A--> <C-v>u2192<Space>  ; → right arrow :inoremap <A-a> <C-v>u03b1<Space>  ; α alpha :inoremap <A-y> <C-v>u03c8<Space>  ; ψ psi Mac OS X keybindings Add to `~/Library/KeyBindings/DefaultKeyBinding.dict' { ""~l"" = (""insertText:"", ""\U03BB""); /* alt + l ~> λ lambda */ ""~f"" = (""insertText:"", ""\U0192""); /* alt + f ~> ƒ function */ ""~-"" = (""insertText:"", ""\U2192""); /* alt + - ~> → right arrow */ ""~a"" = (""insertText:"", ""\U03b1""); /* alt + a ~> α alpha */ ""~y"" = (""insertText:"", ""\U03c8""); /* alt + y ~> ψ psi */ }  StumpWM keybindings (defmacro defkeys-top (&rest keys)   (let ((ks (mapcar #'(lambda (k) (cons 'defkey-top k)) keys)))     `(progn ,@ks)))  (defcommand xdo-lambda () ()     (run-shell-command ""xdotool type λ"")) (defcommand xdo-fn () ()     (run-shell-command ""xdotool type ƒ"")) (defcommand xdo-alpha () ()     (run-shell-command ""xdotool type α"")) (defcommand xdo-arrow () ()     (run-shell-command ""xdotool type →""))  (defkeys-top     (""s-l"" ""xdo-lambda"")     (""s-f"" ""xdo-fn"")     (""s--"" ""xdo-arrow"")     (""s-a"" ""xdo-alpha"")) If you're absolutely opposed to non-ascii characters, you can use: λ == /. ƒ == f → == -> License See LICENSE.md Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/ahungry/glyphs/"	"A library for cutting down the verboseness of Common Lisp in places.."	"true"
"Utilities"	"interface"	"https://bitbucket.org/tarballs_are_good/interface"	"A protocol library.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"null"	"null"	"null"	"tarballs_are_good / interface   — Bitbucket  Bitbucket Features Pricing owner/repository English English 日本語 Sign up Log in interface Actions Clone Compare Fork Navigation Overview Source Commits Branches Pull requests 2 Issues Downloads Settings HTTPS HTTPS SSH Need help cloning? Learn how to clone a repository. Clone in SourceTree Atlassian SourceTree is a free Git and Mercurial client for Windows. Atlassian SourceTree is a free Git and Mercurial client for Mac. Robert Smith interface Overview Clone in SourceTree Clone in SourceTree Atlassian SourceTree is a free Git and Mercurial client for Windows. Atlassian SourceTree is a free Git and Mercurial client for Mac. HTTPS HTTPS SSH Last updated 2015-10-10 Language Common Lisp Access level Read 1 Branch 1 Tag 0 Forks 3 Watchers                               INTERFACE                               =========                             By Robert Smith  1. Introduction  This system contains an implementation of interfaces and implementations. They're sometimes called protocols in other languages.  Broadly speaking, an ""interface"" is some collection of function ""prototypes"" that a valid implementation must implement. For example, something called a ""stack"" must implement stack creation, pushing, peeking, and popping.  The notion of interfaces and implementations aid the distinction between data structures and different implementations of that data structure. This was perhaps pioneered by Modula-3, and became a significant part of other languages like Standard ML and OCaml. In all of the aforementioned languages, interfaces can actually contain more than just functions, such as types and values. Haskell typeclasses are also a form of interface and implementation. They are very general and are even parametric.  One way to accomplish the notion of interfaces and implementations in Lisp is to use some ""abstract class"" and make several (final) subclasses of that class. The interface, in this case, is the abstract class and a collection of generic functions. The implementation would be the final subclass along with method definitions.  For example:      (defclass stack () ())     (defgeneric make-stack (impl))     (defgeneric stack-push (impl s x))     (defgeneric stack-pop (impl s))     (defgeneric stack-peek (impl s))      (defclass list-stack (stack) ())     (defmethod make-stack ((impl list-stack))       nil)     (defmethod stack-push ((impl list-stack) s x)       (cons x s))     (defmethod stack-pop ((impl list-stack) s)       (cdr s))     (defmethod stack-peek ((impl list-stack) s)       (car s))  This is mostly sufficient, though Lisp makes no guarantee that a class will have any set of methods defined for it. (One could perhaps use the MOP for this.) One can ""optimize"" implementations by conflating the notion of an implementation with the actual data structure being implemented, and make it a part of the implementation class. In this case, we could have a slot in LIST-STACK holding the list.  Since methods are not tied to classes, this implementation allows one to have a class implement several methods. Also, it is entirely possible to do away with the superclass; that is a formality tying all implementations to a particular interface with a name.  As I understand, this basic notion is taken to the extreme with Fare's Lisp Interface Library (http://www.cliki.net/lisp-interface-library).   In this system, however, we take a different approach entirely. Instead of using a class to represent interfaces and implementations, we have a structure whose slots are the implementation functions. The name of the structure (which decides what slots it has) is the interface, and the implementation is the actual slot values.  It is cumbersome, however, to use an interface by accessing slots all of the time. Instead, we define functions---which correspond to the slot names---which access the slots of an implementation and pass the arguments to it.  In doing this, there's no dispatch on type required, just access on the slots of the structure. It also forces data structures and the interface to be completely disjoint entities.   2. Example  (define-interface stack ()   (make-stack (&rest r))   (push-stack (s x))   (peek-stack (s))   (pop-stack (s)))  (define-implementation list-stack (stack)   :make-stack   (lambda (&rest r)     r)    :push-stack   (lambda (s x)     (cons x s))    :peek-stack   (lambda (s)     (car s))      :pop-stack   (lambda (s)     (cdr s)))  (define-implementation vector-stack (stack)   :make-stack   (lambda (&rest r)     (let ((length (length r)))       (make-array length                   :adjustable t                   :fill-pointer length                   :initial-contents r)))      :push-stack   (lambda (s x)     (vector-push-extend x s)     s)      :peek-stack   (lambda (s)     (aref s (1- (length s))))      :pop-stack   (lambda (s)     (vector-pop s)     s))  ;;; CL-USER> (pop-stack vector-stack ;;;                     (push-stack vector-stack ;;;                                 (make-stack vector-stack 1 2 3) ;;;                                 5)) ;;; #(1 2 3) ;;; CL-USER> (pop-stack list-stack ;;;                     (push-stack list-stack ;;;                                 (make-stack list-stack 1 2 3) ;;;                                 5)) ;;; (1 2 3)  3. Performance  This implementation has been measured to be between 10% and 30% faster than the classes approach described above. See the file interface-bench.lisp.  4. Other notes  The package also has a handy utility function called CALLING-FORM. It solves the following problem:  Consider a function F with a lambda list (L...). How can we write a function G      (defun G (L...)       <???>)  such that calls to G are precisely equivalent to F? We can use      (calling-form 'f '(L...))  which will produce code which is suitable for the definition of G.  Unlimited private and public hosted repositories. Free for small teams! Sign up for free Close Recent activity 2 commits Pushed to tarballs_are_good/interface 6043c64 Use global vars instead of DEFPARAMETER. 991be9c Put contents of interface-bench into its own package Robert Smith · Check that implementation has all interface functions Issue #3 created in tarballs_are_good/interface Robert Smith · Do lambda list congruency checking Issue #2 created in tarballs_are_good/interface Robert Smith · Implementation and Interface have to be in the same package Issue #1 commented on in tarballs_are_good/interface Robert Smith · Implementation and Interface have to be in the same package Issue #1 updated in tarballs_are_good/interface Robert Smith · 1 commit Pushed to tarballs_are_good/interface 5e898bc Fix Issue #1: Ensure correct packages are used when making symbols. Robert Smith · Implementation and Interface have to be in the same package Issue #1 created in tarballs_are_good/interface Anonymous · 1 commit Pushed to tarballs_are_good/interface 690e554 Add ability to specify single values in interfaces. Robert Smith · 1 commit Pushed to tarballs_are_good/interface a93ce48 Add comment which has alternative syntax. Robert Smith · 1 commit Pushed to tarballs_are_good/interface b85e14f fmt the README Robert Smith · 1 commit Pushed to tarballs_are_good/interface d25a5b4 Make system/package/etc. Import from lisp-random. Robert Smith · Blog Support Plans & pricing Documentation API Site status Version info Terms of service Privacy policy English Git 2.7.4.1.g5468f9e Mercurial 3.6.3 Django 1.7.11 Python 2.7.3 b7520e3d05e9 / b7520e3d05e9 @ app-104 JIRA Software Confluence Bamboo SourceTree HipChat Atlassian Help Online help Learn Git Keyboard shortcuts Latest features Bitbucket tutorials Site status Support"	"null"	"null"	"A protocol library.."	"true"
"Utilities"	"iolib"	"https://github.com/sionescu/iolib"	"I/O library.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"89"	"13"	"23"	"GitHub - sionescu/iolib: Common Lisp I/O library Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 13 Star 89 Fork 23 sionescu/iolib Code Issues 6 Pull requests 3 Pulse Graphs Common Lisp I/O library http://common-lisp.net/projects/iolib/ 1,800 commits 10 branches 10 releases 17 contributors Common Lisp 97.9% C 2.0% Other 0.1% Common Lisp C Other Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags abnf-ppcre cc clhsdoc gh-pages io.event master socket-connected-p sphinx tls windows-support Nothing to show v0.8.1 v0.8.0 v0.7.1 v0.7.0 v0.6.0 v0.5.4 v0.5.3 v0.5.2 v0.5.1 v0.5.0 Nothing to show New pull request Latest commit 0fef8c1 Aug 23, 2014 deadtrickster committed with sionescu Convert the return value of lpf_fd_isset() to :bool Permalink Failed to load latest commit information. doc Really fix docs. Jan 31, 2009 examples Fix typo in the tutorial Oct 18, 2013 extras Modify the ping example to wait for the reply Oct 14, 2013 src Convert the return value of lpf_fd_isset() to :bool Mar 6, 2016 tests Fix unknown keyword test for MAKE-SOCKET Jun 2, 2014 .gitattributes Add git config stuff for special treatment of lisp and texinfo files Jun 2, 2010 .gitconfig Add git config stuff for special treatment of lisp and texinfo files Jun 2, 2010 .gitignore Add .fasls to .gitignore Aug 4, 2007 .template.lisp Remove «Syntax:» from file headers May 27, 2010 .travis.yml Switch to sionescu/cl-travis Jul 22, 2015 CHANGES Document changes since 0.7.3 Mar 10, 2013 LICENCE Update copyright notes Aug 13, 2010 README.md Mention that libfixposix is a dependency. Jan 20, 2016 install-repo.bash Quiet apt Jul 21, 2015 iolib.asd Use version.sexp, remove ASDF2 compat Jan 20, 2016 version.sexp Release 0.8.1 Jan 20, 2016 README.md -- markdown -- Compilation IOlib requires a C library named LibFixPOSIX - https://github.com/sionescu/libfixposix - and its headers in order to compile. LibFixPOSIX can either be installed manually, for which there are instructions in the source code, or through distro repositories. Tests Some of the socket tests require an echo server, the default being one on the Internet. If you can't use that, set iolib-tests:echo-address and iolib-test:echo-port appropriately to point the echo tests somewhere else. Generating documentation To generate the documentation, use this patched version of texinfo-docstrings: http://gitorious.org/iolib/texinfo-docstrings Then make sure that IOLib's .asd files and texinfo-docstrings.asd can be loaded and run GNU make inside doc/ ; you'll then find the generated docs under manual/. This procedure has only been tested with SBCL. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/sionescu/iolib"	"I/O library.."	"true"
"Utilities"	"iterate"	"https://common-lisp.net/project/iterate/"	"An iteration construct for Common Lisp which is extensible and Lispier. No license specified."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"iterate, the extensible iteration construct  iterate Iterate   Bugs   About Iterate Download Iterate Usage Examples Develop Iterate! Discuss Iterate! About iterate iterate is an iteration construct for Common Lisp. It is similar to the CL:LOOP macro, with these distinguishing marks: it is extensible, it helps editors like Emacs indent iterate forms by having a more lisp-like syntax, and it isn't part of the ANSI standard for Common Lisp (which is sometimes a bad thing and sometimes good). Where to get it The Iterate Manual in PDF The Iterate Manual in browsable HTML Iterate itself Iterate has spent most of its life in the CMU AI archive as a lisp file for pre-ANSI Common Lisps. Some people have adapted it to other implementations, but the most activly maintained version right now is the one you find here. You can get the latest version with darcs (this is the recommended way): darcs get http://common-lisp.net/project/iterate/darcs/iterate You can get it by asdf-install, if you have that installed, via:  CL-USER> (asdf-install:install :iterate)  Several lines of compiler output will come up; you'll be asked if you want to accept my GPG key, if you have gnupg installed, and after that, you have iterate installed. If you don't have ASDF-INSTALL in your lisp, but you have ASDF, you can just grab the latest tarball at http://common-lisp.net/project/iterate/releases/iterate-current.tar.gz and unpack it into a directory, say /home/you/iterate-1.0.4. Make a symbolic link called iterate.asd from your asdf:*central-repository* directory to the file /home/you/iterate-1.0.4/iterate.asd, and you're ready to use iterate. How to make it available to your code If you're using ASDF (highly recommended), have :iterate on the :depends-on list to your system, like this:  (defsystem my-example   :depends-on (:iterate)   :components ((:file ""foo"")))  If you're not using ASDF (not recommended), use code like this in one of the files that use the iterate construct:  (eval-when (:compile-toplevel :load-toplevel :execute)   (require 'iterate))  Some examples ...to highlight the superiority of the iterate construct (-: Finding the longest list in a list of lists:  (iterate (for elt in list-of-lists)          (finding elt maximizing (length elt)))  Whereas with loop (with whose maximizing clause can be used to find the greatest sublist length only), you'd have to use something like:  (loop with max-elt = nil       with max-key = 0       for elt in list-of-lists       for key = (length elt) do       (when (> key max-key)         (setq max-elt elt               max-key key))       finally (return max-elt))  So, which version is clearer? I know which I prefer. (-: Here's another example, using named blocks:  (iter outer (for i below (array-dimension ar 0))             (iter (for j below (array-dimension ar 1))                   (in outer (collect (aref ar i j)))))  A named block in an iterate form lets you perform operations inside the context of that named form from iterate forms nested inside it. So here, in this example, we collect all elements in a two-dimensional array in a flat list. The loop equivalent isn't very nice. You can find more documentation on iterate and its features (there are a lot more than I can demonstrate in this document!) in the doc/ directory in your iterate distribution. Development There is a darcs repository for iterate on common-lisp.net. You can browse the repository or get the tree with the following command line: darcs get *YOUR-USER*@common-lisp.net:/project/iterate/darcs/iterate Bugs, feature suggestions and requests Send those to the Iterate development mailing list at < iterate-devel@common-lisp.net> The current bugs file can be found at the current iterate bugs page. We are looking forward to hearing from you!"	"null"	"null"	"An iteration construct for Common Lisp which is extensible and Lispier. No license specified."	"true"
"Utilities"	"localtime"	"https://common-lisp.net/project/local-time/"	"A development library for manipulating date and time information in a semi-standard manner.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"30"	"6"	"19"	"GitHub - dlowe-net/local-time: Time manipulation library for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 6 Star 30 Fork 19 dlowe-net/local-time Code Issues 3 Pull requests 1 Pulse Graphs Time manipulation library for Common Lisp 406 commits 2 branches 10 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master release Nothing to show v1.0.6 v1.0.5 v1.0.4 local-time-1_0_1 local-time-1_0 before_controversial_changes Before_1_0_refactor 2008-11-27 0_9_2 0_5_0 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. doc src test zoneinfo-leaps zoneinfo .gitignore COPYING CREDITS INSTALL README TODO cl-postgres+local-time.asd local-time.asd local-time.test.asd README 							  LOCAL-TIME  See the ""COPYING"" file for information about legal issues of copying and using this library.  See the ""INSTALL"" file for information about building and installing this library.  The LOCAL-TIME library is a Common Lisp library for the manipulation of dates and times.  It is based almost entirely upon Erik Naggum's paper ""The Long Painful History of Time"".  Related projects of interest:  * https://github.com/enaeher/local-time-duration  * http://common-lisp.net/projects/cl-l10n/  See the manual/ directory for more information and/or the website at http://common-lisp.net/project/local-time/  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/dlowe-net/local-time"	"A development library for manipulating date and time information in a semi-standard manner.."	"true"
"Utilities"	"log4cl"	"https://github.com/7max/log4cl"	"Logging framework modelled after Log4J.."	"null"	"null"	"null"	"Apache2.0"	"http://directory.fsf.org/wiki/License:Apache2.0"	"null"	"null"	"63"	"16"	"15"	"GitHub - 7max/log4cl: Common Lisp logging framework, modeled after Log4J Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 16 Star 63 Fork 15 7max/log4cl Code Issues 16 Pull requests 4 Wiki Pulse Graphs Common Lisp logging framework, modeled after Log4J 302 commits 3 branches 5 releases 2 contributors Common Lisp 87.6% Emacs Lisp 12.2% Java 0.2% Common Lisp Emacs Lisp Java Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master ng stable Nothing to show working v1.1.2 v1.1.0 v1.0.0 v0.9.2 Nothing to show New pull request Latest commit d6293f9 Sep 22, 2013 Max Mikhanosha Fix Emacs lockup if mouse clicking in REPL with REPL thread busy Permalink Failed to load latest commit information. elisp Fix Emacs lockup if mouse clicking in REPL with REPL thread busy Sep 22, 2013 examples Adding docs May 17, 2013 images Adding docs May 17, 2013 src Fix slight format string typo in CALL-WITH-LOGGED-PROBLEMS Sep 2, 2013 tests Fix issue #14: accept pathnames in :daily file name Jun 18, 2013 .gitignore Added emacs style backup files Dec 15, 2011 LICENSE Added Apache 2.0 license Feb 26, 2012 NEWS.md Markdown was eating formatting Sep 2, 2013 NOTICE Added Apache 2.0 license Feb 26, 2012 README.md Update documentation to reflect the fact that QuickLisp now pulls the… Jul 3, 2013 README.org Update documentation to reflect the fact that QuickLisp now pulls the… Jul 4, 2013 log4cl-examples.asd Update the NEWS file and bump version to 1.1.2 Sep 2, 2013 log4cl.asd Update the NEWS file and bump version to 1.1.2 Sep 2, 2013 log4slime.asd Update the NEWS file and bump version to 1.1.2 Sep 2, 2013 README.md Introduction NOTE - Because of some mishap with QuickLisp, June 2013 QuickLisp distribution pulled the master branch of Log4CL instead of stable branch as intended. Very few incompatibilities been reported, and it makes no sense to downgrade version that been already available in QuickLisp, therefore QuickLisp will continue to pull the master branch from now on. The major difference of Log4CL 1.1.x version from 1.0.x is the Emacs/Slime integration module, called Log4Slime. This document is written with assumption that you will have Log4Slime loaded and enabled in Emacs. Installation Log4CL is available from QuickLisp. To load it use (ql:quickload :log4cl) command from REPL. Log4Slime is available in QuickLisp since June 2013. Enabling Log4Slime (ql:quickload :log4slime) (log4slime:install) You should get a message like this: Wrote ~/quicklisp/log4slime-setup.el  Add the following two statements to your ~/.emacs file ------------------------------------------------------ (load ""~/quicklisp/log4slime-setup.el"") (global-log4slime-mode 1) ------------------------------------------------------  Follow the above instructions. The most likely point of failure here may be log4slime.el trying to poke the Lisp side to see if log4slime is loaded, and that for some reason it fails. If it fails, there should be a message in *Messages* buffer, that looks like this: Unable to load log4slime lisp support: <lisp side condition> In case you did get the above message and you think you fixed the cause, you can make log4slime try again, by turning M-x global-log4slime-mode off/on a few times You can verify if log4slime is enabled, by looking for the Log4CL menu on top menubar in REPL and Lisp mode buffers, or by submitting a log statement from REPL and seeing output colorized. Hello world (progn   (log:info ""I just ate a ~5f, feeling tired"" pi)    (when (log:debug)     (dotimes (sheep 3)       (log:debug sheep ""zzz"")))   (log:warn ""doh fell asleep for"" (random 10) ""minutes"")) Should produce the following output You can notice several things right away. You can intermix strings and expressions, and expressions will be printed as their un-evaluated form as well as the their value; using a constant FORMAT control string as first argument automatically switches to FORMAT mode. Log statements without arguments, turn into conditional expression that tells you if logging is enabled or not The log output contains some headers in addition to the raw log message, such as the log level that message was submitted with, the time of the message as well as what looks like the name of the current package, and (If you have Log4Slime loaded and turned on), these headers use different faces from actual log message. Changing the log level You can change the log level with by doing (log:config :debug) from REPL. Alternatively, with Log4Slime enabled in REPL buffer, you can right-click on the cl-user part and change the log level from a popup menu. There is a slight difference between doing it using above two methods, with log:config command, the level is changed for the ROOT category, but right clicking on the package name, changes the log level only for that package. To change the ROOT category from Emacs, you can use Log4CL dropdown submenu, or Emacs command log4slime-level-selection which is bound to C-c C-g by default. After pressing C-c C-g which invokes the log4slime-level-selection command you get the following window. Pressing ""p"" to select the package category shows effective log level and allows you to change like so This concludes the very basic introduction, if you were confused by what various terms such as ""category"" mean, click on the hyperlink to read more about Log4CL concepts. Or you can skip the theory and just continue to learn by example. Automatic category naming Try putting the from the previous section into a DEFUN instead of a PROGN form like so: (defun hello ()   (log:info ""I just ate a ~5f, feeling tired"" pi)    (when (log:debug)     (dotimes (sheep 3)       (log:debug sheep ""zzz"")))   (log:warn ""doh fell asleep for"" (random 10) ""minutes"")) If you run it now, the output under both SBCL and CCL should look like this. Right click on the blue function name, allows you to change the log level for that specific function. That is because Log4CL logging macros, automatically determine the category for logging, based on the context where log statement appears. In above example the function was defined in the package CL-USER and function name was HELLO, so the target category of any logging inside the function, was automatically CL-USER.HELLO It starts with the package, then function. You can try putting one of the log statements inside of a LABELS or FLET forms, to see what happens. Also note the farthest to the right in the logging category name, the more specific. The level for ""hello"" overrides that for ""cl-user"", which in turn overrides that of the root category. Naming in source files For the next few examples, it is recommended that you load the examples come together with Log4CL, by doing (ql:quickload :log4cl-examples) It should produce the following output: One thing you should notice, is that source file where function is defined now appears as part of the log message too. Go to the source of ""greetings"". Before you try to use Slime's famous M-. shortcut, try clicking on blue ""greetings"" word with a left mouse button. If everything went better then expected, it should land you at the first log statement of the (defun greetings ()). Cool eh? Naming in CLOS methods Quickly browse through naming-examples.lisp. There are a few methods defined, including :after/:around methods, as well as some with EQL specializers. Run a few of them from REPL, like so: Log statements inside of methods, are using the category name of the generic function, extended with qualifier, and all non-T specializers. Try going to the source of the above methods by clicking on them. It should land in the right method, without showing Slime's XREF window. Note how by changing the level of the foobar you control all the methods, but can override them based on their specializers. Try setting :after category to different levels, to control all the :after methods together. In addition to playing with methods, try (setf (test.package.one:greetings) ""Hey"") too. Context sensitivity As you browse through source, and are inside of one of the methods, check out the Log4CL dropdown menu. Note that ""Defun"" submenu changes for each method. Keyboard level selection Also try C-c C-g shortcut in the same place. You can configure it not to show the selection window at all, by customizing the log4slime-level-selection-single-key Emacs variable. After pressing C-c C-g while inside of the method You can change keys for the selecting various levels by doing M-x customize-group RET log4slime RET Note that keyboard selection ignores the Control key so C-c C-g p u is same as C-c C-g C-p C-u Resetting the mess If you had forgotten which levels you set for what, and just want to see which levels are set where. You can display current logging configuration by doing (log:config) without any arguments, it willdisplay a tree If you have had set a lot of custom levels, and now need to get rid of them, ""Reset Children"" menu item will nukes the log level from everything underneath the parent. Doing ""Reset Children"" on the ROOT category, gets rid of every other log level that was set anywhere. Keyboard equivalent is C-c C-g r Logging configurations After setting the log levels of a few methods, try doing (log:save :foo) then messing around.. You can restore the named configuration with (log:restore :foo). Configurations are saved in a file in the home directory, so they survive image restarts See the Finding needle in a haystack section. The magic of (LOG:CONFIG) Section To be written, for now simply see docstring for LOG:CONFIG Read the docstring and play with options, below are a few examples: Pattern Layout Section to be written, for now see docstring for docstring for PATTERN-LAYOUT Common Practices Some common recipes. Log levels for production Generally log levels INFO and below, are used in normal operations of software, while levels higher then INFO are used by programmers. FATAL is used for un-recoverable errors, that require restart of an application or major component, the FATAL messages are to inform the user that something had died in a way that should not normally happen. ERROR is for serious but generally recoverable errors, that occur doing a normal operation of software. File not found, or such. WARN is for ""suspicious"" things, or to inform the user that some automatic corrective action had failed. Maximum number of retries reached or such. INFO is for informing on major steps that software is performing, and is usually thought of the maximum log level used in normal operations, its ""Say what you are doing but don't flood"" type of messages. By default Log4CL is configured with root category having INFO log level. Log levels for development DEBUG is for for informing about detailed steps taken by operations and printing intermediate values. TRACE is for very detailed debugging, like printing variables inside loops and such. DEBU1..DEBU9 log levels are numerically around the TRACE and can be used if you need more granularity. One possibility is that (log:expr) macro, can be configured via LOG:PACKAGE-OPTIONS mechanism, to use different log level then DEBUG and can set to use one of the extra levels. OFF log level is very important counter-part for DEBUG and TRACE. Its used for ""narrowing things down in reverse"", which is described in the next section Finding needle in a haystack Programmers often need to concentrate on a specific area of their software. With traditional non-hierarchical logging system, having a lot of debug sprinkled around the code, flood the programmers with a lot of information they don't need, and makes it hard to find the messages relevant to the problem being debugged. Because Log4CL is hierarchical, its easy to narrow down the logging, to focus on exactly the right area, by using the following process. Turn DEBUG on for the root category, or entire package and then run your code through the functionality that you are focusing on. REPL will fill with a lot of debugging output. Right-click on each message that is not related to a problem, and turn the corresponding category OFF. You can how go wide or narrow, turn off entire packages or source files, or by individual methods, functions or local functions. If you went too far, use Reset children command on the parent category. If you use CLOS, use the category hierarchy to your advantage, if for example you think problem relates to before or after method, you can can control logging for all :AFTER methods of generic function by clicking :after category in (<gf name> :after <specializer> ...) Once you narrowed down the logging to your liking, you can quickly save that configuration of log levels with (LOG:SAVE), and later (may be in a different image, or even different machine) restore it with (LOG:RESTORE), and you can give these saved configuration names, such as (LOG:SAVE :bug-123) Glossary Very small glossary of Log4CL concepts Loggers and categories Loggers are named singleton objects that form a hierarchy, and are sources of log messages, or more correctly entry points where log message enter the logging system. Each call to a logging macro like (log:debug ...) operates on a specific logger object (See also naming section). Logger's unique name is called ""logger's category"", or ""category name"". Loggers form a hierarchy, based on their category names, where child loggers have their category name prefixed by that of the parent, followed by a dot. So if we have loggers A, A.B, A.B.C and A.B.D then logger A is parent of A.B, which has two children A.B.C and A.B.D - as shown on below diagram. (Note: ROOT logger category name is empty string) ROOT---A---A.B---A.B.C              |              \---A.B.D  Because loggers are singletons, logger category name is usually shortened to just CATEGORY and is used inter-changeably with the word LOGGER; the convention is that thing is ""a logger"" when talking about actual Lisp object, and ""category"" otherwise. Each logger can have a log level threshold, or if its does not have one, it inherits one from its parent. To ensure that for any logger, an effective log level can be determined, the ROOT logger always have a level. Loggers will only pass through messages, if logger's threshold level is equal or greater verbosity, then log message. For example if in above example logger A is configured with info log level, then (log:warn ...) and (log:info) messages will be passed through, but (log:debug) messages would not. Appenders Appenders process log messages by writing them to files, or displaying them on the screen. Appenders attach to a specific logger, and each logger can have many appenders attached. When a log message passes through a logger that has appenders, they are all called in turn to do appender specific processing, be it writing log message to a file, or a terminal. After all of logger's appenders had processed the message, its passed on to the parent logger. So log messages inheritance flows in reverse order from the log level one, tricking up from child loggers towards root, with below exception. Each logger has a property called additivity, which is T by default, which controls the above process. When additivity is NIL, logger is called non-additive and any messages that reach it, will not be passed to the parents. Usually only root logger, or non non-additive loggers will have any appenders attached to them. Layouts When appender decide they want to process the log message, they format the log message by means of a layout. Layout is a separate object, that attaches to each appender, and is responsible for the textual formatting of the message. So while appender provides and manages any serialization for the stream to write to, the layout is actually formatting the log message into that stream. Log4CL provides two layouts, SIMPLE-LAYOUT which is well, simple, and a very configurable PATTERN-LAYOUT, which specifies the formatting of log messages by mean of printf/format like control string. Easiest way to use the pattern layout, is by using LOG:CONFIG command to select between several predefined formats. Or you can look for list of all supported format documentation for the PATTERN-LAYOUT class. Please note that if you are drafting your own format, that Log4SLime fontification relies on regular expressions and the log messages being in a certain order. If your layout is not a minor modification of an built-in one, the Log4Slime fontification may stop working. You can of course adjust the regular expressions used by Log4Slime to match your own custom layout to compensate. Log Levels In Log4CL log levels are numeric constants, in order of increased verbosity: Turn off logging 0=OFF Standard log levels 1=FATAL, 2=ERROR, 3=WARN, 4=INFO, 5=DEBUG Extra debug levels 6..9 named DEBU1 through DEBU4 Standard log level 10=TRACE Extra debug level 11..15 named DEBU5 through DEBU9 Effective log level Effective log level of the logger X is determined as follows. If logger has level threshold set, then this level is the effective log level. If logger is not first child of a parent, whose category is same as the package name logger was instantiated from, the effective log level of X is the effective log level of its parent logger. If logger is first child of a parent P named same as package, and there exists a sibling logger S, with the last part of category name equal to that of a source file logger X was instantiated from, and S has a level threshold set, that level is effective level of logger X Otherwise effective level of logger X is effective level of its parent. ROOT logger always has a level threshold set, so above steps always result in a valid log level. Effective log level is returned by the function (log4cl:effective-log-level LOGGER) FAQ I don't see log messages from other threads. The *TERMINAL-IO* value bound in the other threads is probably different and points to other place (likely *inferior-lisp* buffer under Slime) (log:config :sane2) will copy messages from other threads to REPL while continuing output to thread specific *TERMINAL-IO* (REPL thread will still only log to REPL) (log:config :sane :this-console) will redirect all logging to current console regardless of thread local values of *TERMINAL-IO* Why Log4CL starts its own thread, and how I get rid of it Its a flusher thread to flush the appenders, it increases performance greatly when there is a lot of logging.oe You can stop it by calling (log4cl:stop-hierarchy-watcher-thread) On SBCL Log4CL uses *EXIT-HOOKS* and *SAVE-HOOKS* to automatically flush all appenders on exit, so that last second of logging is not lost, and to terminate the watcher thread when saving image, which can't be done with multiple threads running. I'd like just the log messages, and not all the extra stuff Use pattern layout with just %m%n format (message + newline) How do I log into a file (log:config :daily ""file.txt"") which will be backed up each day to file.txt.YYYYMMDD I want both log file and backup log file to have YYYYMMDD prefix or roll once per week (log:config :daily ""file.txt.%Y%m%d"") file will roll when %Y%m%d expansion changes. What about just one plain file, without rolling (log:config :daily ""file.txt"" :backup nil) Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/7max/log4cl"	"Logging framework modelled after Log4J.."	"true"
"Utilities"	"mixalot"	"https://github.com/ahefner/mixalot"	"A loosely-coupled collection of audio libraries. No license specified."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"19"	"7"	"5"	"GitHub - ahefner/mixalot: Loosely-coupled collection of audio libraries in Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 19 Fork 5 ahefner/mixalot Code Issues 0 Pull requests 0 Pulse Graphs Loosely-coupled collection of audio libraries in Common Lisp http://vintage-digital.com/hefner/software/mixalot/mixalot.html 76 commits 1 branch 3 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v0.0.2 v0.0.2a v0.0.1 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. doc .gitignore NEWS ffi-common.lisp flac-grovelling-metadata.lisp flac-grovelling.lisp flac-metadata.lisp flac-package.lisp flac-stream.lisp flac.asd flac.lisp mixalot-flac.asd mixalot-mp3.asd mixalot-vorbis.asd mixalot.asd mixalot.lisp mp3-stream.lisp mpg123-ffi.asd mpg123.lisp sndfile.lisp strings-common.lisp vorbis-stream.lisp vorbisfile-ffi.asd vorbisfile-grovelling.lisp vorbisfile-package.lisp vorbisfile.lisp Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/ahefner/mixalot"	"A loosely-coupled collection of audio libraries. No license specified."	"true"
"Utilities"	"named-readtables"	"https://github.com/melisgl/named-readtables"	"Provides a readtable namespace, akin to package namespaces.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"9"	"1"	"6"	"GitHub - melisgl/named-readtables: The official repo of named-readtables. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 1 Star 9 Fork 6 melisgl/named-readtables forked from kmizumar/named-readtables Code Issues 2 Pull requests 1 Pulse Graphs The official repo of named-readtables. 71 commits 1 branch 1 release Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show 0.9 Nothing to show New pull request #8 Compare This branch is 15 commits ahead of kmizumar:master. Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. doc src test .gitignore LICENSE README README.md named-readtables.asd README.md Named Readtables Manual Table of Contents 1 named-readtables ASDF System Details 2 Introduction 2.1 Links 2.2 Acknowledgements 3 Overview 3.1 Notes on the API 3.2 Important API idiosyncrasies 3.3 Preregistered Readtables 3.4 Examples 4 Reference [in package EDITOR-HINTS.NAMED-READTABLES] 1 named-readtables ASDF System Details Version: 0.9 Description: Library that creates a namespace for named readtable akin to the namespace of packages. Licence: BSD, see LICENSE Author: Tobias C. Rittweiler trittweiler@common-lisp.net Maintainer: Gábor Melis Mailto: mega@retes.hu 2 Introduction Named-Readtables is a library that provides a namespace for readtables akin to the already-existing namespace of packages. In particular: you can associate readtables with names, and retrieve readtables by names; you can associate source files with readtable names, and be sure that the right readtable is active when compiling/loading the file; similiarly, your development environment now has a chance to automatically determine what readtable should be active while processing source forms on interactive commands. (E.g. think of C-c C-c in Slime (yet to be done)) It follows that Named-Readtables is a facility for using readtables in a localized way. Additionally, it also attempts to become a facility for using readtables in a modular way. In particular: it provides a macro to specify the content of a readtable at a glance; it makes it possible to use multiple inheritance between readtables. 2.1 Links Here is the official repository and the HTML documentation for the latest version. 2.2 Acknowledgements Thanks to Robert Goldman for making me want to write this library. Thanks to Stephen Compall, Ariel Badichi, David Lichteblau, Bart Botta, David Crawford, and Pascal Costanza for being early adopters, providing comments and bugfixes. 3 Overview 3.1 Notes on the API The API heavily imitates the API of packages. This has the nice property that any experienced Common Lisper will take it up without effort. DEFREADTABLE              -   DEFPACKAGE  IN-READTABLE              -   IN-PACKAGE  MERGE-READTABLES-INTO     -   USE-PACKAGE  MAKE-READTABLE            -   MAKE-PACKAGE  UNREGISTER-READTABLE      -   DELETE-PACKAGE  RENAME-READTABLE          -   RENAME-PACKAGE  FIND-READTABLE            -   FIND-PACKAGE  READTABLE-NAME            -   PACKAGE-NAME  LIST-ALL-NAMED-READTABLES -   LIST-ALL-PACKAGES  3.2 Important API idiosyncrasies There are three major differences between the API of Named-Readtables, and the API of packages. Readtable names are symbols not strings. Time has shown that the fact that packages are named by strings causes severe headache because of the potential of package names colliding with each other. Hence, readtables are named by symbols lest to make the situation worse than it already is. Consequently, readtables named CL-ORACLE:SQL-SYNTAX and CL-MYSQL:SQL-SYNTAX can happily coexist next to each other. Or, taken to an extreme, SCHEME:SYNTAX and ELISP:SYNTAX. If, for example to duly signify the importance of your cool readtable hack, you really think it deserves a global name, you can always resort to keywords. The inheritance is resolved statically, not dynamically. A package that uses another package will have access to all the other package's exported symbols, even to those that will be added after its definition. I.e. the inheritance is resolved at run-time, that is dynamically. Unfortunately, we cannot do the same for readtables in a portable manner. Therefore, we do not talk about ""using"" another readtable but about ""merging"" the other readtable's definition into the readtable we are going to define. I.e. the inheritance is resolved once at definition time, that is statically. (Such merging can more or less be implemented portably albeit at a certain cost. Most of the time, this cost manifests itself at the time a readtable is defined, i.e. once at compile-time, so it may not bother you. Nonetheless, we provide extra support for Sbcl, ClozureCL, and AllegroCL at the moment. Patches for your implementation of choice are welcome, of course.) DEFREADTABLE does not have compile-time effects. If you define a package via DEFPACKAGE, you can make that package the currently active package for the subsequent compilation of the same file via IN-PACKAGE. The same is, however, not true for DEFREADTABLE and IN-READTABLE for the following reason: It's unlikely that the need for special reader-macros arises for a problem which can be solved in just one file. Most often, you're going to define the reader macro functions, and set up the corresponding readtable in an extra file. If DEFREADTABLE had compile-time effects, you'd have to wrap each definition of a reader-macro function in an EVAL-WHEN to make its definition available at compile-time. Because that's simply not the common case, DEFREADTABLE does not have a compile-time effect. If you want to use a readtable within the same file as its definition, wrap the DEFREADTABLE and the reader-macro function definitions in an explicit EVAL-WHEN. 3.3 Preregistered Readtables NIL, :STANDARD, and :COMMON-LISP designate the standard readtable. :MODERN designates a case-preserving standard-readtable. :CURRENT designates the current readtable. 3.4 Examples (defreadtable elisp:syntax    (:merge :standard)    (:macro-char #\? #'elisp::read-character-literal t)    (:macro-char #\[ #'elisp::read-vector-literal t)    ...    (:case :preserve))  (defreadtable scheme:syntax    (:merge :standard)    (:macro-char #\[ #'(lambda (stream char)                          (read-delimited-list #\] stream)))    (:macro-char #\# :dispatch)    (:dispatch-macro-char #\# #\t #'scheme::read-#t)    (:dispatch-macro-char #\# #\f #'scheme::read-#f)    ...    (:case :preserve))  (in-readtable elisp:syntax)  ...  (in-readtable scheme:syntax)  ...  4 Reference [macro] DEFREADTABLE NAME &BODY OPTIONS Define a new named readtable, whose name is given by the symbol NAME. Or, if a readtable is already registered under that name, redefine that one. The readtable can be populated using the following OPTIONS: (:MERGE READTABLE-DESIGNATORS+) Merge the readtables designated into the new readtable being defined as per MERGE-READTABLES-INTO. If no :MERGE clause is given, an empty readtable is used. See MAKE-READTABLE. (:FUSE READTABLE-DESIGNATORS+) Like :MERGE except: Error conditions of type READER-MACRO-CONFLICT that are signaled during the merge operation will be silently continued. It follows that reader macros in earlier entries will be overwritten by later ones. For backward compatibility, :FUZE is accepted as an alias of :FUSE. (:DISPATCH-MACRO-CHAR MACRO-CHAR SUB-CHAR FUNCTION) Define a new sub character SUB-CHAR for the dispatching macro character MACRO-CHAR, per SET-DISPATCH-MACRO-CHARACTER. You probably have to define MACRO-CHAR as a dispatching macro character by the following option first. (:MACRO-CHAR MACRO-CHAR FUNCTION [NON-TERMINATING-P]) Define a new macro character in the readtable, per SET-MACRO-CHARACTER. If FUNCTION is the keyword :DISPATCH, MACRO-CHAR is made a dispatching macro character, per MAKE-DISPATCH-MACRO-CHARACTER. (:SYNTAX-FROM FROM-READTABLE-DESIGNATOR FROM-CHAR TO-CHAR) Set the character syntax of TO-CHAR in the readtable being defined to the same syntax as FROM-CHAR as per SET-SYNTAX-FROM-CHAR. (:CASE CASE-MODE) Defines the case sensitivity mode of the resulting readtable. Any number of option clauses may appear. The options are grouped by their type, but in each group the order the options appeared textually is preserved. The following groups exist and are executed in the following order: :MERGE and :FUSE (one group), :CASE, :MACRO-CHAR and :DISPATCH-MACRO-CHAR (one group), finally :SYNTAX-FROM. Notes: The readtable is defined at load-time. If you want to have it available at compilation time -- say to use its reader-macros in the same file as its definition -- you have to wrap the DEFREADTABLE form in an explicit EVAL-WHEN. On redefinition, the target readtable is made empty first before it's refilled according to the clauses. NIL, :STANDARD, :COMMON-LISP, :MODERN, and :CURRENT are preregistered readtable names. [macro] IN-READTABLE NAME Set *READTABLE* to the readtable referred to by the symbol NAME. [function] MAKE-READTABLE &OPTIONAL (NAME NIL NAME-SUPPLIED-P) &KEY MERGE Creates and returns a new readtable under the specified NAME. MERGE takes a list of NAMED-READTABLE-DESIGNATORS and specifies the readtables the new readtable is created from. (See the :MERGE clause of DEFREADTABLE for details.) If MERGE is NIL, an empty readtable is used instead. If NAME is not given, an anonymous empty readtable is returned. Notes: An empty readtable is a readtable where each character's syntax is the same as in the standard readtable except that each macro character has been made a constituent. Basically: whitespace stays whitespace, everything else is constituent. [function] MERGE-READTABLES-INTO RESULT-READTABLE &REST NAMED-READTABLES Copy the contents of each readtable in NAMED-READTABLES([0][] 1) into RESULT-READTABLE. If a macro character appears in more than one of the readtables, i.e. if a conflict is discovered during the merge, an error of type READER-MACRO-CONFLICT is signaled. [function] FIND-READTABLE NAME Looks for the readtable specified by NAME and returns it if it is found. Returns NIL otherwise. [function] ENSURE-READTABLE NAME &OPTIONAL (DEFAULT NIL DEFAULT-P) Looks up the readtable specified by NAME and returns it if it's found. If it is not found, it registers the readtable designated by DEFAULT under the name represented by NAME; or if no default argument is given, it signals an error of type READTABLE-DOES-NOT-EXIST instead. [function] RENAME-READTABLE OLD-NAME NEW-NAME Replaces the associated name of the readtable designated by OLD-NAME with NEW-NAME. If a readtable is already registered under NEW-NAME, an error of type READTABLE-DOES-ALREADY-EXIST is signaled. [function] READTABLE-NAME NAMED-READTABLE Returns the name of the readtable designated by NAMED-READTABLE, or NIL. [function] REGISTER-READTABLE NAME READTABLE Associate READTABLE with NAME. Returns the readtable. [function] UNREGISTER-READTABLE NAMED-READTABLE Remove the association of NAMED-READTABLE. Returns T if successfull, NIL otherwise. [function] COPY-NAMED-READTABLE NAMED-READTABLE Like COPY-READTABLE but takes a NAMED-READTABLE-DESIGNATOR as argument. [function] LIST-ALL-NAMED-READTABLES Returns a list of all registered readtables. The returned list is guaranteed to be fresh, but may contain duplicates. [type] NAMED-READTABLE-DESIGNATOR Either a symbol or a readtable itself. [condition] READER-MACRO-CONFLICT READTABLE-ERROR Continuable. This condition is signaled during the merge process if a reader macro (be it a macro character or the sub character of a dispatch macro character) is present in the both source and the target readtable and the two respective reader macro functions differ. [condition] READTABLE-DOES-ALREADY-EXIST READTABLE-ERROR Continuable. [condition] READTABLE-DOES-NOT-EXIST READTABLE-ERROR [generated by MGL-PAX] Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/melisgl/named-readtables"	"Provides a readtable namespace, akin to package namespaces.."	"true"
"Utilities"	"osicat"	"https://common-lisp.net/project/osicat/"	"A lightweight operating system interface on POSIX-like systems.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"30"	"7"	"8"	"GitHub - osicat/osicat: Osicat is a lightweight operating system interface for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 7 Star 30 Fork 8 osicat/osicat Code Issues 2 Pull requests 0 Pulse Graphs Osicat is a lightweight operating system interface for Common Lisp 156 commits 1 branch 1 release Fetching contributors Common Lisp 98.1% Shell 1.9% Common Lisp Shell Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v0.7.0 Nothing to show New pull request Latest commit fec20a1 Apr 11, 2016 luismbo committed with luismbo Don't exit %OPEN-TEMPORARY-FILE/NO-FD-STREAMS unconditionally … Fixes issue #13. Permalink Failed to load latest commit information. doc Add support for posix_fallocate Feb 1, 2016 mach Fix for OSX. Apr 16, 2008 posix Explicitely use structs in grovel definition Apr 11, 2016 scripts scripts/release.sh: use ""vx.x.x"" tag format Dec 23, 2014 src Don't exit %OPEN-TEMPORARY-FILE/NO-FD-STREAMS unconditionally Apr 11, 2016 tests Fix missing logior in open for fallocate.error.1 test Feb 3, 2016 windows Port to CFFI, integrate CL-POSIX as OSICAT-POSIX, and more. Aug 6, 2007 .gitignore more comprehensive .gitignore May 28, 2011 .travis.yml Pass -y to apt-get install in .travis.yml Feb 1, 2016 LICENSE Initial revision Oct 15, 2003 README.md Add Travis CI setup Dec 23, 2014 TODO Port to CFFI, integrate CL-POSIX as OSICAT-POSIX, and more. Aug 6, 2007 osicat-tests.asd Add Travis CI setup Dec 23, 2014 osicat.asd kludges to get Osicat to load Windows Jun 18, 2015 README.md Osicat is a lightweight operating system interface for Common Lisp on Unix-platforms. It is not a POSIX-style API, but rather a simple lispy accompaniment to the standard ANSI facilities. Osicat homepage: http://www.common-lisp.net/project/osicat/ Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/osicat/osicat"	"A lightweight operating system interface on POSIX-like systems.."	"true"
"Utilities"	"Parenscript"	"https://github.com/vsedach/Parenscript"	"A translator from Common Lisp to Javascript.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"144"	"18"	"25"	"GitHub - vsedach/Parenscript: Official Parenscript repository: http://common-lisp.net/project/parenscript/ Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 18 Star 144 Fork 25 vsedach/Parenscript Code Issues 6 Pull requests 3 Pulse Graphs Official Parenscript repository: http://common-lisp.net/project/parenscript/ 787 commits 1 branch 1 release Fetching contributors Common Lisp 99.1% Emacs Lisp 0.9% Common Lisp Emacs Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v2.6 Nothing to show New pull request Latest commit bc3ba1d Mar 17, 2016 jasom Merge pull request #28 from TatriX/master … Create README.md Permalink Failed to load latest commit information. docs Moved swank-parenscript.lisp to extras and added note about it in ref… Sep 22, 2012 extras Moved swank-parenscript.lisp to extras and added note about it in ref… Sep 22, 2012 runtime Fixed up bogus returns in ps-runtime-lib. May 4, 2011 src Additions to 116f9ca, to not replace Φ() with Φ.call(this) unless Φ r… Jun 9, 2015 t Additions to 116f9ca, to not replace Φ() with Φ.call(this) unless Φ r… Jun 9, 2015 .boring Escape { and } chars in boring regexps Nov 7, 2005 .gitignore Add common fasl suffixes to new file .gitignore Apr 8, 2010 COPYING Added README file Oct 27, 2013 README Added README file Oct 27, 2013 README.md Update README.md Mar 17, 2016 contributors Fixed bug with quoted symbol arguments to CREATE (thanks to Russell S… Jul 27, 2012 parenscript.asd Added :description to asd files Oct 10, 2012 parenscript.test.asd Added :description to asd files Oct 10, 2012 README.md What is Parenscript? Parenscript is a translator from an extended subset of Common Lisp to JavaScript. Parenscript code can run almost identically on both the browser (as JavaScript) and server (as Common Lisp). Parenscript code is treated the same way as Common Lisp code, making the full power of Lisp macros available for JavaScript. This provides a web development environment that is unmatched in its ability to reduce code duplication and provide advanced metaprogramming facilities to web developers. Installation (ql:quickload :parenscript) or download the latest release Documentation Reference Manual Tutorial What's the difference? Parenscript is different from almost all other ""language X"" to JavaScript translators in that it imposes almost no overhead: No runtime dependencies Any piece of Parenscript code is runnable as-is. There are no JavaScript files to include. Native types Parenscript works entirely with native JavaScript datatypes. There are no new types introduced, and object prototypes are not touched. Native calling convention Any JavaScript code can be called without the need for bindings. Likewise, Parenscript can be used to make efficient, self-contained JavaScript libraries. Readable code Parenscript generates concise, formatted, idiomatic JavaScript code. Identifier names are preserved. This enables seamless debugging in tools like Firebug. Efficiency Parenscript introduces minimal overhead for advanced Common Lisp features. The generated code is almost as fast as hand-written JavaScript. Links Web site Source repository License BSD (see COPYING file) Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/vsedach/Parenscript"	"A translator from Common Lisp to Javascript.."	"true"
"Utilities"	"parse-js"	"http://marijnhaverbeke.nl/parse-js/"	"A package for parsing ECMAScript 3.."	"null"	"null"	"null"	"zlib"	"http://directory.fsf.org/wiki/License:Zlib"	"null"	"null"	"null"	"null"	"null"	"parse-js / A JavaScript parser parse-js parse-js is a Common Lisp package for parsing JavaScript — ECMAScript 3, to be more precise. It is released under a zlib-style licence. For any feedback, contact me: Marijn Haverbeke. The library can be downloaded, checked out from the git repository, or installed with asdf-install. News 07-02-2013: New release. More corner-case bugs fixed. Representation of for-in nodes changed to accomodate things like for (x.y in z). Array element expressions may now be nil, when parsing a literal like [1,,3]. 03-01-2011: New release. Lots of conformance fixes, driven by CL-JavaScript and UglifyJS work. parse-js-string is deprecated now (parse-js accepts strings), and basic support for ECMAScript 5 has been added. 11-06-2010: Move from darcs to git for version control, update release tarball. Reference function parse-js (input &key ecma-version strict-semicolons reserved-words) → syntax-tree Reads a program from a string or a stream, and produces an abstract syntax tree, which is a nested structure consisting of lists starting with keywords. The exact format of this structure is not very well documented, but the file as.txt gives a basic description. The keyword arguments can be used to influence the parsing mode. emca-version can be 3 or 5, and influences the standard that is followed. The default is 3. Support for version 5 is incomplete at this time. When strict-semicolons is true, the parser will complain about missing semicolons, even when they would have been inserted by 'automatic semicolon insertion' rules. Finally, if reserved-words is true, the parser will complain about 'future reserved words', such as class being used. class js-parse-error The type of errors raised when invalid input is encountered. Inherits from simple-error, and has js-parse-error-line and js-parse-error-char accessors that can be used to read the location at which the error occurred. function lex-js (stream) → function A JavaScript tokeniser. The function returned can be called repeatedly to read the next token object. See below for a description of these objects. When the end of the stream is reached, tokens with type :eof are returned. function token-type (token) → keyword Reader for the type of token objects. Types are keywords (one of :num :punc :string :operator :name :atom :keyword :eof). function token-value (token) → value Reader for the content of token objects. The type of this value depends on the type of the token ― it holds strings for names, for example, and numbers for number tokens. function token-line (token) → number The line on which a token was read. function token-char (token) → number The character at which a token starts."	"null"	"null"	"A package for parsing ECMAScript 3.."	"true"
"Utilities"	"quicksearch"	"https://github.com/tkych/quicksearch"	"Look up online libraries from the REPL.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"18"	"3"	"2"	"GitHub - tkych/quicksearch: Search Engine Interface for Common Lisp. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 18 Fork 2 tkych/quicksearch Code Issues 1 Pull requests 0 Pulse Graphs Search Engine Interface for Common Lisp. http://tkych.github.io/quicksearch/ 34 commits 2 branches 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Latest commit fb02ecf Apr 13, 2014 tkych Fix Bug: A string is given to octetes-to-string. … This bug was found and fixed by g000001, thanks! c.f. http://g000001.cddddr.org/3606044400 . Permalink Failed to load latest commit information. CHANGELOG LICENSE README.md Fix Bug: A string is given to octetes-to-string. Apr 13, 2014 quicksearch.asd Added: quickdocs-url into quicklisp-search results description. Aug 17, 2013 quicksearch.lisp Fix Bug: A string is given to octetes-to-string. Apr 13, 2014 README.md Last modified: 2014-04-13 12:00:30 tkych Version: 0.01.04 (beta) Quicksearch Quicksearch is a search-engine-interface for Common Lisp. The goal of Quicksearch is to find the CL library quickly. For example, if you will find the library about json, just type (qs:? 'json) at REPL. The function quicksearch searches for CL projects in Quicklisp, Cliki, GitHub and BitBucket, then outputs results in REPL. The function ? is abbreviation wrapper for quicksearch. Depends-on bordeaux-threads iterate alexandria anaphora cl-ppcre drakma html-entities yason flexi-streams do-urlencode Installation cl-test-grid results: http://common-lisp.net/project/cl-test-grid/library/quicksearch.html Auto: CL-REPL> (ql:quickload :quicksearch) Manual: SHELL$ git clone https://github.com/tkych/quicksearch.git CL-REPL> (push #p""/path-to-quicksearch/quicksearch/"" asdf:*central-registry*) CL-REPL> (ql:quickload :quicksearch) or (asdf:load-system :quicksearch) Examples Null result: CL-REPL> (qs:? ""supercalifragilisticexpialidocious"") ;<=> (qs:quicksearch ""supercalifragilisticexpialidocious"") NIL  If it raises a threading error, probably your CL system might be not support threads. In this case, please type (qs:config :threading? nil) at REPL, then try it again. If search-results is null, then just return NIL. Simple search: CL-REPL> (qs:? ""crypt"") ;<=> (qs:quicksearch ""crypt"")  SEARCH-RESULTS: ""crypt""   Quicklisp   crypt   Cliki   ARC4   JARW   VLM_on_Linux   GitHub   cl-crypt   cl-crypto   cl-crypto   cryptography   cryptoschool   Cryptopsaras T  If search-results is not null, then results are printed and return T. Since bitbucket-result is null, it is not printed. Description: CL-REPL> (qs:? 'Crypt :d) ;<=> (qs:quicksearch 'Crypt :?description t)  SEARCH-RESULTS: ""crypt"" =======================   Quicklisp  ---------   crypt       http://quickdocs.org/cl-crypt/   Cliki  -----   ARC4       A Common Lisp implementation of ARC4, a Cryptography code, can be found on       the   JARW       Dr John AR Williams' utilities   VLM_on_Linux       Instructions for running the Symbolics VLM virtual machine on Linux   GitHub  ------   cl-crypt       Common-Lisp implementation of unix crypt function   cl-crypto       A common lisp package of ciphers, public-key algorithms, etc.   cl-crypto       Pure lisp crypto, written from specs   cryptography       implementations of ciphers for cryptography class   cryptoschool       Lisp files related to the cryptography class being taught by Ben Warner   Cryptopsaras       Reads files generated by Acinonyx. T  A symbol (as search-word) is automatically converted into a downcase-string. If option :d is on, then the description of the project is printed (QuickDocs-url for Quicklisp-search). The function QUICKSEARCH's options are redundant, but explanatory. The function ?'s options are not explanatory, but minimum. URL, Space, Cutoff: CL-REPL> (qs:? ""crypt"" :ug 4) ;<=> (qs:quicksearch ""crypt""                               ;                    :?url t :?cut-off 4                               ;                    :?quicklisp nil :?cliki nil :?bitbucket nil)  SEARCH-RESULTS: ""crypt"" =======================   GitHub  ------   cl-crypt       https://github.com/renard/cl-crypt   cl-crypto       https://github.com/bgs100/cl-crypto   cl-crypto       https://github.com/billstclair/cl-crypto   cryptography       https://github.com/MorganBauer/cryptography   .......> 2 T  If option :u is on, then the project's url is printed. If option :g is on, then only github-results are printed (also :q - quicklisp, :c - cliki, :b - bitbutcket. these options are addable). If cut-off is supplied (above 4), then the number of output results is bellow cut-off (the number (above 2) after .......> is number of remains). The order of options is nothing to do with search-result (e.g. :ug 4 <=> 4 :gu <=> :u 4 :g <=> ...). Config: CL-REPL> (qs:? 'lisp-koans :du 1) ;<=> (qs:quicksearch 'lisp-koans                                   ;                    :?description t :?url t :?cut-off 1)  SEARCH-RESULTS: ""lisp-koans"" ============================   GitHub  ------   lisp-koans       https://github.com/google/lisp-koans       Common Lisp Koans is a language learning exercise in the same vein as the       ruby koans, python koans and others.   It is a port of the prior koans       with some modifications to highlight lisp-specific features.  Structured       as ordered groups of broken unit tests, the project guides the learner       progressively through many Common Lisp language features.   .......> 4 T  CL-REPL> (qs:config :maximum-columns-of-description 50) Current maximum columns of description: 50 T  CL-REPL> (qs:? 'lisp-koans :du 1)  SEARCH-RESULTS: ""lisp-koans"" ============================   GitHub  ------   lisp-koans       https://github.com/google/lisp-koans       Common Lisp Koans is a language learning       exercise in the same vein as the ruby koans,       python koans and others.   It is a port of       the prior koans with some modifications to       highlight lisp-specific features.       Structured as ordered groups of broken unit       tests, the project guides the learner       progressively through many Common Lisp       language features.   .......> 4 T  :maximum-columns-of-description controls in printing description (default is 80). Reference Manual [function] QUICKSEARCH search-word &key ?web ?description ?url ?cut-off ?quicklisp ?cliki ?github ?bitbucket QUICKSEARCH searches for CL projects with search-word in Quicklisp, Cliki, GitHub and BitBucket. search-word must be a string, number or symbol (symbol will be automatically converted into downcase-string). Keywords: If ?web is NIL, it does not search in Cliki, GitHub and BitBucket. If ?quicklisp is NIL, it does not search in Quicklisp (also ?cliki, ?github, ?bitbucket). At least one search-space must be specified. If ?description is T, it displays project's descriptions (QuickDocs-url for Quicklisp-search). If ?url is T, it display project's url. ?cut-off is the max number of printing repositories each space. Note: ?cut-off controls only printing results, nothing to do with the max number of fetching repositories. see. function CONFIG documentation About #\Space in search-word: In case search-word contains #\Space, Quicklisp-search is OR-search, whereas Cliki-search, GitHub-, BitBucket- is AND-search. e.g. (quicksearch ""foo bar"") Quicklisp-search for ""foo"" OR ""bar"". Cliki-search, GitHub-, BitBucket- for ""foo"" AND ""bar"". [function] ? search-word &rest options ? is abbreviation wrapper for function QUICKSEARCH. search-word must be a string, number or symbol. options must be a non-negative integer (as Cut-Off) and/or some keywords which consists of some Option-Chars. Examples: (? ""crypt"") <=> (quicksearch ""crypt"" :?description nil :?url nil :?cut-off 50                      :?quicklisp t :?cliki t :?github t :?bitbucket t)  (? ""crypt"" :du 10) <=> (quicksearch ""crypt"" :?description T :?url T :?cut-off 10                      :?quicklisp t :?cliki t :?github t :?bitbucket t)  (? ""crypt"" 20 :g :d) <=> (quicksearch ""crypt"" :?description T :?url nil :?cut-off 20                      :?quicklisp nil :?cliki nil :?github T :?bitbucket nil)  Options: Cut-Off: The max number of printing results (default is 50). Option-Chars: d, D -- output Description (or QuickDocs-url for Quicklisp-search) u, U -- output URL q, Q -- search in Quicklisp c, C -- search in Cliki g, G -- search in GitHub b, B -- search in Bitbucket Note: Option-Char is idempotent (e.g. :dd <=> :d). The order of Option-Chars is nothing to do with output. (e.g. :du <=> :ud) If options contains more than 2 Cut-Offs, only last one is applied. The order of options is nothing to do with output (except for some Cut-Offs). If no search space is specified, all spaces is specified (e.g. :d <=> :dqcgb) If at most one search space is specified, then others are not specified. [function] CONFIG &key maximum-columns-of-description maximum-number-of-fetching-repositories cache-size clear-cache? threading? quicklisp-verbose? Function CONFIG customizes printing, fetching or caching. Keywords: :maximum-columns-of-description The value must be a plus integer bigger than 5. If the length of description-string is bigger than this value, then output of description is inserted newline for easy to see. Default value is 80. :maximum-number-of-fetching-repositories This value controls the number of fetching repositories. The value must be a plus integer. Increasing this value, the number of fetching repositories increases, but also space & time does. Default value is 50. :cache-size The value must be a plus integer. This value is the number of stored previous search-results. Increasing this value, the number of caching results increases, but also space does. Default value is 4. :clear-cache? The value must be a boolean. If value is T, then clear all caches. :threading? The value must be a boolean (default T). If value is NIL, then QUICKSEARCH becomes not to use threads for searching. Note: Currently in SBCL (1.1.8), threads are part of the default build on x86[-64] Linux only. Other platforms (x86[-64] Darwin (Mac OS X), x86[-64] FreeBSD, x86 SunOS (Solaris), and PPC Linux) experimentally supports threads and must be explicitly enabled at build-time. For more details, please see SBCL manual. quicklisp-verbose? The value must be a boolean (default NIL). If value is T, then outputs version of quicklisp and whether library had installed your local. Example:      CL-REPL> (qs:config :quicklisp-verbose? T)      CL-REPL> (qs:? ""json"" :q)       SEARCH-RESULTS: ""json""        Quicklisp: 2013-04-20   ;<- quicklisp version        !cl-json               ;<- if library has installed via quicklisp, print prefix ""!"".        !cl-json.test        com.gigamonkeys.json   ;<- if not, none.        json-template        st-json      T  Note: If you would prefer permanent config, for example, add codes something like the following in the CL init file. In .sbclrc for SBCL, ccl-init.lisp for CCL: (ql:quickload :quicksearch) (qs:config :maximum-columns-of-description 50            :maximum-number-of-fetching-repositories 20            :cache-size 2            :threading? nil            :quicklisp-verbose? t)  [special variable] *USER-AGENT* *user-agent* tells the server who is requested (i.e. User-Agent header value). If you are embedding quicksearch in a larger application, you should change the value of *user-agent* to your application name and URL. TODO ADD search-space: Common-Lisp.net ADD search-space: Google code Author, License, Copyright Takaya OCHIAI <#.(reverse ""moc.liamg@lper.hcykt"")> MIT License Copyright (C) 2013 Takaya OCHIAI Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/tkych/quicksearch"	"Look up online libraries from the REPL.."	"true"
"Utilities"	"ratify"	"https://github.com/Shinmera/ratify"	"A collection of utilities to ratify, validate and parse inputs.."	"null"	"null"	"null"	"Artistic License 2.0"	"http://directory.fsf.org/wiki/License:ArtisticLicense2.0"	"null"	"null"	"2"	"3"	"1"	"GitHub - Shinmera/ratify: A collection of Common Lisp utilities to ratify, validate and parse inputs. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 2 Fork 1 Shinmera/ratify Code Issues 0 Pull requests 0 Pulse Graphs A collection of Common Lisp utilities to ratify, validate and parse inputs. https://shinmera.github.io/ratify 20 commits 2 branches 0 releases Fetching contributors HTML 61.8% Common Lisp 38.2% HTML Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. LICENSE README.md about.html css.lisp Added START and END params to TEST and PARSE functions to make it mor… Nov 28, 2015 date.lisp email.lisp html.lisp package.lisp parsing.lisp ratify.asd testing.lisp Added START and END params to TEST and PARSE functions to make it mor… Nov 28, 2015 toolkit.lisp types.lisp uri.lisp url.lisp README.md About Ratify Ratify is a collection of utilities to perform validation checks and parsing. The main intention of usage for this is in web-applications in order to check form inputs for correctness and automatically parse them into their proper representations or return meaningful errors. How To Ratify has a load of TEST-* functions, each accompanied by a predicate equivalent. The TEST-* functions will signal errors of type RATIFICATION-ERROR if the test fails, whereas the predicates will simply return NIL. Both will return the passed argument unmodified on success. Some of the tests have an equivalent PARSE-* function in order to turn the string into a more useful representation. The main interaction with Ratify is not supposed to be directly with the TEST-* and PARSE-* functions however, but rather through the TEST and PARSE wrapper functions. Both also have a macro shorthand to perform many tests and parsings at once, PERFORM-COMBINED-TESTS and WITH-PARSED-FORMS. These macros will perform as many tests as possible and only signal an error right after all tests have been made. This error is of type COMBINED-ERROR, which contains all the errors that occurred during the testing. (ratify:perform-combined-tests   (:integer ""45"")   (:date ""2014-08-01"")   (:ratio ""566/21""))  (ratify:perform-combined-tests   (:integer ""4.5"" ""e"")   (:date ""2014-08-01"" ""2014"" ""2014-55-99"")   (:ratio ""566/21"" ""5.6/21"")) ; Evaluation aborted on #&lt;RATIFY-TESTING:COMBINED-ERROR {10074E51D3}&gt;.  Or to perform parsing: (let ((int ""45"")       (url ""http://foo.bar/baz.jp?what=ever#hashtag"")       (uri ""things-are://sometimes:complicated@with-all.these/damn?protocols=i'm#telling+you!"")       (dt ""2014-08-01T21:23:01""))   (ratify:with-parsed-forms ((:integer int) (:url url) (:uri uri) (:datetime dt))     (list int url uri dt)))  If an error occurs, the ERRORS function gives access to the list of errors that the COMBINED-ERROR contains. For a complete list of testing and parsing functions, please see the symbol index. The syntax grammar used to describe the valid values in the docstrings of each test is regex with the addition of <brackets> to refer to other tests, sometimes accompanied with a second line that describes limits of the values. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Shinmera/ratify"	"A collection of utilities to ratify, validate and parse inputs.."	"true"
"Utilities"	"Salza2"	"http://www.xach.com/lisp/salza2/"	"A library for creating compressed data.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"null"	"null"	"null"	"Salza2 - Create compressed data from Common Lisp Salza2 - Create compressed data from Common Lisp Abstract Salza2 is a Common Lisp library for creating compressed data in the ZLIB, DEFLATE, or GZIP data formats, described in RFC 1950, RFC 1951, and RFC 1952, respectively. It does not use any external libraries for compression. It does not yet support decompression. Salza2 is available under a BSD-like license. The latest version is 2.0.9, released on July 18th, 2013. Download shortcut: http://www.xach.com/lisp/salza2.tgz Contents Overview and Limitations Dictionary Standard Compressors deflate-compressor zlib-compressor gzip-compressor callback compress-octet compress-octet-vector finish-compression reset with-compressor Customizing Compressors write-bits write-octet start-data-format process-input finish-data-format Checksums adler32-checksum crc32-checksum update result result-octets reset Shortcuts make-stream-output-callback gzip-stream gzip-file compress-data References Acknowledgements Feedback Overview and Limitations Salza2 provides an interface for creating a compressor object. This object acts as a sink for octets (either individual octets or vectors of octets), and is a source for octets in a compressed data format. The compressed octet data is provided to a user-defined callback that can write it to a stream, copy it to another vector, etc. Salza2 has built-in compressors that support the ZLIB, DEFLATE, and GZIP data formats. The classes and generic function protocol are available to make it easy to support similar formats via subclassing and new methods. ZLIB and GZIP are extensions to the DEFLATE format and are implemented as subclasses of DEFLATE-COMPRESSOR with a few methods implemented for the protocol. Salza2 is the successor to Salza, but it is not backwards-compatible. Among other changes, Salza2 drops support for compressing Lisp character data, since the compression formats are octet-based and obtaining encoded octets from Lisp characters varies from implementation to implementation. There are a number of functions that provide a simple interface to specific tasks such as gzipping a file or compressing a single vector. Salza2 does not decode compressed data. There is no support for dynamically defined Huffman codes. There is currently no interface for changing the tradeoff between compression speed and compressed data size. Dictionary The following symbols are exported from the SALZA2 package. Standard Compressors [Classes] deflate-compressor zlib-compressor gzip-compressor Instances of these classes may be created via make-instance. The only supported initarg is :CALLBACK. See CALLBACK for the expected value. [Accessor] callback compressor => callback (setf (callback compressor) new-value) => new-value Gets or sets the callback function of compressor. The callback should be a function of two arguments, an octet vector and an end index, and it should process all octets from the start of the vector below the end index as the compressed output data stream of the compressor. See MAKE-STREAM-OUTPUT-CALLBACK for an example callback. [Function] compress-octet octet compressor => | Adds octet to compressor to be compressed. [Function] compress-octet-vector vector compressor &key start end => | Adds the octets from vector to compressor to be compressed, beginning with the octet at start and ending at the octet at end - 1. If start is not specified, it defaults to 0. If end is not specified, it defaults to the total length of vector. Equivalent to (but much more efficient than) the following:  (loop for i from start below end       do (compress-octet (aref vector i) compressor))  [Generic function] finish-compression compressor => | Compresses any pending data, concludes the data format for compressor with FINISH-DATA-FORMAT, and invokes the user callback for the final octets of the compressed data format. This function must be called at the end of compression to ensure the validity of the data format; it is called implicitly by WITH-COMPRESSOR. [Generic function] reset compressor => | The default method for DEFLATE-COMPRESSOR objects resets the internal state of compressor and calls START-DATA-FORMAT. This allows the re-use of a single compressor object for multiple compression tasks. [Macro] with-compressor (var class &rest initargs &key &allow-other-keys) &body body => | Evaluates body with var bound to a new compressor created as with (apply #'make-instance class initargs). FINISH-COMPRESSION is implicitly called on the compressor at the end of evaluation. Customizing Compressors Compressor objects follow a protocol that makes it easy to create specialized data formats. The ZLIB data format is essentially the same as the DEFLATE format with an additional header and a trailing checksum; this is implemented by creating a new class and adding a few new methods to the generic functions below. For example, consider a new compressed data format FOO that encapsulates a DEFLATE data stream but adds four signature octets, F0 0D 00 D1, to the start of the output data stream, and adds a trailing 32-bit length value, MSB first, after the end. It could be implemented like this:  (defclass foo-compressor (deflate-compressor)   ((data-length     :initarg :data-length     :accessor data-length))   (:default-initargs    :data-length 0))  (defmethod start-data-format :before ((compressor foo-compressor))   (write-octet #xF0 compressor)   (write-octet #x0D compressor)   (write-octet #x00 compressor)   (write-octet #xD1 compressor))  (defmethod process-input :after ((compressor foo-compressor) input start count)   (declare (ignore input start))   (incf (data-length compressor) count))  (defmethod finish-data-format :after ((compressor foo-compressor))   (let ((length (data-length compressor)))     (write-octet (ldb (byte 8 24) length) compressor)     (write-octet (ldb (byte 8 16) length) compressor)     (write-octet (ldb (byte 8  8) length) compressor)     (write-octet (ldb (byte 8  0) length) compressor)))  (defmethod reset :after ((compressor foo-compressor))   (setf (data-length compressor) 0))  [Function] write-bits code size compressor => | Writes size low bits of the integer code to the output buffer of compressor. Follows the bit packing layout described in RFC 1951. The bits are not compressed, but become literal parts of the output stream. [Function] write-octet octet compressor => | Writes octet to the output buffer of compressor. Bits of the octet are not packed; the octet is added to the output buffer at the next octet boundary. The octet is not compressed, but becomes a literal part of the output stream. [Generic function] start-data-format compressor => | Outputs any prologue bits or octets needed to produce a valid compressed data stream for compressor. Called from initialize-instance and RESET for subclasses of deflate-compressor. Should not be called directly, but subclasses may add methods to customize what literal data is added to the beginning of the output buffer. [Generic function] process-input compressor input start count => | Called when count octets of the octet vector input, starting from start, are about to be compressed. This generic function should not be called directly, but may be specialized. This is useful for data formats that must maintain information about the uncompressed contents of a compressed data stream, such as checksums or total data length. [Generic function] finish-data-format compressor => | Called by FINISH-COMPRESSION. Outputs any epilogue bits or octets needed to produce a valid compressed data stream for compressor. This generic function should not be called directly, but may be specialized. Checksums Checksums are used in several data formats to check data integrity. For example, PNG uses a CRC32 checksum for its chunks of data. Salza2 exports support for two common checksums. [Standard classes] adler32-checksum crc32-checksum Instances of these classes may be created directly with make-instance. [Generic function] update checksum buffer start count => | Updates checksum with count octets from the octet vector buffer, starting at start. [Generic function] result checksum => result Returns the accumulated value of checksum as an integer. [Generic function] result-octets checksum => result-list Returns the individual octets of checksum as a list of octets, in MSB order. [Generic function] reset checksum => | The default method for checksum objects resets the internal state of checksum so it may be re-used. Shortcuts Some shortcuts for common compression tasks are available. [Function] make-stream-output-callback stream => callback> Creates and returns a callback function that writes all compressed data to stream. It is defined like this:  (defun make-stream-output-callback (stream)   (lambda (buffer end)     (write-sequence buffer stream :end end)))  [Function] gzip-stream input-stream output-stream => | Compresses all data read from input-stream and writes the compressed data to output-stream. [Function] gzip-file input-file output-file => pathname Compresses input-file and writes the compressed data to output-file. [Function] compress-data data compressor-designator &rest initargs => compressed-data Compresses the octet vector data and returns the compressed data as an octet vector. compressor-designator should be either a compressor object, designating itself, or a symbol, designating a compressor created as with (apply #'make-instance compressor-designator initargs). For example:  * (compress-data (sb-ext:string-to-octets ""Hello, hello, hello, hello world."")                   'zlib-compressor) #(8 153 243 72 205 201 201 215 81 200 192 164 20 202 243 139 114 82 244 0 194 64 11 139)  References Deutsch and Gailly, ZLIB Compressed Data Format Specification version 3.3 (RFC 1950) Deutsch, DEFLATE Compressed Data Format Specification version 1.3 (RFC 1951) Deutsch, GZIP file format specification version 4.3 (RFC 1952) Wikipedia, Rabin-Karp string search algorithm Acknowledgements Thanks to Paul Khuong for his help optimizing the modulo-8191 hashing. Thanks to Austin Haas for providing some test SWF files demonstrating a data format bug. Feedback Please direct any comments, questions, bug reports, or other feedback to Zach Beane."	"null"	"null"	"A library for creating compressed data.."	"true"
"Utilities"	"serapeum"	"https://github.com/TBRSS/serapeum/"	"Another general-purpose utility library.."	"null"	"null"	"null"	"Expat"	"http://directory.fsf.org/wiki/License:Expat"	"null"	"null"	"44"	"11"	"5"	"GitHub - TBRSS/serapeum: Utilities beyond Alexandria Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 11 Star 44 Fork 5 TBRSS/serapeum Code Issues 0 Pull requests 0 Pulse Graphs Utilities beyond Alexandria 415 commits 3 branches 0 releases Fetching contributors Common Lisp 99.9% Makefile 0.1% Common Lisp Makefile Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master view-source Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. tests .gitignore .travis.yml LICENSE.txt Makefile README.md arrays.lisp binding.lisp box.lisp clos.lisp conditions.lisp control-flow.lisp definitions.lisp docs.lisp fbind.lisp files.lisp functions.lisp hash-tables.lisp hooks.lisp internal-definitions.lisp iter.lisp lists.lisp macro-tools.lisp mop.lisp numbers.lisp octets.lisp op.lisp Centralize exports in the defpackage. Jun 18, 2015 package.lisp queue.lisp reference.md sequences.lisp serapeum.asd Make internal-definitions depend on control-flow. Jul 7, 2016 strings.lisp symbols.lisp threads.lisp time.lisp trees.lisp types.lisp vectors.lisp README.md Overview Serapeum is a conservative library of Common Lisp utilities. It is a supplement, not a competitor, to Alexandria. That means it is safe to do: (defpackage ... (:use #:cl #:alexandria #:serapeum),  without package conflicts. There may already be too many utility libraries for Common Lisp. Releasing another has become something to apologize for, not celebrate. But I would rather make my apologies than have to maintain copy-pasted versions of the same utilities across a dozen systems. And, though Serapeum is justified even if only I ever use it, the best way to ensure its quality is to write it as if for general use. Serapeum is conservative: it contains only utilities I actually use, and which have survived refactoring. But it is less conservative than Alexandria. Alexandria limits itself to utilities with a Common Lisp pedigree. Serapeum casts a wider net: other dialects of Lisp, and other languages in the functional and array families, have been drafted. Alexandria is self-contained. It exists in splendid isolation, without depending on, or even acknowledging, other libraries. Serapeum tries to be a good citizen of the Quicklisp era: whenever possible, it avoids duplicating functionality that can be had elsewhere. Some of the utilities in Serapeum are original; others are borrowed from other languages, or from other Lispers. I try to give credit in the docstrings, but sometimes I have forgotten where I got an idea or a name. I regard missing credits as bugs: please report them. Serapeum is intended to be portable, but it is only tested where it is developed, on SBCL and Clozure CL. Patches for other Lisps are welcome, whether bug fixes or unportable enhancements. Commentary One goal of Serapeum is to have excellent documentation. A utility library is a fork of its language; it deserves documentation of the same quality as a language reference. If a utility is not worth documenting, it is not worth having. The full function reference will be found here. (It is in a separate file in deference to documentation browsers, which often print the README as a preamble to their own function reference). Most utilities in Serapeum stand alone, but there are some families that deserve separate introduction. Binding values in the function namespace fbind, fbind*, fbindrec, and fbindrec* bind values in the function namespace. fbind and fbindrec are like flet and labels, respectively. (fbind ((fn (lambda ....))) ...) ≡ (flet ((fn ...)) ...)  (fbindrec ((fn (lambda ...))) ...) ≡ (labels ((fn ...)) ...)  fbind* and fbindrec* have no exact parallels: they bind functions in sequence, so that each can be used in the construction (not just the definition, as with fbindrec) of the next. (fbind* ((flip2 (lambda (fn)                  (lambda (x y)                    (funcall fn y x))))          (xcons (flip2 #'cons)))   (xcons 2 1)) => (1 . 2)  These are non-trivial implementations. In many cases, fbind can produce code that is more efficient than using funcall, and even eliminate the overhead of higher-order functions like compose and curry. And fbindrec, which builds on fbind, further implements the optimizing transformation from Waddell et. al., Fixing Letrec. For binding values in the function namespace at the top level, Serapeum provides defalias: (defalias xcons (flip #'cons))  This is equivalent to (setf (fdefinition ...)), but also gives the function a compile-time definition so compilers don’t complain about its being undefined. CLOS Serapeum includes some utilities for CLOS. These utilities do nothing earthshaking, but since the function reference does not include them, they should be documented somewhere. Method combination: standard with context Serapeum exports a method combination, serapeum:standard/context. You may recognize it as the wrapping-standard method combination due to Tim Bradshaw. Generic functions defined with standard/context behave the same as ordinary generic functions, except that they allow an extra qualifier, :context. This extra qualifier works almost like :around, except instead of being run in most-specific-first order, like methods defined with :around, methods defined with :context are run in most-specific-last order. Furthermore, :context methods take priority over any other methods, including :around methods. The big idea is that a class can use :context methods to make sure that any methods defined by subclasses – even :around methods – run in a certain dynamic context. Metaclass: topmost-object-class In most cases, when I write a metaclass, I want all of the classes defined using that metaclass to inherit from a specific class. Injecting a topmost class is not difficult to do, but it involves a certain amount of boilerplate. To eliminate that boilerplate, Serapeum exports a metaclass, topmost-object-class, to use as a base class for your metaclasses. When you define a metaclass, all you have to do to ensure that classes defined using your metaclass inherit from a specific class is to supply the name of the class to inherit from in the definition of the metaclass. This is better demonstrated than explained: ;;; The class to inherit from. (defclass my-topmost-object ()   ())  ;;; The metaclass. (defclass my-metaclass (serapeum:topmost-object-class)   ()   (:default-initargs    :topmost-class 'my-topmost-object))  (defclass my-class ()   ()   (:metaclass my-metaclass))  (typep (make-instance 'my-class) 'my-topmost-object) => t Note that, since the topmost object is usually a standard class, there is a validate-superclass method which allows an instance of topmost-object-class to inherit from a standard class. Internal definitions The local form lets you use top-level definition forms to create local bindings. You can use defun instead of labels, defmacro instead of macrolet, def (which is Serapeum’s macro for top-level lexical bindings) instead of let, and so forth. This has three advantages: Given a set of variable, function, and macro bindings, you can leave it to the compiler to figure out how to nest them. (This could be because you are porting a function from a language that uses flat bindings, or just because you are writing a very complicated function.) You can use macro-defining macros (macros that expand into defmacro), as well as macros that expand into defun forms, to create local bindings. You can (using local*) easily switch to block compilation of top-level functions. Serapeum’s implementation of internal definitions is as complete as it can be while remaining portable. That means full support for variables, functions, and symbol macros, but restricted support for macros. Example: macros that expand into top-level definitions For example, memoizing local functions is usually clumsy; given local you can define a single defmemo form that supports both defun and labels. (defmacro defmemo (name params &body body)   (with-gensyms (memo-table args result result?)     `(let ((,memo-table (make-hash-table :test 'equal)))        (defun ,name (&rest ,args)          (multiple-value-bind (,result ,result?)              (gethash ,args ,memo-table)            (if ,result?                ,result                (setf (gethash ,args ,memo-table)                      (apply (lambda ,params                               ,@body)                               ,args))))))))  This expands into let and labels as you might expect. (local   (defmemo fibonacci (n)     (if (<= n 1)         1         (+ (fibonacci (- n 1))            (fibonacci (- n 2)))))    (fibonacci 100))   => 573147844013817084101  Example: block compiling The macro local* is almost the same as local, except that it leaves the last form in the body intact. This is useful for obtaining block compilation in Lisps that don’t have a syntax for it. During development, you define functions at the top level inside a progn.  (progn    (defun aux-fn ...)    (defun entry-point ...))  Then, when you decide you want block compilation, simply switch the progn to a local*:  (local*    (defun aux-fn ...)    (defun entry-point ...))  Compile-time exhaustiveness checking etypecase-of is just like etypecase, except that it takes an additional argument – the type to be matched against – and warns, at compile time, if the clauses in its body are not an exhaustive partition of that type. (defun negative-integer? (n)   (etypecase-of t n     ((not integer) nil)     ((integer * -1) t)     ((integer 1 *) nil))) => Warning  (defun negative-integer? (n)   (etypecase-of t n     ((not integer) nil)     ((integer * -1) t)     ((integer 1 *) nil)     ((integer 0) nil))) => No warning  ecase-of is a succint variant of etypecase with the same syntax as ecase. We may call a type defined using member an enumeration. Take an enumeration like this: (deftype switch-state ()   '(member :on :off :stuck :broken))  Now we can use ecase-of to take all the states of the switch into account. (defun flick (switch)   (ecase-of switch-state (state switch)     (:on (switch-off switch))     (:off (switch-on switch)))) => Warning  (defun flick (switch)   (ecase-of switch-state (state switch)     (:on (switch-off switch))     (:off (switch-on switch))     ((:stuck :broken) (error ""Sorry, can't flick ~a"" switch)))) => No warning  typecase-of and case-of are etypecase-of and ecase-of, respectively, except that they expect, and enforce, the presence of an otherwise clause. There are continuable versions of these macros – ctypecase-of and ccase-of. Dividing sequences All recent functional programming languages share a family of useful sequence-related functions with terrible names. All of them are called something like “split”, “divide”, or “group”, more or less at random. For each function, we ensure: It is efficient. It returns like sequences for like (lists for lists, strings for strings, &c.). It accommodates generic sequences (list and vector are not necessarily an exhaustive partition of sequence). It has a distinctive name which does not use any of the weasel words “split,” “divide,” or “group.” The function that returns runs of like elements in a sequence is called runs: (runs '(head tail head head tail)) => '((head) (tail) (head head) (tail))  The function that returns a sequence in batches of a certain size is called batches: (batches (iota 11) 2) => ((0 1) (2 3) (4 5) (6 7) (8 9) (10))  The function which groups the like elements of a sequence is called assort (because it returns a sequence assorted by some property). (assort (iota 10)         :key (lambda (n) (mod n 3))) => '((0 3 6 9) (1 4 7) (2 5 8))  The function that takes a predicate and a sequence, and returns two sequences – one sequence of the elements for which the function returns true, and one sequence of the elements for which it returns false – is (still) called partition. (partition #'oddp (iota 10)) => (1 3 5 7 9), (0 2 4 6 8)  The generalized version of partition, which takes a number of functions and returns the items that satisfy each condition, is called partitions. (partitions (list #'primep #'evenp) (iota 10)) => ((2 3 5 7) (0 4 6 8)), (1 9)  Items that do not belong in any partition are returned as a second value. Serapeum simply re-exports split-sequence, which seems to be firmly rooted under its present name. Function reference The complete reference is in a separate file. (Note that the reference is generated from docstrings, and should not be edited by hand.) Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/TBRSS/serapeum/"	"Another general-purpose utility library.."	"true"
"Utilities"	"simple-currency"	"https://github.com/a0-prw/simple-currency"	"A currency conversion library using daily information published by the ECB.."	"null"	"null"	"null"	"FreeBSD"	"http://directory.fsf.org/wiki?title=License:FreeBSD"	"null"	"null"	"2"	"3"	"0"	"GitHub - a0-prw/simple-currency: simple-currency is a Common Lisp library which converts between currencies using foreign exchange information published daily by the ECB Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 2 Fork 0 a0-prw/simple-currency Code Issues 0 Pull requests 0 Pulse Graphs simple-currency is a Common Lisp library which converts between currencies using foreign exchange information published daily by the ECB 28 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. .gitignore LICENCE README currency-info.lisp package.lisp simple-currency.asd simple-currency.lisp README This is a simple library for converting between currencies using the foreign exchange information posted daily by the ECB. You can find more information on the time of updates etc at:  http://www.ecb.int/stats/exchange/eurofxref/html/index.en.html  The library is so simple that it is easier for a user to just read the documentation strings and the function definitions themselves, so please look at simple-currency.lisp if you want more detailed documentation.  Installation:  This package uses DRAKMA, XMLS, SIMPLE-DATE, SPLIT-SEQUENCE, and CL-STORE but if you use quicklisp (http://www.quicklisp.org/beta/), they will be automatically installed for you.  Put this package somewhere quicklisp can find it, by default under ~/quicklisp/local-projects/.  Then do the following 2 things:  (ql:quickload :simple-currency) (CIES:UPDATE-CURRENCIES-HASH) ;;downloads currency info from ecb  If it does not return NIL, you are ready to go  Usage example:  (CIES:CONVERT 100 :USD :GBP)  ==>  861350/13373 #<SIMPLE-DATE:INTERVAL P1D>  If you want it to look like a money amount, you can do  (CIES:DISPLAY-CURRENCY (CIES:CONVERT 100 :USD :GBP) :GBP)  ==> ""GBP 64.41""  Likewise with checking the interval for unacceptably old quotations - see documentation for simple-date.  NB: Remember that floats ""contaminate"" so if you do (CIES:CONVERT 100.25 :eur :usd).  You will get a float back: display-currency calls a function which expects a rational, so that will signal an error.  Convenience facilities:  There is a macro (CIES:WITH-CURRENCY :xyz <conversion-form>) which can replace references to (convert <number> <target currency>) in conversion-form with (DISPLAY-CURRENCY (CONVERT <number> <from> <to>) <from>).  I haven't thought very hard about this macro, so it might hold unintended surprises.  There is a simple database of currency information which can be accessed with CIES:LOOKUP-CURRENCY, so for example, if you are in the SIMPLE-CURRENCY package or have USED it:  (ccy-ddigits (lookup-currency :jpy)) ==> ""0""  Another example:  (map 'list (lambda (acode)                    (let ((cd (lookup-currency acode)))                      (list acode (ccy-country cd) (ccy-name cd))))            (available-currencies))  ==> ((""EUR""   (""Vatican City State (HOLY SEE)"" ""SPAIN"" ""SLOVENIA"" ""SLOVAKIA"" ""SAN MARINO""    ""SAINT PIERRE AND MIQUELON"" ""SAINT MARTIN (FRENCH PART)"" ""SAINT BARTHELEMY""    ""REUNION"" ""PORTUGAL"" ""NETHERLANDS"" ""MONTENEGRO"" ""MONACO"" ""MAYOTTE""    ""MARTINIQUE"" ""MALTA"" ""LUXEMBOURG"" ""ITALY"" ""IRELAND""    ""HOLY SEE (VATICAN CITY STATE)"" ""GUADELOUPE"" ""GREECE"" ""GERMANY""    ""FRENCH SOUTHERN TERRITORIES"" ""FRENCH GUIANA"" ""FRANCE"" ""FINLAND""    ""EUROPEAN UNION"" ""ESTONIA"" ""CYPRUS"" ""BELGIUM"" ""AUSTRIA"" ""ANDORRA""    ""AALAND ISLANDS"")   ""Euro"")  (""ZAR"" (""SOUTH AFRICA"" ""NAMIBIA"" ""LESOTHO"") ""Rand"")  (""THB"" (""THAILAND"") ""Baht"") (""SGD"" (""SINGAPORE"") ""Singapore Dollar"")  (""PHP"" (""PHILIPPINES"") ""Philippine Peso"")  (""NZD"" (""TOKELAU"" ""PITCAIRN"" ""NIUE"" ""NEW ZEALAND"" ""COOK ISLANDS"")   ""New Zealand Dollar"")  (""MYR"" (""MALAYSIA"") ""Malaysian Ringgit"") (""MXN"" (""MEXICO"") ""Mexican Peso"")  (""KRW"" (""KOREA, REPUBLIC OF"") ""Won"") (""INR"" (""INDIA"" ""BHUTAN"") ""Indian Rupee"")  (""ILS"" (""ISRAEL"") ""New Israeli Sheqel"") (""IDR"" (""INDONESIA"") ""Rupiah"")  (""HKD"" (""HONG KONG"") ""Hong Kong Dollar"") (""CNY"" (""CHINA"") ""Yuan Renminbi"")  (""CAD"" (""CANADA"") ""Canadian Dollar"") (""BRL"" (""BRAZIL"") ""Brazilian Real"")  (""AUD""   (""TUVALU"" ""NORFOLK ISLAND"" ""NAURU"" ""KIRIBATI""    ""HEARD ISLAND AND McDONALD ISLANDS"" ""COCOS (KEELING) ISLANDS""    ""CHRISTMAS ISLAND"" ""AUSTRALIA"")   ""Australian Dollar"")  (""TRY"" (""TURKEY"") ""Turkish Lira"")  (""RUB"" (""RUSSIAN FEDERATION"") ""Russian Ruble"")  (""HRK"" (""CROATIA"") ""Croatian Kuna"")  (""NOK"" (""SVALBARD AND JAN MAYEN"" ""NORWAY"" ""BOUVET ISLAND"") ""Norwegian Krone"")  (""CHF"" (""SWITZERLAND"" ""LIECHTENSTEIN"") ""Swiss Franc"")  (""SEK"" (""SWEDEN"") ""Swedish Krona"") (""RON"" (""ROMANIA"") ""New Romanian Leu"")  (""PLN"" (""POLAND"") ""Zloty"") (""LVL"" (""LATVIA"") ""Latvian Lats"")  (""LTL"" (""LITHUANIA"") ""Lithuanian Litas"") (""HUF"" (""HUNGARY"") ""Forint"")  (""GBP"" (""UNITED KINGDOM"" ""JERSEY"" ""ISLE OF MAN"" ""GUERNSEY"") ""Pound Sterling"")  (""DKK"" (""GREENLAND"" ""FAROE ISLANDS"" ""DENMARK"") ""Danish Krone"")  (""CZK"" (""CZECH REPUBLIC"") ""Czech Koruna"") (""BGN"" (""BULGARIA"") ""Bulgarian Lev"")  (""JPY"" (""JAPAN"") ""Yen"")  (""USD""   (""VIRGIN ISLANDS (US)"" ""VIRGIN ISLANDS (BRITISH)""    ""UNITED STATES MINOR OUTLYING ISLANDS"" ""UNITED STATES""    ""TURKS AND CAICOS ISLANDS"" ""TIMOR-LESTE"" ""PUERTO RICO"" ""PANAMA"" ""PALAU""    ""NORTHERN MARIANA ISLANDS"" ""MICRONESIA, FEDERATED STATES OF""    ""MARSHALL ISLANDS"" ""HAITI"" ""GUAM"" ""EL SALVADOR"" ""ECUADOR""    ""BRITISH INDIAN OCEAN TERRITORY"" ""BONAIRE, SINT EUSTATIUS AND SABA""    ""AMERICAN SAMOA"")   ""US Dollar""))  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/a0-prw/simple-currency"	"A currency conversion library using daily information published by the ECB.."	"true"
"Utilities"	"template"	"https://bitbucket.org/tarballs_are_good/template"	"A library for templates and functions, similar to C++.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"null"	"null"	"null"	"tarballs_are_good / template   — Bitbucket  Bitbucket Features Pricing owner/repository English English 日本語 Sign up Log in template Actions Clone Compare Fork Navigation Overview Source Commits Branches 1 Pull requests 3 Issues Wiki Downloads Settings HTTPS HTTPS SSH Need help cloning? Learn how to clone a repository. Clone in SourceTree Atlassian SourceTree is a free Git and Mercurial client for Windows. Atlassian SourceTree is a free Git and Mercurial client for Mac. Robert Smith template Overview Clone in SourceTree Clone in SourceTree Atlassian SourceTree is a free Git and Mercurial client for Windows. Atlassian SourceTree is a free Git and Mercurial client for Mac. HTTPS HTTPS SSH Last updated 2014-12-26 Language Common Lisp Access level Read 1 Branch 1 Tag 1 Fork 1 Watcher                                TEMPLATE                                ========                             By Robert Smith  TEMPLATE is a package for templates and template functions, similar to C++ templates.  Example:  ;;; Define the templated function. (define-templated-function add (type) (x y)   `(locally (declare (type ,type x y))      (the ,type (+ x y))))  ;;; Instantiate it with a few types. (instantiate-templated-function add fixnum) (instantiate-templated-function add single-float)  ;;; Call it. (add '(fixnum) 1 2) (add '(single-float) 1.0 2.0)  Unlimited private and public hosted repositories. Free for small teams! Sign up for free Close Recent activity IGNORE-line wrong for &OPTIONAL with value... Issue #3 commented on in tarballs_are_good/template Patrick Stein · ASDF file references LICENSE rather than LICENSE.txt Issue #2 commented on in tarballs_are_good/template Patrick Stein · Fixed references to LICENSE.txt file Pull request #1 created in tarballs_are_good/template Patrick Stein · IGNORE-line wrong for &OPTIONAL with value... Issue #3 created in tarballs_are_good/template Patrick Stein · ASDF file references LICENSE rather than LICENSE.txt Issue #2 created in tarballs_are_good/template Patrick Stein · 1 commit Pushed to tarballs_are_good/template 28a0736 add text file extensions Robert Smith · The name of this package is already a nickname of a popular package. Issue #1 created in tarballs_are_good/template AnonymousUser · 1 commit Pushed to tarballs_are_good/template 1ee743b Better error message for undefined templates. Robert Smith · 1 commit Pushed to tarballs_are_good/template 1e9b303 Parse the documentation out of DEFINE-TEMPLATED-FUNCTION and pass along. Robert Smith · 1 commit Pushed to tarballs_are_good/template 457921c Initial checkin of template functionality. Robert Smith · tarballs_are_good/template Repository created Robert Smith · Blog Support Plans & pricing Documentation API Site status Version info Terms of service Privacy policy English Git 2.7.4.1.g5468f9e Mercurial 3.6.3 Django 1.7.11 Python 2.7.3 b7520e3d05e9 / b7520e3d05e9 @ app-124 JIRA Software Confluence Bamboo SourceTree HipChat Atlassian Help Online help Learn Git Keyboard shortcuts Latest features Bitbucket tutorials Site status Support"	"null"	"null"	"A library for templates and functions, similar to C++.."	"true"
"Utilities"	"texp"	"http://mr.gy/software/texp/"	"A DSL to generate TeX. No license specified."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"api.html api.log api.meta api.mk2 api.pdf api.txt manual.html manual.log manual.meta manual.mk2 manual.pdf manual.txt"	"null"	"null"	"A DSL to generate TeX. No license specified."	"true"
"Utilities"	"trivial-benchmark"	"https://github.com/Shinmera/trivial-benchmark"	"Tiny benchmarking library.."	"null"	"null"	"null"	"Artistic Licence 2.0"	"http://directory.fsf.org/wiki/License:ArtisticLicense2.0"	"null"	"null"	"7"	"1"	"0"	"GitHub - Shinmera/trivial-benchmark: Tiny Common Lisp library to do some quick benchmark tests Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 1 Star 7 Fork 0 Shinmera/trivial-benchmark Code Issues 0 Pull requests 0 Pulse Graphs Tiny Common Lisp library to do some quick benchmark tests http://shinmera.github.io/trivial-benchmark/ 14 commits 2 branches 0 releases Fetching contributors HTML 61.6% Common Lisp 38.4% HTML Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. LICENSE README.md about.html package.lisp samples.lisp timer.lisp toolkit.lisp trivial-benchmark.asd README.md About Trivial-Benchmark Frequently I want to do a quick benchmark comparison of my functions. TIME is nice to get some data, but it's limited to a single run so there isn't really much of a statistical value in it. Trivial-benchmark runs a block of code many times and outputs some statistical data for it. On SBCL this includes the data from TIME, for all other implementations just the REAL- and RUN-TIME data. However, you can extend the system by adding your own metrics to it, or even by adding additional statistical computeations. How To For basic throwaway benchmarking, the with-timing macro should suffice: (benchmark:with-timing (1000)   (+ 1 1))  However, you can also do more complex timing using make-timer and with-sampling. The former creates a new timer object (with an optional list of metrics to sample) and the latter collects one sample for each metric of the timer for the duration of the body forms. (defvar *timer* (benchmark:make-timer))  (benchmark:with-sampling (*timer*)   (+ 1 1))  (benchmark:with-sampling (*timer*)   (expt 10 100))  (benchmark:report *timer*)  (benchmark:reset *timer*)  (benchmark:report *timer*)  Sample Output: Extending Trivial-Benchmark If you're interested in adding additional metrics, you'll want to take a look at the metric class, as well as the related methods, start stop discard commit take-sample samples sample-size condense reduce-samples compute report reset. For a basic metric, you only need to implement start, stop, commit, samples, and take-sample. The other functions have standard methods that will do their computations based on those five. If you have a function that returns a current state of your sample and simply want to have the metric show the delta between start and stop, you can use define-delta-metric. (define-delta-metric (run-time internal-time-units-per-second)   (get-internal-run-time))  You can also implement a new computation type that is used to display the different metrics in the table. For that, simply write a method on compute with the name of your computation as an eql-specializer and then push the name onto *default-computations* so that it's always displayed when using report. As an example, the maximum is simply calculated as follows: (defmethod compute ((x (eql :maximum)) (metric metric))   (reduce-samples metric #'max))  Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Shinmera/trivial-benchmark"	"Tiny benchmarking library.."	"true"
"Utilities"	"trivial-garbage"	"https://github.com/trivial-garbage/trivial-garbage"	"A portable finalizer, weak hash-table and weak pointer API. Public domain."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"17"	"4"	"3"	"GitHub - trivial-garbage/trivial-garbage: Portable GC-related APIs for Common Lisp. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 4 Star 17 Fork 3 trivial-garbage/trivial-garbage Code Issues 5 Pull requests 0 Pulse Graphs Portable GC-related APIs for Common Lisp. http://common-lisp.net/project/trivial-garbage 62 commits 1 branch 3 releases Fetching contributors Common Lisp 92.3% CSS 7.7% Common Lisp CSS Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show v0.20 0_18 0_17 Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. doc .gitignore .travis.yml README.md build.xcvb gendocs.lisp release.lisp tests.lisp trivial-garbage.asd trivial-garbage.lisp README.md trivial-garbage provides a portable API to finalizers, weak hash-tables and weak pointers on all major implementations of the Common Lisp programming language. Documentation is available at the project's website. It is placed in the public domain with absolutely no warranty. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/trivial-garbage/trivial-garbage"	"A portable finalizer, weak hash-table and weak pointer API. Public domain."	"true"
"Utilities"	"trivial-types"	"https://github.com/m2ym/trivial-types"	"Trivial type definitions.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"23"	"3"	"1"	"GitHub - m2ym/trivial-types: Trivial type definitions for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 23 Fork 1 m2ym/trivial-types Code Issues 0 Pull requests 0 Pulse Graphs Trivial type definitions for Common Lisp 7 commits 1 branch 0 releases Fetching contributors Common Lisp 100.0% Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. src .gitignore README.markdown trivial-types.asd README.markdown trivial-types - Trivial type definitions TRIVIAL-TYPES provides missing but important type definitions such as PROPER-LIST, ASSOCIATION-LIST, PROPERTY-LIST and TUPLE. By using these types, you can keep type declarations more accurate. For example, you may write a class definition like: (defclass person ()   ((name :type string))   ((age :type fixnum))   ((friends :type list)))  However, it is not obvious for anyone except you that FRIENDS slot has only a list of person. If you want declare FRIENDS slot more accurately, PROPER-LIST is the best for that: (defclass person ()   ((name :type string))   ((age :type fixnum))   ((friends :type (proper-list person))))  In addition, TRIVIAL-TYPES also provides standard designators defined in ANSI standard such as PACKAGE-DESIGNATOR. They are useful when you write a function that takes a package-oid argument like: (defun list-external-symbols (package)   (declare (package-designator package))   (loop for symbol being the external-symbol of package         collect symbol))  [Package] trivial-types [Function] proper-list-p proper-list-p object  Returns true if OBJECT is a proper list. Examples: (proper-list-p 1) => NIL (proper-list-p '(1 . 2)) => NIL (proper-list-p nil) => T (proper-list-p '(1 2 3)) => T  [Type] proper-list proper-list &optional (element-type '*)  Equivalent to (and list (satisfies proper-list-p)). ELEMENT-TYPE is just ignored. Examples: (typep '(1 2 3) '(proper-list integer)) => T (typep '(1 2 3) '(proper-list string)) => T  [Function] property-list-p property-list-p object  Returns true if OBJECT is a property list. Examples: (property-list-p 1) => NIL (property-list-p '(1 2 3)) => NIL (property-list-p '(foo)) => NIL (property-list-p nil) => T (property-list-p '(foo 1)) => T (property-list-p '(:a 1 :b 2)) => T  [Type] property-list property-list &optional (value-type '*)  Equivalent to (and list (satisfies property-list-p)). VALUE-TYPE is just ignored. Examples: (typep '(:a 1 :b 2) '(property-list integer)) => T (typep '(:a 1 :b 2) '(property-list string)) => T  [Function] association-list-p association-list-p var  Returns true if OBJECT is an association list. Examples: (association-list-p 1) => NIL (association-list-p '(1 2 3)) => NIL (association-list-p nil) => T (association-list-p '((foo))) => T (association-list-p '((:a . 1) (:b . 2))) => T  [Type] association-list association-list &optional (key-type '*) (value-type '*)  Equivalent to (proper-list (cons KEY-TYPE VALUE-TYPE)). KEY-TYPE and VALUE-TYPE are just ignored. Examples: (typep '((:a . 1) (:b . 2)) '(association-list integer)) => T (typep '((:a . 1) (:b . 2)) '(association-list string)) => T  [Function] tuplep tuplep object  Returns true if OBJECT is a tuple, meaning a proper list. Examples: (tuplep 1) => NIL (tuplep '(1 . 2)) => NIL (tuplep nil) => T (tuplep '(1 2 3)) => T  [Type] tuple tuple &rest element-types  Equivalent to (and list (cons ARG1 (cons ARG2 (cons ARG3 ...)))) where ARGn is each element of ELEMENTS-TYPES. Examples: (typep 1 'tuple) => NIL (typep '(1 . 2) 'tuple) => NIL (typep '(1 2 3) 'tuple) => NIL (typep '(1 2 3) '(tuple integer integer)) => NIL (typep '(1 2 3) '(tuple string integer integer)) => NIL (typep nil 'tuple) => T (typep nil '(tuple)) => T (typep '(1 2 3) '(tuple integer integer integer)) => T  [Type] character-designator character-designator  [Type] function-designator function-designator  [Type] file-position-designator file-position-designator  [Type] list-designator list-designator  [Type] package-designator package-designator  [Type] pathname-designator pathname-designator  [Type] stream-designator stream-designator  [Type] string-designator string-designator  [Function] file-associated-stream-p file-associated-stream-p stream  Returns true if STREAM is a stream associated to a file. [Type] file-associated-stream file-associated-stream  Equivalent to (and stream (satisfies file-associated-stream-p)). [Type] non-nil non-nil &optional type  Equivalent to (and (not null) TYPE) if TYPE is given, otherwise (not null). Examples: (typep nil '(non-nil symbol)) => NIL  [Function] type-specifier-p type-specifier-p type-specifier  Returns true if TYPE-SPECIFIER is a valid type specfiier. [Function] type-expand type-expand type-specifier &optional env  Expand TYPE-SPECIFIER in the lexical environment ENV. Authors Tomohiro Matsuyama License LLGPL Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/m2ym/trivial-types"	"Trivial type definitions.."	"true"
"Utilities"	"trivial-utf8"	"https://common-lisp.net/project/trivial-utf-8/"	"A small library for doing UTF-8-based I/O. Not available on Quicklisp. No license specified."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Trivial UTF-8 Trivial UTF-8 Trivial UTF-8 is a small library for doing UTF-8-based in- and output on a Lisp implementation that already supports Unicode -- meaning char-code and code-char deal with Unicode character codes. The rationale for the existence of this library is that while Unicode-enabled implementations usually do provide some kind of interface to dealing with character encodings, these are typically not terribly flexible or uniform. The Babel library solves a similar problem while understanding more encodings. Trivial UTF-8 was written before Babel existed, but for new projects you might be better off going with Babel. The one plus that Trivial UTF-8 has is that it doesn't depend on any other libraries. Download and installation Trivial-utf-8 is released under a BSD-style license (see source file). The latest release can be downloaded from http://common-lisp.net/project/trivial-utf-8/trivial-utf-8.tgz, or installed with asdf-install. A darcs repository with the most recent changes can be checked out with: > darcs get http://common-lisp.net/project/trivial-utf-8/darcs/trivial-utf-8 Or look at it online. Support and mailing lists The trivial-utf-8-devel mailing list can be used for any questions, discussion, bug-reports, patches, or anything else relating to this library. Or mail the author/maintainer directly: Marijn Haverbeke. Reference function string-to-utf-8-bytes (string) => array of (unsigned-byte 8) Convert a string into an array of unsigned bytes containing its utf-8 representation. function utf-8-bytes-to-string (bytes) => string Convert a byte array containing utf-8 encoded characters into the string it encodes. function write-utf-8-bytes (string output &key null-terminate) Write a string to a byte-stream, encoding it as utf-8. function read-utf-8-string (input &key null-terminated stop-at-eof char-length byte-length) Read utf-8 encoded data from a byte stream and construct a string with the characters found. When null-terminated is given it will stop reading at a null character, stop-at-eof tells it to stop at the end of file without raising an error, and the char-length and byte-length parameters can be used to specify the maximum amount of characters or bytes to read. function utf-8-byte-length (string) => integer Calculate the amount of bytes needed to encode a string. function utf-8-group-size (byte) => integer Determine the amount of bytes that are part of the character starting with a given byte. condition utf-8-decoding-error A condition of this type is raised whenever an incorrectly encoded character is encountered. Back to Common-lisp.net. Valid XHTML 1.0 Strict"	"null"	"null"	"A small library for doing UTF-8-based I/O. Not available on Quicklisp. No license specified."	"true"
"Utilities"	"ubiquitous"	"https://github.com/Shinmera/ubiquitous"	"A library providing easy-to-use persistent configuration storage.."	"null"	"null"	"null"	"Artistic License 2.0"	"http://directory.fsf.org/wiki/License:ArtisticLicense2.0"	"null"	"null"	"4"	"2"	"0"	"GitHub - Shinmera/ubiquitous: A library providing a universal application configuration mechanism. Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 2 Star 4 Fork 0 Shinmera/ubiquitous Code Issues 0 Pull requests 0 Pulse Graphs A library providing a universal application configuration mechanism. https://shinmera.github.io/ubiquitous 27 commits 2 branches 0 releases Fetching contributors Common Lisp 52.6% HTML 47.4% Common Lisp HTML Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Latest commit d84b41e Jun 25, 2016 Shinmera Fix problem with [] being non-terminating macro characters, which lea… … …d to reloading a storage file failing if the last token in a ubiquitous list was a symbol. Permalink Failed to load latest commit information. LICENSE ゆっくりしていってね！！！ Sep 4, 2015 README.md Fix object serialisation to serialise all slots and use allocate-inst… May 13, 2016 about.html Doc up Sep 13, 2015 accessor.lisp Added accessor methods for functions. Feb 4, 2016 concurrent.lisp Added ubiquitous-concurrent Sep 4, 2015 config.lisp Added optimisation where WITH-TRANSACTION does not offload unless nec… Feb 4, 2016 documentation.lisp Added WITH-LOCAL-STORAGE/LAZY-LOADER. Feb 4, 2016 package.lisp Added WITH-LOCAL-STORAGE/LAZY-LOADER. Feb 4, 2016 pathname.lisp ゆっくりしていってね！！！ Sep 4, 2015 storage.lisp Fix problem with [] being non-terminating macro characters, which lea… Jun 25, 2016 ubiquitous-concurrent.asd Added ubiquitous-concurrent Sep 4, 2015 ubiquitous-logo.png About & logo Sep 4, 2015 ubiquitous.asd Added optimisation where WITH-TRANSACTION does not offload unless nec… Feb 4, 2016 README.md About Ubiquitous Ubiquitous is a very easy-to-use library for persistent configuration storage. It automatically takes care of finding a suitable place to save your data, and provides simple functions to access and modify the data within. How To Load ubiquitous through ASDF or Quicklisp. (ql:quickload :ubiquitous)  The main functions you will be using are restore, and value. The former loads the configuration according to a designator, and the latter is an accessor allowing you to retrieve and set properties. (restore 'my-config) (setf (value :test) ""hi!"") (value :test)  When values are set, it automatically saves the configuration to file. The location of the file is stored in *storage-pathname*, which is automatically computed according to what is most suitable for the given parameter and OS. On Windows it will be under %HOME%\AppData\Local\common-lisp\ubiquitous\ and everywhere else under ~/.config/common-lisp/ubiquitous/. The exact behaviour of the pathname choosing is documented in designator-pathname. value doesn't take a single name, but rather a path to a configuration value. The way things are traversed is handled by the field generic accessor. It tries to handle a number of commonly used structures, but you might have to extend it for your own classes, if you want to store those directly and traverse them. If a place does not exist yet, Ubiquitous will try to augment it if possible by creating a hash-table. This allows you to directly write a long path without having to worry about the containers existing. (setf (value 'something 'that 'goes 6 'levels 'deep) ""Calling from the depths!"")  Often times for configuration one might want to specify a default value to use. (defaulted-value ""localhost"" :hostname)  In case you need to remove a value, there's remvalue. (remvalue 'something 'that 'goes 6 'levels 'deep)  By default, an extended s-expression format is used to store things in a file. If you need a different format, you can add methods to read-storage and write-storage, and set *storage-type* to your type name. Since (setf value) automatically calls offload to persist the storage, this might lead to a lot of saving all over the place. In order to avoid this, you can bundle a block of operations in a with-transaction form, which will only perform an offload once the block exits. Ubiquitous in itself does not have any external dependencies, so you may also bundle it into a singular file to just load using ASDF: (asdf:operate :build-op :ubiquitous)  Which will produce an independent ubiquitous.lisp file in (asdf:system-source-directory :ubiquitous). Concurrency By default Ubiquitous does not try to handle concurrent access in any way. The reason for this is not laziness, but merely the desire to avoid dependencies for those that don't need it. However, if you require safe concurrent access and handling of the storage, simply load ubiquitous-concurrent instead of ubiquitous. This will also pull in bordeaux-threads and establish additional methods around the standard definitions that will ensure concurrency safety. This will still work irregardless of how many different storage objects you use, as the locking on the operations happens on the currently accessed storage object itself, rather than on a global lock. In order to avoid needless locking and unlocking, you should bundle your operations into a with-transaction block, which will only perform a lock once. Shortcomings A couple of shortcomings exist in Ubiquitous, almost by necessity. As you might know out of experience, certain modifying operations are not possible to do without being able to modify the container of the object itself. As an example, poping an element off the head of the list requires setting the variable that contains the list, rather than the list itself. This sort of thing is rather annoying to model in a generic manner without complicating the common case needlessly. Furthermore, in a couple of instances ambiguity arises due to multiple actions being possible. In detail, the following operations are supported suboptimally, or not at all: remfield on a list with one element left that is to be removed. The car of the cons will simply be set to NIL. remfield on a vector. This would require shifting fields and potentially adjusting it. The desired effect cannot be estimated and so Ubiquitous does not support the operation at all. remfield on a standard-object, as class-slots cannot be removed without the MOP and you probably wouldn't want that to happen anyway. setf field on a list or vector where the field is an index exceeding the length. In this case, an error is signalled as extending the object to the required length might not be a desired or possible effect. setf field on a list where the field is a symbol or string. Lists are commonly used as alists or plists. Ubiquitous strictly expects alists. Another shortcoming is in the department of serialisation. Ubiquitous does not try to be overly smart about things, which especially comes into effect when serialising standard-objects. Ubiquitous saves the class' slots and restores it by calling allocate-instance without initargs and then setf slot-value-ing one slot after the other. If you need more tailored support for serialising your object, you must extend define-ubiquitous-reader and define-ubiquitous-writer, or write a new storage format altogether. Furthermore, since the default behaviour is to use the lisp printer and reader (with special handling for hash-table, standard-object, standard-class, and package) to serialise objects, several things might get lost in translation, such as the fill-pointer and adjustability of a vector. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Shinmera/ubiquitous"	"A library providing easy-to-use persistent configuration storage.."	"true"
"XML"	"CXML"	"https://common-lisp.net/project/cxml/"	"XML parser, with a range of extension libraries.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"Closure XML Closure XML Installing Closure XML Download Implementation-specific notes Compilation Tests Quick-Start Example / FAQ SAX parsing and serialization Parsing and Validating Serialization Miscellaneous SAX handlers Recoders Caching of DTD Objects XML Catalogs SAX Interface Klacks parser Parsing incrementally Convenience functions Bridging Klacks and SAX Location information Examples DOM implementation Parsing with the DOM builder Serialization DOM/Lisp mapping XMLS Builder Closure XML Parser An XML parser written in Common Lisp. Closure XML was written by Gilbert Baumann as part of the Closure web browser and is now maintained by David Lichteblau. It is licensed under Lisp-LGPL. CXML implements a namespace-aware, validating XML 1.0 parser as well as the DOM Level 2 Core interfaces. Two parser interfaces are offered, one SAX-like, the other similar to StAX. Send bug reports to cxml-devel@common-lisp.net (list information). Add-on features The following libraries are available as separate downloads: cxml-rng: Relax NG validation cxml-stp: STP, an alternative to DOM Plexippus: XPath 1.0 Xuriella: XSLT 1.0 Closure HTML: parse HTML 4; convert between HTML and XHTML Recent Changes cxml and closure-common are now available from git instead of CVS. Please refer to the installation instructions for details. rel-2008-11-30 Support for user-specified output encodings using Babel. More support for input encodings, thanks to Pierre Mai. Lisps using full 21 bit code points as characters are now fully supported (including SBCL and Clozure CL) addition to the existing support for 16 bit characters using UTF-16 (including Allegro and LispWorks). The feature rune-is-utf-16 is now set on 16 bit Lisps. Make sure to update and recompile both cxml and closure-common when upgrading. New sink slot sink-omit-xml-declaration-p; functions cxml:unescaped and sax:unescaped. Added XPath support to the XMLS compatibility model. Fixed various DTD serialization bugs. Fixed xmls compatibility bugs. Fixed variable names in with-source. Fixed klacks-error export. Consistently use strings as base URIs. Fixed PARSE for non-file-streams. Added support for the UTF-8 ""BOM"", thanks to Ivan Shvedunov. Runes have been moved into a separate project, named closure-common. Releases will be available as separate tarballs in the download directory. Please refer to the installation instructions for details. rel-2007-10-21 Moved runes into a separate project. Incompatible SAX changes: Added new classes sax:abstract-handler, sax:content-handler, sax:default-handler. Implementations of SAX handlers should now subclass one of these classes. fixed make-source :buffering nil, thanks to Magnus Henoch for the report fixed time and space usage in cases where entity references follow each other (thanks to Ivan Shvedunov for the report) In the DOM builder, grow a buffer for string normalization exponentially, fixing a long-standing speed issue. rel-2007-08-05 Various DTD serialization fixes UTF-8 fix, thanks to Francis Leboutte rel-2007-07-07 Fixed build on non-Unicode lisps. Fixed parsing on non-Unicode lisps. Fixed Unicode detection on OpenMCL. New function cxml:parse. Serialization no longer defaults to canonical form. Fixed octet array argument to make-source. XMLS compatibility is not bug-for-bug-compatible with XMLS any more. There is now a mode using pairs of local name and namespace URI, and a second mode using qualified names only. The old behaviour using pairs of prefix and local names was removed. (Thanks to Douglas Crosher.) SCL support (thanks to Douglas Crosher). Includes support for implementations where URIs are valid namestrings, and a mode where normal streams are used instead of xstreams and ystreams (albeit both SCL-specific at this point). new convenience serialization function cxml:doctype. Various DTD serialization fixes. rel-2007-05-26 cxml.asd has been split up into cxml.asd for the XML parser and runes.asd for the runes package, in preparation of a complete split of the two systems. Future CXML releases will use separate tarballs for runes and cxml. xml:base support (SAX and Klacks only, not yet used in DOM). See documentation here and here. New class broadcast-handler as a generalization of the older sax-proxy. New class tapping-source, a klacks source that relays events from an upstream klacks source unchanged, while also emitting them as SAX events to a user-specified handler at the same time. Changed attributes to carry an lname even when occurring without a namespace. Added new functions attribute*, unparse-attribute, and macro with-element*, with-namespace* to the SAX generation wrapper API. Klacks improvements: Incompatibly changed klacks:find-element and find-event to consider the current event as a result. Added klacks-error, klacks:expect, klacks:skip, klacks:expecting-element. Fixed serialize-event to generate start-prefix-mapping and end-prefix-mapping events. New function map-current-namespace-declarations. fixed build with common-lisp-controller rel-2007-02-18 New StAX-like parser interface. Serialization fixes (thanks to Nathan Bird, Donavon Keithley). characters.lisp cleanup (thanks to Nathan Bird). Namespace normalizer bugfixes. Minor changes: clone-node on document as an extension. DOM class hierarchy reworked. New function parse-empty-document. Fixed the DOM serializer to not throw away local names. Fixed a long-standing bug in the parser for documents without a doctype. ANSI conformance fixes. rel-2006-01-05 Implemented DOM 2 Core. Error handling overhaul. UTF-8 string support in DOM on Lisps without Unicode characters. Sink API has been changed. Support internal subset serialization. Whitespace normalizer. Gilbert Baumann has clarified the license as Lisp-LGPL. Use trivial-gray-streams. rel-2005-06-25 Port to OpenMCL (thanks to Rudi Schlatte). Port to LispWorks (thanks to Edi Weitz). Minor new features: include-default-values argument to make-xmls-builder; handler argument to parse-dtd-stream; SAX proxy class Various bugfixes. patch-357 (2004-10-10) Auto-detect unicode support for better asdf-installability. Use the puri library for Sys-ID handling. Semi-automatic caching of DTD instances. Support user-defined entity resolvers. Support for Oasis XML Catalogs. xhtmlgen version of Franz htmlgen. Fixes for SBCL's unicode support. patch-306 (2004-09-03) Event-based serialization which does not require DOM documents XMLS compatiblity minor bugfixes (thread safety; should work on clisp again) patch-279 (2004-05-11) Validation bugfixes; XHTML DTD parses again; corrected SAX entity handling patch-204 Renamed package XML to CXML. The unparse functions support non-canonical output now. patch-191 (2004-03-18) Initial release."	"null"	"null"	"XML parser, with a range of extension libraries.."	"true"
"XML"	"Plump"	"https://github.com/Shinmera/plump"	"A lenient XML parser.."	"null"	"null"	"null"	"Artistic License 2.0"	"http://directory.fsf.org/wiki/License:ArtisticLicense2.0"	"null"	"null"	"20"	"3"	"4"	"GitHub - Shinmera/plump: Practically Lenient and Unimpressive Markup Parser for Common Lisp Skip to content Personal Open source Business Explore Sign up Sign in Pricing Blog Support Search GitHub This repository Watch 3 Star 20 Fork 4 Shinmera/plump Code Issues 1 Pull requests 0 Pulse Graphs Practically Lenient and Unimpressive Markup Parser for Common Lisp https://shinmera.github.io/plump 190 commits 2 branches 0 releases Fetching contributors HTML 59.2% Common Lisp 40.8% HTML Common Lisp Clone or download Use SSH Clone with HTTPS Use Git or checkout with SVN using the web URL. Use HTTPS Clone with SSH Use an SSH key and passphrase from account. Open in Desktop Download ZIP Find file Branch: master Switch branches/tags Branches Tags gh-pages master Nothing to show Nothing to show New pull request Fetching latest commit… Cannot retrieve the latest commit at this time. Permalink Failed to load latest commit information. LICENSE README.md about.html dom.lisp entities.lisp lexer.lisp package-dom.lisp package-lexer.lisp package-parser.lisp package.lisp parser.lisp plump-dom.asd plump-lexer.asd plump-logo.png plump-parser.asd plump.asd processing.lisp special-tags.lisp tag-dispatcher.lisp README.md What is Plump? Plump is a parser for HTML/XML like documents, focusing on being lenient towards invalid markup. It can handle things like invalid attributes, bad closing tag order, unencoded entities, inexistent tag types, self-closing tags and so on. It parses documents to a class representation and offers a small set of DOM functions to manipulate it. You are free to change it to parse to your own classes though. How To Load Plump through Quicklisp or ASDF: (ql:quickload :plump)  Using the PARSE function, plump will transform a string, pathname or stream into a document: (plump:parse ""<foo><bar this is=\""a thing\"">baz</bar><span id=\""test\"">oh my"")  This returns a root node. If you want to append a document to a root node (or any other node that accepts children) that you've made, you can pass it into the parse function. To return the document into a readable form, you can call SERIALIZE: (plump:serialize *)  Using the DOM you can easily traverse the document and change it: (plump:remove-child (plump:get-element-by-id ** ""test"")) (plump:serialize ***)  By default plump includes a few special tag dispatchers to catch HTML oddities like self-closing tags and fulltext-nodes. Especially the self-closing tags can lead to problems in XML documents. In order to parse without any HTML ""tricks"", you can simply do: (let ((plump:*tag-dispatchers* plump:*xml-tags*)) (plump:parse ""<link>foo</link>""))  Extending Plump If you want to handle a certain tag in a special way, you can write your own tag-dispatcher. For example comments, the doctype and self-closing tags are handled in this fashion. In order to properly hook in, you will have to learn to use Plump's lexer (see next section). (plump:define-tag-dispatcher (my-dispatcher *tag-dispatchers*) (name)     (string-equal name ""my-tag"")   (let ((attrs (plump:read-attributes)))     (when (char= (plump:consume) #\/)       (plump:consume)) ;; Consume closing     (make-instance 'my-tag :parent plump:*root* :attributes attrs)))  If you don't want to disturb the standard Plump tag dispatchers list, you can define your own special variable to contain the dispatchers and bind *tag-dispatchers* to that during parsing, as shown for the XML example above. Shorthand macros exist to define self-closing or full-text tags: (plump:define-self-closing-element img *tag-dispatchers* *html-tags*) (plump:define-fulltext-element style *tag-dispatchers* *html-tags*)  XML allows for script tags (like <?php ?>). By default Plump does not specify any special reading for any script tag. If an unhandled script tag is encountered, a warning is emitted and Plump will try to just read anything until ?> is encountered. For most script tags this probably will not suffice, as they might contain some form of escaped ?>. If you do want to use Plump to process script tags properly as well, you will have to define your own reader with define-processing-parser. You can also use that macro to define a reader that outputs a more suitable format than a text tag. During parsing, all elements are created through MAKE-* functions like MAKE-ROOT, MAKE-ELEMENT, MAKE-TEXT-NODE, and so on. By overriding these functions you can instead delegate the parsing to your own DOM. If you subclass the DOM classes, you might want to define a method on SERIALIZE-OBJECT to produce the right output. Plump's Lexer Since parser generators are good for strict grammars and Plump needed to be fast and lenient, it comes with its own primitive reading/lexing mechanisms. All the lexer primitives are defined in lexer.lisp and you can leverage them for your own projects as well, if you so desire. In order to allow the lexing to work, you'll have to wrap your processing code in with-lexer-environment. You can then use functions like consume, advance, unread, peek and consume-until to process the input. make-matcher allows you to use a very simple language to define matching operations. This will evaluate to a function with no arguments that should return T if it matches and NIL otherwise. Combining matchers with consume-until allows you to easily make sequence readers: (plump:with-lexer-environment (""<foo>"")   (when (char= #\< (plump:consume))     (plump:consume-until (plump:make-matcher (is #\>)))))  Available matcher constructs are not, and, or, is, in, next, prev, any, and find. define-matcher allows you to associate keywords to matchers, which you can then use as a matcher rule in make-matcher. Regular symbols act as variables: (let ((find ""baz""))   (plump:with-lexer-environment (""foo bar baz"")      (plump:consume-until (plump:make-matcher (is find)))))  Speed If you know of other native-lisp libraries that beat Plump, please do let me know, I would be very interested! See Also lQuery Dissect and manipulate the DOM with jQuery-like commands. CLSS Traverse the DOM by CSS selectors. plump-tex Serialize between TeX and the Plump DOM. plump-sexp Serialize between SEXPrs and the Plump DOM. Contact GitHub API Training Shop Blog About © 2016 GitHub, Inc. Terms Privacy Security Status Help Something went wrong with that request. Please try again. You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session."	"null"	"https://github.com/Shinmera/plump"	"A lenient XML parser.."	"true"
"XML"	"s-xml"	"http://cliki.net/S-XML"	"A basic parser.."	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"null"	"CLiki: s-xml CLiki - s-xml s-xml S-XML is a simple basic XML parser with both a function and (S)SAX like event interface as well as a DOM interface with LXML, SXML and an XML-ELEMENT struct DOM representation. See also web, for other tools. This XML parser implementation has the following features: It works (handling many common XML usages). It is very small (the core is about 700 lines of code, including comments and whitespace). It has a core API that is simple, efficient and pure functional, much like that from SSAX. It supports different DOM models: an XSML-based one, an LXML-based one and a classic xml-element struct based one. It is reasonably time and space efficient (internally avoiding garbage generation as much as possible). It does support CDATA. It should support the same character sets as your Common Lisp implementation. It does support XML name spaces. Originally it was written by Sven Van Caekenberghe. It is now being maintained by Sven Van Caekenberghe, Rudi Schlatte and Brian Mastenbrook. ASDF-install package (obsolete) http://www.common-lisp.net/project/s-xml/s-xml.tgz Current version History Backlinks Edit Create Home Recent Changes About Text Formatting Tools Search CLiki CLiki the common lisp wiki Account name Password register"	"null"	"null"	"A basic parser.."	"true"
"XML"	"xmls"	"http://quickdocs.org/xmls/"	"A small, simple, non-validating XML parser.."	"null"	"null"	"null"	"3-clause BSD"	"http://directory.fsf.org/wiki/License:BSD_3Clause"	"null"	"null"	"null"	"null"	"null"	"xmls | Quickdocs Quickdocs xmls 2015-04-07 Website Download <html> <head/> <body> <h1>XMLS</h1>  <h2>Summary</h2> <p>   Xmls is a small, simple, non-validating xml parser for Common Lisp.  It's   designed to be a self-contained, easily embedded parser that recognizes a useful   subset of the XML spec.  It provides a simple mapping from xml to lisp    s-expressions and back. </p>  <h2>Features</h2> <ul>   <li>     Free (BSD license).   </li>   <li>     Understands enough of the xml spec to parse many common documents, including     those occurring in common internet protocols like xml-rpc, webdav, and BEEP.     Parses 85 out of the 98 valid documents in the oasis parser compliance suite.   </li>   <li>     Small and easily embedded.  The entire parser is contained in one     file and it's currently less than 600 lines of code.  Xmls is written in     pure lisp and requires no external parsing tools or foreign libraries.   </li>   <li>     Supports xml namespaces.   </li>   <li>     Threadsafe.   </li>   <li>     Serializes s-expr list structures back to xml as well as parsing xml.   </li> </ul>  <h2>Limitations</h2> <ul>   <li>     Parses entire document into memory and consequently can't handle large     documents.   </li>   <li>     No detailed error reporting.   </li> </ul>  <h2>XML Representation</h2>  <p>   Parsed xml is represented as a lisp list.  A node is represented as follows: </p>  <pre> (name (attributes) children*) </pre>  <p>   A name is either a simple string, if the element does not belong to a namespace,   or a list of (name namespace-url) if the element does belong to a namespace. </p>  <p>   Attributes are stored as (name value) lists. </p>  <p>   Children are stored as a list of either element nodes or text nodes. </p>  <p>   For example, the following xml document: </p>  <pre> &lt;?xml version=""1.0""?&gt; &lt;!-- test document --&gt; &lt;book title='The Cyberiad'&gt;   &lt;!-- comment in here --&gt;   &lt;author xmlns='http://authors'&gt;Stanislaw Lem&lt;/author&gt;   &lt;info:subject xmlns:info='http://bookinfo' rank='1'&gt;&amp;quot;Cybernetic Fables&amp;quot;&lt;/info:subject&gt; &lt;/book&gt; </pre>  Would parse as:  <pre> (""book"" ((""title"" ""The Cyberiad""))  ((""author"" . ""http://authors"") NIL ""Stanislaw Lem"")  ((""subject"" . ""http://bookinfo"") ((""rank"" ""1"")) ""\""Cybernetic Fables\"""")) </pre>  <p>   Xmls also includes a helper function, make-node for creating xml nodes   of this form: </p>  <pre> (make-node &amp;key name ns attrs children) </pre>  <p>   Xmls provides the corresponding accessor functions node-name, node-ns   node-attrs, and node-children. </p>  <h2>Usage</h2>  <p>   The interface is straightforward.  The two main functions are parse and toxml. </p>  <pre> (parse source &amp;key (compress-whitespace t)) </pre>  <p>   Parse accepts either a string or an input stream and attempts to parse the xml   document contained therein.  It will return the s-expr parse tree if it's   successful or nil if parsing fails.    If compress-whitespace is t, content nodes will be trimmed of whitespace and   empty whitespace strings between nodes will be discarded. </p>  <pre> (write-prologue xml-decl doctype stream) </pre>  <p>   write-prologue writes the leading   <code>&lt;?xml ... ?&gt;</code> and <code>&lt;!DOCTYPE ... &gt;</code>   elements to <code>stream</code>.   <code>xml-decl</code> is an alist of attribute name value pairs.   Valid xml-decl attributes per the xml spec are ""version"", ""encoding"",   and ""standalone"", though write-prologue does not verify this.   <code>doctype</code> is a string containing the document type definition. </p>  <pre> (write-prolog xml-decl doctype stream) </pre> <p> U.S. spelling alternative to <pre>write-prologue</pre>. </p>  <pre> (write-xml xml stream &amp;key (indent nil)) </pre>  <p>   write-xml accepts a lisp list in the format described above and writes the   equivalent xml string to stream.  Currently, if nodes use namespaces xmls will not    assign namespaces prefixes but will explicitly assign the namespace to each node.  This   will be changed in a later release.    Xmls will indent the generated xml output if indent is non-nil. </p>  <pre> (toxml node &amp;key (indent nil)) </pre>  <p>   Toxml is a convenience wrapper around write-xml that returns the in a newly   allocated string. </p>  <h3>Helper functions</h3>  <p>These are intended to allow programmers to avoid direct manipulation of the   s-expression representation.  If you use these, your code should be easier to   read and you will avoid problems if there is a change in internal   representation (such changes would be hard to even find, much less correct, if   using the lists directly).</p>  <dl>   <dt><code>       make-xmlrep  (tag &key attribs children)   </code>   </dt>   <dd>Constructor function.</dd>  <dt><code>     xmlrep-add-child! (xmlrep child) </code> </dt> <dd>Add a new child node to the XMLREP node.</dd> <dt><code>     xmlrep-tag (xmlrep) </code> </dt>   <dd>Extract the tag from XMLREP.</dd> <dt><code>xmlrep-tagmatch (tag treenode)</code> </dt> <dd>Returns true if TAG is the tag of TREENODE.  Match is   case <em>insensitive</em> (quite possibly this is the Wrong Thing). </dd> <dt><code>     xmlrep-attribs (xmlrep) </code> </dt> <dd>Extract the attributes from an XMLREP node.</dd> <dt><code>     xmlrep-children (xmlrep) </code> </dt> <dd>Extract the children from an XMLREP node.</dd> <dt><code>     xmlrep-find-child-tags (tag treenode) </code> </dt> <dd>Return all of the (direct) children of TREENODE whose tags are TAG.   Matching done by <a href=""#xmlrep-tagmatch""><code>xmlrep-tagmatch</code></a>. <dt><code>     xmlrep-find-child-tag (tag treenode     &optional (if-unfound :error)) </code> </dt> <dd>Find a <em>single</em> child of TREENODE with TAG.  Returns an error if there is more or less than one such child.</dd> <dl>   <dt><code>     xmlrep-string-child (treenode)     </code></dt>   <dd>Find the <em>single</em> string-valued child of TREENODE.  Returns an     error if there is more than one child, or if a single child is not     string-valued.</dd> </dl> <dl>   <dt><code>     xmlrep-integer-child (treenode)     </code></dt>   <dd>Find the <em>single</em> child of TREENODE whose value is a string that     can be parsed into an integer.  Returns an     error if there is more than one child, or if a single child is not    appropriately valued.</dd> </dl>     <dt><code>     xmlrep-attrib-value (attrib treenode     &optional (if-undefined :error)) </code> </dt> <dd>Find the value of ATTRIB, a string, in TREENODE. if there is no ATTRIB, will return the value of IF-UNDEFINED, which defaults to :ERROR.</dd> <dt><code>     xmlrep-boolean-attrib-value (attrib treenode     &optional (if-undefined :error)) </code> </dt> <dd>Find the value of ATTRIB, a string, in TREENODE. The value should be either ""true"" or ""false"".  The function will return T or NIL, accordingly.  If there is no ATTRIB,   will return the value of IF-UNDEFINED, which defaults to :ERROR.</dd> </dl> <h2>Installation</h2>  <p>   xmls can be installed as an asdf system.  An asdf   system definition is provided with the distribution. </p>  <p>Previous versions of XMLS were single files, and could be installed simply by   loading the file xmls.lisp.  This option is no longer supported.</p>   <h2>Contact Information</h2>    <p>    Please contact Robert Goldman, rpgoldman AT sift.info with any    questions or bug reports. </p> </body> </html>  Categories xml Requirements 0 None. Required by 8 cl-openid cl-openid cl-pango Bindings to the pango text layout library. cl-rss Remote Site Summary cl-sendmail Common Lisp interface to use /usr/lib/sendmail for mail submission. cl-typesetting Common Lisp Typesetting system clinch An OpenGL Game Engine. simple-currency SIMPLE-CURRENCY provides conversions between currencies using data published daily by the European Central Bank, no guarantees about the accuracy of the data are given or even implied. For details of the ECB FX rates see: http://www.ecb.int/stats/exchange/eurofxref/html/index.en.html xmls-tools xmls-tools is a library to supplement use of xmls. It includes support for parsing with side effects, searching and validating XML. It includes an example side effect parser in the form of a XHTML to text converter.xmls-tools was written by Robert Marlow.Download xmls-tools from http://www.bobturf.org/software/xmls-tools/ Links API Reference Website © 2013-2015 Eitaro Fukamachi"	"null"	"null"	"A small, simple, non-validating XML parser.."	"true"
